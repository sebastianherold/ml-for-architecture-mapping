FileName,Label,FileContent
Apache20LicenseHelp.java,apacheutils-6.9.122,"package org.processmining.help;

public class Apache20LicenseHelp {

	public final static String TEXT = """"
			+ ""Retrieves (live) and shows the Apache 2.0 License."";
}
"
Apache20License.java,apacheutils-6.9.122,"package org.processmining.models;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;

import org.processmining.framework.util.HTMLToString;

public class Apache20License implements HTMLToString {

	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buffer = new StringBuffer();
		URL url;
		InputStream is = null;
		BufferedReader br;
		String line;
		String start = ""visible }</style>"";
		String end = ""h1 id=\""apply\"">APPENDIX"";

		if (includeHTMLTags) {
			buffer.append(""<html>"");
		}
		try {
			url = new URL(""http://www.apache.org/licenses/LICENSE-2.0.html"");
			is = url.openStream(); // throws an IOException
			br = new BufferedReader(new InputStreamReader(is));
			boolean copy = false;

			while ((line = br.readLine()) != null) {
				if (line.indexOf(start) > 0) {
					copy = true;
					line = line.substring(line.indexOf(start) + start.length());
				}
				if (line.indexOf(end) > 0) {
					line = line.substring(0, line.indexOf(end) - 1);
					if (copy) {
						copy = false;
						buffer.append(line);
						buffer.append(""\n"");
					}
				}
				if (copy) {
					buffer.append(line);
					buffer.append(""\n"");
				}
			}
		} catch (MalformedURLException mue) {
			mue.printStackTrace();
		} catch (IOException ioe) {
			ioe.printStackTrace();
		} finally {
			try {
				if (is != null)
					is.close();
			} catch (IOException ioe) {
				// nothing to see here
			}
		}
		if (includeHTMLTags) {
			buffer.append(""</html>"");
		}

		return buffer.toString();
	}

}
"
Apache20LicensePlugin.java,apacheutils-6.9.122,"package org.processmining.plugins;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.help.Apache20LicenseHelp;
import org.processmining.models.Apache20License;

@Plugin(name = ""Show Apache License, Version 2.0"", parameterLabels = { }, returnLabels = { ""Apache License, Version 2.0"" }, returnTypes = { Apache20License.class }, help = Apache20LicenseHelp.TEXT)
public class Apache20LicensePlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Show Apache License, Version 2.0"", requiredParameterLabels = { })
	public Apache20License show(UIPluginContext context) {
		return new Apache20License();
	}
}
"
LGPLLicenseHelp.java,basicutils-6.9.126,"package org.processmining.basicutils.help;

public class LGPLLicenseHelp {

	public final static String TEXT = """"
			+ ""Retrieves (live) and shows the L-GPL License."";
}
"
ObjectArrayImpl.java,basicutils-6.9.126,"package org.processmining.basicutils.models.impl;

import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;

import org.processmining.basicutils.models.ObjectArray;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;

import com.csvreader.CsvReader;

public abstract class ObjectArrayImpl<K> implements ObjectArray<K>  {
	protected List<K> list = new ArrayList<K>();
	
	public void init() {
		list = new ArrayList<K>();
	}

	public int addElement(K element) {
		list.add(element);
		return list.size() - 1;
	}

	public int removeElement(K element) {
		int ret = list.indexOf(element);
		list.remove(element);
		return ret;
	}

	public void addElement(int index, K element) {
		list.add(index, element);
	}

	public void removeElement(int index) {
		list.remove(index);
	}

	public K getElement(int index) {
		return list.get(index);
	}

	public int getSize() {
		return list.size();
	}
	
	@SuppressWarnings(""unchecked"")
	public void importFromStream(PluginContext context, InputStream input, String parent, AbstractImportPlugin importer) throws Exception {
		Reader streamReader = new InputStreamReader(input);
		CsvReader csvReader = new CsvReader(streamReader);
		init();
		while (csvReader.readRecord()) {
			String fileName = csvReader.get(0);
			if (parent != null && fileName.indexOf(File.separator) == -1) {
				fileName = parent + File.separator + fileName;
			}
			System.out.println(""Importing element "" + fileName);
			K element = (K) importer.importFile(context, fileName);
			this.addElement(element);
		}
		csvReader.close();
	}
}
"
LGPLLicense.java,basicutils-6.9.126,"package org.processmining.basicutils.models;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;

import org.processmining.framework.util.HTMLToString;

public class LGPLLicense implements HTMLToString {

	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buffer = new StringBuffer();
		URL url;
		InputStream is = null;
		BufferedReader br;
		String line;
		String start = ""<div dir=\""ltr\"">"";
		String end = ""/div>"";

		if (includeHTMLTags) {
			buffer.append(""<html>"");
		}
		try {
			url = new URL(""https://www.gnu.org/licenses/lgpl.html"");
			is = url.openStream(); // throws an IOException
			br = new BufferedReader(new InputStreamReader(is));
			boolean copy = false;

			while ((line = br.readLine()) != null) {
				if (line.indexOf(start) >= 0) {
					copy = true;
					line = line.substring(line.indexOf(start) + start.length());
				}
				if (line.indexOf(end) > 0) {
					line = line.substring(0, line.indexOf(end) - 1);
					if (copy) {
						copy = false;
						buffer.append(line);
						buffer.append(""\n"");
					}
				}
				if (copy) {
					buffer.append(line);
					buffer.append(""\n"");
				}
			}
		} catch (MalformedURLException mue) {
			mue.printStackTrace();
		} catch (IOException ioe) {
			ioe.printStackTrace();
		} finally {
			try {
				if (is != null)
					is.close();
			} catch (IOException ioe) {
				// nothing to see here
			}
		}
		if (includeHTMLTags) {
			buffer.append(""</html>"");
		}

		return buffer.toString();
	}

}
"
ObjectArray.java,basicutils-6.9.126,"package org.processmining.basicutils.models;

import java.io.File;
import java.io.InputStream;

import org.processmining.framework.plugin.PluginContext;

public interface ObjectArray<K> {
	/**
	 * Initializes the object array.
	 */
	void init();

	/**
	 * Add the element to the array
	 * @param element
	 * @return the index of the element
	 */
	int addElement(K element);

	/**
	 * Remove the element from the array
	 * @param element
	 * @return
	 */
	int removeElement(K element);

	/**
	 * Add the element at the specific index
	 * @param index
	 * @param element
	 */
	void addElement(int index, K element);

	/**
	 * Remove the element at the specific index
	 * @param index
	 */
	void removeElement(int index);

	/**
	 * Return the element at the specific index
	 * @param index
	 * @return
	 */
	K getElement(int index);
	
	int getSize();
	
	public void importFromStream(PluginContext context, InputStream input, String parent) throws Exception;
	public void exportToFile(PluginContext context, File file) throws Exception;
}
"
PluginParametersImpl.java,basicutils-6.9.126,"package org.processmining.basicutils.parameters.impl;

import org.processmining.basicutils.parameters.PluginParameters;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.events.Logger.MessageLevel;

public class PluginParametersImpl implements PluginParameters {

	private int messageLevel;
	private boolean tryConnections;
	
	public PluginParametersImpl() {
		setMessageLevel(PluginParameters.MESSAGE);
		setTryConnections(true);
	}
	
	public PluginParametersImpl(PluginParameters parameters) {
		setMessageLevel(parameters.getMessageLevel());
		setTryConnections(parameters.isTryConnections());
	}
	
	public boolean equals(Object object) {
		if (object instanceof PluginParametersImpl) {
			PluginParametersImpl parameters = (PluginParametersImpl) object;
			return getMessageLevel() == parameters.getMessageLevel()
					&& isTryConnections() == parameters.isTryConnections();
		}
		return false;
	}
	
	public int getMessageLevel() {
		return messageLevel;
	}

	public void setMessageLevel(int messageLevel) {
		this.messageLevel = messageLevel;
	}
	
	public void displayMessage(String text) {
		if (messageLevel >= PluginParameters.MESSAGE) {
			System.out.println(text);
		}
	}
	
	public void displayWarning(String text) {
		if (messageLevel >= PluginParameters.WARNING) {
			System.out.println(text);
		}
	}
	
	public void displayError(String text) {
		if (messageLevel >= PluginParameters.ERROR) {
			System.err.println(text);
		}
	}

	public void displayMessage(PluginContext context, String text) {
		if (messageLevel >= PluginParameters.MESSAGE) {
			context.log(text, MessageLevel.NORMAL);
		}
	}
	
	public void displayWarning(PluginContext context, String text) {
		if (messageLevel >= PluginParameters.WARNING) {
			context.log(text, MessageLevel.WARNING);
		}
	}
	
	public void displayError(PluginContext context, String text) {
		if (messageLevel >= PluginParameters.ERROR) {
			context.log(text, MessageLevel.ERROR);
		}
	}

	public boolean isTryConnections() {
		return tryConnections;
	}

	public void setTryConnections(boolean tryConnections) {
		this.tryConnections = tryConnections;
	}
}
"
PluginParameters.java,basicutils-6.9.126,"package org.processmining.basicutils.parameters;

import org.processmining.framework.plugin.PluginContext;

public interface PluginParameters {

	public final static int MESSAGE = 1;
	public final static int WARNING = 2;
	public final static int ERROR = 3;
	public final static int DEBUG = 4;

	public int getMessageLevel();

	public void setMessageLevel(int messageLevel);
	
	public void displayMessage(String text);
	
	public void displayWarning(String text);
	
	public void displayError(String text);

	public void displayMessage(PluginContext context, String text);
	
	public void displayWarning(PluginContext context, String text);
	
	public void displayError(PluginContext context, String text);

	public boolean isTryConnections();

	public void setTryConnections(boolean tryConnections);
}
"
LGPLLicensePlugin.java,basicutils-6.9.126,"package org.processmining.basicutils.plugins;

import org.processmining.basicutils.help.LGPLLicenseHelp;
import org.processmining.basicutils.models.LGPLLicense;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Show L-GPL License"", parameterLabels = { }, returnLabels = { ""Apache License, Version 2.0"" }, returnTypes = { LGPLLicense.class }, help = LGPLLicenseHelp.TEXT)
public class LGPLLicensePlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Show L-GPL License"", requiredParameterLabels = { })
	public LGPLLicense runUI(UIPluginContext context) {
		return new LGPLLicense();
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public LGPLLicense show(UIPluginContext context) {
		return runUI(context);
	}
}
"
HTMLUtils.java,basicutils-6.9.126,"package org.processmining.basicutils.utils;

public class HTMLUtils {

	public static String encode(String s) {
		return s.replaceAll(""&"", ""&amp;"").replaceAll(""<"", ""&lt"").replaceAll("">"", ""&gt;"");
	}
}
"
StringConstants.java,basicutils-6.9.126,"package org.processmining.basicutils.utils;

public class StringConstants {

	public final static String START = "" |start> "";
	public final static String END = "" [end] "";
	
}
"
HTMLUtils.java,basicutils-6.9.126,"package org.processmining.utils;

/**
 * @deprecated Use HTMLUtils from org.processmining.basicutils.utils
 */
@Deprecated
public class HTMLUtils {

	public static String encode(String s) {
		return s.replaceAll(""&"", ""&amp;"").replaceAll(""<"", ""&lt"").replaceAll("">"", ""&gt;"");
	}
}
"
ColourMap.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public abstract class ColourMap {
	public abstract Color colour(long weight, long maxWeight);

	public abstract Color colour(double value);

	@Deprecated
	public Color colour3(long weight, long min, long max) {
		if (max == min) {
			return colour(weight, weight);
		}
		return colour(weight - min, max - min);
	}

	public Color colour(long weight, long min, long max) {
		if (max == min) {
			return colour(weight, weight);
		}
		return colour(weight - min, max - min);
	}

	public Color colour(double weight, double min, double max) {
		if (max == min) {
			return colour(1);
		}
		double x = (weight - min) / (max-min);
		
		return colour(x);
	}

	public String colourString(long weight, long min, long max) {
		return toHexString(colour(weight, min, max));
	}

	public static String toHexString(Color colour) {
		return ""#"" + toHex(colour.getRed()) + toHex(colour.getGreen()) + toHex(colour.getBlue());
	}

	public static String toHex(int i) {
		String s = Integer.toHexString(i);
		if (s.length() == 2) {
			return s;
		} else {
			return ""0"" + s;
		}
	}
}
"
ColourMapBlackBody.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapBlackBody extends ColourMap {

	public Color colour(long weight, long maxWeight) {
		return ColourMaps.colourMapBlackBody(weight, maxWeight);
	}

	public Color colour(double value) {
		return ColourMaps.colourMapBlackBody(value);
	}

}
"
ColourMapBlue.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;


public class ColourMapBlue extends ColourMap {

	public Color colour(long weight, long maxWeight) {
		return ColourMaps.colourMapBlue(weight, maxWeight);
	}
	
	public Color colour(double value) {
		return ColourMaps.colourMapBlue(value);
	}
}
"
ColourMapFixed.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapFixed extends ColourMap {
	private Color colour;

	public ColourMapFixed(Color colour) {
		this.colour = colour;
	}

	public Color colour(long weight, long maxWeight) {
		return colour;
	}

	public Color colour(double value) {
		return colour;
	}
}
"
ColourMapFixedOpacity.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapFixedOpacity extends ColourMap {
	private final ColourMap base;
	private final int opacity;

	public ColourMapFixedOpacity(ColourMap base, float opacity) {
		this.base = base;
		this.opacity = (int) (opacity * 255);
	}

	public Color colour(long weight, long maxWeight) {
		Color colour = base.colour(weight, maxWeight);
		return new Color(colour.getRed(), colour.getGreen(), colour.getBlue(), opacity);
	}

	public Color colour(double value) {
		Color colour = base.colour(value);
		return new Color(colour.getRed(), colour.getGreen(), colour.getBlue(), opacity);
	}

}
"
ColourMapGreen.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapGreen extends ColourMap {

	public Color colour(long weight, long maxWeight) {
		return ColourMaps.colourMapGreen(weight, maxWeight);
	}

	public Color colour(double value) {
		return ColourMaps.colourMapGreen(value);
	}

}
"
ColourMapGreyBlack.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapGreyBlack extends ColourMap {

	public Color colour(long weight, long maxWeight) {
		return ColourMaps.colourMapGreyBlack(weight, maxWeight);
	}

	public Color colour(double value) {
		return ColourMaps.colourMapGreyBlack(value);
	}

}
"
ColourMapInterpolate.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

/**
 * Interpolates a list of colours.
 * 
 * @author sander
 *
 */
public abstract class ColourMapInterpolate extends ColourMap {

	protected abstract float[][] getData();

	public Color colour(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;
		return colour(x);
	}

	public Color colour(double x) {
		float[][] data = getData();
		int indexBelow = (int) Math.floor((data.length - 1) * x);
		int indexAbove = (int) Math.ceil((data.length - 1) * x);
		if (indexBelow == indexAbove) {
			return new Color(data[indexAbove][0], data[indexAbove][1], data[indexAbove][2]);
		}

		float r = interpolate(data[indexBelow][0], data[indexAbove][0], indexBelow, indexAbove, (data.length - 1) * x);
		float g = interpolate(data[indexBelow][1], data[indexAbove][1], indexBelow, indexAbove, (data.length - 1) * x);
		float b = interpolate(data[indexBelow][2], data[indexAbove][2], indexBelow, indexAbove, (data.length - 1) * x);
		return new Color(r, g, b);
	}

	public float interpolate(float fromY, float toY, float fromX, float toX, double X) {
		return (float) (fromY - ((fromY - toY) * (fromX - X) / (fromX - toX)));
	}
}
"
ColourMapLightBlue.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapLightBlue extends ColourMap {

	public Color colour(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;

		x = (x * 0.25f) + 0.1f;
		return new Color(1 - x, 1 - x, 1);
	}
	
	public Color colour(double x) {
		x = (x * 0.25f) + 0.1f;
		return new Color((float) (1 - x), (float) (1 - x), 1);
	}

}
"
ColourMapOpacity.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapOpacity extends ColourMap {
	private final ColourMap base;

	public ColourMapOpacity(ColourMap base) {
		this.base = base;
	}

	public Color colour(long weight, long maxWeight) {
		float opacity = weight / (float) maxWeight;
		Color colour = base.colour(weight, maxWeight);
		return new Color(colour.getRed(), colour.getGreen(), colour.getBlue(), opacity);
	}

	public Color colour(double opacity) {
		Color colour = base.colour(opacity);
		return new Color(colour.getRed(), colour.getGreen(), colour.getBlue(), (float) opacity);
	}

}
"
ColourMapRed.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapRed extends ColourMap {
	
	public Color colour(long weight, long maxWeight) {
		return ColourMaps.colourMapRed(weight, maxWeight);
	}
	
	public Color colour(double value) {
		return ColourMaps.colourMapRed(value);
	}

}
"
ColourMaps.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMaps {
	public static Color colourMapBlackBody(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;

		/*
		 * //blue-yellow x = (x * (float) 0.5) + (float) 0.5; return new
		 * Color(x, x, 1-x);
		 */
		x = (x * (float) 0.75) + (float) 0.25;

		//black-body
		return new Color(Math.min(Math.max((1 - x) * 3, 0), 1),
				Math.min(Math.max((((1 - x) - 1 / (float) 3) * 3), 0), 1),
				Math.min(Math.max((((1 - x) - 2 / (float) 3) * 3), 0), 1));
	}

	public static Color colourMapBlackBody(double x) {
		/*
		 * //blue-yellow x = (x * (float) 0.5) + (float) 0.5; return new
		 * Color(x, x, 1-x);
		 */
		x = (x * (float) 0.75) + (float) 0.25;

		//black-body
		return new Color((float) (Math.min(Math.max((1 - x) * 3, 0), 1)),
				(float) (Math.min(Math.max((((1 - x) - 1 / 3) * 3), 0), 1)),
				(float) (Math.min(Math.max((((1 - x) - 2 / 3) * 3), 0), 1)));
	}

	public static Color colourMapRed(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;

		x = (x * (float) 0.5) + (float) 0.5;
		return new Color(1, 1 - x, 1 - x);
	}

	public static Color colourMapRed(double x) {
		x = (x * 0.5) + 0.5;
		return new Color(1, (float) (1 - x), (float) (1 - x));
	}

	public static Color colourMapGreen(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;

		x = (x * (float) 0.75) + (float) 0.25;
		return new Color(1 - x, 1, 1 - x);
	}

	public static Color colourMapGreen(double x) {
		x = (x * 0.75) + 0.25;
		return new Color((float) (1 - x), 1, (float) (1 - x));
	}

	public static Color colourMapBlue(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;

		x = (x * (float) 0.75) + (float) 0.25;
		return new Color(1 - x, 1 - x, 1);
	}

	public static Color colourMapBlue(double x) {
		x = (x * 0.75) + 0.25;
		return new Color((float) (1 - x), (float) (1 - x), 1);
	}

	public static Color colourMapGreyBlack(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;

		x = (x * (float) 0.6) + (float) 0.4;
		return new Color(1 - x, 1 - x, 1 - x);
	}

	public static Color colourMapGreyBlack(double x) {
		x = (x * 0.6) + 0.4;
		return new Color((float) (1 - x), (float) (1 - x), (float) (1 - x));
	}

	public static double getLuma(Color colour) {
		int R = colour.getRed();
		int G = colour.getGreen();
		int B = colour.getBlue();
		return 0.299 * R + 0.587 * G + 0.114 * B;
	}
}
"
ColourMapViridis.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

public class ColourMapViridis extends ColourMapInterpolate {

	protected float[][] data = new float[][] { { 0.267004f, 0.004874f, 0.329415f }, { 0.268510f, 0.009605f, 0.335427f },
			{ 0.269944f, 0.014625f, 0.341379f }, { 0.271305f, 0.019942f, 0.347269f },
			{ 0.272594f, 0.025563f, 0.353093f }, { 0.273809f, 0.031497f, 0.358853f },
			{ 0.274952f, 0.037752f, 0.364543f }, { 0.276022f, 0.044167f, 0.370164f },
			{ 0.277018f, 0.050344f, 0.375715f }, { 0.277941f, 0.056324f, 0.381191f },
			{ 0.278791f, 0.062145f, 0.386592f }, { 0.279566f, 0.067836f, 0.391917f },
			{ 0.280267f, 0.073417f, 0.397163f }, { 0.280894f, 0.078907f, 0.402329f },
			{ 0.281446f, 0.084320f, 0.407414f }, { 0.281924f, 0.089666f, 0.412415f },
			{ 0.282327f, 0.094955f, 0.417331f }, { 0.282656f, 0.100196f, 0.422160f },
			{ 0.282910f, 0.105393f, 0.426902f }, { 0.283091f, 0.110553f, 0.431554f },
			{ 0.283197f, 0.115680f, 0.436115f }, { 0.283229f, 0.120777f, 0.440584f },
			{ 0.283187f, 0.125848f, 0.444960f }, { 0.283072f, 0.130895f, 0.449241f },
			{ 0.282884f, 0.135920f, 0.453427f }, { 0.282623f, 0.140926f, 0.457517f },
			{ 0.282290f, 0.145912f, 0.461510f }, { 0.281887f, 0.150881f, 0.465405f },
			{ 0.281412f, 0.155834f, 0.469201f }, { 0.280868f, 0.160771f, 0.472899f },
			{ 0.280255f, 0.165693f, 0.476498f }, { 0.279574f, 0.170599f, 0.479997f },
			{ 0.278826f, 0.175490f, 0.483397f }, { 0.278012f, 0.180367f, 0.486697f },
			{ 0.277134f, 0.185228f, 0.489898f }, { 0.276194f, 0.190074f, 0.493001f },
			{ 0.275191f, 0.194905f, 0.496005f }, { 0.274128f, 0.199721f, 0.498911f },
			{ 0.273006f, 0.204520f, 0.501721f }, { 0.271828f, 0.209303f, 0.504434f },
			{ 0.270595f, 0.214069f, 0.507052f }, { 0.269308f, 0.218818f, 0.509577f },
			{ 0.267968f, 0.223549f, 0.512008f }, { 0.266580f, 0.228262f, 0.514349f },
			{ 0.265145f, 0.232956f, 0.516599f }, { 0.263663f, 0.237631f, 0.518762f },
			{ 0.262138f, 0.242286f, 0.520837f }, { 0.260571f, 0.246922f, 0.522828f },
			{ 0.258965f, 0.251537f, 0.524736f }, { 0.257322f, 0.256130f, 0.526563f },
			{ 0.255645f, 0.260703f, 0.528312f }, { 0.253935f, 0.265254f, 0.529983f },
			{ 0.252194f, 0.269783f, 0.531579f }, { 0.250425f, 0.274290f, 0.533103f },
			{ 0.248629f, 0.278775f, 0.534556f }, { 0.246811f, 0.283237f, 0.535941f },
			{ 0.244972f, 0.287675f, 0.537260f }, { 0.243113f, 0.292092f, 0.538516f },
			{ 0.241237f, 0.296485f, 0.539709f }, { 0.239346f, 0.300855f, 0.540844f },
			{ 0.237441f, 0.305202f, 0.541921f }, { 0.235526f, 0.309527f, 0.542944f },
			{ 0.233603f, 0.313828f, 0.543914f }, { 0.231674f, 0.318106f, 0.544834f },
			{ 0.229739f, 0.322361f, 0.545706f }, { 0.227802f, 0.326594f, 0.546532f },
			{ 0.225863f, 0.330805f, 0.547314f }, { 0.223925f, 0.334994f, 0.548053f },
			{ 0.221989f, 0.339161f, 0.548752f }, { 0.220057f, 0.343307f, 0.549413f },
			{ 0.218130f, 0.347432f, 0.550038f }, { 0.216210f, 0.351535f, 0.550627f },
			{ 0.214298f, 0.355619f, 0.551184f }, { 0.212395f, 0.359683f, 0.551710f },
			{ 0.210503f, 0.363727f, 0.552206f }, { 0.208623f, 0.367752f, 0.552675f },
			{ 0.206756f, 0.371758f, 0.553117f }, { 0.204903f, 0.375746f, 0.553533f },
			{ 0.203063f, 0.379716f, 0.553925f }, { 0.201239f, 0.383670f, 0.554294f },
			{ 0.199430f, 0.387607f, 0.554642f }, { 0.197636f, 0.391528f, 0.554969f },
			{ 0.195860f, 0.395433f, 0.555276f }, { 0.194100f, 0.399323f, 0.555565f },
			{ 0.192357f, 0.403199f, 0.555836f }, { 0.190631f, 0.407061f, 0.556089f },
			{ 0.188923f, 0.410910f, 0.556326f }, { 0.187231f, 0.414746f, 0.556547f },
			{ 0.185556f, 0.418570f, 0.556753f }, { 0.183898f, 0.422383f, 0.556944f },
			{ 0.182256f, 0.426184f, 0.557120f }, { 0.180629f, 0.429975f, 0.557282f },
			{ 0.179019f, 0.433756f, 0.557430f }, { 0.177423f, 0.437527f, 0.557565f },
			{ 0.175841f, 0.441290f, 0.557685f }, { 0.174274f, 0.445044f, 0.557792f },
			{ 0.172719f, 0.448791f, 0.557885f }, { 0.171176f, 0.452530f, 0.557965f },
			{ 0.169646f, 0.456262f, 0.558030f }, { 0.168126f, 0.459988f, 0.558082f },
			{ 0.166617f, 0.463708f, 0.558119f }, { 0.165117f, 0.467423f, 0.558141f },
			{ 0.163625f, 0.471133f, 0.558148f }, { 0.162142f, 0.474838f, 0.558140f },
			{ 0.160665f, 0.478540f, 0.558115f }, { 0.159194f, 0.482237f, 0.558073f },
			{ 0.157729f, 0.485932f, 0.558013f }, { 0.156270f, 0.489624f, 0.557936f },
			{ 0.154815f, 0.493313f, 0.557840f }, { 0.153364f, 0.497000f, 0.557724f },
			{ 0.151918f, 0.500685f, 0.557587f }, { 0.150476f, 0.504369f, 0.557430f },
			{ 0.149039f, 0.508051f, 0.557250f }, { 0.147607f, 0.511733f, 0.557049f },
			{ 0.146180f, 0.515413f, 0.556823f }, { 0.144759f, 0.519093f, 0.556572f },
			{ 0.143343f, 0.522773f, 0.556295f }, { 0.141935f, 0.526453f, 0.555991f },
			{ 0.140536f, 0.530132f, 0.555659f }, { 0.139147f, 0.533812f, 0.555298f },
			{ 0.137770f, 0.537492f, 0.554906f }, { 0.136408f, 0.541173f, 0.554483f },
			{ 0.135066f, 0.544853f, 0.554029f }, { 0.133743f, 0.548535f, 0.553541f },
			{ 0.132444f, 0.552216f, 0.553018f }, { 0.131172f, 0.555899f, 0.552459f },
			{ 0.129933f, 0.559582f, 0.551864f }, { 0.128729f, 0.563265f, 0.551229f },
			{ 0.127568f, 0.566949f, 0.550556f }, { 0.126453f, 0.570633f, 0.549841f },
			{ 0.125394f, 0.574318f, 0.549086f }, { 0.124395f, 0.578002f, 0.548287f },
			{ 0.123463f, 0.581687f, 0.547445f }, { 0.122606f, 0.585371f, 0.546557f },
			{ 0.121831f, 0.589055f, 0.545623f }, { 0.121148f, 0.592739f, 0.544641f },
			{ 0.120565f, 0.596422f, 0.543611f }, { 0.120092f, 0.600104f, 0.542530f },
			{ 0.119738f, 0.603785f, 0.541400f }, { 0.119512f, 0.607464f, 0.540218f },
			{ 0.119423f, 0.611141f, 0.538982f }, { 0.119483f, 0.614817f, 0.537692f },
			{ 0.119699f, 0.618490f, 0.536347f }, { 0.120081f, 0.622161f, 0.534946f },
			{ 0.120638f, 0.625828f, 0.533488f }, { 0.121380f, 0.629492f, 0.531973f },
			{ 0.122312f, 0.633153f, 0.530398f }, { 0.123444f, 0.636809f, 0.528763f },
			{ 0.124780f, 0.640461f, 0.527068f }, { 0.126326f, 0.644107f, 0.525311f },
			{ 0.128087f, 0.647749f, 0.523491f }, { 0.130067f, 0.651384f, 0.521608f },
			{ 0.132268f, 0.655014f, 0.519661f }, { 0.134692f, 0.658636f, 0.517649f },
			{ 0.137339f, 0.662252f, 0.515571f }, { 0.140210f, 0.665859f, 0.513427f },
			{ 0.143303f, 0.669459f, 0.511215f }, { 0.146616f, 0.673050f, 0.508936f },
			{ 0.150148f, 0.676631f, 0.506589f }, { 0.153894f, 0.680203f, 0.504172f },
			{ 0.157851f, 0.683765f, 0.501686f }, { 0.162016f, 0.687316f, 0.499129f },
			{ 0.166383f, 0.690856f, 0.496502f }, { 0.170948f, 0.694384f, 0.493803f },
			{ 0.175707f, 0.697900f, 0.491033f }, { 0.180653f, 0.701402f, 0.488189f },
			{ 0.185783f, 0.704891f, 0.485273f }, { 0.191090f, 0.708366f, 0.482284f },
			{ 0.196571f, 0.711827f, 0.479221f }, { 0.202219f, 0.715272f, 0.476084f },
			{ 0.208030f, 0.718701f, 0.472873f }, { 0.214000f, 0.722114f, 0.469588f },
			{ 0.220124f, 0.725509f, 0.466226f }, { 0.226397f, 0.728888f, 0.462789f },
			{ 0.232815f, 0.732247f, 0.459277f }, { 0.239374f, 0.735588f, 0.455688f },
			{ 0.246070f, 0.738910f, 0.452024f }, { 0.252899f, 0.742211f, 0.448284f },
			{ 0.259857f, 0.745492f, 0.444467f }, { 0.266941f, 0.748751f, 0.440573f },
			{ 0.274149f, 0.751988f, 0.436601f }, { 0.281477f, 0.755203f, 0.432552f },
			{ 0.288921f, 0.758394f, 0.428426f }, { 0.296479f, 0.761561f, 0.424223f },
			{ 0.304148f, 0.764704f, 0.419943f }, { 0.311925f, 0.767822f, 0.415586f },
			{ 0.319809f, 0.770914f, 0.411152f }, { 0.327796f, 0.773980f, 0.406640f },
			{ 0.335885f, 0.777018f, 0.402049f }, { 0.344074f, 0.780029f, 0.397381f },
			{ 0.352360f, 0.783011f, 0.392636f }, { 0.360741f, 0.785964f, 0.387814f },
			{ 0.369214f, 0.788888f, 0.382914f }, { 0.377779f, 0.791781f, 0.377939f },
			{ 0.386433f, 0.794644f, 0.372886f }, { 0.395174f, 0.797475f, 0.367757f },
			{ 0.404001f, 0.800275f, 0.362552f }, { 0.412913f, 0.803041f, 0.357269f },
			{ 0.421908f, 0.805774f, 0.351910f }, { 0.430983f, 0.808473f, 0.346476f },
			{ 0.440137f, 0.811138f, 0.340967f }, { 0.449368f, 0.813768f, 0.335384f },
			{ 0.458674f, 0.816363f, 0.329727f }, { 0.468053f, 0.818921f, 0.323998f },
			{ 0.477504f, 0.821444f, 0.318195f }, { 0.487026f, 0.823929f, 0.312321f },
			{ 0.496615f, 0.826376f, 0.306377f }, { 0.506271f, 0.828786f, 0.300362f },
			{ 0.515992f, 0.831158f, 0.294279f }, { 0.525776f, 0.833491f, 0.288127f },
			{ 0.535621f, 0.835785f, 0.281908f }, { 0.545524f, 0.838039f, 0.275626f },
			{ 0.555484f, 0.840254f, 0.269281f }, { 0.565498f, 0.842430f, 0.262877f },
			{ 0.575563f, 0.844566f, 0.256415f }, { 0.585678f, 0.846661f, 0.249897f },
			{ 0.595839f, 0.848717f, 0.243329f }, { 0.606045f, 0.850733f, 0.236712f },
			{ 0.616293f, 0.852709f, 0.230052f }, { 0.626579f, 0.854645f, 0.223353f },
			{ 0.636902f, 0.856542f, 0.216620f }, { 0.647257f, 0.858400f, 0.209861f },
			{ 0.657642f, 0.860219f, 0.203082f }, { 0.668054f, 0.861999f, 0.196293f },
			{ 0.678489f, 0.863742f, 0.189503f }, { 0.688944f, 0.865448f, 0.182725f },
			{ 0.699415f, 0.867117f, 0.175971f }, { 0.709898f, 0.868751f, 0.169257f },
			{ 0.720391f, 0.870350f, 0.162603f }, { 0.730889f, 0.871916f, 0.156029f },
			{ 0.741388f, 0.873449f, 0.149561f }, { 0.751884f, 0.874951f, 0.143228f },
			{ 0.762373f, 0.876424f, 0.137064f }, { 0.772852f, 0.877868f, 0.131109f },
			{ 0.783315f, 0.879285f, 0.125405f }, { 0.793760f, 0.880678f, 0.120005f },
			{ 0.804182f, 0.882046f, 0.114965f }, { 0.814576f, 0.883393f, 0.110347f },
			{ 0.824940f, 0.884720f, 0.106217f }, { 0.835270f, 0.886029f, 0.102646f },
			{ 0.845561f, 0.887322f, 0.099702f }, { 0.855810f, 0.888601f, 0.097452f },
			{ 0.866013f, 0.889868f, 0.095953f }, { 0.876168f, 0.891125f, 0.095250f },
			{ 0.886271f, 0.892374f, 0.095374f }, { 0.896320f, 0.893616f, 0.096335f },
			{ 0.906311f, 0.894855f, 0.098125f }, { 0.916242f, 0.896091f, 0.100717f },
			{ 0.926106f, 0.897330f, 0.104071f }, { 0.935904f, 0.898570f, 0.108131f },
			{ 0.945636f, 0.899815f, 0.112838f }, { 0.955300f, 0.901065f, 0.118128f },
			{ 0.964894f, 0.902323f, 0.123941f }, { 0.974417f, 0.903590f, 0.130215f },
			{ 0.983868f, 0.904867f, 0.136897f }, { 0.993248f, 0.906157f, 0.143936f } };

	protected float[][] getData() {
		return data;
	}
}"
ColourMapWhiteRed.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.colourMaps;

import java.awt.Color;

public class ColourMapWhiteRed extends ColourMap {
	public Color colour(long weight, long maxWeight) {
		float x = weight / (float) maxWeight;
		return new Color(1, x, x);
	}

	public Color colour(double value) {
		return new Color(1, (float) value, (float) value);
	}
}
"
AbstractDotElement.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot;

import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArrayList;

import org.processmining.plugins.graphviz.visualisation.listeners.DotElementSelectionListener;

public abstract class AbstractDotElement implements DotElement {
	private final String id;
	private Map<String, String> optionsMap;
	private String label;

	private boolean selectable = false;
	private final List<DotElementSelectionListener> selectionListeners = new CopyOnWriteArrayList<>();
	private final List<MouseListener> mouseListeners = new CopyOnWriteArrayList<MouseListener>();

	public AbstractDotElement() {
		id = ""e"" + UUID.randomUUID().toString();
		label = """";
		optionsMap = new HashMap<>();
	}

	public String getId() {
		return id;
	}

	public String getLabel() {
		return label;
	}

	public void setLabel(String label) {
		this.label = label;
	}

	public String labelToString() {
		return escapeString(label);
	}
	
	protected String escapeString(String value) {
		if (value.length() > 2 && value.substring(0, 1).equals(""<"")
				&& value.substring(value.length() - 1, value.length()).equals("">"")) {
			return value;
		} else {
			String value2 = value.replace(""\"""", ""\\\"""");
			return ""\"""" + value2 + ""\"""";
		}
	}

	@Override
	public void setOption(String key, String value) {
		optionsMap.put(key, value);
	}
	
	@Override
	public String getOption(String key) {
		if (optionsMap.containsKey(key)) {
			return optionsMap.get(key);
		}
		return null;
	}
	
	@Override
	public Set<String> getOptionKeySet() {
		return Collections.unmodifiableSet(optionsMap.keySet());
	}

	public void addMouseListener(MouseListener l) {
		mouseListeners.add(l);
	}

	public void mouseClicked(MouseEvent e) {
		for (MouseListener l : mouseListeners) {
			l.mouseClicked(e);
		}
	}

	public void mouseEntered(MouseEvent e) {
		for (MouseListener l : mouseListeners) {
			l.mouseEntered(e);
		}
	}

	public void mouseExited(MouseEvent e) {
		for (MouseListener l : mouseListeners) {
			l.mouseExited(e);
		}
	}

	public void mousePressed(MouseEvent e) {
		for (MouseListener l : mouseListeners) {
			l.mousePressed(e);
		}
	}

	public void mouseReleased(MouseEvent e) {
		for (MouseListener l : mouseListeners) {
			l.mouseReleased(e);
		}
	}

	//selection stuff
	public void setSelectable(boolean selectable) {
		this.selectable = selectable;
	}

	public boolean isSelectable() {
		return selectable;
	}
	
	public void addSelectionListener(DotElementSelectionListener listener) {
		setSelectable(true);
		selectionListeners.add(listener);
	}
	
	public List<DotElementSelectionListener> getSelectionListeners() {
		return Collections.unmodifiableList(selectionListeners);	
	}
}
"
Dot.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;

import org.apache.commons.io.IOUtils;

public class Dot extends DotCluster {

	public enum GraphDirection {
		topDown(""TD""), leftRight(""LR""), bottomTop(""BT""), rightLeft(""RL"");

		private final String name;

		private GraphDirection(String s) {
			name = s;
		}

		public String getName() {
			return name;
		}
	}

	private String stringValue = null;

	public Dot() {
		setOption(""rankdir"", ""TD"");
		setOption(""compound"", ""true"");
	}

	public String toString() {
		if (stringValue != null) {
			return stringValue;
		}

		StringBuilder result = new StringBuilder();
		result.append(""digraph G {\n"");

		appendOptions(result);

		contentToString(result);

		result.append(""}"");

		return result.toString();
	}

	public Dot(InputStream input) throws IOException {
		this.stringValue = IOUtils.toString(input, ""UTF-8"");
	}

	public void exportToFile(File file) throws IOException {
		BufferedWriter writer = null;
		try {
			writer = new BufferedWriter(new FileWriter(file));
			writer.write(toString());
		} finally {
			try {
				if (writer != null) {
					writer.close();
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	public GraphDirection getDirection() {
		String value = getOption(""rankdir"");
		for (GraphDirection dir : GraphDirection.values()) {
			if (dir.getName().equals(value)) {
				return dir;
			}
		}
		return GraphDirection.topDown;
	}

	public void setDirection(GraphDirection direction) {
		setOption(""rankdir"", direction.getName());
	}

	public void setStringValue(String stringValue) {
		this.stringValue = stringValue;
	}

	public boolean isKeepOrderingOfChildren() {
		return ""out"".equals(getGraphOption(""ordering""));
	}

	public void setKeepOrderingOfChildren(boolean keepOrderingOfChildren) {
		if (keepOrderingOfChildren) {
			setGraphOption(""ordering"", ""out"");
		} else {
			setGraphOption(""ordering"", """"); // graphviz default
		}
	}

}"
Dot2Image.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot;

import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

import org.apache.commons.compress.utils.IOUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;

public class Dot2Image {

	public static final int dotVersion = 8;

	public enum Type {
		png, pdf, svg
	}

	public enum Engine {
		dot, neato
	}

	public static InputStream dot2imageInputStream(Dot dot, Type type) {
		Engine engine;
		if (dot.getOption(""engine"") == ""neato"") {
			engine = Engine.neato;
		} else {
			engine = Engine.dot;
		}
		return dot2imageInputStream(dot.toString(), type, engine);
	}

	public static InputStream dot2imageInputStream(String dot, Type type) {
		return dot2imageInputStream(dot, type, Engine.dot);
	}

	public static InputStream dot2imageInputStream(Dot dot, Type type, Engine engine) {
		return dot2imageInputStream(dot.toString(), type, engine);
	}

	public static InputStream dot2imageInputStream(String dot, Type type, Engine engine) {
		File dotDirectory;
		try {
			dotDirectory = getDotDirectory();
		} catch (IOException e1) {
			e1.printStackTrace();
			throw new RuntimeException(""Graphviz-dot binary not found. \n"" + ExceptionUtils.getStackTrace(e1));
		}

		//detect the operating system and locate dot binary
		String os = System.getProperty(""os.name"").toLowerCase();
		File dotFile;
		if (os.indexOf(""win"") >= 0) {
			//windows
			dotFile = new File(dotDirectory, ""dot.exe"");
		} else if (os.indexOf(""mac"") >= 0) {
			//assume mac
			dotFile = new File(new File(dotDirectory, ""mac""), ""dot"");
			dotFile.setExecutable(true);
		} else if (System.getProperty(""os.arch"").contains(""64"")) {
			//assume linux 64 bit
			dotFile = new File(new File(dotDirectory, ""linux64""), ""dot"");
			dotFile.setExecutable(true);
		} else {
			//assume linux 32 bit
			dotFile = new File(new File(dotDirectory, ""linux32""), ""dot"");
			dotFile.setExecutable(true);
		}

		//		System.out.println(dotFile);

		if (!dotFile.exists() || !dotFile.canExecute()) {
			throw new RuntimeException(""Graphviz-dot binary not found. "" + dotFile.toString());
		}

		String args[];
		switch (engine) {
			case dot :
				args = new String[3];
				args[0] = dotFile.getAbsolutePath();
				args[1] = ""-T"" + type;
				args[2] = ""-q"";
				break;
			case neato :
				args = new String[5];
				args[0] = dotFile.getAbsolutePath();
				args[1] = ""-n"";
				args[2] = ""-Kneato"";
				args[3] = ""-T"" + type;
				args[4] = ""-q"";
				break;
			default :
				args = new String[3];
				args[0] = dotFile.getAbsolutePath();
				args[1] = ""-T"" + type;
				args[2] = ""-q"";
				break;

		}

		final ProcessBuilder pb = new ProcessBuilder(args);
		pb.redirectErrorStream(false);

		Process dotProcess = null;
		try {
			dotProcess = pb.start();
			BufferedWriter out2 = new BufferedWriter(new OutputStreamWriter(dotProcess.getOutputStream(), ""UTF-8""));
			out2.write(dot.toString());
			out2.flush();
			out2.close();
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}

		redirectIO(dotProcess.getErrorStream(), System.err);
		InputStream outputOfDot = new BufferedInputStream(dotProcess.getInputStream());

		return outputOfDot;
	}

	public static boolean dot2image(String dot, File file, Type type) {
		return dot2image(dot, file, type, Engine.dot);
	}

	public static boolean dot2image(String dot, File file, Type type, Engine engine) {
		try {
			InputStream inputStream = dot2imageInputStream(dot, type, engine);
			FileOutputStream outputStream = new FileOutputStream(file);
			IOUtils.copy(inputStream, outputStream);
			outputStream.flush();
			outputStream.close();
		} catch (IOException e) {
			e.printStackTrace();
			return false;
		}
		return true;
	}

	public static boolean dot2image(Dot dot, File file, Type type) {
		return dot2image(dot.toString(), file, type);
	}

	public static boolean dot2image(Dot dot, File file, Type type, Engine engine) {
		return dot2image(dot.toString(), file, type, engine);
	}

	private static List<String> dotFiles = new LinkedList<String>(Arrays.asList(""dot.exe"", ""cdt.dll"", ""cgraph.dll"",
			""config6"", ""dot.exe"", ""fontconfig_fix.dll"", ""fontconfig.dll"", ""freetype6.dll"", ""glut32.dll"", ""gvc.dll"",
			""gvplugin_core.dll"", ""gvplugin_dot_layout.dll"", ""gvplugin_gd.dll"", ""gvplugin_gdiplus.dll"",
			""gvplugin_neato_layout.dll"", ""gvplugin_pango.dll"", ""iconv.dll"", ""intl.dll"", ""jpeg62.dll"",
			""libatk-1.0-0.dll"", ""libcairo-2.dll"", ""libexpat-1.dll"", ""libexpat.dll"", ""libfontconfig-1.dll"",
			""libfreetype-6.dll"", ""libgdk_pixbuf-2.0-0.dll"", ""libgdk-win32-2.0-0.dll"", ""libgdkglext-win32-1.0-0.dll"",
			""libgio-2.0-0.dll"", ""libglib-2.0-0.dll"", ""libgmodule-2.0-0.dll"", ""libgobject-2.0-0.dll"",
			""libgthread-2.0-0.dll"", ""libgtk-win32-2.0-0.dll"", ""libgtkglext-win32-1.0-0.dll"", ""libltdl-3.dll"",
			""libpango-1.0-0.dll"", ""libpangocairo-1.0-0.dll"", ""libpangoft2-1.0-0.dll"", ""libpangowin32-1.0-0.dll"",
			""cdt.dll"", ""cgraph.dll"", ""config6"", ""dot.exe"", ""fontconfig_fix.dll"", ""fontconfig.dll"", ""freetype6.dll"",
			""glut32.dll"", ""gvc.dll"", ""gvplugin_core.dll"", ""gvplugin_dot_layout.dll"", ""gvplugin_gd.dll"",
			""gvplugin_gdiplus.dll"", ""gvplugin_neato_layout.dll"", ""gvplugin_pango.dll"", ""iconv.dll"", ""intl.dll"",
			""jpeg62.dll"", ""libatk-1.0-0.dll"", ""libcairo-2.dll"", ""libexpat-1.dll"", ""libexpat.dll"", ""libfontconfig-1.dll"",
			""libfreetype-6.dll"", ""libgdk_pixbuf-2.0-0.dll"", ""libgdk-win32-2.0-0.dll"", ""libgdkglext-win32-1.0-0.dll"",
			""libgio-2.0-0.dll"", ""libglib-2.0-0.dll"", ""libgmodule-2.0-0.dll"", ""libgobject-2.0-0.dll"",
			""libgthread-2.0-0.dll"", ""libgtk-win32-2.0-0.dll"", ""libgtkglext-win32-1.0-0.dll"", ""libltdl-3.dll"",
			""libpango-1.0-0.dll"", ""libpangocairo-1.0-0.dll"", ""libpangoft2-1.0-0.dll"", ""libpangowin32-1.0-0.dll"",
			""libpng12.dll"", ""libpng14-14.dll"", ""libxml2.dll"", ""ltdl.dll"", ""Pathplan.dll"", ""zlib1.dll"", ""libpng12.dll"",
			""libpng14-14.dll"", ""libxml2.dll"", ""ltdl.dll"", ""Pathplan.dll"", ""zlib1.dll"",
			//linux
			""linux32/dot"", ""linux64/dot"",
			//mac
			""mac/dot""));

	private static synchronized File getDotDirectory() throws IOException {
		File dotDirectory = new File(new File(System.getProperty(""java.io.tmpdir""), "".prom-graphviz""),
				""dotBinaries"" + dotVersion);
		if (!dotDirectory.exists()) {
			createDotDirectoryByCopying(dotDirectory);
		}

		for (String fileName : dotFiles) {
			File outputFile = new File(dotDirectory, fileName);
			if (!outputFile.exists()) {
				createDotDirectoryByCopying(dotDirectory);
				break;
			}
		}

		return dotDirectory;
	}

	private static void createDotDirectoryByCopying(File targetDirectory) throws IOException {
		System.out.println(""dot directory "" + targetDirectory + "" does not exist; create it and copy binaries to it"");
		targetDirectory.mkdirs();
		new File(targetDirectory, ""mac"").mkdir();
		new File(targetDirectory, ""linux32"").mkdir();
		new File(targetDirectory, ""linux64"").mkdir();

		//copy files to dot directory
		for (String fileName : dotFiles) {
			File outputFile = new File(targetDirectory, fileName);
			System.out.println(""copy "" + fileName);
			InputStream inputStream = Dot2Image.class
					.getResourceAsStream(""/org/processmining/plugins/graphviz/dot/binaries/"" + fileName);
			FileOutputStream outputStream = new FileOutputStream(outputFile);
			IOUtils.copy(inputStream, outputStream);
			outputFile.setExecutable(true);

			outputStream.flush();
			outputStream.close();
		}
	}

	private static void redirectIO(final InputStream src, final PrintStream dest) {
		new Thread(new Runnable() {
			public void run() {
				Scanner sc = new Scanner(src);
				while (sc.hasNextLine()) {
					dest.println(sc.nextLine());
				}
			}
		}).start();
	}
}
"
DotCluster.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class DotCluster extends DotNode {

	private final List<DotNode> nodes;
	private final List<DotEdge> edges;
	private final List<DotCluster> clusters;

	private final Map<String, String> graphOptionMap;
	private final Map<String, String> nodeOptionMap;
	private final Map<String, String> edgeOptionMap;

	protected DotCluster() {
		super("""", null);
		nodes = new ArrayList<DotNode>();
		edges = new ArrayList<DotEdge>();
		clusters = new ArrayList<DotCluster>();
		graphOptionMap = new HashMap<>();
		nodeOptionMap = new HashMap<>();
		edgeOptionMap = new HashMap<>();
	}

	/**
	 * 
	 * @return An unmodifiable list of all nodes in the graph (not in
	 *         sub-graphs).
	 */
	public List<DotNode> getNodes() {
		return Collections.unmodifiableList(nodes);
	}

	/**
	 * 
	 * @return An unmodifiable list of all nodes in this graph and all it's
	 *         sub-graphs.
	 */
	public List<DotNode> getNodesRecursive() {
		List<DotNode> result = new LinkedList<DotNode>();
		result.addAll(nodes);
		result.addAll(clusters);

		for (DotCluster cluster : clusters) {
			result.addAll(cluster.getNodesRecursive());
		}

		return Collections.unmodifiableList(result);
	}

	/**
	 * Add a new dot node to the graph with the given label.
	 * 
	 * @param label
	 * @return the new dot node.
	 */
	public DotNode addNode(String label) {
		return addNode(label, null);
	}

	/**
	 * Add a new dot node to the graph.
	 * 
	 * @param label
	 * @param options
	 *            A map of node options, which will not be copied.
	 * @return the new dot node.
	 */
	public DotNode addNode(String label, Map<String, String> options) {
		DotNode result = new DotNode(label, options);
		addNode(result);
		return result;
	}

	/**
	 * Add an existing dot node to the graph.
	 * 
	 * @param node
	 */
	public void addNode(DotNode node) {
		nodes.add(node);
	}

	/**
	 * Insert a new dot node to the graph.
	 * 
	 * @param index
	 *            The index at which the node is to be inserted.
	 * @param label
	 * @return the new dot node.
	 */
	public DotNode insertNode(int index, String label) {
		return insertNode(index, label, null);
	}

	/**
	 * Insert a new dot node to the graph.
	 * 
	 * @param index
	 *            The index at which the node is to be inserted.
	 * @param label
	 * @param options
	 *            A map of node options, which will not be copied.
	 * @return the new dot node.
	 */
	public DotNode insertNode(int index, String label, Map<String, String> options) {
		DotNode result = new DotNode(label, options);
		insertNode(index, result);
		return result;
	}

	/**
	 * Insert an existing node into the graph.
	 * 
	 * @param index
	 *            The index at which the node is to be inserted.
	 * @param node
	 */
	public void insertNode(int index, DotNode node) {
		nodes.add(index, node);
	}

	/**
	 * Remove all equivalent dot nodes from the graph.
	 * 
	 * @param node
	 */
	public void removeNode(DotNode node) {
		Iterator<DotNode> it = nodes.iterator();
		while (it.hasNext()) {
			if (node.equals(it.next())) {
				it.remove();
			}
		}
	}

	/**
	 * Set a default node option. It will be a default for all nodes in this
	 * graph.
	 * 
	 * @param option
	 * @param value
	 */
	public void setNodeOption(String option, String value) {
		nodeOptionMap.put(option, value);
	}

	/**
	 * Get a default node option.
	 * 
	 * @param option
	 * @return The value of that option, or null if it is not set.
	 */
	public String getNodeOption(String option) {
		if (nodeOptionMap.containsKey(option)) {
			return nodeOptionMap.get(option);
		}
		return null;
	}

	/**
	 * 
	 * @return An unmodifiable list of all default node options for this graph.
	 */
	public Set<String> getNodeOptionKeySet() {
		return Collections.unmodifiableSet(nodeOptionMap.keySet());
	}

	/**
	 * 
	 * @return An unmodifiable list of all edges in this graph (not in
	 *         sub-graphs).
	 */
	public List<DotEdge> getEdges() {
		return Collections.unmodifiableList(edges);
	}

	/**
	 * 
	 * @return An unmodifiable list of all edges in this graph and in all its
	 *         sub-graphs.
	 */
	public List<DotEdge> getEdgesRecursive() {
		List<DotEdge> result = new LinkedList<DotEdge>();
		result.addAll(edges);

		for (DotCluster cluster : clusters) {
			result.addAll(cluster.getEdgesRecursive());
		}

		return Collections.unmodifiableList(result);
	}

	/**
	 * Add an edge that connects source to target, with a default label.
	 * 
	 * @param source
	 * @param target
	 * @return
	 */
	public DotEdge addEdge(DotNode source, DotNode target) {
		return addEdge(source, target, """");
	}

	/**
	 * Add an edge that connects source to target, having a label, without
	 * further options set.
	 * 
	 * @param source
	 * @param target
	 * @param label
	 * @return
	 */
	public DotEdge addEdge(DotNode source, DotNode target, String label) {
		return addEdge(source, target, label, null);
	}

	/**
	 * Add an edge that connects source to target, having a label and using an
	 * options map. This options map is not copied.
	 * 
	 * @param source
	 * @param target
	 * @param label
	 * @param optionsMap
	 * @return
	 */
	public DotEdge addEdge(DotNode source, DotNode target, String label, Map<String, String> optionsMap) {
		DotEdge result = new DotEdge(source, target, label, optionsMap);
		addEdge(result);
		return result;
	}

	/**
	 * Add a previously defined dot edge.
	 * 
	 * @param edge
	 */
	public void addEdge(DotEdge edge) {
		edges.add(edge);
	}

	/**
	 * Remove all equivalent edges from the graph.
	 * 
	 * @param edge
	 */
	public void removeEdge(DotEdge edge) {
		Iterator<DotEdge> it = edges.iterator();
		while (it.hasNext()) {
			if (edge == it.next()) {
				it.remove();
			}
		}
	}

	/**
	 * 
	 * @param source
	 * @param target
	 * @return The first edge from source to target in the graph.
	 */
	public DotEdge getFirstEdge(DotNode source, DotNode target) {
		for (DotEdge edge : edges) {
			if (edge.getSource() == source && edge.getTarget() == target) {
				return edge;
			}
		}
		return null;
	}

	/**
	 * Sets a default edge option. This will be the default for all edges in
	 * this graph.
	 * 
	 * @param option
	 * @param value
	 */
	public void setEdgeOption(String option, String value) {
		edgeOptionMap.put(option, value);
	}

	/**
	 * 
	 * @param option
	 * @return The value of the option, or null if it does not exist.
	 */
	public String getEdgeOption(String option) {
		if (edgeOptionMap.containsKey(option)) {
			return edgeOptionMap.get(option);
		}
		return null;
	}

	/**
	 * 
	 * @return An unmodifiable set of all default edge options set for this
	 *         graph.
	 */
	public Set<String> getEdgeOptions() {
		return Collections.unmodifiableSet(edgeOptionMap.keySet());
	}

//	@Deprecated
//	public Set<String> getEdgeOptionKeySet() {
//		return getEdgeOptions();
//	}

	/**
	 * 
	 * @return An unmodifiable list of clusters in this graph (not in
	 *         sub-graphs).
	 */
	public List<DotCluster> getClusters() {
		return Collections.unmodifiableList(clusters);
	}

	/**
	 * Add a new cluster to the graph.
	 * 
	 * @return
	 */
	public DotCluster addCluster() {
		DotCluster cluster = new DotCluster();
		clusters.add(cluster);
		return cluster;
	}

	/**
	 * Removes all equivalent clusters from the graph (not from sub-graphs).
	 * 
	 * @param cluster
	 */
	public void removeCluster(DotCluster cluster) {
		Iterator<DotCluster> it = clusters.iterator();
		while (it.hasNext()) {
			if (cluster.equals(it.next())) {
				it.remove();
			}
		}
	}

	/**
	 * Sets a default option for sub-graphs of this graph.
	 * 
	 * @param option
	 * @param value
	 */
	public void setGraphOption(String option, String value) {
		graphOptionMap.put(option, value);
	}

	/**
	 * Gets a default option for sub-graphs of this graph.
	 * 
	 * @param option
	 * @return the value of the option, or null if it does not exist.
	 */
	public String getGraphOption(String option) {
		if (graphOptionMap.containsKey(option)) {
			return graphOptionMap.get(option);
		}
		return null;
	}

	/**
	 * 
	 * @return An unmodifiable set of graph options that are set on this graph.
	 */
	public Set<String> getGraphOptions() {
		return Collections.unmodifiableSet(graphOptionMap.keySet());
	}

//	@Deprecated
//	public Set<String> getGraphOptionKeySet() {
//		return Collections.unmodifiableSet(graphOptionMap.keySet());
//	}

	/**
	 * Get a string representation of this graph in the Dot-language.
	 */
	public String toString() {
		StringBuilder result = new StringBuilder();
		result.append(""subgraph \"""" + getId() + ""\""{\n"");

		result.append(""id=\"""" + getId() + ""\"";"");
		result.append(""label="" + labelToString() + "";"");

		appendOptions(result);

		contentToString(result);

		result.append(""}"");

		return result.toString();
	}

	protected void appendOptions(StringBuilder result) {
		for (String key : getOptionKeySet()) {
			/*
			 * HV, May 11, 2017
			 * Graph label may contain HTML code. Deal with that.
			 */
			if (key.equals(""label"")) {
				String label = getOption(key);
				if (label.startsWith(""<"") && label.endsWith("">"")) {
					// Label contains HTML code, copy as-is
					result.append(key + ""="" + label + "";\n"");
					continue;
				}
			} 
			result.append(key + ""=\"""" + getOption(key) + ""\"";\n"");
		}
		appendSpecialOptions(result, ""graph"", graphOptionMap);
		appendSpecialOptions(result, ""node"", nodeOptionMap);
		appendSpecialOptions(result, ""edge"", edgeOptionMap);
	}

	protected void appendSpecialOptions(StringBuilder result, String type, Map<String, String> optionMap) {
		Iterator<String> graphOptionIter = optionMap.keySet().iterator();
		if (graphOptionIter.hasNext()) {
			result.append(type);
			result.append(""["");
			while (graphOptionIter.hasNext()) {
				String key = graphOptionIter.next();
				result.append(key + ""="" + escapeString(optionMap.get(key)));
				if (graphOptionIter.hasNext()) {
					result.append(',');
				}
			}
			result.append(""];\n"");
		}
	}

	protected void contentToString(StringBuilder result) {
		for (DotNode node : nodes) {
			result.append(node);
			result.append(""\n"");
		}

		for (DotEdge edge : edges) {
			result.append(edge);
			result.append(""\n"");
		}

		for (DotCluster cluster : clusters) {
			result.append(cluster);
			result.append(""\n"");
		}
	}

	@Override
	public String getId() {
		return ""cluster_"" + super.getId();
	}

}
"
DotEdge.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot;

import java.util.Map;
import java.util.Map.Entry;

public class DotEdge extends AbstractDotElement {

	private DotNode source;
	private DotNode target;

	public DotEdge(DotNode source, DotNode target) {
		this.setSource(source);
		this.setTarget(target);
	}

	public DotEdge(DotNode source, DotNode target, String label, Map<String, String> optionsMap) {
		this.setSource(source);
		this.setTarget(target);
		this.setLabel(label);
		if (optionsMap != null) {
			for (Entry<String, String> e : optionsMap.entrySet()) {
				setOption(e.getKey(), e.getValue());
			}
		}
	}

	public DotNode getTarget() {
		return target;
	}

	public void setTarget(DotNode target) {
		this.target = target;
	}

	public DotNode getSource() {
		return source;
	}

	public void setSource(DotNode source) {
		this.source = source;
	}

	public String toString() {
		/**
		 * Dot does not support edges from/to clusters. I such edges are added,
		 * use an arbitrary node in the cluster as the target.
		 */
		DotNode localSource = source;
		DotNode localTarget = target;
		{
			if (localSource instanceof DotCluster && !((DotCluster) localSource).getNodes().isEmpty()) {
				localSource = ((DotCluster) localSource).getNodes().get(0);
			}
			if (localTarget instanceof DotCluster && !((DotCluster) localTarget).getNodes().isEmpty()) {
				localTarget = ((DotCluster) localTarget).getNodes().get(0);
			}
		}

		String result = ""\"""" + localSource.getId() + ""\"" -> \"""" + localTarget.getId() + ""\"" [label="" + labelToString()
				+ "" id=\"""" + getId() + ""\"""";

		for (String key : getOptionKeySet()) {
			result += "","" + key + ""="" + escapeString(getOption(key));
		}
		
		/**
		 * If the edges goes to/from a cluster, we need to set the lhead/ltail.
		 */
		if (localSource != source) {
			result += "",ltail="" + escapeString(source.getId());
		}
		if (localTarget != target) {
			result += "",lhead="" + escapeString(target.getId());
		}

		return result + ""];"";
	}
}
"
DotElement.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot;

import java.awt.event.MouseListener;
import java.util.List;
import java.util.Set;

import org.processmining.plugins.graphviz.visualisation.listeners.DotElementSelectionListener;

public interface DotElement extends MouseListener {

	public String getLabel();

	public void setLabel(String label);

	public void setOption(String key, String value);

	/**
	 * 
	 * @param key
	 * @return the value of the option if it was set, otherwise null.
	 */
	public String getOption(String key);

	/**
	 * 
	 * @return the set of options that is set (keys)
	 */
	public Set<String> getOptionKeySet();

	public String getId();

	//mouse listeners, gui stuff

	/**
	 * Please note that in the current implementation, only a click on a drawn
	 * pixel of an element is registered as a click (due to Bezier curves for
	 * edges and irregular shapes for nodes). Thus, only if a user clicks on the
	 * border or label of a node, the click is registered. The same holds for
	 * mouseEnter and mouseExit events: these are based on drawn pixels.
	 * 
	 * To avoid this problem, give each node a fill using
	 * node.setOption(""fillcolor"", ""#FFFFFF"") and node.setOption(""style"",
	 * ""filled"").
	 * 
	 * @param l
	 */
	public void addMouseListener(MouseListener l);

	//selection listeners

	/**
	 * Sets whether this node can be selected.
	 * 
	 * Please note that in the current implementation, only a click on a drawn
	 * pixel of an element is registered as a click (due to Bezier curves for
	 * edges and irregular shapes for nodes). Thus, only if a user clicks on the
	 * border or label of a node, the click is registered.
	 * 
	 * To avoid this problem, give each node a fill using
	 * node.setOption(""fillcolor"", ""#FFFFFF"") and node.setOption(""style"",
	 * ""filled"").
	 * 
	 * @param selectable
	 */
	public void setSelectable(boolean selectable);

	/**
	 * Please note that in the current implementation, only a click on a drawn
	 * pixel of an element is registered as a click (due to Bezier curves for
	 * edges and irregular shapes for nodes). Thus, only if a user clicks on the
	 * border or label of a node, the click is registered.
	 * 
	 * To avoid this problem, give each node a fill using
	 * node.setOption(""fillcolor"", ""#FFFFFF"") and node.setOption(""style"",
	 * ""filled"").
	 * 
	 * @return whether the element is selectable.
	 */
	public boolean isSelectable();

	/**
	 * Add a selection/deselection listener. Side-effect: enables selection of
	 * the element. Thread-safe.
	 * 
	 * Please note that in the current implementation, only a click on a drawn
	 * pixel of an element is registered as a click (due to Bezier curves for
	 * edges and irregular shapes for nodes). Thus, only if a user clicks on the
	 * border or label of a node, the click is registered.
	 * 
	 * To avoid this problem, give each node a fill using
	 * node.setOption(""fillcolor"", ""#FFFFFF"") and node.setOption(""style"",
	 * ""filled"").
	 * 
	 * @param listener
	 */
	public void addSelectionListener(DotElementSelectionListener listener);

	public List<DotElementSelectionListener> getSelectionListeners();
}
"
DotNode.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot;

import java.util.Map;
import java.util.Map.Entry;

public class DotNode extends AbstractDotElement {

	protected DotNode(String label, Map<String, String> optionsMap) {
		this.setLabel(label);
		if (optionsMap != null) {
			for (Entry<String, String> e : optionsMap.entrySet()) {
				setOption(e.getKey(), e.getValue());
			}
		}
	}

	public boolean equals(Object object) {
		if (!(object instanceof DotNode)) {
			return false;
		}
		return ((DotNode) object).getId().equals(getId());
	}

	public String toString() {
		String result = ""\"""" + getId() + ""\"" [label="" + labelToString() + "", id=\"""" + getId() + ""\"""";
		for (String key : getOptionKeySet()) {
			result += "","" + key + ""="" + escapeString(getOption(key));
		}
		return result + ""];"";
	}

}
"
DotEMFExportPlugin.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot.plugins;

import java.io.File;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.visualisation.export.ExporterEMF;

/**
 * Exports a Dot object
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export Dot as EMF"", returnLabels = {}, returnTypes = {}, level = PluginLevel.Regular, parameterLabels = {
		""Dot"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export EMF"", extension = ""emf"")
public final class DotEMFExportPlugin extends DotImageExportPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Dot as EMF"")
	public void exportAsEMF(PluginContext context, Dot dot, File file) throws IOException {
		export(dot, file, new ExporterEMF());
	}
}"
DotEPSExportPlugin.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot.plugins;

import java.io.File;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.visualisation.export.ExporterEPS;

/**
 * Exports a Dot object
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export Dot as EPS"", returnLabels = {}, returnTypes = {}, level = PluginLevel.Regular, parameterLabels = {
		""Dot"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export EPS"", extension = ""eps"")
public final class DotEPSExportPlugin extends DotImageExportPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Dot as EPS"")
	public void exportAsEPS(PluginContext context, Dot dot, File file) throws IOException {
		export(dot, file, new ExporterEPS());
	}
}"
DotExportPlugin.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot.plugins;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;

/**
 * Exports a Dot object
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export Dot"", returnLabels = {}, returnTypes = {}, level = PluginLevel.Regular, parameterLabels = {
		""Dot"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export Dot"", extension = ""dot"")
public final class DotExportPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Dot File"")
	public void export(PluginContext context, Dot dot, File file) throws IOException {
		try (BufferedWriter fileWriter = new BufferedWriter(new FileWriter(file))) {
			fileWriter.write(dot.toString());
		}
	}
}"
DotImageExportPlugin.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot.plugins;

import java.awt.Dimension;
import java.io.File;
import java.io.IOException;

import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.visualisation.DotPanel;
import org.processmining.plugins.graphviz.visualisation.export.Exporter;

public abstract class DotImageExportPlugin {

	protected void export(Dot dot, File file, Exporter exporter) throws IOException {
		DotPanel panel = new DotPanel(dot);
		panel.setSize(new Dimension((int) panel.getSVG().getWidth(), (int) panel.getSVG().getHeight()));
		try {
			exporter.export(panel, file);
		} catch (Exception e) {
			if (e instanceof IOException) {
				throw (IOException) e;
			} else {
				throw new IOException(""Cannot export Dot."", e);
			}
		}
	}

}
"
DotPDFExportPlugin.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot.plugins;

import java.io.File;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.visualisation.export.ExporterPDF;

/**
 * Exports a Dot object
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export Dot as PDF"", returnLabels = {}, returnTypes = {}, level = PluginLevel.Regular, parameterLabels = {
		""Dot"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export PDF"", extension = ""pdf"")
public final class DotPDFExportPlugin extends DotImageExportPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Dot as PDF"")
	public void exportAsPDF(PluginContext context, Dot dot, File file) throws IOException {
		export(dot, file, new ExporterPDF());
	}
	
}"
DotPNGExportPlugin.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot.plugins;

import java.io.File;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.visualisation.export.ExporterPNG;

/**
 * Exports a Dot object
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export Dot as PNG"", returnLabels = {}, returnTypes = {}, level = PluginLevel.Regular, parameterLabels = {
		""Dot"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export PNG"", extension = ""png"")
public final class DotPNGExportPlugin extends DotImageExportPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Dot as PNG"")
	public void exportAsPNG(PluginContext context, Dot dot, File file) throws IOException {
		export(dot, file, new ExporterPNG());
	}
}"
DotSVGExportPlugin.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.dot.plugins;

import java.io.File;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.visualisation.export.ExporterSVG;

/**
 * Exports a Dot object
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export Dot as SVG"", returnLabels = {}, returnTypes = {}, level = PluginLevel.Regular, parameterLabels = {
		""Dot"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export SVG"", extension = ""svg"")
public final class DotSVGExportPlugin extends DotImageExportPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Dot as SVG"")
	public void exportAsSVG(PluginContext context, Dot dot, File file) throws IOException {
		export(dot, file, new ExporterSVG());
	}
}"
DotPanel.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation;

import java.awt.Color;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;

import org.processmining.plugins.graphviz.colourMaps.ColourMap;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.dot.Dot.GraphDirection;
import org.processmining.plugins.graphviz.dot.Dot2Image;
import org.processmining.plugins.graphviz.dot.Dot2Image.Type;
import org.processmining.plugins.graphviz.dot.DotEdge;
import org.processmining.plugins.graphviz.dot.DotElement;
import org.processmining.plugins.graphviz.dot.DotNode;
import org.processmining.plugins.graphviz.visualisation.export.Exporter;
import org.processmining.plugins.graphviz.visualisation.export.ExporterDot;
import org.processmining.plugins.graphviz.visualisation.listeners.DotElementSelectionListener;
import org.processmining.plugins.graphviz.visualisation.listeners.GraphChangedListener;
import org.processmining.plugins.graphviz.visualisation.listeners.GraphChangedListener.GraphChangedReason;
import org.processmining.plugins.graphviz.visualisation.listeners.MouseInElementsChangedListener;
import org.processmining.plugins.graphviz.visualisation.listeners.SelectionChangedListener;

import com.kitfox.svg.Group;
import com.kitfox.svg.RenderableElement;
import com.kitfox.svg.SVGDiagram;
import com.kitfox.svg.SVGElement;
import com.kitfox.svg.SVGElementException;
import com.kitfox.svg.SVGException;
import com.kitfox.svg.SVGUniverse;
import com.kitfox.svg.animation.AnimationElement;
import com.kitfox.svg.xml.StyleAttribute;

public class DotPanel extends NavigableSVGPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -6201301504669783161L;

	private Action changeGraphDirection = new AbstractAction() {
		private static final long serialVersionUID = -38576326322179480L;

		public void actionPerformed(ActionEvent e) {
			GraphDirection newDirection;
			switch (dot.getDirection()) {
				case bottomTop :
					newDirection = GraphDirection.leftRight;
					break;
				case leftRight :
					newDirection = GraphDirection.rightLeft;
					break;
				case rightLeft :
					newDirection = GraphDirection.topDown;
					break;
				case topDown :
					newDirection = GraphDirection.bottomTop;
					break;
				default :
					newDirection = GraphDirection.bottomTop;
					break;
			}
			userSettings.setDirection(newDirection);
			changeDot(dot, true);
			graphChanged(GraphChangedReason.graphDirectionChanged, newDirection);
		}
	};

	private Action increaseAspectRatio = new AbstractAction() {
		private static final long serialVersionUID = 2323619233153604381L;

		public void actionPerformed(ActionEvent e) {
			userSettings.nodeSeparation = Math.min(userSettings.nodeSeparation + .05, 4);
			changeDot(dot, true);
			graphChanged(GraphChangedReason.nodeSeparationChanged, userSettings.nodeSeparation);
		}
	};

	private Action decreaseAspectRatio = new AbstractAction() {
		private static final long serialVersionUID = 1136135860512175161L;

		public void actionPerformed(ActionEvent e) {
			userSettings.nodeSeparation = Math.max(userSettings.nodeSeparation - 0.05, 0.02);
			changeDot(dot, true);
			graphChanged(GraphChangedReason.nodeSeparationChanged, userSettings.nodeSeparation);
		}
	};

	private Dot dot;
	private final DotPanelUserSettings userSettings;
	private HashMap<String, DotElement> id2element;
	private Set<DotElement> selectedElements;
	private Set<DotElement> mouseInElements;
	private final CopyOnWriteArrayList<SelectionChangedListener<DotElement>> selectionChangedListeners = new CopyOnWriteArrayList<>();
	private final CopyOnWriteArrayList<MouseInElementsChangedListener<DotElement>> mouseInElementsChangedListeners = new CopyOnWriteArrayList<>();
	private final CopyOnWriteArrayList<GraphChangedListener> graphChangedListeners = new CopyOnWriteArrayList<>();

	public DotPanel(Dot dot) {
		super(dot2svg(dot));
		this.dot = dot;
		prepareNodeSelection(dot);
		mouseInElements = new HashSet<>();
		userSettings = new DotPanelUserSettings(dot);

		//listen to ctrl+d for a change in graph layouting direction
		helperControlsShortcuts.add(""ctrl d"");
		helperControlsExplanations.add(""change graph direction"");
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_D, InputEvent.CTRL_MASK),
				""changeGraphDirection"");
		getActionMap().put(""changeGraphDirection"", changeGraphDirection);

		//listen to ctrl+q for increasing aspect ratio
		helperControlsShortcuts.add(""ctrl q"");
		helperControlsExplanations.add(""increase graph node distance"");
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_Q, InputEvent.CTRL_MASK),
				""increaseAspectRatio"");
		getActionMap().put(""increaseAspectRatio"", increaseAspectRatio);

		//listen to ctrl+w for decreasing aspect ratio
		helperControlsShortcuts.add(""ctrl w"");
		helperControlsExplanations.add(""decrease graph node distance"");
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.CTRL_MASK),
				""decreaseAspectRatio"");
		getActionMap().put(""decreaseAspectRatio"", decreaseAspectRatio);

		//add mouse listeners
		final DotPanel this2 = this;
		addMouseListener(new MouseAdapter() {
			public void mousePressed(MouseEvent e) {
				e.setSource(this2);
				for (DotElement element : getElementsAtPoint(e.getPoint())) {
					element.mousePressed(e);
				}
			}
		});
	}

	@Override
	protected boolean processMouseClick(MouseEvent e) {
		boolean superChanged = super.processMouseClick(e);

		//pass clicks to elements and process selection changes, but not if the click was already catched.
		boolean selectionChange = false;
		Point point = e.getPoint();
		if (!superChanged) {
			e.setSource(this);
			for (DotElement element : getElementsAtPoint(point)) {
				element.mouseClicked(e);

				if (SwingUtilities.isLeftMouseButton(e)) {
					selectionChange = selectionChange || processSelection(element, e);
				}
			}

			if (SwingUtilities.isLeftMouseButton(e) && !selectionChange && !e.isControlDown()) {
				//the user did not click on anything clickable. Remove the selection.
				selectionChange = removeSelection();
			}

			if (selectionChange) {
				selectionChanged();
			}
		}

		return superChanged || selectionChange;
	};

	@Override
	protected boolean processMouseRelease(MouseEvent e) {
		boolean superChanged = super.processMouseRelease(e);

		//call mouseReleased on all elements under the mouse
		for (DotElement element : getElementsAtPoint(e.getPoint())) {
			element.mouseReleased(e);
		}

		return superChanged;
	}

	@Override
	protected boolean processMouseDrag(MouseEvent e) {
		boolean changed = super.processMouseDrag(e);

		//if we start dragging, we exit all elements
		changed |= exitAllElements(e);

		return changed;
	}

	@Override
	protected boolean processMouseMove(MouseEvent e) {
		boolean captured = super.processMouseMove(e);

		boolean changed = false;

		if (captured) {
			//something above us captured the mouse hover, so exit all dot elements
			changed = exitAllElements(e);
		} else {
			//process the mouseEnter and Exit of the dot elements
			Set<DotElement> newElements = getElementsAtPoint(e.getPoint());
			//exit
			for (DotElement element : mouseInElements) {
				if (!newElements.contains(element)) {
					element.mouseExited(e);
					changed = true;
				}
			}
			//enter
			for (DotElement element : newElements) {
				if (!mouseInElements.contains(element)) {
					element.mouseEntered(e);
					changed = true;
				}
			}
			mouseInElements = newElements;

			if (changed) {
				mouseInElementsChanged();
			}
		}

		return changed || captured;
	}

	@Override
	protected boolean processMouseExit(MouseEvent e) {
		boolean changed = super.processMouseExit(e);

		//exit the dot elements, as we are leaving the screen
		changed |= exitAllElements(e);

		return changed;
	}

	@Override
	public List<Exporter> getExporters() {
		List<Exporter> exporters = super.getExporters();
		exporters.add(new ExporterDot());
		return exporters;
	}

	/**
	 * Deselect all nodes; return whether the selection changed
	 * 
	 * @return
	 */
	private boolean removeSelection() {
		for (DotElement element : selectedElements) {
			for (DotElementSelectionListener listener : element.getSelectionListeners()) {
				listener.deselected(element, image);
			}
		}
		boolean result = !selectedElements.isEmpty();
		selectedElements.clear();
		return result;
	}

	private boolean processSelection(DotElement element, MouseEvent e) {
		if (element.isSelectable()) {
			if (e.isControlDown()) {
				//only change this element
				if (selectedElements.contains(element)) {
					//deselect element
					selectedElements.remove(element);
					for (DotElementSelectionListener listener : element.getSelectionListeners()) {
						listener.deselected(element, image);
					}
				} else {
					//select element
					selectedElements.add(element);
					for (DotElementSelectionListener listener : element.getSelectionListeners()) {
						listener.selected(element, image);
					}
				}
			} else {
				if (selectedElements.contains(element)) {
					//clicked on selected element without keypress
					if (selectedElements.size() > 1) {
						//deselect all other selected elements
						Iterator<DotElement> it = selectedElements.iterator();
						while (it.hasNext()) {
							DotElement selectedElement = it.next();
							if (selectedElement != element) {
								for (DotElementSelectionListener listener : selectedElement.getSelectionListeners()) {
									listener.deselected(selectedElement, image);
								}
								it.remove();
							}
						}
					} else {
						//only this element was selected, deselect it
						selectedElements.remove(element);
						for (DotElementSelectionListener a : element.getSelectionListeners()) {
							a.deselected(element, image);
						}
					}
				} else {
					//clicked on not selected element without keypress
					//deselect all selected elements
					Iterator<DotElement> it = selectedElements.iterator();
					while (it.hasNext()) {
						DotElement selectedElement = it.next();
						if (selectedElement != element) {
							for (DotElementSelectionListener listener : selectedElement.getSelectionListeners()) {
								listener.deselected(selectedElement, image);
							}
							it.remove();
						}
					}
					//select this element
					selectedElements.add(element);
					for (DotElementSelectionListener listener : element.getSelectionListeners()) {
						listener.selected(element, image);
					}
				}
			}
			return true;
		}
		return false;
	}

	@SuppressWarnings(""unchecked"")
	private Set<DotElement> getElementsAtPoint(Point pointUserCoordinates) {
		HashSet<DotElement> result = new HashSet<DotElement>();
		if (isInImage(pointUserCoordinates)) {
			Point2D pointImageCoordinates = transformUser2Image(pointUserCoordinates);
			try {
				//get the elements at the clicked position
				List<List<RenderableElement>> elements = image.pick(pointImageCoordinates, false, null);

				StyleAttribute classAttribute = new StyleAttribute(""class"");
				StyleAttribute idAttribute = new StyleAttribute(""id"");
				for (List<RenderableElement> path : elements) {
					for (RenderableElement element : path) {
						//RenderableElement element = path.iterator().next();
						if (element instanceof Group) {
							Group group = (Group) element;

							//get the class
							group.getPres(classAttribute);

							//get the id
							group.getPres(idAttribute);
							String id = idAttribute.getStringValue();

							if (classAttribute.getStringValue().equals(""node"")
									|| classAttribute.getStringValue().equals(""edge"")) {
								//we have found a node or edge
								DotElement dotElement = id2element.get(id);
								if (dotElement != null) {
									result.add(dotElement);
								}
							}
						}
					}
				}

			} catch (SVGException e1) {
				e1.printStackTrace();
			}
		}
		return result;
	}

	private boolean exitAllElements(MouseEvent e) {
		for (DotElement element : mouseInElements) {
			element.mouseExited(e);
		}
		boolean changed = !mouseInElements.isEmpty();
		mouseInElements.clear();
		if (changed) {
			mouseInElementsChanged();
		}
		return changed;
	}

	/**
	 * Sets a new image
	 * 
	 * @param dot
	 *            ; set dot to this
	 * @param resetView
	 *            ; whether reset the view to centered+fitting
	 */
	public void changeDot(Dot dot, boolean resetView) {
		userSettings.applyToDot(dot);
		SVGDiagram diagram = dot2svg(dot);
		changeDot(dot, diagram, resetView);
	}

	/**
	 * Sets a new precomputed image. Assumptions are made about the dot & the
	 * diagram, so do not provide arbitrary ones.
	 * 
	 * @param dot
	 *            ; set dot to this
	 * @param diagram
	 *            ; use this SVG image
	 * @param resetView
	 *            ; whether reset the view to centered+fitting
	 */
	public void changeDot(Dot dot, SVGDiagram diagram, boolean resetView) {
		prepareNodeSelection(dot);
		this.dot = dot;
		setImage(diagram, resetView);
	}

	private void prepareNodeSelection(Dot dot) {
		selectedElements = new HashSet<DotElement>();

		id2element = new HashMap<String, DotElement>();
		for (DotNode dotNode : dot.getNodesRecursive()) {
			id2element.put(dotNode.getId(), dotNode);
		}
		for (DotEdge dotEdge : dot.getEdgesRecursive()) {
			id2element.put(dotEdge.getId(), dotEdge);
		}
	}

	/*
	 * convert Dot into svg
	 */
	public static SVGDiagram dot2svg(Dot dot) {
		SVGUniverse universe = new SVGUniverse();

		InputStream stream = Dot2Image.dot2imageInputStream(dot, Type.svg);
		URI uri;
		try {
			uri = universe.loadSVG(stream, ""hoi"");
		} catch (IOException e) {
			return null;
		}

		SVGDiagram diagram = universe.getDiagram(uri);

		if (diagram == null) {
			throw new RuntimeException(""the dot-structure given is not valid\n"" + dot.toString());
		}
		return diagram;
	}

	/*
	 * select a dotElement
	 */
	public void select(DotElement element) {
		selectedElements.add(element);
		for (DotElementSelectionListener listener : element.getSelectionListeners()) {
			listener.selected(element, image);
		}
		selectionChanged();
	}

	/**
	 * 
	 * @param image
	 * @param element
	 * @return the svg element of a DotElement
	 */
	public static Group getSVGElementOf(SVGDiagram image, DotElement element) {
		SVGElement svgElement = image.getElement(element.getId());
		if (svgElement instanceof Group) {
			return (Group) svgElement;
		}
		return null;
	}

	/**
	 * Set a css-property of a DotElement; returns the old value or null.
	 * 
	 * @param image
	 * @param element
	 * @param attribute
	 * @param value
	 * @return
	 */
	public static String setCSSAttributeOf(SVGDiagram image, DotElement element, String attribute, String value) {
		Group group = getSVGElementOf(image, element);
		return setCSSAttributeOf(group, attribute, value);
	}

	public static String getAttributeOf(SVGElement element, String attribute) {
		try {
			if (element.hasAttribute(attribute, AnimationElement.AT_CSS)) {
				StyleAttribute sty = new StyleAttribute(attribute);
				element.getStyle(sty);
				return sty.getStringValue();
			}
			if (element.hasAttribute(attribute, AnimationElement.AT_XML)) {
				StyleAttribute sty = new StyleAttribute(attribute);
				element.getPres(sty);
				return sty.getStringValue();
			}
		} catch (SVGElementException e) {
			e.printStackTrace();
		} catch (SVGException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static String setCSSAttributeOf(SVGElement element, String attribute, Color colour) {
		return setCSSAttributeOf(element, attribute, ColourMap.toHexString(colour));
	}

	/**
	 * Set a css-property of an SVG element; returns the old value or null
	 * providing null as value removes the attribute
	 * 
	 * @param element
	 * @param attribute
	 * @param value
	 * @return
	 */
	public static String setCSSAttributeOf(SVGElement element, String attribute, String value) {
		try {
			if (element.hasAttribute(attribute, AnimationElement.AT_CSS)) {
				StyleAttribute sty = new StyleAttribute(attribute);
				element.getStyle(sty);
				String oldValue = sty.getStringValue();
				if (value != null) {
					element.setAttribute(attribute, AnimationElement.AT_CSS, value);
				} else {
					element.removeAttribute(attribute, AnimationElement.AT_CSS);
				}
				return oldValue;
			} else {
				if (value != null) {
					element.addAttribute(attribute, AnimationElement.AT_CSS, value);
				}
			}
		} catch (SVGElementException e) {
			e.printStackTrace();
		} catch (SVGException e) {
			e.printStackTrace();
		}
		return null;
	}

	public Set<DotElement> getSelectedElements() {
		return Collections.unmodifiableSet(selectedElements);
	}

	public Set<DotElement> getMouseInElements() {
		return Collections.unmodifiableSet(mouseInElements);
	}

	public List<DotEdge> getEdges() {
		return dot.getEdgesRecursive();
	}

	public List<DotNode> getNodes() {
		return dot.getNodesRecursive();
	}

	public SVGDiagram getSVG() {
		return image;
	}

	public Dot getDot() {
		return dot;
	}

	public DotPanelUserSettings getUserSettings() {
		return userSettings;
	}

	//listeners
	private void graphChanged(GraphChangedReason reason, Object newState) {
		for (GraphChangedListener listener : graphChangedListeners) {
			listener.graphChanged(reason, newState);
		}
	}

	private void selectionChanged() {
		for (SelectionChangedListener<DotElement> listener : selectionChangedListeners) {
			listener.selectionChanged(Collections.unmodifiableSet(selectedElements));
		}
	}

	private void mouseInElementsChanged() {
		for (MouseInElementsChangedListener<DotElement> listener : mouseInElementsChangedListeners) {
			listener.mouseInElementsChanged(Collections.unmodifiableSet(mouseInElements));
		}
	}

	public void addSelectionChangedListener(SelectionChangedListener<DotElement> listener) {
		selectionChangedListeners.add(listener);
	}

	public void addGraphChangedListener(GraphChangedListener listener) {
		graphChangedListeners.add(listener);
	}

	public void addMouseInElementsChangedListener(MouseInElementsChangedListener<DotElement> listener) {
		mouseInElementsChangedListeners.add(listener);
	}

	/**
	 * Public method to change the graph direction. No listeners are called;
	 * that's your responsibility.
	 * 
	 * @param topdown
	 */
	public void setDirection(GraphDirection direction) {
		userSettings.setDirection(direction);
		changeDot(dot, true);
	}
}
"
DotPanelUserSettings.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation;

import java.util.Locale;

import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.dot.Dot.GraphDirection;

/**
 * Keeps track of the user state, i.e. key presses.
 * 
 * @author sleemans
 *
 */

public class DotPanelUserSettings {
	public GraphDirection direction;
	public double nodeSeparation;
	
	public DotPanelUserSettings(Dot dot) {
		readFromDot(dot);
	}

	/**
	 * Applies the dot panel user settings to a Dot instance.
	 * 
	 * @param dot
	 */
	public void applyToDot(Dot dot) {
		dot.setDirection(direction);
		dot.setOption(""nodesep"", """" + String.format(Locale.ENGLISH, ""%.2f"", nodeSeparation));
		dot.setOption(""ranksep"", """" + String.format(Locale.ENGLISH, ""%.2f"", nodeSeparation * 2));
	}
	
	public void readFromDot(Dot dot) {
		direction = dot.getDirection();
		String nodeSep = dot.getOption(""nodesep"");
		if (nodeSep != null) {
			nodeSeparation = Double.valueOf(nodeSep);
		} else {
			nodeSeparation = 0.25;
		}
	}
	
	public void setDirection(GraphDirection direction) {
		this.direction = direction;
	}
	
	public String toString() {
		return ""d "" + direction + "", ns "" + nodeSeparation;
	}
}
"
DotVisualisation.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation;

import javax.swing.JComponent;

import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.graphviz.dot.Dot;

@Plugin(name = ""Dot visualisation"", returnLabels = { ""Dot visualisation"" }, returnTypes = { JComponent.class }, parameterLabels = { ""Dot"" }, userAccessible = true, level = PluginLevel.Regular)
@Visualizer
public class DotVisualisation {

	@PluginVariant(requiredParameterLabels = { 0 })
	public JComponent visualize(PluginContext context, Dot dot) {

		return new DotPanel(dot);
	}
}
"
ExportDialog.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.export;

import java.io.File;
import java.util.Arrays;
import java.util.prefs.Preferences;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

public class ExportDialog extends JFileChooser {
	private static final long serialVersionUID = -6928894765212379860L;
	private static final Preferences preferences = Preferences.userRoot().node(""org.processmining.graphviz"");

	@Deprecated
	public ExportDialog(NavigableSVGPanel parent, Exporter... exporters) {
		this(parent, Arrays.asList(exporters));
	}
	
	public ExportDialog(NavigableSVGPanel parent, Iterable<Exporter> exporters) {
		super(preferences.get(""lastUsedFolder"", new File(""."").getAbsolutePath()));
		setAcceptAllFileFilterUsed(false);
		//addChoosableFileFilter(new ExporterPDFfit());
		for (Exporter exporter: exporters) {
			addChoosableFileFilter(exporter);
		}

		try {
			int returnVal = showSaveDialog(parent);
			if (returnVal == JFileChooser.APPROVE_OPTION) {
				Exporter fileFilter = (Exporter) getFileFilter();
				File file = fileFilter.addExtension(getSelectedFile());

				fileFilter.export(parent, file);

				//save the path for later use
				preferences.put(""lastUsedFolder"", file.getParent());
			}
		} catch (Exception e) {
			JOptionPane.showConfirmDialog(this, e.getMessage(), ""Error while saving image"", JOptionPane.OK_OPTION);
		}
	}

	@Override
	public void approveSelection() {
		Exporter fileFilter = (Exporter) getFileFilter();
		File f = fileFilter.addExtension(getSelectedFile());
		if (f.exists() && getDialogType() == SAVE_DIALOG) {
			int result = JOptionPane.showConfirmDialog(this, ""The file already exists, do you want to overwrite it?"",
					""Existing file"", JOptionPane.YES_NO_OPTION);
			switch (result) {
				case JOptionPane.YES_OPTION :
					super.approveSelection();
					return;
				default :
					return;
			}
		}
		super.approveSelection();
	}

}
"
Exporter.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.export;

import java.io.File;

import javax.swing.filechooser.FileFilter;

import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;


public abstract class Exporter extends FileFilter {
	protected abstract String getExtension();

	public abstract void export(NavigableSVGPanel panel, File file) throws Exception;

	public String getDescription() {
		return getExtension();
	}
	
	public File addExtension(File file) {
		if (!file.getName().endsWith(""."" + getExtension())) {
			return new File(file + ""."" + getExtension());
		}
		return file;
	}

	@Override
	public boolean accept(final File file) {
		String extension = """";
		int i = file.getName().lastIndexOf('.');
		if (i >= 0) {
			extension = file.getName().substring(i + 1);
		}
		return file.isDirectory() || extension.toLowerCase().equals(getExtension());
	}
}
"
ExporterDot.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.export;

import java.io.File;
import java.io.PrintWriter;

import org.processmining.plugins.graphviz.visualisation.DotPanel;
import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

public class ExporterDot extends Exporter {

	@Override
	public String getDescription() {
		return ""dot (graph structure)"";
	};
	
	protected String getExtension() {
		return ""dot"";
	}

	public void export(NavigableSVGPanel panel, File file) throws Exception {
		if (panel instanceof DotPanel) {
			PrintWriter writer = new PrintWriter(file);
			writer.print(((DotPanel) panel).getDot());
			writer.close();
		}
	}

}"
ExporterEMF.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.export;

import java.awt.Dimension;
import java.io.File;
import java.util.Properties;

import org.freehep.graphics2d.VectorGraphics;
import org.freehep.graphicsio.emf.EMFGraphics2D;
import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

public class ExporterEMF extends Exporter {

	protected String getExtension() {
		return ""emf"";
	}

	public void export(NavigableSVGPanel panel, File file) throws Exception {

		double width = panel.getImage().getViewRect().getWidth();
		double height = panel.getImage().getViewRect().getHeight();

		VectorGraphics g = new EMFGraphics2D(file, new Dimension((int) Math.ceil(width), (int) Math.ceil(height)));
		Properties p = new Properties();
		g.setProperties(p);
		g.startExport();
		panel.print(g);
		g.endExport();
	}

}"
ExporterEPS.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.export;

import java.awt.Dimension;
import java.io.File;
import java.util.Properties;

import org.freehep.graphics2d.VectorGraphics;
import org.freehep.graphicsio.ps.EPSGraphics2D;
import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

public class ExporterEPS extends Exporter {

	protected String getExtension() {
		return ""eps"";
	}

	public void export(NavigableSVGPanel panel, File file) throws Exception {

		double width = panel.getImage().getViewRect().getWidth();
		double height = panel.getImage().getViewRect().getHeight();

		Dimension dimension = new Dimension((int) Math.ceil(width), (int) Math.ceil(height));
		VectorGraphics g = new EPSGraphics2D(file, dimension);
		Properties p = new Properties(EPSGraphics2D.getDefaultProperties());
		p.setProperty(EPSGraphics2D.PAGE_SIZE, EPSGraphics2D.CUSTOM_PAGE_SIZE);
		p.setProperty(EPSGraphics2D.PAGE_MARGINS, ""0, 0, 0, 0"");
		p.put(EPSGraphics2D.CUSTOM_PAGE_SIZE, dimension.width + "", "" + dimension.height);
		g.setProperties(p);
		g.startExport();
		panel.print(g);
		g.endExport();
	}

}"
ExporterPDF.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.export;

import java.awt.Graphics2D;
import java.io.File;
import java.io.FileOutputStream;

import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

import com.itextpdf.awt.PdfGraphics2D;
import com.itextpdf.text.Document;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfWriter;

/**
 * Due to bugs in direct pdf export, first export to eps and then convert to
 * pdf.
 * 
 * @author sander
 *
 */

public class ExporterPDF extends Exporter {

	protected String getExtension() {
		return ""pdf"";
	}

	public void export(NavigableSVGPanel panel, File file) throws Exception {
		float width = (float) panel.getImage().getViewRect().getWidth();
		float height = (float) panel.getImage().getViewRect().getHeight();

		Document document = new Document(new Rectangle(width, height), 0, 0, 0, 0);
		PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));
		document.open();
		PdfContentByte canvas = writer.getDirectContent();
		
		Graphics2D g = new PdfGraphics2D(canvas, width, height);
		panel.print(g);
		g.dispose();
		
		document.close();
	}

}
"
ExporterPNG.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.export;

import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.io.File;

import javax.imageio.ImageIO;

import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

public class ExporterPNG extends Exporter {

	protected String getExtension() {
		return ""png"";
	}

	public void export(NavigableSVGPanel panel, File file) throws Exception {
		BufferedImage bi = new BufferedImage(Math.round(panel.getImage().getWidth()), Math.round(panel.getImage().getHeight()),
				BufferedImage.TYPE_INT_ARGB);
		Graphics2D g = bi.createGraphics();
		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		panel.print(g);
		ImageIO.write(bi, ""PNG"", file);
	}

}
"
ExporterSVG.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.export;

import java.awt.Dimension;
import java.io.File;
import java.util.Properties;

import org.freehep.graphics2d.VectorGraphics;
import org.freehep.graphicsio.svg.SVGGraphics2D;
import org.processmining.plugins.graphviz.visualisation.NavigableSVGPanel;

public class ExporterSVG extends Exporter {

	protected String getExtension() {
		return ""svg"";
	}

	public void export(NavigableSVGPanel panel, File file) throws Exception {	
		double width = panel.getImage().getViewRect().getWidth();
		double height = panel.getImage().getViewRect().getHeight();
		
		Dimension dimension = new Dimension((int) Math.ceil(width), (int) Math.ceil(height));
		VectorGraphics g = new SVGGraphics2D(file, dimension);
		Properties p = new Properties(SVGGraphics2D.getDefaultProperties());
		g.setProperties(p);
		g.startExport();
		panel.print(g);
		g.endExport();
	}

}
"
DotElementSelectionListener.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.listeners;

import org.processmining.plugins.graphviz.dot.DotElement;

import com.kitfox.svg.SVGDiagram;

public interface DotElementSelectionListener {
	public void selected(DotElement element, SVGDiagram image);
	public void deselected(DotElement element, SVGDiagram image);
}
"
ElementSelectionListener.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.listeners;

@Deprecated
public interface ElementSelectionListener<E> {
	public void selected(E element);
	public void deselected(E element);
}
"
GraphChangedListener.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.listeners;

public interface GraphChangedListener {
	
	public enum GraphChangedReason {
		graphDirectionChanged, nodeSeparationChanged 
	}
	
	public void graphChanged(GraphChangedReason reason, Object newState);
}
"
ImageTransformationChangedListener.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.listeners;

import java.awt.geom.AffineTransform;

public interface ImageTransformationChangedListener {
	public void imageTransformationChanged(AffineTransform image2user, AffineTransform user2image);
}
"
MouseInElementsChangedListener.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.listeners;

import java.util.Set;

public interface MouseInElementsChangedListener<E> {
	/**
	 * Called when the selection changes.
	 * @param selectedElements The new set of selected elements.
	 */
	public void mouseInElementsChanged(Set<E> mouseInElements);
}
"
SelectionChangedListener.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation.listeners;

import java.util.Set;

public interface SelectionChangedListener<E> {
	
	/**
	 * Called when the selection changes.
	 * @param selectedElements The new set of selected elements.
	 */
	public void selectionChanged(Set<E> selectedElements);
}
"
NavigableSVGPanel.java,graphviz-6.9.256,"package org.processmining.plugins.graphviz.visualisation;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Stroke;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.Arc2D;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Point2D;
import java.awt.print.PageFormat;
import java.awt.print.Printable;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;

import org.processmining.plugins.graphviz.visualisation.export.ExportDialog;
import org.processmining.plugins.graphviz.visualisation.export.Exporter;
import org.processmining.plugins.graphviz.visualisation.export.ExporterEMF;
import org.processmining.plugins.graphviz.visualisation.export.ExporterEPS;
import org.processmining.plugins.graphviz.visualisation.export.ExporterPDF;
import org.processmining.plugins.graphviz.visualisation.export.ExporterPNG;
import org.processmining.plugins.graphviz.visualisation.export.ExporterSVG;
import org.processmining.plugins.graphviz.visualisation.listeners.ImageTransformationChangedListener;

import com.kitfox.svg.SVGDiagram;
import com.kitfox.svg.SVGException;

/**
 * A JPanel that displays an SVG image. Animation support is present, but not
 * complete, i.e. you'll need a subclass to perform animation. Controls are
 * included to ease implementation of subclasses.
 * 
 * @author sleemans
 *
 */
public class NavigableSVGPanel extends JPanel implements Printable {

	private static final long serialVersionUID = -3285916948952045282L;

	//state variables and constants
	protected SVGDiagram image;
	protected AffineTransform image2user = new AffineTransform();
	private AffineTransform user2image = new AffineTransform();
	private Point lastMousePosition;
	private Dimension lastPanelDimension = null;
	private boolean resetViewLater = false;

	protected boolean isDraggingImage = false;
	private final static double zoomIncrement = 1.8;

	//animation controls
	protected boolean isDraggingAnimation = false;
	protected boolean isDraggingTimeScale = false;
	private boolean wasPlayingBeforeDragging = false;
	protected Rectangle animationControls;
	protected Rectangle controlsPlayPause = new Rectangle();
	protected Rectangle controlsTimeScale = new Rectangle();
	private Rectangle controlsProgressLine = new Rectangle();
	private boolean animationControlsShowing = false;

	//navigation variables and constants
	private double navigationScale = 1.0;
	public final static double navigationImageWidthInPartOfPanel = 0.1;
	public final static Color navigationImageBorderColor = Color.black;
	public final static float dash1[] = { 10.0f };
	public final static BasicStroke navigationImageOutlineStroke = new BasicStroke(1.0f, BasicStroke.CAP_BUTT,
			BasicStroke.JOIN_MITER, 10.0f, dash1, 0.0f);

	//listeners
	private ImageTransformationChangedListener imageTransformationChangedListener = null;

	//helper controls variables and constants
	private Arc2D helperControlsArc = null;
	private boolean helperControlsShowing = false;
	public static final int helperControlsWidth = 350;
	public static final Font helperControlsFont = new Font(Font.MONOSPACED, Font.BOLD, 12);
	private static final Font helperControlsButtonFont = new Font(""TimesRoman"", Font.PLAIN, 20);
	private static final String helperControlsButtonString = ""?"";

	//help-popup
	protected List<String> helperControlsShortcuts = new ArrayList<>(
			Arrays.asList(""up/down"", ""left/right"", ""ctrl ="", ""ctrl -"", ""ctrl 0"", ""ctrl i"", ""ctrl p""));
	protected List<String> helperControlsExplanations = new ArrayList<>(Arrays.asList(""pan up/down"", ""pan left/right"",
			""zoom in"", ""zoom out"", ""reset zoom & pan"", ""save image"", ""print""));

	private Action zoomInAction = new AbstractAction() {
		private static final long serialVersionUID = 3863042569537144601L;

		public void actionPerformed(ActionEvent e) {
			//zoom in on the center of the panel
			try {
				zoomIn(new Point(getWidth() / 2, getHeight() / 2));
			} catch (NoninvertibleTransformException e1) {
				e1.printStackTrace();
			}
			updateTransformation();
			repaint();
		}
	};

	private Action zoomOutAction = new AbstractAction() {
		private static final long serialVersionUID = 7842478506942554961L;

		public void actionPerformed(ActionEvent e) {
			//zoom in of the center of the panel
			try {
				zoomOut(new Point(getWidth() / 2, getHeight() / 2));
			} catch (NoninvertibleTransformException e1) {
				e1.printStackTrace();
			}
			updateTransformation();
			repaint();
		}
	};

	private Action resetViewAction = new AbstractAction() {
		private static final long serialVersionUID = 1114226211978622533L;

		public void actionPerformed(ActionEvent e) {
			//reset the view
			try {
				resetView();
			} catch (NoninvertibleTransformException e1) {
				e1.printStackTrace();
			}
			updateTransformation();
			repaint();
		}
	};

	private Action walkAction = new AbstractAction() {
		private static final long serialVersionUID = 1114226211978622533L;

		public void actionPerformed(ActionEvent e) {
			String command = e.getActionCommand();
			if (command.equals(""DOWN"")) {
				image2user.translate(0, -10);
			} else if (command.equals(""UP"")) {
				image2user.translate(0, 10);
			} else if (command.equals(""LEFT"")) {
				image2user.translate(10, 0);
			} else if (command.equals(""RIGHT"")) {
				image2user.translate(-10, 0);
			}
			try {
				user2image = image2user.createInverse();
			} catch (NoninvertibleTransformException e1) {
				e1.printStackTrace();
			}
			updateTransformation();
			repaint();
		}
	};

	private Action printAction = new AbstractAction() {
		private static final long serialVersionUID = -7112953904402077397L;

		public void actionPerformed(ActionEvent e) {
			PrinterJob job = PrinterJob.getPrinterJob();
			job.setPrintable(NavigableSVGPanel.this);
			boolean ok = job.printDialog();
			if (ok) {
				try {
					job.print();
				} catch (PrinterException ex) {
					/* The job did not successfully complete */
				}
			}
		}
	};

	public NavigableSVGPanel(final SVGDiagram newImage) {
		setOpaque(false);
		setDoubleBuffered(true);
		setFocusable(true);
		setImage(newImage, false);
		setupListeners();
	}

	public void setupListeners() {
		//set up resize listener
		addComponentListener(new ComponentAdapter() {
			public void componentResized(ComponentEvent e) {
				try {
					if (image2user.isIdentity() || resetViewLater) {
						lastPanelDimension = new Dimension(getWidth(), getHeight());
						resetView();
					} else if (lastPanelDimension != null) {
						//on resizing, keep the center in center, and scale proportionally to the width.
						double zoom = lastPanelDimension.getWidth() / getWidth();
						user2image.translate(lastPanelDimension.getWidth() / 2.0, lastPanelDimension.getHeight() / 2.0);
						user2image.scale(zoom, zoom);
						lastPanelDimension = new Dimension(getWidth(), getHeight());
						user2image.translate(-lastPanelDimension.getWidth() / 2.0,
								-lastPanelDimension.getHeight() / 2.0);
						image2user = user2image.createInverse();
					} else {
						lastPanelDimension = new Dimension(getWidth(), getHeight());
					}
				} catch (NoninvertibleTransformException e1) {
					e1.printStackTrace();
				}
				updateTransformation();
				repaint();
			}
		});

		//set up mouse listener
		addMouseListener(new MouseListener() {
			public void mouseReleased(MouseEvent e) {
				processMouseRelease(e);
			}

			public void mousePressed(MouseEvent e) {
				processMousePress(e);
			}

			public void mouseExited(MouseEvent e) {
				processMouseExit(e);
			}

			public void mouseEntered(MouseEvent e) {

			}

			public void mouseClicked(MouseEvent e) {
				if (isFocusable()) {
					requestFocusInWindow();
				}
				processMouseClick(e);
			}
		});

		//set up drag listener
		addMouseMotionListener(new MouseMotionListener() {
			public void mouseDragged(MouseEvent e) {
				processMouseDrag(e);
			}

			public void mouseMoved(MouseEvent e) {
				processMouseMove(e);
			}
		});

		//set up scroll listener
		addMouseWheelListener(new MouseWheelListener() {
			public void mouseWheelMoved(MouseWheelEvent e) {
				Point p = e.getPoint();
				boolean zoomIn = (e.getWheelRotation() < 0);

				if (isInNavigation(p)) {
					//zoom navigation
					if (zoomIn) {
						zoomNavigation(1.2);
					} else {
						zoomNavigation(0.8);
					}
				} else {
					//zoom image
					try {
						if (zoomIn) {
							zoomIn(p);
						} else {
							zoomOut(p);
						}
						updateTransformation();
					} catch (NoninvertibleTransformException ex) {
						ex.printStackTrace();
					}
				}
				repaint();
			}
		});

		//listen to ctrl + to zoom in
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_EQUALS, InputEvent.CTRL_MASK),
				""zoomIn""); // + key in English keyboards
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_PLUS, InputEvent.CTRL_MASK),
				""zoomIn""); // + key in non-English keyboards
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ADD, InputEvent.CTRL_MASK),
				""zoomIn""); // + key on the numpad
		getActionMap().put(""zoomIn"", zoomInAction);

		//listen to ctrl - to zoom out
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_MINUS, InputEvent.CTRL_MASK),
				""zoomOut""); // - key
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_SUBTRACT, InputEvent.CTRL_MASK),
				""zoomOut""); // - key on the numpad
		getActionMap().put(""zoomOut"", zoomOutAction);

		//listen to arrow keys to walk around
		registerKeyboardAction(walkAction, ""DOWN"", KeyStroke.getKeyStroke(""DOWN""), JComponent.WHEN_IN_FOCUSED_WINDOW);
		registerKeyboardAction(walkAction, ""UP"", KeyStroke.getKeyStroke(""UP""), JComponent.WHEN_IN_FOCUSED_WINDOW);
		registerKeyboardAction(walkAction, ""LEFT"", KeyStroke.getKeyStroke(""LEFT""), JComponent.WHEN_IN_FOCUSED_WINDOW);
		registerKeyboardAction(walkAction, ""RIGHT"", KeyStroke.getKeyStroke(""RIGHT""), JComponent.WHEN_IN_FOCUSED_WINDOW);

		//listen to ctrl 0 to reset view
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_0, InputEvent.CTRL_MASK),
				""viewReset""); // - key
		getActionMap().put(""viewReset"", resetViewAction);

		//listen to ctrl i to save image
		{
			getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_I, InputEvent.CTRL_MASK),
					""saveAs""); // - key
			getActionMap().put(""saveAs"", new AbstractAction() {
				private static final long serialVersionUID = -4780600363000017631L;

				public void actionPerformed(ActionEvent arg0) {
					exportView();
				}
			});
		}

		//listen to ctrl p to print
		getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_P, InputEvent.CTRL_MASK), ""print""); // - key
		getActionMap().put(""print"", printAction);
	}

	/**
	 * Paints the panel and its image at the current zoom level, location, and
	 * interpolation method dependent on the image scale.
	 * </p>
	 * 
	 * @param g
	 *            the <code>Graphics</code> context for painting
	 */
	protected void paintComponent(Graphics g) {
		if (!isPaintingForPrint()) {
			super.paintComponent(g); // Paints the background
		}

		Graphics2D g2 = (Graphics2D) g;

		if (image == null) {
			return;
		}

		//set anti-aliasing if desired
		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

		//set clipping mask to save a few cpu/gpu cycles
		if (!isPaintingForPrint()) {
			g2.setClip(0, 0, getWidth(), getHeight());
		} else {
			g2.setClip((int) Math.round(image.getViewRect().getX()), (int) Math.round(image.getViewRect().getY()),
					(int) Math.round(image.getViewRect().getWidth()),
					(int) Math.round(image.getViewRect().getHeight()));
		}

		//draw image
		if (!isPaintingForPrint()) {
			g2.transform(image2user);
		}
		paintImage(g2);
		if (!isPaintingForPrint()) {
			g2.transform(user2image);
		}

		//draw animation
		drawAnimation(g2);

		//Draw navigation image
		if (!isPaintingForPrint() && !isImageCompletelyInPanel()) {
			int width = (int) Math.round(getNavigationWidth());
			int height = (int) Math.round(getNavigationHeight());
			drawSVG(g2, image, 0, 0, width, height);
			g2.drawRect(0, 0, width, height);
			drawNavigationOutline(g2);
		}

		//draw helper controls
		if (!isPaintingForPrint()) {
			drawHelperControls(g2);
		}

		//draw animation controls
		if (!isPaintingForPrint()) {
			drawAnimationControls((Graphics2D) g);
		}
	}

	protected void paintImage(Graphics2D g) {
		try {
			image.render(g);
		} catch (SVGException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Draw an svg image at the given coordinates and of the given size.
	 * 
	 * @param g
	 * @param image
	 * @param x
	 * @param y
	 * @param width
	 * @param height
	 */
	public static void drawSVG(Graphics2D g, SVGDiagram image, int x, int y, int width, int height) {

		double scaleX = width / image.getWidth();
		double scaleY = height / image.getHeight();

		g.translate(x, y);
		g.scale(scaleX, scaleY);

		try {
			image.render(g);
		} catch (SVGException e) {
			e.printStackTrace();
		}

		g.scale(1 / scaleX, 1 / scaleY);
		g.translate(-x, -y);
	}

	/**
	 * Draw the animation.
	 * 
	 * @param g
	 */
	protected void drawAnimation(Graphics2D g) {

	}

	/**
	 * Paints an outline over the navigation to denote what part of the main
	 * image is displayed.
	 * 
	 * @param g
	 * @param t
	 */
	private void drawNavigationOutline(Graphics2D g) {

		//get edges of panel in image coordinates
		Point2D.Double nw = new Point.Double(0, 0);
		user2image.transform(nw, nw);
		Point2D.Double se = new Point.Double(getWidth(), getHeight());
		user2image.transform(se, se);

		//transform to navigation coordinates
		Point2D nwNav = transformImageToNavigation(nw);
		Point2D seNav = transformImageToNavigation(se);

		int x = (int) Math.round(nwNav.getX());
		int y = (int) Math.round(nwNav.getY());
		int width = (int) Math.round(seNav.getX() - nwNav.getX());
		int height = (int) Math.round(seNav.getY() - nwNav.getY());

		if (x + width > getNavigationWidth()) {
			width = (int) Math.round(getNavigationWidth() - x);
		}
		if (y + height > getNavigationHeight()) {
			height = (int) Math.round(getNavigationHeight() - y);
		}
		Stroke backupStroke = g.getStroke();
		g.setColor(navigationImageBorderColor);
		g.setStroke(navigationImageOutlineStroke);
		g.drawRect(x, y, width, height);
		g.setStroke(backupStroke);

	}

	/**
	 * Draws the little help-question-mark in the right bottom corner and the
	 * help text that appears when hovering over it.
	 * 
	 * @param g
	 */
	private void drawHelperControls(Graphics g) {
		Color backupColour = g.getColor();
		Font backupFont = g.getFont();

		FontMetrics fm = getFontMetrics(helperControlsButtonFont);
		int width = fm.stringWidth(helperControlsButtonString);

		//draw the background arc
		if (helperControlsShowing) {
			g.setColor(new Color(0, 0, 0, 180));
		} else {
			g.setColor(new Color(0, 0, 0, 20));
		}
		helperControlsArc = new Arc2D.Float(Arc2D.PIE);
		helperControlsArc.setFrame(getWidth() - 25, getHeight() - 25, 50, 50);
		helperControlsArc.setAngleStart(90);
		helperControlsArc.setAngleExtent(90);
		g.fillArc(getWidth() - 25, getHeight() - 25, 50, 50, 90, 90);

		//draw the helper panel
		if (helperControlsShowing) {
			int x = getWidth() - (25 + helperControlsWidth);
			int y = getHeight() - (helperControlsShortcuts.size() * 20 - 10);

			//background
			g.setColor(new Color(0, 0, 0, 180));
			g.fillRoundRect(x - 15, y - 20, helperControlsWidth, helperControlsShortcuts.size() * 20 + 20, 10, 10);

			//text
			g.setColor(new Color(255, 255, 255, 220));
			g.setFont(helperControlsFont);
			for (int i = 0; i < helperControlsShortcuts.size(); i++) {
				g.drawString(String.format(""%-12s"", helperControlsShortcuts.get(i)) + "" ""
						+ helperControlsExplanations.get(i), x, y);
				y += 20;
			}
		}

		//draw the question mark
		if (helperControlsShowing) {
			g.setColor(new Color(255, 255, 255, 128));
		} else {
			g.setColor(new Color(0, 0, 0, 128));
		}
		g.setFont(helperControlsButtonFont);
		g.drawString(helperControlsButtonString, getWidth() - width - 3, getHeight() - 3);

		//revert colour and font
		g.setColor(backupColour);
		g.setFont(backupFont);
	}

	private void drawAnimationControls(Graphics2D g) {
		Color backupColour = g.getColor();

		int alpha = 20;
		if (!isAnimationEnabled()) {
			alpha = 0;
		} else if (animationControlsShowing) {
			alpha = 180;
		}

		g.setColor(new Color(0, 0, 0, alpha));
		int width = getWidth() - 100;
		int height = 50;
		int x = (getWidth() - width) / 2;
		int y = getHeight() - 2 * height;
		g.fillRoundRect(x, y, width, height, 10, 10);
		animationControls = new Rectangle(x, y, width, height);

		//play button
		g.setColor(new Color(255, 255, 255, alpha));
		controlsPlayPause.setBounds(x + 10, y + 10, 30, height);
		if (!isAnimationPlaying()) {
			//play button
			Polygon triangle = new Polygon();
			triangle.addPoint(x + 10, y + 10);
			triangle.addPoint(x + 10, y + height - 10);
			triangle.addPoint(x + 10 + 25, y + (height / 2));
			g.fillPolygon(triangle);
		} else {
			//pause button
			g.fillRoundRect(x + 10, y + 10, 10, height - 20, 5, 5);
			g.fillRoundRect(x + 25, y + 10, 10, height - 20, 5, 5);
		}

		//time scale control
		{
			int rightX = x + 50 + 30;
			int leftX = x + 50;
			int topY = y + (height / 3);
			int bottomY = y + (height / 3) * 2;

			if (animationControlsShowing) {
				//dynamic part
				{
					int x2 = (int) (leftX + getTimeScale() * (rightX - leftX));
					int y2 = (int) (bottomY + getTimeScale() * (topY - bottomY));

					//line
					g.drawLine(x2, bottomY + 5, x2, y2 - 5);

					//fill
					Polygon triangle = new Polygon();
					triangle.addPoint(x2, y2);
					triangle.addPoint(leftX, bottomY);
					triangle.addPoint(x2, bottomY);
					g.fillPolygon(triangle);
				}

				//outline
				{
					Polygon triangle = new Polygon();
					triangle.addPoint(rightX, topY);
					triangle.addPoint(leftX, bottomY);
					triangle.addPoint(rightX, bottomY);
					g.drawPolygon(triangle);
				}
			}

			controlsTimeScale.setBounds(leftX, y + 5, rightX - leftX, height - 10);
		}

		//progress line
		{
			int startLineX = x + 100;
			int endLineX = x + width - 20;
			int lineY = y + height / 2;

			if (animationControlsShowing) {
				g.drawLine(startLineX, lineY, endLineX, lineY);
				double progress = (getAnimationTime() - getAnimationMinimumTime())
						/ (getAnimationMaximumTime() - getAnimationMinimumTime());

				//draw the little oval that denotes where we are
				double ovalX = (startLineX + (endLineX - startLineX) * progress) - 5;
				double ovalY = lineY - 5;
				g.translate(ovalX, ovalY);
				g.fillOval(0, 0, 10, 10);
				g.translate(-ovalX, -ovalY);
			}

			getControlsProgressLine().setBounds(startLineX, y, endLineX - startLineX, height);
		}

		g.setColor(backupColour);
	}

	/**
	 * 
	 * @return The width of the navigation part in user coordinates.
	 */
	private double getNavigationWidth() {
		return getWidth() * navigationImageWidthInPartOfPanel * navigationScale;
	}

	/**
	 * 
	 * @return The height of the navigation part in user coordinates.
	 */
	private double getNavigationHeight() {
		return (getNavigationWidth() / image.getWidth()) * image.getHeight();
	}

	/**
	 * Transforms the given point in navigation coordinates to image coordinates
	 * 
	 * @param p
	 * @return
	 */
	public Point2D transformNavigationToImage(Point2D p) {
		double x = p.getX() * image.getWidth() / getNavigationWidth();
		double y = p.getY() * image.getHeight() / getNavigationHeight();

		return new Point2D.Double(x, y);
	}

	/**
	 * Transforms the given point in image coordinates to navigation coordinates
	 * 
	 * @param p
	 * @return
	 */
	public Point2D transformImageToNavigation(Point2D p) {
		double x = p.getX() * getNavigationWidth() / image.getWidth();
		double y = p.getY() * getNavigationHeight() / image.getHeight();

		return new Point2D.Double(x, y);
	}

	/**
	 * Returns whether a point (in user coordinates) is in the image and not in
	 * the navigation image.
	 * 
	 * @param pointInUserCoordinates
	 * @return
	 */
	public boolean isInImage(Point pointInUserCoordinates) {
		if (isInNavigation(pointInUserCoordinates)) {
			return false;
		}
		return getImageBoundingBoxInUserCoordinates().contains(pointInUserCoordinates);
	}

	/**
	 * Returns whether a point (in user coordinates) is in the navigation image.
	 * 
	 * @param pointInUserCoordinates
	 * @return
	 */
	public boolean isInNavigation(Point pointInUserCoordinates) {
		return (pointInUserCoordinates.x < getNavigationWidth() && pointInUserCoordinates.y < getNavigationHeight());
	}

	public boolean isInHelperControls(Point pointInUserCoordinates) {
		return helperControlsArc != null && helperControlsArc.contains(pointInUserCoordinates);
	}

	/**
	 * 
	 * @return The currently registered shortcuts, which are displayed when
	 *         hovering over the question mark in the lower right corner.
	 */
	public List<String> getHelperControlsShortcuts() {
		return helperControlsShortcuts;
	}

	/**
	 * Sets the shortcuts, displayed when hovering over the question mark in the
	 * lower right corner.
	 * 
	 * @param helperControlsShortcuts
	 */
	public void setHelperControlsShortcuts(List<String> helperControlsShortcuts) {
		this.helperControlsShortcuts = helperControlsShortcuts;
	}

	/**
	 * @return The currently registered shortcut explanations, which are
	 *         displayed when hovering over the question mark in the lower right
	 *         corner.
	 */
	public List<String> getHelperControlsExplanations() {
		return helperControlsExplanations;
	}

	/**
	 * Sets the shortcut explanations, displayed when hovering over the question
	 * mark in the lower right corner.
	 * 
	 * @param helperControlsExplanations
	 */
	public void setHelperControlsExplanations(List<String> helperControlsExplanations) {
		this.helperControlsExplanations = helperControlsExplanations;
	}

	/**
	 * 
	 * @return The currently displaying svg image.
	 */
	public SVGDiagram getImage() {
		return image;
	}

	/**
	 * 
	 * @return The bounding box of the image in user coordinates, truncated
	 *         (approximately) to the visible area.
	 */
	public Rectangle getVisibleImageBoundingBoxInUserCoordinates() {
		//transform point (0,0) to user coordinates
		Point2D.Double nw = new Point.Double(0, 0);
		user2image.transform(nw, nw);
		double x1 = Math.min(Math.max(0, nw.getX()), getWidth());
		double y1 = Math.min(Math.max(0, nw.getY()), getHeight());

		//transform the other corner to user coordinates
		Point2D se = new Point2D.Double(image.getWidth(), image.getHeight());
		user2image.transform(se, se);
		double x2 = Math.min((Math.max(0, se.getX())), getWidth());
		double y2 = Math.min((Math.max(0, se.getY())), getHeight());

		return new Rectangle((int) Math.min(x1, x2), (int) Math.min(y1, y2), (int) Math.abs(x2 - x1),
				(int) Math.abs(y2 - y1));
	}

	/**
	 * 
	 * @return the bounding box of the complete image in user coordinates
	 */
	public Rectangle getImageBoundingBoxInUserCoordinates() {
		//transform point (0,0) to user coordinates
		Point2D.Double nw = new Point.Double(0, 0);
		image2user.transform(nw, nw);
		double x1 = nw.getX();
		double y1 = nw.getY();

		//transform the other corner to user coordinates
		Point2D se = new Point2D.Double(image.getWidth(), image.getHeight());
		image2user.transform(se, se);
		double x2 = se.getX();
		double y2 = se.getY();

		return new Rectangle((int) Math.min(x1, x2), (int) Math.min(y1, y2), (int) Math.abs(x2 - x1),
				(int) Math.abs(y2 - y1));
	}

	/**
	 * Returns whether the image is completely visible in the panel
	 * 
	 * @param panState
	 * @param diagram
	 * @param panel
	 * @return
	 */
	public boolean isImageCompletelyInPanel() {
		//check the northwest corner
		Point2D.Double nw = new Point.Double(0, 0);
		image2user.transform(nw, nw);
		if (nw.getX() < 0 || nw.getY() < 0) {
			return false;
		}

		//check the southeast corner
		Point2D.Double se = new Point2D.Double(image.getWidth(), image.getHeight());
		image2user.transform(se, se);
		if (se.getX() > getWidth() || se.getY() > getHeight()) {
			return false;
		}

		return true;
	}

	/**
	 * <p>
	 * Sets an image for display in the panel.
	 * </p>
	 * 
	 * @param image
	 *            an image to be set in the panel
	 */
	public void setImage(SVGDiagram image, boolean resetView) {
		if (image == null) {
			System.out.println(""invalid dot given"");
			throw new NullPointerException(""invalid dot given"");
		}
		this.image = image;
		image.setDeviceViewport(new java.awt.Rectangle(0, 0, (int) image.getWidth(), (int) image.getHeight()));

		if (resetView) {
			try {
				resetView();
			} catch (NoninvertibleTransformException e) {
				e.printStackTrace();
			}
			updateTransformation();
		}

		repaint();
	}

	/**
	 * Scale and center the image just in the viewport.
	 * 
	 * @throws NoninvertibleTransformException
	 */
	public void resetView() throws NoninvertibleTransformException {
		if (getWidth() <= 0 || getHeight() <= 0) {
			resetViewLater = true;
			return;
		}
		resetViewLater = false;

		double scaleX = getWidth() / (double) image.getWidth();
		double scaleY = getHeight() / (double) image.getHeight();
		double scale = Math.min(scaleX, scaleY);

		double width = scale * image.getWidth();
		double height = scale * image.getHeight();

		double x = (getWidth() - width) / 2.0;
		double y = (getHeight() - height) / 2.0;

		image2user.setToIdentity();
		image2user.translate(x, y);
		image2user.scale(scale, scale);
		user2image = image2user.createInverse();

		//reset navigation image
		navigationScale = 1.0;
	}

	/**
	 * The user clicked within the navigation image and this part of the image
	 * is displayed in the panel. The clicked point of the image is centered in
	 * the panel.
	 * 
	 * @param pointInNavigationCoordinates
	 * @throws NoninvertibleTransformException
	 */
	public void centerImageAround(Point pointInNavigationCoordinates) throws NoninvertibleTransformException {
		//transform to image coordinates
		Point2D pImage = transformNavigationToImage(pointInNavigationCoordinates);

		//transform to user coordinates
		image2user.transform(pImage, pImage);

		//compute difference
		double dx = (getWidth() / 2.0 - pImage.getX()) / image2user.getScaleX();
		double dy = (getHeight() / 2.0 - pImage.getY()) / image2user.getScaleY();

		//and translate
		image2user.translate(dx, dy);
		user2image = image2user.createInverse();
	}

	/**
	 * Zoom in keeping the given point at its place
	 * 
	 * @param aroundInUserCoordinates
	 * @throws NoninvertibleTransformException
	 */
	private void zoomIn(Point2D aroundInUserCoordinates) throws NoninvertibleTransformException {
		user2image.translate(aroundInUserCoordinates.getX(), aroundInUserCoordinates.getY());
		user2image.scale(1 / zoomIncrement, 1 / zoomIncrement);
		user2image.translate(-aroundInUserCoordinates.getX(), -aroundInUserCoordinates.getY());
		image2user = user2image.createInverse();
	}

	/**
	 * Zoom out keeping the given point at its place
	 * 
	 * @param aroundInUserCoordinates
	 * @throws NoninvertibleTransformException
	 */
	private void zoomOut(Point2D aroundInUserCoordinates) throws NoninvertibleTransformException {
		user2image.translate(aroundInUserCoordinates.getX(), aroundInUserCoordinates.getY());
		user2image.scale(zoomIncrement, zoomIncrement);
		user2image.translate(-aroundInUserCoordinates.getX(), -aroundInUserCoordinates.getY());
		image2user = user2image.createInverse();
	}

	/**
	 * Process a mouse press.
	 * 
	 * @param e
	 * @return whether the press was handled and did something.
	 */
	protected boolean processMousePress(MouseEvent e) {
		Point point = e.getPoint();
		lastMousePosition = point;

		//process press in helper text
		if (SwingUtilities.isLeftMouseButton(e) && isInHelperControls(point)) {
			return true;
		}

		//process press in animation controls
		if (SwingUtilities.isLeftMouseButton(e) && isAnimationEnabled() && animationControls != null
				&& animationControls.contains(point)) {
			if (getControlsProgressLine().contains(point)) {
				//clicked in progress line area
				wasPlayingBeforeDragging = isAnimationPlaying();
			} else if (controlsPlayPause.contains(point)) {
				//clicked on play/pause button
				pauseResume();

				//repaint to make sure the button is changed
				repaint();
			} else if (controlsTimeScale.contains(point)) {
				//clicked in time scale
			}
			return true;
		}

		//process press in navigation
		if (SwingUtilities.isLeftMouseButton(e) && isInNavigation(point)) {
			//pressed in navigation
			try {
				centerImageAround(point);
			} catch (NoninvertibleTransformException e1) {
				e1.printStackTrace();
			}
			updateTransformation();
			repaint();
			return true;
		}

		//process press anywhere else (=> on the image)
		if (SwingUtilities.isLeftMouseButton(e)) {
			return true;
		}

		return false;
	}

	/**
	 * Process a mouse release
	 * 
	 * @param e
	 * @return whether the hover was handled and did something.
	 */
	protected boolean processMouseRelease(MouseEvent e) {
		if (isDraggingAnimation) {
			double progress = Math.max(0,
					Math.min(1, (e.getX() - getControlsProgressLine().x) / (getControlsProgressLine().width * 1.0)));
			seek(getAnimationMinimumTime() + progress * (getAnimationMaximumTime() - getAnimationMinimumTime()));
			if (wasPlayingBeforeDragging) {
				resume();
			} else {
				renderOneFrame();
				repaint();
			}
		}

		if (isDraggingImage) {
			renderOneFrame();
		}

		isDraggingImage = false;
		isDraggingAnimation = false;
		isDraggingTimeScale = false;

		return processMouseMove(e);
	}

	/**
	 * Process a mouse drag;
	 * 
	 * @param e
	 * @return whether the drag was handled and did something.
	 */
	protected boolean processMouseDrag(MouseEvent e) {
		if (!isDraggingImage && !isDraggingAnimation && !isDraggingTimeScale) {
			if (SwingUtilities.isLeftMouseButton(e) && isAnimationEnabled() && animationControls != null
					&& animationControls.contains(lastMousePosition)
					&& getControlsProgressLine().contains(lastMousePosition)) {
				isDraggingAnimation = true;
			} else if (SwingUtilities.isLeftMouseButton(e) && isAnimationEnabled() && animationControls != null
					&& animationControls.contains(lastMousePosition) && controlsTimeScale.contains(lastMousePosition)) {
				isDraggingTimeScale = true;
			} else if (SwingUtilities.isLeftMouseButton(e) && contains(e.getPoint())
					&& !animationControls.contains(lastMousePosition)) {
				isDraggingImage = true;
			}
		}

		if (isDraggingImage) {
			Point point = e.getPoint();
			if (lastMousePosition != null) {
				double dx = (point.x - lastMousePosition.x) / image2user.getScaleX();
				double dy = (point.y - lastMousePosition.y) / image2user.getScaleY();

				//pan with the difference in user coordinates between the last known mouse position and this one
				image2user.translate(dx, dy);
				try {
					user2image = image2user.createInverse();
				} catch (NoninvertibleTransformException e1) {
					e1.printStackTrace();
				}
			}
			lastMousePosition = point;
			updateTransformation();
			repaint();
			return true;
		} else if (isDraggingAnimation) {
			pause();

			double progress = Math.min(1,
					Math.max(0, (e.getX() - getControlsProgressLine().x) / (getControlsProgressLine().width * 1.0)));
			seek(getAnimationMinimumTime() + progress * (getAnimationMaximumTime() - getAnimationMinimumTime()));
			renderOneFrame();
			lastMousePosition = e.getPoint();
			return true;
		} else if (isDraggingTimeScale) {
			double progress = Math.min(1,
					Math.max(0, (e.getX() - controlsTimeScale.x) / (controlsTimeScale.width * 1.0)));
			setTimeScale(progress);
			lastMousePosition = e.getPoint();
			repaint();
			return true;
		}

		return false;
	}

	/**
	 * Process a mouse move. Captured = true implies that the hover was already
	 * processed (and we should hide everything related to hovering).
	 * 
	 * @param e
	 * @return whether the move is hovering something.
	 */
	protected boolean processMouseMove(MouseEvent e) {
		lastMousePosition = e.getPoint();
		if (!isDraggingImage && helperControlsArc != null && !helperControlsShowing
				&& isInHelperControls(e.getPoint())) {
			//we have to show the helper controls
			helperControlsShowing = true;
			animationControlsShowing = false;
			repaint();
			return true;
		} else if (!isDraggingImage && animationControls != null && !animationControlsShowing
				&& isInAnimationControls(e.getPoint())) {
			//we have to show the animation controls
			animationControlsShowing = true;
			helperControlsShowing = false;
			repaint();
			return true;
		} else {
			//hide things
			if (animationControlsShowing && !isInAnimationControls(e.getPoint())) {
				animationControlsShowing = false;
				repaint();
			}
			if (helperControlsShowing && !isInHelperControls(e.getPoint())) {
				helperControlsShowing = false;
				repaint();
			}
			return helperControlsShowing || animationControlsShowing || isInNavigation(e.getPoint());
		}
	}

	/**
	 * Process a mouse click
	 * 
	 * @param e
	 * @return whether the click was handled and did something.
	 */
	protected boolean processMouseClick(MouseEvent e) {
		if (SwingUtilities.isLeftMouseButton(e) && isAnimationEnabled() && animationControls != null
				&& animationControls.contains(lastMousePosition)
				&& getControlsProgressLine().contains(lastMousePosition)) {
			double progress = Math.max(0,
					Math.min(1, (e.getX() - getControlsProgressLine().x) / (getControlsProgressLine().width * 1.0)));
			seek(getAnimationMinimumTime() + progress * (getAnimationMaximumTime() - getAnimationMinimumTime()));
			if (wasPlayingBeforeDragging) {
				resume();
			} else {
				renderOneFrame();
				repaint();
			}
		}

		if (controlsTimeScale.contains(e.getPoint())) {
			double progress = Math.min(1,
					Math.max(0, (e.getX() - controlsTimeScale.x) / (controlsTimeScale.width * 1.0)));
			setTimeScale(progress);
			repaint();
		}

		return isInHelperControls(e.getPoint()) || isInAnimationControls(e.getPoint()) || isInNavigation(e.getPoint());
	}

	/**
	 * Process a mouse exit
	 * 
	 * @param e
	 * @return whether the exit was handled and did something.
	 */
	protected boolean processMouseExit(MouseEvent e) {
		if (helperControlsShowing) {
			helperControlsShowing = false;
			repaint();
		}
		if (animationControlsShowing) {
			animationControlsShowing = false;
			repaint();
		}
		if (isDraggingAnimation) {
			isDraggingAnimation = false;
			if (wasPlayingBeforeDragging) {
				resume();
			} else {
				renderOneFrame();
				repaint();
			}
		}
		if (isDraggingImage) {
			isDraggingImage = false;
		}
		if (isDraggingTimeScale) {
			isDraggingTimeScale = false;
		}
		return false;
	}

	/**
	 * Zoom the navigation
	 * 
	 * @param zoomFactor
	 */
	private void zoomNavigation(double zoomFactor) {
		navigationScale *= zoomFactor;
	}

	public void setImageTransformationChangedListener(ImageTransformationChangedListener listener) {
		this.imageTransformationChangedListener = listener;
	}

	private void updateTransformation() {
		if (imageTransformationChangedListener != null) {
			imageTransformationChangedListener.imageTransformationChanged(image2user, user2image);
		}
	}

	public Point2D transformUser2Image(Point2D p) {
		return user2image.transform(p, null);
	}

	public Point2D transformImage2User(Point2D p) {
		return image2user.transform(p, null);
	}

	/**
	 * Needs to be overridden by a subclass.
	 * 
	 * @return whether the animation is rendered and controls are displayed.
	 */
	public boolean isAnimationEnabled() {
		return false;
	}

	/**
	 * Needs to be overridden by a subclass.
	 * 
	 * @return whether the animation is currently playing (not paused)
	 */
	public boolean isAnimationPlaying() {
		return false;
	}

	/**
	 * Needs to be overridden by a subclass.
	 * 
	 * @return the time scale set, which is a 0 <= number <= 1.
	 */
	public double getTimeScale() {
		return 0.5;
	}

	/**
	 * Request the time scale to be set. Needs to be overridden by a subclass.
	 * 
	 * @param time
	 */
	public void setTimeScale(double time) {

	}

	/**
	 * Needs to be overridden by a subclass.
	 * 
	 * @return the current animation time.
	 */
	public double getAnimationTime() {
		return 0;
	}

	/**
	 * Needs to be overridden by a subclass.
	 * 
	 * @return the minimum animation time.
	 */
	public double getAnimationMinimumTime() {
		return 0;
	}

	/**
	 * Needs to be overridden by a subclass.
	 * 
	 * @return the maximum animation time.
	 */
	public double getAnimationMaximumTime() {
		return 0;
	}

	/**
	 * 
	 * @param p
	 * @return whether a point lies in the animation controls.
	 */
	protected boolean isInAnimationControls(Point p) {
		return isAnimationEnabled() && animationControls != null && animationControls.contains(p);
	}

	/**
	 * Request the next animation frame to be rendered at the given time. Needs
	 * to be overridden by a subclass.
	 * 
	 * @param time
	 */
	public void seek(double time) {

	}

	/**
	 * Request the animation to pause. Needs to be overridden by a subclass.
	 */
	public void pause() {

	}

	/**
	 * Resume the animation from pausing. Needs to be overridden by a subclass.
	 */
	public void resume() {

	}

	/**
	 * Request the animation to pause or resume. Needs to be overridden by a
	 * subclass.
	 * 
	 */
	public void pauseResume() {

	}

	/**
	 * Request one frame of the animation to be rendered. Needs to be overridden
	 * by a subclass.
	 * 
	 */
	public void renderOneFrame() {

	}

	public Rectangle getControlsProgressLine() {
		return controlsProgressLine;
	}

	public boolean isAnimationControlsShowing() {
		return animationControlsShowing;
	}

	/**
	 * 
	 * @return The list of exporters. Subclasses can override this to a relevant
	 *         list. Called everytime the user attempts to export the image.
	 */
	public List<Exporter> getExporters() {
		List<Exporter> exporters = new ArrayList<>();
		exporters.add(new ExporterPDF());
		exporters.add(new ExporterPNG());
		exporters.add(new ExporterSVG());
		exporters.add(new ExporterEPS());
		exporters.add(new ExporterEMF());
		return exporters;
	}

	/**
	 * Prompts the user for a file name and saves the view under that file name.
	 */
	public void exportView() {
		new ExportDialog(this, getExporters());
	}

	public int print(Graphics g, PageFormat pageFormat, int page) throws PrinterException {
		if (page > 0) {
			return NO_SUCH_PAGE;
		}

		Graphics2D g2d = (Graphics2D) g;

		double scaleX = pageFormat.getImageableWidth() / image.getWidth();
		double scaleY = pageFormat.getImageableHeight() / image.getHeight();

		if (scaleX < scaleY) {
			g2d.translate(pageFormat.getImageableWidth() / 2, pageFormat.getImageableHeight() / 2);
			g2d.rotate(Math.toRadians(-90));
			g2d.translate(pageFormat.getImageableHeight() / -2, pageFormat.getImageableWidth() / -2);
			g2d.translate(-pageFormat.getImageableX(), pageFormat.getImageableY());

			double scale = pageFormat.getImageableHeight() / image.getWidth();
			g2d.scale(scale, scale);
		} else {
			g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());
			g2d.scale(scaleY, scaleY);
		}

		// Now we perform our rendering
		print(g2d);

		// tell the caller that this page is part
		// of the printed document
		return PAGE_EXISTS;
	}
}
"
A.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 1:56 AM
 */

package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.net.URI;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class A extends Group
{
    public static final String TAG_NAME = ""a"";

    URI href;
    String title;

    /** Creates a new instance of Stop */
    public A()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }
    
    protected void build() throws SVGException
    {
        super.build();
        
        StyleAttribute sty = new StyleAttribute();
        
        if (getPres(sty.setName(""xlink:href"")))
        {
            href = sty.getURIValue(getXMLBase());
        }
        
        if (getPres(sty.setName(""xlink:title"")))
        {
            title = sty.getStringValue();
        }
    }

    /**
     * Updates all attributes in this diagram associated with a time event.
     * Ie, all attributes with track information.
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
        boolean changeState = super.updateTime(curTime);
//        if (trackManager.getNumTracks() == 0) return false;

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        
        if (getPres(sty.setName(""xlink:href"")))
        {
            href = sty.getURIValue(getXMLBase());
        }
        
        if (getPres(sty.setName(""xlink:title"")))
        {
            title = sty.getStringValue();
        }
        
        return changeState;
    }
}
"
Animate.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 2:51 AM
 */

package com.kitfox.svg.animation;

import java.awt.Color;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;

import com.kitfox.svg.SVGConst;
import com.kitfox.svg.SVGElement;
import com.kitfox.svg.SVGException;
import com.kitfox.svg.SVGLoaderHelper;
import com.kitfox.svg.animation.parser.AnimTimeParser;
import com.kitfox.svg.xml.ColorTable;
import com.kitfox.svg.xml.StyleAttribute;
import com.kitfox.svg.xml.XMLParseUtil;


/**
 * Animate is a really annoying morphic tag that could represent a real value,
 * a color or a path
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Animate extends AnimateBase implements AnimateColorIface
{
    public static final String TAG_NAME = ""animate"";
    
//    StyleAttribute retAttrib = new StyleAttribute
    public static final int DT_REAL = 0;
    public static final int DT_COLOR = 1;
    public static final int DT_PATH = 2;
    int dataType = DT_REAL;
    
    protected double fromValue = Double.NaN;
    protected double toValue = Double.NaN;
    protected double byValue = Double.NaN;
    protected double[] valuesValue;
    
    protected Color fromColor = null;
    protected Color toColor = null;

    protected GeneralPath fromPath = null;
    protected GeneralPath toPath = null;

    /** Creates a new instance of Animate */
    public Animate()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    public int getDataType()
    {
        return dataType;
    }
    
    public void loaderStartElement(SVGLoaderHelper helper, Attributes attrs, SVGElement parent) throws SAXException
    {
		//Load style string
        super.loaderStartElement(helper, attrs, parent);

        String strn = attrs.getValue(""from"");
        if (strn != null)
        {
            if (XMLParseUtil.isDouble(strn))
            {
                fromValue = XMLParseUtil.parseDouble(strn); 
            } 
//            else if (attrs.getValue(""attributeName"").equals(""d""))
//            {
//                fromPath = this.buildPath(strn, GeneralPath.WIND_EVEN_ODD);
//                dataType = DT_PATH;
//            }
            else
            {
                fromColor = ColorTable.parseColor(strn); 
                if (fromColor == null)
                {
                    //Try path
                    fromPath = buildPath(strn, GeneralPath.WIND_EVEN_ODD);
                    dataType = DT_PATH;
                }
                else dataType = DT_COLOR;
            }
        }

        strn = attrs.getValue(""to"");
        if (strn != null)
        {
            if (XMLParseUtil.isDouble(strn))
            {
                toValue = XMLParseUtil.parseDouble(strn); 
            } 
            else
            {
                toColor = ColorTable.parseColor(strn); 
                if (toColor == null)
                {
                    //Try path
                    toPath = buildPath(strn, GeneralPath.WIND_EVEN_ODD);
                    dataType = DT_PATH;
                }
                else dataType = DT_COLOR;
            }
        }

        strn = attrs.getValue(""by"");
        try 
        {
            if (strn != null) byValue = XMLParseUtil.parseDouble(strn); 
        } catch (Exception e) {}

        strn = attrs.getValue(""values"");
        try 
        {
            if (strn != null) valuesValue = XMLParseUtil.parseDoubleList(strn); 
        } catch (Exception e) {}
    }
    
    /**
     * Evaluates this animation element for the passed interpolation time.  Interp
     * must be on [0..1].
     */
    public double eval(double interp)
    {
        boolean fromExists = !Double.isNaN(fromValue);
        boolean toExists = !Double.isNaN(toValue);
        boolean byExists = !Double.isNaN(byValue);
        boolean valuesExists = valuesValue != null;
        
        if (valuesExists)
        {
            double sp = interp * valuesValue.length;
            int ip = (int)sp;
            double fp = sp - ip;
            
            int i0 = ip;
            int i1 = ip + 1;
            
            if (i0 < 0) return valuesValue[0];
            if (i1 >= valuesValue.length) return valuesValue[valuesValue.length - 1];
            return valuesValue[i0] * (1 - fp) + valuesValue[i1] * fp;
        }
        else if (fromExists && toExists)
        {
            return toValue * interp + fromValue * (1.0 - interp);
        }
        else if (fromExists && byExists)
        {
            return fromValue + byValue * interp;
        }
        else if (toExists && byExists)
        {
            return toValue - byValue * (1.0 - interp);
        }
        else if (byExists)
        {
            return byValue * interp;
        }
        else if (toExists)
        {
            StyleAttribute style = new StyleAttribute(getAttribName());
            try
            {
                getParent().getStyle(style, true, false);
            }
            catch (SVGException ex)
            {
                Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, 
                    ""Could not get from value"", ex);
            }
            double from = style.getDoubleValue();
            return toValue * interp + from * (1.0 - interp);
        }
  
        //Should not reach this line
        throw new RuntimeException(""Animate tag could not be evalutated - insufficient arguements"");
    }

    public Color evalColor(double interp)
    {
        if (fromColor == null && toColor != null)
        {
            float[] toCol = new float[3];
            toColor.getColorComponents(toCol);
            return new Color(toCol[0] * (float)interp, 
                toCol[1] * (float)interp, 
                toCol[2] * (float)interp);
        }
        else if (fromColor != null && toColor != null)
        {
            float nInterp = 1 - (float)interp;
            
            float[] fromCol = new float[3];
            float[] toCol = new float[3];
            fromColor.getColorComponents(fromCol);
            toColor.getColorComponents(toCol);
            return new Color(fromCol[0] * nInterp + toCol[0] * (float)interp, 
                fromCol[1] * nInterp + toCol[1] * (float)interp, 
                fromCol[2] * nInterp + toCol[2] * (float)interp);
        }
        
        throw new RuntimeException(""Animate tag could not be evalutated - insufficient arguements"");
    }

    public GeneralPath evalPath(double interp)
    {
        if (fromPath == null && toPath != null)
        {
            PathIterator itTo = toPath.getPathIterator(new AffineTransform());
            
            GeneralPath midPath = new GeneralPath();
            float[] coordsTo = new float[6];
            
            for (; !itTo.isDone(); itTo.next())
            {
                int segTo = itTo.currentSegment(coordsTo);
                
                switch (segTo)
                {
                    case PathIterator.SEG_CLOSE:
                        midPath.closePath();
                        break;
                    case PathIterator.SEG_CUBICTO:
                        midPath.curveTo(
                                (float)(coordsTo[0] * interp), 
                                (float)(coordsTo[1] * interp), 
                                (float)(coordsTo[2] * interp), 
                                (float)(coordsTo[3] * interp), 
                                (float)(coordsTo[4] * interp), 
                                (float)(coordsTo[5] * interp)
                                );
                        break;
                    case PathIterator.SEG_LINETO:
                        midPath.lineTo(
                                (float)(coordsTo[0] * interp), 
                                (float)(coordsTo[1] * interp)
                                );
                        break;
                    case PathIterator.SEG_MOVETO:
                        midPath.moveTo(
                                (float)(coordsTo[0] * interp), 
                                (float)(coordsTo[1] * interp)
                                );
                        break;
                    case PathIterator.SEG_QUADTO:
                        midPath.quadTo(
                                (float)(coordsTo[0] * interp), 
                                (float)(coordsTo[1] * interp), 
                                (float)(coordsTo[2] * interp), 
                                (float)(coordsTo[3] * interp)
                                );
                        break;
                }
            }
            
            return midPath;
        }
        else if (toPath != null)
        {
            PathIterator itFrom = fromPath.getPathIterator(new AffineTransform());
            PathIterator itTo = toPath.getPathIterator(new AffineTransform());
            
            GeneralPath midPath = new GeneralPath();
            float[] coordsFrom = new float[6];
            float[] coordsTo = new float[6];
            
            for (; !itFrom.isDone(); itFrom.next(), itTo.next())
            {
                int segFrom = itFrom.currentSegment(coordsFrom);
                int segTo = itTo.currentSegment(coordsTo);
                
                if (segFrom != segTo)
                {
                    throw new RuntimeException(""Path shape mismatch"");
                }
                
                switch (segFrom)
                {
                    case PathIterator.SEG_CLOSE:
                        midPath.closePath();
                        break;
                    case PathIterator.SEG_CUBICTO:
                        midPath.curveTo(
                                (float)(coordsFrom[0] * (1 - interp) + coordsTo[0] * interp), 
                                (float)(coordsFrom[1] * (1 - interp) + coordsTo[1] * interp), 
                                (float)(coordsFrom[2] * (1 - interp) + coordsTo[2] * interp), 
                                (float)(coordsFrom[3] * (1 - interp) + coordsTo[3] * interp), 
                                (float)(coordsFrom[4] * (1 - interp) + coordsTo[4] * interp), 
                                (float)(coordsFrom[5] * (1 - interp) + coordsTo[5] * interp)
                                );
                        break;
                    case PathIterator.SEG_LINETO:
                        midPath.lineTo(
                                (float)(coordsFrom[0] * (1 - interp) + coordsTo[0] * interp), 
                                (float)(coordsFrom[1] * (1 - interp) + coordsTo[1] * interp)
                                );
                        break;
                    case PathIterator.SEG_MOVETO:
                        midPath.moveTo(
                                (float)(coordsFrom[0] * (1 - interp) + coordsTo[0] * interp), 
                                (float)(coordsFrom[1] * (1 - interp) + coordsTo[1] * interp)
                                );
                        break;
                    case PathIterator.SEG_QUADTO:
                        midPath.quadTo(
                                (float)(coordsFrom[0] * (1 - interp) + coordsTo[0] * interp), 
                                (float)(coordsFrom[1] * (1 - interp) + coordsTo[1] * interp), 
                                (float)(coordsFrom[2] * (1 - interp) + coordsTo[2] * interp), 
                                (float)(coordsFrom[3] * (1 - interp) + coordsTo[3] * interp)
                                );
                        break;
                }
            }
            
            return midPath;
        }
        
        throw new RuntimeException(""Animate tag could not be evalutated - insufficient arguements"");
    }
    
    /**
     * If this element is being accumulated, detemine the delta to accumulate by
     */
    public double repeatSkipSize(int reps)
    {
        boolean fromExists = !Double.isNaN(fromValue);
        boolean toExists = !Double.isNaN(toValue);
        boolean byExists = !Double.isNaN(byValue);
        
        if (fromExists && toExists)
        {
            return (toValue - fromValue) * reps;
        }
        else if (fromExists && byExists)
        {
            return (fromValue + byValue) * reps;
        }
        else if (toExists && byExists)
        {
            return toValue * reps;
        }
        else if (byExists)
        {
            return byValue * reps;
        }

        //Should not reach this line
        return 0;
    }

    protected void rebuild(AnimTimeParser animTimeParser) throws SVGException
    {
        super.rebuild(animTimeParser);

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""from"")))
        {
            String strn = sty.getStringValue();
            if (XMLParseUtil.isDouble(strn))
            {
                fromValue = XMLParseUtil.parseDouble(strn);
            }
            else
            {
                fromColor = ColorTable.parseColor(strn);
                if (fromColor == null)
                {
                    //Try path
                    fromPath = buildPath(strn, GeneralPath.WIND_EVEN_ODD);
                    dataType = DT_PATH;
                }
                else dataType = DT_COLOR;
            }
        }

        if (getPres(sty.setName(""to"")))
        {
            String strn = sty.getStringValue();
            if (XMLParseUtil.isDouble(strn))
            {
                toValue = XMLParseUtil.parseDouble(strn);
            }
            else
            {
                toColor = ColorTable.parseColor(strn);
                if (toColor == null)
                {
                    //Try path
                    toPath = buildPath(strn, GeneralPath.WIND_EVEN_ODD);
                    dataType = DT_PATH;
                }
                else dataType = DT_COLOR;
            }
        }

        if (getPres(sty.setName(""by"")))
        {
            String strn = sty.getStringValue();
            if (strn != null) byValue = XMLParseUtil.parseDouble(strn);
        }

        if (getPres(sty.setName(""values"")))
        {
            String strn = sty.getStringValue();
            if (strn != null) valuesValue = XMLParseUtil.parseDoubleList(strn);
        }
    }
    
}
"
AnimateBase.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 2:51 AM
 */

package com.kitfox.svg.animation;

import com.kitfox.svg.SVGConst;
import com.kitfox.svg.SVGElement;
import com.kitfox.svg.SVGException;
import com.kitfox.svg.SVGLoaderHelper;
import com.kitfox.svg.animation.parser.AnimTimeParser;
import com.kitfox.svg.animation.parser.ParseException;
import com.kitfox.svg.xml.StyleAttribute;
import java.io.StringReader;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
abstract public class AnimateBase extends AnimationElement
{
    protected double repeatCount = Double.NaN;
    protected TimeBase repeatDur;
    
    /** Creates a new instance of Animate */
    public AnimateBase()
    {
    }
    
    public void evalParametric(AnimationTimeEval state, double curTime)
    {
        evalParametric(state, curTime, repeatCount, repeatDur == null ? Double.NaN : repeatDur.evalTime());
    }
    
    public void loaderStartElement(SVGLoaderHelper helper, Attributes attrs, SVGElement parent) throws SAXException
    {
		//Load style string
        super.loaderStartElement(helper, attrs, parent);

        String repeatDurTime = attrs.getValue(""repeatDur"");

        try
        {
            if (repeatDurTime != null)
            {
                helper.animTimeParser.ReInit(new StringReader(repeatDurTime));
                this.repeatDur = helper.animTimeParser.Expr();
                this.repeatDur.setParentElement(this);
            }
        }
        catch (Exception e)
        {
            throw new SAXException(e);
        }
        
        String strn = attrs.getValue(""repeatCount"");
        if (strn == null)
        {
            repeatCount = 1;
        }
        else if (""indefinite"".equals(strn))
        {
            repeatCount = Double.POSITIVE_INFINITY;
        }
        else
        {
            try { repeatCount = Double.parseDouble(strn); } 
            catch (Exception e) { repeatCount = Double.NaN; }
        }
    }

    protected void rebuild(AnimTimeParser animTimeParser) throws SVGException
    {
        super.rebuild(animTimeParser);

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""repeatDur"")))
        {
            String strn = sty.getStringValue();
            if (strn != null)
            {
                animTimeParser.ReInit(new StringReader(strn));
                try
                {
                    this.repeatDur = animTimeParser.Expr();
                }
                catch (ParseException ex)
                {
                    Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, 
                        ""Could not parse '"" + strn + ""'"", ex);
                }
            }
        }

        if (getPres(sty.setName(""repeatCount"")))
        {
            String strn = sty.getStringValue();
            if (strn == null)
            {
                repeatCount = 1;
            }
            else if (""indefinite"".equals(strn))
            {
                repeatCount = Double.POSITIVE_INFINITY;
            }
            else
            {
                try { repeatCount = Double.parseDouble(strn); }
                catch (Exception e) { repeatCount = Double.NaN; }
            }
        }
    }
}
"
AnimateColor.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 2:51 AM
 */

package com.kitfox.svg.animation;

import com.kitfox.svg.SVGElement;
import com.kitfox.svg.SVGException;
import com.kitfox.svg.SVGLoaderHelper;
import com.kitfox.svg.animation.parser.AnimTimeParser;
import com.kitfox.svg.xml.ColorTable;
import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Color;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;


/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class AnimateColor extends AnimateBase implements AnimateColorIface
{
    public static final String TAG_NAME = ""animateColor"";
    
    
    protected Color fromValue;
    protected Color toValue;
    
    /** Creates a new instance of Animate */
    public AnimateColor()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    public void loaderStartElement(SVGLoaderHelper helper, Attributes attrs, SVGElement parent) throws SAXException
    {
		//Load style string
        super.loaderStartElement(helper, attrs, parent);

        String strn = attrs.getValue(""from"");
        fromValue = ColorTable.parseColor(strn);

        strn = attrs.getValue(""to"");
        toValue = ColorTable.parseColor(strn);
    }

    
    /**
     * Evaluates this animation element for the passed interpolation time.  Interp
     * must be on [0..1].
     */
    public Color evalColor(double interp)
    {
        int r1 = fromValue.getRed();
        int g1 = fromValue.getGreen();
        int b1 = fromValue.getBlue();
        int r2 = toValue.getRed();
        int g2 = toValue.getGreen();
        int b2 = toValue.getBlue();
        double invInterp = 1.0 - interp;
        
        return new Color((int)(r1 * invInterp + r2 * interp), 
            (int)(g1 * invInterp + g2 * interp), 
            (int)(b1 * invInterp + b2 * interp));
    }

    protected void rebuild(AnimTimeParser animTimeParser) throws SVGException
    {
        super.rebuild(animTimeParser);

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""from"")))
        {
            String strn = sty.getStringValue();
            fromValue = ColorTable.parseColor(strn);
        }

        if (getPres(sty.setName(""to"")))
        {
            String strn = sty.getStringValue();
            toValue = ColorTable.parseColor(strn);
        }
    }
}
"
AnimateColorIface.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 16, 2005, 6:24 AM
 */

package com.kitfox.svg.animation;

import java.awt.*;

/**
 *
 * @author kitfox
 */
public interface AnimateColorIface
{
    public Color evalColor(double interp);
}
"
AnimateMotion.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 2:51 AM
 */

package com.kitfox.svg.animation;

import com.kitfox.svg.SVGElement;
import com.kitfox.svg.SVGException;
import com.kitfox.svg.SVGLoaderHelper;
import com.kitfox.svg.animation.parser.AnimTimeParser;
import com.kitfox.svg.xml.StyleAttribute;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;


/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class AnimateMotion extends AnimateXform
{
    public static final String TAG_NAME = ""animateMotion"";
    
    static final Matcher matchPoint = Pattern.compile(""\\s*(\\d+)[^\\d]+(\\d+)\\s*"").matcher("""");
    
//    protected double fromValue;
//    protected double toValue;
    GeneralPath path;
    int rotateType = RT_ANGLE;
    double rotate;  //Static angle to rotate by
    
    public static final int RT_ANGLE = 0;  //Rotate by constant 'rotate' degrees
    public static final int RT_AUTO = 1;  //Rotate to reflect tangent of position on path
    
    final ArrayList bezierSegs = new ArrayList();
    double curveLength;
    
    /** Creates a new instance of Animate */
    public AnimateMotion()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    public void loaderStartElement(SVGLoaderHelper helper, Attributes attrs, SVGElement parent) throws SAXException
    {
		//Load style string
        super.loaderStartElement(helper, attrs, parent);
        
        //Motion element implies animating the transform element
        if (attribName == null) 
        {
            attribName = ""transform"";
            attribType = AT_AUTO;
            additiveType = AD_SUM;
        }
        

        String path = attrs.getValue(""path"");
        if (path != null)
        {
            this.path = buildPath(path, GeneralPath.WIND_NON_ZERO);
        }
        
        //Now parse rotation style
        String rotate = attrs.getValue(""rotate"");
        if (rotate != null)
        {
            if (rotate.equals(""auto""))
            {
                this.rotateType = RT_AUTO;
            }
            else
            {
                try { this.rotate = Math.toRadians(Float.parseFloat(rotate)); } catch (Exception e) {}
            }
        }

        //Determine path
        String from = attrs.getValue(""from"");
        String to = attrs.getValue(""to"");

        buildPath(from, to);
    }
    
    protected static void setPoint(Point2D.Float pt, String x, String y)
    {
        try { pt.x = Float.parseFloat(x); } catch (Exception e) {};
        
        try { pt.y = Float.parseFloat(y); } catch (Exception e) {};
    }

    private void buildPath(String from, String to)
    {
        if (from != null && to != null)
        {
            Point2D.Float ptFrom = new Point2D.Float(), ptTo = new Point2D.Float();

            matchPoint.reset(from);
            if (matchPoint.matches())
            {
                setPoint(ptFrom, matchPoint.group(1), matchPoint.group(2));
            }

            matchPoint.reset(to);
            if (matchPoint.matches())
            {
                setPoint(ptFrom, matchPoint.group(1), matchPoint.group(2));
            }

            if (ptFrom != null && ptTo != null)
            {
                path = new GeneralPath();
                path.moveTo(ptFrom.x, ptFrom.y);
                path.lineTo(ptTo.x, ptTo.y);
            }
        }

        paramaterizePath();
    }
    
    private void paramaterizePath()
    {
        bezierSegs.clear();
        curveLength = 0;
        
        double[] coords = new double[6];
        double sx = 0, sy = 0;
        
        for (PathIterator pathIt = path.getPathIterator(new AffineTransform()); !pathIt.isDone(); pathIt.next())
        {
            Bezier bezier = null;
                    
            int segType = pathIt.currentSegment(coords);
            
            switch (segType)
            {
                case PathIterator.SEG_LINETO: 
                {
                    bezier = new Bezier(sx, sy, coords, 1);
                    sx = coords[0];
                    sy = coords[1];
                    break;
                }
                case PathIterator.SEG_QUADTO:
                {
                    bezier = new Bezier(sx, sy, coords, 2);
                    sx = coords[2];
                    sy = coords[3];
                    break;
                }
                case PathIterator.SEG_CUBICTO:
                {
                    bezier = new Bezier(sx, sy, coords, 3);
                    sx = coords[4];
                    sy = coords[5];
                    break;
                }
                case PathIterator.SEG_MOVETO:
                {
                    sx = coords[0];
                    sy = coords[1];
                    break;
                }
                case PathIterator.SEG_CLOSE:
                    //Do nothing
                    break;
                
            }

            if (bezier != null)
            {
                bezierSegs.add(bezier);
                curveLength += bezier.getLength();
            }
        }
    }
    
    /**
     * Evaluates this animation element for the passed interpolation time.  Interp
     * must be on [0..1].
     */
    public AffineTransform eval(AffineTransform xform, double interp)
    {
        Point2D.Double point = new Point2D.Double();
        
        if (interp >= 1)
        {
            Bezier last = (Bezier)bezierSegs.get(bezierSegs.size() - 1);
            last.getFinalPoint(point);
            xform.setToTranslation(point.x, point.y);
            return xform;
        }
        
        double curLength = curveLength * interp;
        for (Iterator it = bezierSegs.iterator(); it.hasNext();)
        {
            Bezier bez = (Bezier)it.next();
            
            double bezLength = bez.getLength();
            if (curLength < bezLength)
            {
                double param = curLength / bezLength;
                bez.eval(param, point);
                break;
            }
            
            curLength -= bezLength;
        }
        
        xform.setToTranslation(point.x, point.y);
        
        return xform;
    }
    

    protected void rebuild(AnimTimeParser animTimeParser) throws SVGException
    {
        super.rebuild(animTimeParser);

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""path"")))
        {
            String strn = sty.getStringValue();
            this.path = buildPath(strn, GeneralPath.WIND_NON_ZERO);
        }

        if (getPres(sty.setName(""rotate"")))
        {
            String strn = sty.getStringValue();
            if (strn.equals(""auto""))
            {
                this.rotateType = RT_AUTO;
            }
            else
            {
                try { this.rotate = Math.toRadians(Float.parseFloat(strn)); } catch (Exception e) {}
            }
        }

        String from = null;
        if (getPres(sty.setName(""from"")))
        {
            from = sty.getStringValue();
        }

        String to = null;
        if (getPres(sty.setName(""to"")))
        {
            to = sty.getStringValue();
        }
        
        buildPath(from, to);
    }
}
"
AnimateTransform.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 2:51 AM
 */

package com.kitfox.svg.animation;

import com.kitfox.svg.SVGElement;
import com.kitfox.svg.SVGException;
import com.kitfox.svg.SVGLoaderHelper;
import com.kitfox.svg.animation.parser.AnimTimeParser;
import com.kitfox.svg.xml.StyleAttribute;
import com.kitfox.svg.xml.XMLParseUtil;
import java.awt.geom.AffineTransform;
import java.util.regex.Pattern;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;


/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class AnimateTransform extends AnimateXform
{
    public static final String TAG_NAME = ""animateTransform"";
    
//    protected AffineTransform fromValue;
//    protected AffineTransform toValue;
//    protected double[] fromValue;  //Transform parameters
//    protected double[] toValue;
    protected double[][] values;
    protected double[] keyTimes;

    public static final int AT_REPLACE = 0;
    public static final int AT_SUM = 1;

    protected int additive = AT_REPLACE;

    public static final int TR_TRANSLATE = 0;
    public static final int TR_ROTATE = 1;
    public static final int TR_SCALE = 2;
    public static final int TR_SKEWY = 3;
    public static final int TR_SKEWX = 4;
    public static final int TR_INVALID = 5;

    protected int xformType = TR_INVALID;

    /** Creates a new instance of Animate */
    public AnimateTransform()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    public void loaderStartElement(SVGLoaderHelper helper, Attributes attrs, SVGElement parent) throws SAXException
    {
		//Load style string
        super.loaderStartElement(helper, attrs, parent);

        //Type of matrix of transform.  Should be one of the known names used to
        // define matrix transforms
        // valid types: translate, scale, rotate, skewX, skewY
        // 'matrix' not valid for animation
        String type = attrs.getValue(""type"").toLowerCase();
        if (type.equals(""translate"")) xformType = TR_TRANSLATE;
        if (type.equals(""rotate"")) xformType = TR_ROTATE;
        if (type.equals(""scale"")) xformType = TR_SCALE;
        if (type.equals(""skewx"")) xformType = TR_SKEWX;
        if (type.equals(""skewy"")) xformType = TR_SKEWY;

        String fromStrn = attrs.getValue(""from"");
        String toStrn = attrs.getValue(""to"");
        if (fromStrn != null && toStrn != null)
        {
            //fromValue = parseSingleTransform(type + ""("" + strn + "")"");
            double[] fromValue = XMLParseUtil.parseDoubleList(fromStrn);
            fromValue = validate(fromValue);

    //        toValue = parseSingleTransform(type + ""("" + strn + "")"");
            double[] toValue = XMLParseUtil.parseDoubleList(toStrn);
            toValue = validate(toValue);
            
            values = new double[][]{fromValue, toValue};
            keyTimes = new double[]{0, 1};
        }

        String keyTimeStrn = attrs.getValue(""keyTimes"");
        String valuesStrn = attrs.getValue(""values"");
        if (keyTimeStrn != null && valuesStrn != null)
        {
            keyTimes = XMLParseUtil.parseDoubleList(keyTimeStrn);
            
            String[] valueList = Pattern.compile("";"").split(valuesStrn);
            values = new double[valueList.length][];
            for (int i = 0; i < valueList.length; i++)
            {
                double[] list = XMLParseUtil.parseDoubleList(valueList[i]);
                values[i] = validate(list);
            }
        }
        
        //Check our additive state
        String additive = attrs.getValue(""additive"");
        if (additive != null)
        {
            if (additive.equals(""sum"")) this.additive = AT_SUM;
        }
    }

    /**
     * Check list size against current xform type and ensure list
     * is expanded to a standard list size
     */
    private double[] validate(double[] paramList)
    {
        switch (xformType)
        {
            case TR_SCALE:
            {
                if (paramList == null)
                {
                    paramList = new double[]{1, 1};
                }
                else if (paramList.length == 1)
                {
                    paramList = new double[]{paramList[0], paramList[0]};
                    
//                    double[] tmp = paramList;
//                    paramList = new double[2];
//                    paramList[0] = paramList[1] = tmp[0];
                }
            }
        }

        return paramList;
    }

    /**
     * Evaluates this animation element for the passed interpolation time.  Interp
     * must be on [0..1].
     */
    public AffineTransform eval(AffineTransform xform, double interp)
    {
        int idx = 0;
        for (; idx < keyTimes.length - 1; idx++)
        {
            if (interp >= keyTimes[idx])
            {
                idx--;
                if (idx < 0) idx = 0;
                break;
            }
        }
        
        double spanStartTime = keyTimes[idx];
        double spanEndTime = keyTimes[idx + 1];
//        double span = spanStartTime - spanEndTime;
        
        interp = (interp - spanStartTime) / (spanEndTime - spanStartTime);
        double[] fromValue = values[idx];
        double[] toValue = values[idx + 1];
        
        switch (xformType)
        {
            case TR_TRANSLATE:
            {
                double x0 = fromValue.length >= 1 ? fromValue[0] : 0;
                double x1 = toValue.length >= 1 ? toValue[0] : 0;
                double y0 = fromValue.length >= 2 ? fromValue[1] : 0;
                double y1 = toValue.length >= 2 ? toValue[1] : 0;
                
                double x = lerp(x0, x1, interp);
                double y = lerp(y0, y1, interp);
                
                xform.setToTranslation(x, y);
                break;
            }
            case TR_ROTATE:
            {
                double x1 = fromValue.length == 3 ? fromValue[1] : 0;
                double y1 = fromValue.length == 3 ? fromValue[2] : 0;
                double x2 = toValue.length == 3 ? toValue[1] : 0;
                double y2 = toValue.length == 3 ? toValue[2] : 0;
                
                double theta = lerp(fromValue[0], toValue[0], interp);
                double x = lerp(x1, x2, interp);
                double y = lerp(y1, y2, interp);
                xform.setToRotation(Math.toRadians(theta), x, y);
                break;
            }
            case TR_SCALE:
            {
                double x0 = fromValue.length >= 1 ? fromValue[0] : 1;
                double x1 = toValue.length >= 1 ? toValue[0] : 1;
                double y0 = fromValue.length >= 2 ? fromValue[1] : 1;
                double y1 = toValue.length >= 2 ? toValue[1] : 1;
                
                double x = lerp(x0, x1, interp);
                double y = lerp(y0, y1, interp);
                xform.setToScale(x, y);
                break;
            }
            case TR_SKEWX:
            {
                double x = lerp(fromValue[0], toValue[0], interp);
                xform.setToShear(Math.toRadians(x), 0.0);
                break;
            }
            case TR_SKEWY:
            {
                double y = lerp(fromValue[0], toValue[0], interp);
                xform.setToShear(0.0, Math.toRadians(y));
                break;
            }
            default:
                xform.setToIdentity();
                break;
        }

        return xform;
    }

    protected void rebuild(AnimTimeParser animTimeParser) throws SVGException
    {
        super.rebuild(animTimeParser);

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""type"")))
        {
            String strn = sty.getStringValue().toLowerCase();
            if (strn.equals(""translate"")) xformType = TR_TRANSLATE;
            if (strn.equals(""rotate"")) xformType = TR_ROTATE;
            if (strn.equals(""scale"")) xformType = TR_SCALE;
            if (strn.equals(""skewx"")) xformType = TR_SKEWX;
            if (strn.equals(""skewy"")) xformType = TR_SKEWY;
        }

        String fromStrn = null;
        if (getPres(sty.setName(""from"")))
        {
            fromStrn = sty.getStringValue();
        }

        String toStrn = null;
        if (getPres(sty.setName(""to"")))
        {
            toStrn = sty.getStringValue();
        }

        if (fromStrn != null && toStrn != null)
        {
            double[] fromValue = XMLParseUtil.parseDoubleList(fromStrn);
            fromValue = validate(fromValue);

            double[] toValue = XMLParseUtil.parseDoubleList(toStrn);
            toValue = validate(toValue);

            values = new double[][]{fromValue, toValue};
        }

        String keyTimeStrn = null;
        if (getPres(sty.setName(""keyTimes"")))
        {
            keyTimeStrn = sty.getStringValue();
        }

        String valuesStrn = null;
        if (getPres(sty.setName(""values"")))
        {
            valuesStrn = sty.getStringValue();
        }

        if (keyTimeStrn != null && valuesStrn != null)
        {
            keyTimes = XMLParseUtil.parseDoubleList(keyTimeStrn);

            String[] valueList = Pattern.compile("";"").split(valuesStrn);
            values = new double[valueList.length][];
            for (int i = 0; i < valueList.length; i++)
            {
                double[] list = XMLParseUtil.parseDoubleList(valueList[i]);
                values[i] = validate(list);
            }
        }

        //Check our additive state

        if (getPres(sty.setName(""additive"")))
        {
            String strn = sty.getStringValue().toLowerCase();
            if (strn.equals(""sum"")) this.additive = AT_SUM;
        }
    }
}
"
AnimateXform.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 14, 2005, 6:46 AM
 */

package com.kitfox.svg.animation;

import com.kitfox.svg.SVGElement;
import com.kitfox.svg.SVGLoaderHelper;
import java.awt.geom.AffineTransform;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;



/**
 *
 * @author kitfox
 */
abstract public class AnimateXform extends AnimateBase
{
    public AnimateXform()
    {
    }
    
    public void loaderStartElement(SVGLoaderHelper helper, Attributes attrs, SVGElement parent) throws SAXException
    {
        super.loaderStartElement(helper, attrs, parent);
    }
    
    abstract public AffineTransform eval(AffineTransform xform, double interp);
    
}
"
AnimationElement.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 2:52 AM
 */

package com.kitfox.svg.animation;

import java.io.StringReader;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;

import com.kitfox.svg.SVGConst;
import com.kitfox.svg.SVGElement;
import com.kitfox.svg.SVGException;
import com.kitfox.svg.SVGLoaderHelper;
import com.kitfox.svg.animation.parser.AnimTimeParser;
import com.kitfox.svg.animation.parser.ParseException;
import com.kitfox.svg.xml.StyleAttribute;


/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public abstract class AnimationElement extends SVGElement
{
    protected String attribName;
//    protected String attribType;
    protected int attribType = AT_AUTO;

    public static final int AT_CSS = 0;
    public static final int AT_XML = 1;
    public static final int AT_AUTO = 2;  //Check CSS first, then XML

    protected TimeBase beginTime;
    protected TimeBase durTime;
    protected TimeBase endTime;
    protected int fillType = FT_AUTO;

    /** <a href=""http://www.w3.org/TR/smil20/smil-timing.html#adef-fill"">More about the <b>fill</b> attribute</a> */
    public static final int FT_REMOVE = 0;
    public static final int FT_FREEZE = 1;
    public static final int FT_HOLD = 2;
    public static final int FT_TRANSITION = 3;
    public static final int FT_AUTO = 4;
    public static final int FT_DEFAULT = 5;

    /** Additive state of track */
    public static final int AD_REPLACE = 0;
    public static final int AD_SUM = 1;

    int additiveType = AD_REPLACE;
    
    /** Accumlative state */
    public static final int AC_REPLACE = 0;
    public static final int AC_SUM = 1;

    int accumulateType = AC_REPLACE;

    /** Creates a new instance of AnimateEle */
    public AnimationElement()
    {
    }

    public static String animationElementToString(int attrValue)
    {
        switch (attrValue)
        {
            case AT_CSS:
                return ""CSS"";
            case AT_XML:
                return ""XML"";
            case AT_AUTO:
                return ""AUTO"";
            default:
                throw new RuntimeException(""Unknown element type"");
        }
    }
    
    public void loaderStartElement(SVGLoaderHelper helper, Attributes attrs, SVGElement parent) throws SAXException
    {
		//Load style string
        super.loaderStartElement(helper, attrs, parent);

        attribName = attrs.getValue(""attributeName"");
        String attribType = attrs.getValue(""attributeType"");
        if (attribType != null)
        {
            attribType = attribType.toLowerCase();
            if (attribType.equals(""css"")) this.attribType = AT_CSS;
            else if (attribType.equals(""xml"")) this.attribType = AT_XML;
        }

        String beginTime = attrs.getValue(""begin"");
        String durTime = attrs.getValue(""dur"");
        String endTime = attrs.getValue(""end"");

        try
        {
            if (beginTime != null)
            {
                helper.animTimeParser.ReInit(new StringReader(beginTime));
                this.beginTime = helper.animTimeParser.Expr();
                this.beginTime.setParentElement(this);
            }

            if (durTime != null)
            {
                helper.animTimeParser.ReInit(new StringReader(durTime));
                this.durTime = helper.animTimeParser.Expr();
                this.durTime.setParentElement(this);
            }

            if (endTime != null)
            {
                helper.animTimeParser.ReInit(new StringReader(endTime));
                this.endTime = helper.animTimeParser.Expr();
                this.endTime.setParentElement(this);
            }
        }
        catch (Exception e)
        {
            throw new SAXException(e);
        }
        
//        this.beginTime = TimeBase.parseTime(beginTime);
//        this.durTime = TimeBase.parseTime(durTime);
//        this.endTime = TimeBase.parseTime(endTime);

        String fill = attrs.getValue(""fill"");

        if (fill != null)
        {
            if (fill.equals(""remove"")) this.fillType = FT_REMOVE;
            if (fill.equals(""freeze"")) this.fillType = FT_FREEZE;
            if (fill.equals(""hold"")) this.fillType = FT_HOLD;
            if (fill.equals(""transiton"")) this.fillType = FT_TRANSITION;
            if (fill.equals(""auto"")) this.fillType = FT_AUTO;
            if (fill.equals(""default"")) this.fillType = FT_DEFAULT;
        }
        
        String additiveStrn = attrs.getValue(""additive"");
        
        if (additiveStrn != null)
        {
            if (additiveStrn.equals(""replace"")) this.additiveType = AD_REPLACE;
            if (additiveStrn.equals(""sum"")) this.additiveType = AD_SUM;
        }
        
        String accumulateStrn = attrs.getValue(""accumulate"");
        
        if (accumulateStrn != null)
        {
            if (accumulateStrn.equals(""replace"")) this.accumulateType = AC_REPLACE;
            if (accumulateStrn.equals(""sum"")) this.accumulateType = AC_SUM;
        }
    }

    public String getAttribName() { return attribName; }
    public int getAttribType() { return attribType; }
    public int getAdditiveType() { return additiveType; }
    public int getAccumulateType() { return accumulateType; }

    public void evalParametric(AnimationTimeEval state, double curTime)
    {
        evalParametric(state, curTime, Double.NaN, Double.NaN);
    }

    /**
     * Compares current time to start and end times and determines what degree
     * of time interpolation this track currently represents.  Returns
     * Float.NaN if this track cannot be evaluated at the passed time (ie,
     * it is before or past the end of the track, or it depends upon
     * an unknown event)
     * @param state - A structure that will be filled with information
     * regarding the applicability of this animatoin element at the passed
     * time.
     * @param curTime - Current time in seconds
     * @param repeatCount - Optional number of repetitions of length 'dur' to
     * do.  Set to Double.NaN to not consider this in the calculation.
     * @param repeatDur - Optional amoun tof time to repeat the animaiton.
     * Set to Double.NaN to not consider this in the calculation.
     */
    protected void evalParametric(AnimationTimeEval state, double curTime, double repeatCount, double repeatDur)
    {
        double begin = (beginTime == null) ? 0 : beginTime.evalTime();
        if (Double.isNaN(begin) || begin > curTime)
        {
            state.set(Double.NaN, 0);
            return;
        }

        double dur = (durTime == null) ? Double.NaN : durTime.evalTime();
        if (Double.isNaN(dur))
        {
            state.set(Double.NaN, 0);
            return;
        }

        //Determine end point of this animation
        double end = (endTime == null) ? Double.NaN : endTime.evalTime();
        double repeat;
//        if (Double.isNaN(repeatDur))
//        {
//            repeatDur = dur;
//        }
        if (Double.isNaN(repeatCount) && Double.isNaN(repeatDur))
        {
            repeat = Double.NaN;
        }
        else
        {
            repeat = Math.min(
                Double.isNaN(repeatCount) ? Double.POSITIVE_INFINITY : dur * repeatCount,
                Double.isNaN(repeatDur) ? Double.POSITIVE_INFINITY : repeatDur);
        }
        if (Double.isNaN(repeat) && Double.isNaN(end))
        {
            //If neither and end point nor a repeat is specified, end point is 
            // implied by duration.
            end = begin + dur;
        }

        double finishTime;
        if (Double.isNaN(end))
        {
            finishTime = begin + repeat;
        }
        else if (Double.isNaN(repeat))
        {
            finishTime = end;
        }
        else
        {
            finishTime = Math.min(end, repeat);
        }
        
        double evalTime = Math.min(curTime, finishTime);
//        if (curTime > finishTime) evalTime = finishTime;
        
        
//        double evalTime = curTime;

//        boolean pastEnd = curTime > evalTime;
        
//        if (!Double.isNaN(end) && curTime > end) { pastEnd = true; evalTime = Math.min(evalTime, end); }
//        if (!Double.isNaN(repeat) && curTime > repeat) { pastEnd = true; evalTime = Math.min(evalTime, repeat); }
        
        double ratio = (evalTime - begin) / dur;
        int rep = (int)ratio;
        double interp = ratio - rep;
        
        //Adjust for roundoff
        if (interp < 0.00001) interp = 0;

//        state.set(interp, rep);
//        if (!pastEnd)
//        {
//            state.set(interp, rep, false);
//            return;
//        }

        //If we are still within the clip, return value
        if (curTime == evalTime)
        {
            state.set(interp, rep);
            return;
        }
        
        //We are past end of clip.  Determine to clamp or ignore.
        switch (fillType)
        {
            default:
            case FT_REMOVE:
            case FT_AUTO:
            case FT_DEFAULT:
                state.set(Double.NaN, rep);
                return;
            case FT_FREEZE:
            case FT_HOLD:
            case FT_TRANSITION:
                state.set(interp == 0 ? 1 : interp, rep);
                return;
        }

    }

    public double evalStartTime()
    {
        return beginTime == null ? Double.NaN : beginTime.evalTime();
    }

    public double evalDurTime()
    {
        return durTime == null ? Double.NaN : durTime.evalTime();
    }

    /**
     * Evaluates the ending time of this element.  Returns 0 if not specified.
     *
     * @see hasEndTime
     */
    public double evalEndTime()
    {
        return endTime == null ? Double.NaN : endTime.evalTime();
    }

    /**
     * Checks to see if an end time has been specified for this element.
     */
    boolean hasEndTime() { return endTime != null; }

    /**
     * Updates all attributes in this diagram associated with a time event.
     * Ie, all attributes with track information.
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime)
    {
        //Animation elements to not change with time
        return false;
    }

    public void rebuild() throws SVGException
    {
        AnimTimeParser animTimeParser = new AnimTimeParser(new StringReader(""""));

        rebuild(animTimeParser);
    }

    protected void rebuild(AnimTimeParser animTimeParser) throws SVGException
    {
        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""begin"")))
        {
            String newVal = sty.getStringValue();
            animTimeParser.ReInit(new StringReader(newVal));
            try {
                this.beginTime = animTimeParser.Expr();
            } catch (ParseException ex) {
                    Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, 
                        ""Could not parse '"" + newVal + ""'"", ex);
            }
        }

        if (getPres(sty.setName(""dur"")))
        {
            String newVal = sty.getStringValue();
            animTimeParser.ReInit(new StringReader(newVal));
            try {
                this.durTime = animTimeParser.Expr();
            } catch (ParseException ex) {
                    Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, 
                        ""Could not parse '"" + newVal + ""'"", ex);
            }
        }

        if (getPres(sty.setName(""end"")))
        {
            String newVal = sty.getStringValue();
            animTimeParser.ReInit(new StringReader(newVal));
            try {
                this.endTime = animTimeParser.Expr();
            } catch (ParseException ex) {
                Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, 
                    ""Could not parse '"" + newVal + ""'"", ex);
            }
        }

        if (getPres(sty.setName(""fill"")))
        {
            String newVal = sty.getStringValue();
            if (newVal.equals(""remove"")) this.fillType = FT_REMOVE;
            if (newVal.equals(""freeze"")) this.fillType = FT_FREEZE;
            if (newVal.equals(""hold"")) this.fillType = FT_HOLD;
            if (newVal.equals(""transiton"")) this.fillType = FT_TRANSITION;
            if (newVal.equals(""auto"")) this.fillType = FT_AUTO;
            if (newVal.equals(""default"")) this.fillType = FT_DEFAULT;
        }

        if (getPres(sty.setName(""additive"")))
        {
            String newVal = sty.getStringValue();
            if (newVal.equals(""replace"")) this.additiveType = AD_REPLACE;
            if (newVal.equals(""sum"")) this.additiveType = AD_SUM;
        }

        if (getPres(sty.setName(""accumulate"")))
        {
            String newVal = sty.getStringValue();
            if (newVal.equals(""replace"")) this.accumulateType = AC_REPLACE;
            if (newVal.equals(""sum"")) this.accumulateType = AC_SUM;
        }

    }
}
"
AnimationTimeEval.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 21, 2004, 1:31 PM
 */

package com.kitfox.svg.animation;

/**
 *
 * @author  kitfox
 */
public class AnimationTimeEval
{
    /**
     * Value on [0..1] representing the interpolation value of queried animation
     * element, or Double.NaN if element does not provide a valid evalutaion
     */
    public double interp;
    
    /**
     * Number of completed repetitions
     */
    public int rep;
    
    /**
     * True if this evaluation is in a frozen state; ie, past the end of the
     * track and held in the ""freeze"" state.
     */
//    public boolean pastEnd;
    
    /** Creates a new instance of AnimateTimeEval */
    public AnimationTimeEval()
    {
    }
    
//    public void set(double interp, int rep, boolean pastEnd)
    public void set(double interp, int rep)
    {
        this.interp = interp;
        this.rep = rep;
//        this.pastEnd = pastEnd;
    }
}
"
Bezier.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 14, 2005, 4:08 AM
 */

package com.kitfox.svg.animation;

import java.awt.geom.Point2D;
import java.util.Arrays;

/**
 * http://mathworld.wolfram.com/BezierCurve.html
 * @author kitfox
 */
public class Bezier
{
    public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(coord);
		long temp;
		temp = Double.doubleToLongBits(length);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		return result;
	}

	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Bezier other = (Bezier) obj;
		if (!Arrays.equals(coord, other.coord))
			return false;
		if (Double.doubleToLongBits(length) != Double.doubleToLongBits(other.length))
			return false;
		return true;
	}



	double length;
    double[] coord;
    
    public double[] getCoord() {
    	return coord;
    }

    public Bezier(double sx, double sy, double[] coords, int numCoords)
    {
        setCoords(sx, sy, coords, numCoords);
    }
    
    public void setCoords(double sx, double sy, double[] coords, int numCoords)
    {
        coord = new double[numCoords * 2 + 2];
        coord[0] = sx;
        coord[1] = sy;
        for (int i = 0; i < numCoords; i++)
        {
            coord[i * 2 + 2] = coords[i * 2];
            coord[i * 2 + 3] = coords[i * 2 + 1];
        }
        
        calcLength();        
    }
    
    /**
     * Retuns aproximation of the length of the bezier
     */
    public double getLength()
    {
        return length;
    }
    
    private void calcLength()
    {
        length = 0;
        for (int i = 2; i < coord.length; i += 2)
        {
            length += lineLength(coord[i - 2], coord[i - 1], coord[i], coord[i + 1]);
        }
    }
    
    private double lineLength(double x1, double y1, double x2, double y2)
    {
        double dx = x2 - x1, dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    public Point2D.Double getFinalPoint(Point2D.Double point)
    {
        point.x = coord[coord.length - 2];
        point.y = coord[coord.length - 1];
        return point;
    }
    
    public Point2D.Double eval(double param, Point2D.Double point)
    {
        point.x = 0;
        point.y = 0;
        int numKnots = coord.length / 2;
        
        for (int i = 0; i < numKnots; i++)
        {
            double scale = bernstein(numKnots - 1, i, param);
            point.x += coord[i * 2] * scale;
            point.y += coord[i * 2 + 1] * scale;
        }
        
        return point;
    }
    
    /**
     * Calculates the bernstein polynomial for evaluating parametric bezier
     * @param numKnots - one less than number of knots in this curve hull
     * @param knotNo - knot we are evaluating Bernstein for
     * @param param - Parametric value we are evaluating at
     */
    private double bernstein(int numKnots, int knotNo, double param)
    {
        double iParam = 1 - param;
        //Faster evaluation for easy cases:
        switch (numKnots)
        {
            case 0:
                return 1;
            case 1:
            {
                switch (knotNo)
                {
                    case 0:
                        return iParam;
                    case 1:
                        return param;
                }
                break;
            }
            case 2:
            {
                switch (knotNo)
                {
                    case 0:
                        return iParam * iParam;
                    case 1:
                        return 2 * iParam * param;
                    case 2:
                        return param * param;
                }
                break;
            }
            case 3:
            {
                switch (knotNo)
                {
                    case 0:
                        return iParam * iParam * iParam;
                    case 1:
                        return 3 * iParam * iParam * param;
                    case 2:
                        return 3 * iParam * param * param;
                    case 3:
                        return param * param * param;
                }
                break;
            }
        }
        
        //If this bezier has more than four points, calculate bernstein the hard way
        double retVal = 1;
        for (int i = 0; i < knotNo; i++)
        {
            retVal *= param;
        }
        for (int i = 0; i < numKnots - knotNo; i++)
        {
            retVal *= iParam;
        }
        retVal *= choose(numKnots, knotNo);
        
        return retVal;
    }
    
    
    
    private int choose(int num, int denom)
    {
        int denom2 = num - denom;
        if (denom < denom2)
        {
            int tmp = denom;
            denom = denom2;
            denom2 = tmp;
        }
        
        int prod = 1;
        for (int i = num; i > denom; i--)
        {
            prod *= num;
        }
        
        for (int i = 2; i <= denom2; i++)
        {
            prod /= i;
        }
        
        return prod;
    }
}
"
AnimTimeParser.java,kitfox-6.9.6,"/* Generated By:JJTree&JavaCC: Do not edit this line. AnimTimeParser.java */
package com.kitfox.svg.animation.parser;

import com.kitfox.svg.SVGConst;
import com.kitfox.svg.animation.TimeBase;
import com.kitfox.svg.animation.TimeCompound;
import com.kitfox.svg.animation.TimeDiscrete;
import com.kitfox.svg.animation.TimeIndefinite;
import com.kitfox.svg.animation.TimeLookup;
import com.kitfox.svg.animation.TimeSum;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

public class AnimTimeParser/*@bgen(jjtree)*/implements AnimTimeParserTreeConstants, AnimTimeParserConstants {/*@bgen(jjtree)*/
  protected JJTAnimTimeParserState jjtree = new JJTAnimTimeParserState();/**
     * Test the parser
     */
    public static void main(String args[]) throws ParseException
    {
//        AnimTimeParser parser = new AnimTimeParser(System.in);
        StringReader reader;

        reader = new StringReader(""1:30 + 5ms"");
        AnimTimeParser parser = new AnimTimeParser(reader);
        TimeBase tc;

        tc = parser.Expr();
        System.err.println(""AnimTimeParser eval to "" + tc.evalTime());

        reader = new StringReader(""19"");
        parser.ReInit(reader);
        tc = parser.Expr();
        System.err.println(""AnimTimeParser eval to "" + tc.evalTime());
    }

/**
 * Expression structure
 */
  final public TimeBase Expr() throws ParseException {
 /*@bgen(jjtree) Expr */
    ASTExpr jjtn000 = new ASTExpr(JJTEXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);TimeBase term;
    ArrayList list = new ArrayList();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
      case FLOAT:
      case INDEFINITE:
      case MOUSE_OVER:
      case WHEN_NOT_ACTIVE:
      case IDENTIFIER:
        term = Sum();
            list.add(term);
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      label_1:
      while (true) {
        if (jj_2_1(2)) {
          ;
        } else {
          break label_1;
        }
        jj_consume_token(15);
        term = Sum();
            list.add(term);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 15:
        jj_consume_token(15);
        break;
      default:
        jj_la1[1] = jj_gen;
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        switch (list.size())
        {
            case 0:
                {if (true) return new TimeIndefinite();}
            case 1:
                {if (true) return (TimeBase)list.get(0);}
            default:
                {if (true) return new TimeCompound(list);}
        }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error(""Missing return statement in function"");
  }

  final public TimeBase Sum() throws ParseException {
 /*@bgen(jjtree) Sum */
    ASTSum jjtn000 = new ASTSum(JJTSUM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t = null;
    TimeBase t1;
    TimeBase t2 = null;
    try {
      t1 = Term();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 16:
      case 17:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 16:
          t = jj_consume_token(16);
          break;
        case 17:
          t = jj_consume_token(17);
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        t2 = Term();
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            if (t2 == null) {if (true) return t1;}

            if (t.image.equals(""-""))
            {
                {if (true) return new TimeSum(t1, t2, false);}
            }
            else
            {
                {if (true) return new TimeSum(t1, t2, true);}
            }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error(""Missing return statement in function"");
  }

  final public TimeBase Term() throws ParseException {
 /*@bgen(jjtree) Term */
    ASTTerm jjtn000 = new ASTTerm(JJTTERM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);TimeBase base;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INDEFINITE:
        base = IndefiniteTime();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return base;}
        break;
      case INTEGER:
      case FLOAT:
        base = LiteralTime();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return base;}
        break;
      case IDENTIFIER:
        base = LookupTime();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return base;}
        break;
      case MOUSE_OVER:
      case WHEN_NOT_ACTIVE:
        base = EventTime();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return base;}
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error(""Missing return statement in function"");
  }

  final public TimeIndefinite IndefiniteTime() throws ParseException {
 /*@bgen(jjtree) IndefiniteTime */
  ASTIndefiniteTime jjtn000 = new ASTIndefiniteTime(JJTINDEFINITETIME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(INDEFINITE);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        {if (true) return new TimeIndefinite();}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error(""Missing return statement in function"");
  }

  final public TimeDiscrete EventTime() throws ParseException {
 /*@bgen(jjtree) EventTime */
  ASTEventTime jjtn000 = new ASTEventTime(JJTEVENTTIME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MOUSE_OVER:
        jj_consume_token(MOUSE_OVER);
        break;
      case WHEN_NOT_ACTIVE:
        jj_consume_token(WHEN_NOT_ACTIVE);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            //For now, map all events to the zero time
            {if (true) return new TimeDiscrete(0);}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error(""Missing return statement in function"");
  }

  final public TimeDiscrete LiteralTime() throws ParseException {
 /*@bgen(jjtree) LiteralTime */
    ASTLiteralTime jjtn000 = new ASTLiteralTime(JJTLITERALTIME);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);double t1, t2, t3 = Double.NaN, value;
    Token t;
    try {
      t1 = Number();
            value = t1;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNITS:
      case 18:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 18:
          jj_consume_token(18);
          t2 = Number();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 18:
            jj_consume_token(18);
            t3 = Number();
            break;
          default:
            jj_la1[6] = jj_gen;
            ;
          }
            //Return clock time format (convert to seconds)
            if (Double.isNaN(t3))
            {
                value = t1 * 60 + t2;
            }
            else
            {
                value = t1 * 3600 + t2 * 60 + t3;
            }
          break;
        case UNITS:
          t = jj_consume_token(UNITS);
            //Return units format (convert to seconds)
            if (t.image.equals(""ms"")) value = t1 / 1000;
            if (t.image.equals(""min"")) value = t1 * 60;
            if (t.image.equals(""h"")) value = t1 * 3600;
          break;
        default:
          jj_la1[7] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        {if (true) return new TimeDiscrete(value);}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error(""Missing return statement in function"");
  }

  final public TimeLookup LookupTime() throws ParseException {
 /*@bgen(jjtree) LookupTime */
    ASTLookupTime jjtn000 = new ASTLookupTime(JJTLOOKUPTIME);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);double paramNum = 0.0;
    Token node, event;
    try {
      node = jj_consume_token(IDENTIFIER);
      jj_consume_token(19);
      event = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 20:
        paramNum = ParamList();
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        {if (true) return new TimeLookup(null, node.image, event.image, """" + paramNum);}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error(""Missing return statement in function"");
  }

  final public double ParamList() throws ParseException {
 /*@bgen(jjtree) ParamList */
    ASTParamList jjtn000 = new ASTParamList(JJTPARAMLIST);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);double num;
    try {
      jj_consume_token(20);
      num = Number();
      jj_consume_token(21);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        {if (true) return num;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error(""Missing return statement in function"");
  }

  final public double Number() throws ParseException {
 /*@bgen(jjtree) Number */
    ASTNumber jjtn000 = new ASTNumber(JJTNUMBER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOAT:
        t = jj_consume_token(FLOAT);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        try {
            {if (true) return Double.parseDouble(t.image);}
        }
        catch (Exception e) {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Could not parse double '"" + t.image + ""'"", e);
        }

        {if (true) return 0.0;}
        break;
      case INTEGER:
        t = jj_consume_token(INTEGER);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        try {
            {if (true) return Double.parseDouble(t.image);}
        }
        catch (Exception e) {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Could not parse double '"" + t.image + ""'"", e);
        }

        {if (true) return 0.0;}
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error(""Missing return statement in function"");
  }

  final public int Integer() throws ParseException {
 /*@bgen(jjtree) Integer */
    ASTInteger jjtn000 = new ASTInteger(JJTINTEGER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(INTEGER);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        try {
            {if (true) return Integer.parseInt(t.image);}
        }
        catch (Exception e) {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Could not parse int '"" + t.image + ""'"", e);
        }

        {if (true) return 0;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error(""Missing return statement in function"");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_3R_10() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_13() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  private boolean jj_3R_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) return true;
    }
    return false;
  }

  private boolean jj_3R_7() {
    if (jj_3R_11()) return true;
    return false;
  }

  private boolean jj_3R_6() {
    if (jj_3R_10()) return true;
    return false;
  }

  private boolean jj_3R_5() {
    if (jj_3R_9()) return true;
    return false;
  }

  private boolean jj_3R_2() {
    if (jj_3R_3()) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(15)) return true;
    if (jj_3R_2()) return true;
    return false;
  }

  private boolean jj_3R_3() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_4()) {
    jj_scanpos = xsp;
    if (jj_3R_5()) {
    jj_scanpos = xsp;
    if (jj_3R_6()) {
    jj_scanpos = xsp;
    if (jj_3R_7()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_4() {
    if (jj_3R_8()) return true;
    return false;
  }

  private boolean jj_3R_14() {
    if (jj_scan_token(INTEGER)) return true;
    return false;
  }

  private boolean jj_3R_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(11)) {
    jj_scanpos = xsp;
    if (jj_scan_token(12)) return true;
    }
    return false;
  }

  private boolean jj_3R_8() {
    if (jj_scan_token(INDEFINITE)) return true;
    return false;
  }

  private boolean jj_3R_9() {
    if (jj_3R_12()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public AnimTimeParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[11];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x5f00,0x8000,0x30000,0x30000,0x5f00,0x1800,0x40000,0x42000,0x42000,0x100000,0x300,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[1];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public AnimTimeParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public AnimTimeParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new AnimTimeParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public AnimTimeParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AnimTimeParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public AnimTimeParser(AnimTimeParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(AnimTimeParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[22];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 11; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 22; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 1; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
"
AnimTimeParserConstants.java,kitfox-6.9.6,"/* Generated By:JJTree&JavaCC: Do not edit this line. AnimTimeParserConstants.java */
package com.kitfox.svg.animation.parser;


/**
 * Token literal values and constants.
 * Generated by org.javacc.parser.OtherFilesGen#start()
 */
public interface AnimTimeParserConstants {

  /** End of File. */
  int EOF = 0;
  /** RegularExpression Id. */
  int LETTER = 6;
  /** RegularExpression Id. */
  int DIGIT = 7;
  /** RegularExpression Id. */
  int INTEGER = 8;
  /** RegularExpression Id. */
  int FLOAT = 9;
  /** RegularExpression Id. */
  int INDEFINITE = 10;
  /** RegularExpression Id. */
  int MOUSE_OVER = 11;
  /** RegularExpression Id. */
  int WHEN_NOT_ACTIVE = 12;
  /** RegularExpression Id. */
  int UNITS = 13;
  /** RegularExpression Id. */
  int IDENTIFIER = 14;

  /** Lexical state. */
  int DEFAULT = 0;

  /** Literal token values. */
  String[] tokenImage = {
    ""<EOF>"",
    ""\"" \"""",
    ""\""\\t\"""",
    ""\""\\n\"""",
    ""\""\\r\"""",
    ""\""\\f\"""",
    ""<LETTER>"",
    ""<DIGIT>"",
    ""<INTEGER>"",
    ""<FLOAT>"",
    ""\""indefinite\"""",
    ""\""mouseover\"""",
    ""\""whenNotActive\"""",
    ""<UNITS>"",
    ""<IDENTIFIER>"",
    ""\"";\"""",
    ""\""+\"""",
    ""\""-\"""",
    ""\"":\"""",
    ""\"".\"""",
    ""\""(\"""",
    ""\"")\"""",
  };

}
"
AnimTimeParserTokenManager.java,kitfox-6.9.6,"/* Generated By:JJTree&JavaCC: Do not edit this line. AnimTimeParserTokenManager.java */
package com.kitfox.svg.animation.parser;
import com.kitfox.svg.SVGConst;
import com.kitfox.svg.animation.TimeBase;
import com.kitfox.svg.animation.TimeCompound;
import com.kitfox.svg.animation.TimeDiscrete;
import com.kitfox.svg.animation.TimeIndefinite;
import com.kitfox.svg.animation.TimeLookup;
import com.kitfox.svg.animation.TimeSum;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

/** Token Manager. */
public class AnimTimeParserTokenManager implements AnimTimeParserConstants
{

  /** Debug output. */
  public  java.io.PrintStream debugStream = System.out;
  /** Set debug output. */
  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
private final int jjStopStringLiteralDfa_0(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x30000L) != 0L)
            return 6;
         if ((active0 & 0x80000L) != 0L)
            return 2;
         if ((active0 & 0x1400L) != 0L)
         {
            jjmatchedKind = 14;
            return 11;
         }
         if ((active0 & 0x800L) != 0L)
         {
            jjmatchedKind = 14;
            return 13;
         }
         return -1;
      case 1:
         if ((active0 & 0x1c00L) != 0L)
         {
            jjmatchedKind = 14;
            jjmatchedPos = 1;
            return 11;
         }
         return -1;
      case 2:
         if ((active0 & 0x1c00L) != 0L)
         {
            jjmatchedKind = 14;
            jjmatchedPos = 2;
            return 11;
         }
         return -1;
      case 3:
         if ((active0 & 0x1c00L) != 0L)
         {
            jjmatchedKind = 14;
            jjmatchedPos = 3;
            return 11;
         }
         return -1;
      case 4:
         if ((active0 & 0x1c00L) != 0L)
         {
            jjmatchedKind = 14;
            jjmatchedPos = 4;
            return 11;
         }
         return -1;
      case 5:
         if ((active0 & 0x1c00L) != 0L)
         {
            jjmatchedKind = 14;
            jjmatchedPos = 5;
            return 11;
         }
         return -1;
      case 6:
         if ((active0 & 0x1c00L) != 0L)
         {
            jjmatchedKind = 14;
            jjmatchedPos = 6;
            return 11;
         }
         return -1;
      case 7:
         if ((active0 & 0x1c00L) != 0L)
         {
            jjmatchedKind = 14;
            jjmatchedPos = 7;
            return 11;
         }
         return -1;
      case 8:
         if ((active0 & 0x800L) != 0L)
            return 11;
         if ((active0 & 0x1400L) != 0L)
         {
            jjmatchedKind = 14;
            jjmatchedPos = 8;
            return 11;
         }
         return -1;
      case 9:
         if ((active0 & 0x1000L) != 0L)
         {
            jjmatchedKind = 14;
            jjmatchedPos = 9;
            return 11;
         }
         if ((active0 & 0x400L) != 0L)
            return 11;
         return -1;
      case 10:
         if ((active0 & 0x1000L) != 0L)
         {
            jjmatchedKind = 14;
            jjmatchedPos = 10;
            return 11;
         }
         return -1;
      case 11:
         if ((active0 & 0x1000L) != 0L)
         {
            jjmatchedKind = 14;
            jjmatchedPos = 11;
            return 11;
         }
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_0(int pos, long active0)
{
   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
}
private int jjStopAtPos(int pos, int kind)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   return pos + 1;
}
private int jjMoveStringLiteralDfa0_0()
{
   switch(curChar)
   {
      case 40:
         return jjStopAtPos(0, 20);
      case 41:
         return jjStopAtPos(0, 21);
      case 43:
         return jjStartNfaWithStates_0(0, 16, 6);
      case 45:
         return jjStartNfaWithStates_0(0, 17, 6);
      case 46:
         return jjStartNfaWithStates_0(0, 19, 2);
      case 58:
         return jjStopAtPos(0, 18);
      case 59:
         return jjStopAtPos(0, 15);
      case 105:
         return jjMoveStringLiteralDfa1_0(0x400L);
      case 109:
         return jjMoveStringLiteralDfa1_0(0x800L);
      case 119:
         return jjMoveStringLiteralDfa1_0(0x1000L);
      default :
         return jjMoveNfa_0(0, 0);
   }
}
private int jjMoveStringLiteralDfa1_0(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 104:
         return jjMoveStringLiteralDfa2_0(active0, 0x1000L);
      case 110:
         return jjMoveStringLiteralDfa2_0(active0, 0x400L);
      case 111:
         return jjMoveStringLiteralDfa2_0(active0, 0x800L);
      default :
         break;
   }
   return jjStartNfa_0(0, active0);
}
private int jjMoveStringLiteralDfa2_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(0, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(1, active0);
      return 2;
   }
   switch(curChar)
   {
      case 100:
         return jjMoveStringLiteralDfa3_0(active0, 0x400L);
      case 101:
         return jjMoveStringLiteralDfa3_0(active0, 0x1000L);
      case 117:
         return jjMoveStringLiteralDfa3_0(active0, 0x800L);
      default :
         break;
   }
   return jjStartNfa_0(1, active0);
}
private int jjMoveStringLiteralDfa3_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(1, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(2, active0);
      return 3;
   }
   switch(curChar)
   {
      case 101:
         return jjMoveStringLiteralDfa4_0(active0, 0x400L);
      case 110:
         return jjMoveStringLiteralDfa4_0(active0, 0x1000L);
      case 115:
         return jjMoveStringLiteralDfa4_0(active0, 0x800L);
      default :
         break;
   }
   return jjStartNfa_0(2, active0);
}
private int jjMoveStringLiteralDfa4_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(2, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(3, active0);
      return 4;
   }
   switch(curChar)
   {
      case 78:
         return jjMoveStringLiteralDfa5_0(active0, 0x1000L);
      case 101:
         return jjMoveStringLiteralDfa5_0(active0, 0x800L);
      case 102:
         return jjMoveStringLiteralDfa5_0(active0, 0x400L);
      default :
         break;
   }
   return jjStartNfa_0(3, active0);
}
private int jjMoveStringLiteralDfa5_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(3, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(4, active0);
      return 5;
   }
   switch(curChar)
   {
      case 105:
         return jjMoveStringLiteralDfa6_0(active0, 0x400L);
      case 111:
         return jjMoveStringLiteralDfa6_0(active0, 0x1800L);
      default :
         break;
   }
   return jjStartNfa_0(4, active0);
}
private int jjMoveStringLiteralDfa6_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(4, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(5, active0);
      return 6;
   }
   switch(curChar)
   {
      case 110:
         return jjMoveStringLiteralDfa7_0(active0, 0x400L);
      case 116:
         return jjMoveStringLiteralDfa7_0(active0, 0x1000L);
      case 118:
         return jjMoveStringLiteralDfa7_0(active0, 0x800L);
      default :
         break;
   }
   return jjStartNfa_0(5, active0);
}
private int jjMoveStringLiteralDfa7_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(5, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(6, active0);
      return 7;
   }
   switch(curChar)
   {
      case 65:
         return jjMoveStringLiteralDfa8_0(active0, 0x1000L);
      case 101:
         return jjMoveStringLiteralDfa8_0(active0, 0x800L);
      case 105:
         return jjMoveStringLiteralDfa8_0(active0, 0x400L);
      default :
         break;
   }
   return jjStartNfa_0(6, active0);
}
private int jjMoveStringLiteralDfa8_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(6, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(7, active0);
      return 8;
   }
   switch(curChar)
   {
      case 99:
         return jjMoveStringLiteralDfa9_0(active0, 0x1000L);
      case 114:
         if ((active0 & 0x800L) != 0L)
            return jjStartNfaWithStates_0(8, 11, 11);
         break;
      case 116:
         return jjMoveStringLiteralDfa9_0(active0, 0x400L);
      default :
         break;
   }
   return jjStartNfa_0(7, active0);
}
private int jjMoveStringLiteralDfa9_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(7, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(8, active0);
      return 9;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x400L) != 0L)
            return jjStartNfaWithStates_0(9, 10, 11);
         break;
      case 116:
         return jjMoveStringLiteralDfa10_0(active0, 0x1000L);
      default :
         break;
   }
   return jjStartNfa_0(8, active0);
}
private int jjMoveStringLiteralDfa10_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(8, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(9, active0);
      return 10;
   }
   switch(curChar)
   {
      case 105:
         return jjMoveStringLiteralDfa11_0(active0, 0x1000L);
      default :
         break;
   }
   return jjStartNfa_0(9, active0);
}
private int jjMoveStringLiteralDfa11_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(9, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(10, active0);
      return 11;
   }
   switch(curChar)
   {
      case 118:
         return jjMoveStringLiteralDfa12_0(active0, 0x1000L);
      default :
         break;
   }
   return jjStartNfa_0(10, active0);
}
private int jjMoveStringLiteralDfa12_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(10, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(11, active0);
      return 12;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x1000L) != 0L)
            return jjStartNfaWithStates_0(12, 12, 11);
         break;
      default :
         break;
   }
   return jjStartNfa_0(11, active0);
}
private int jjStartNfaWithStates_0(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_0(state, pos + 1);
}
private int jjMoveNfa_0(int startState, int curPos)
{
   int startsAt = 0;
   jjnewStateCnt = 18;
   int i = 1;
   jjstateSet[0] = startState;
   int kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         do
         {
            switch(jjstateSet[--i])
            {
               case 6:
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 9)
                        kind = 9;
                     jjCheckNAddStates(0, 3);
                  }
                  else if (curChar == 46)
                     jjCheckNAdd(2);
                  break;
               case 13:
               case 11:
                  if ((0x3ff200000000000L & l) == 0L)
                     break;
                  if (kind > 14)
                     kind = 14;
                  jjCheckNAdd(11);
                  break;
               case 0:
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 8)
                        kind = 8;
                     jjCheckNAddStates(4, 8);
                  }
                  else if ((0x280000000000L & l) != 0L)
                     jjCheckNAddTwoStates(1, 6);
                  else if (curChar == 46)
                     jjCheckNAdd(2);
                  break;
               case 1:
                  if (curChar == 46)
                     jjCheckNAdd(2);
                  break;
               case 2:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAddTwoStates(2, 3);
                  break;
               case 4:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(5);
                  break;
               case 5:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAdd(5);
                  break;
               case 7:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(7, 1);
                  break;
               case 8:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 9)
                     kind = 9;
                  jjCheckNAddTwoStates(8, 3);
                  break;
               case 16:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 8)
                     kind = 8;
                  jjCheckNAddStates(4, 8);
                  break;
               case 17:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 8)
                     kind = 8;
                  jjCheckNAdd(17);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 13:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 14)
                        kind = 14;
                     jjCheckNAdd(11);
                  }
                  if (curChar == 105)
                     jjstateSet[jjnewStateCnt++] = 14;
                  else if (curChar == 115)
                  {
                     if (kind > 13)
                        kind = 13;
                  }
                  break;
               case 0:
                  if ((0x7fffffe07fffffeL & l) != 0L)
                  {
                     if (kind > 14)
                        kind = 14;
                     jjCheckNAdd(11);
                  }
                  if ((0x8010000000000L & l) != 0L)
                  {
                     if (kind > 13)
                        kind = 13;
                  }
                  else if (curChar == 109)
                     jjAddStates(9, 10);
                  break;
               case 3:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(11, 12);
                  break;
               case 9:
                  if ((0x8010000000000L & l) != 0L && kind > 13)
                     kind = 13;
                  break;
               case 10:
                  if ((0x7fffffe07fffffeL & l) == 0L)
                     break;
                  if (kind > 14)
                     kind = 14;
                  jjCheckNAdd(11);
                  break;
               case 11:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 14)
                     kind = 14;
                  jjCheckNAdd(11);
                  break;
               case 12:
                  if (curChar == 109)
                     jjAddStates(9, 10);
                  break;
               case 14:
                  if (curChar == 110 && kind > 13)
                     kind = 13;
                  break;
               case 15:
                  if (curChar == 105)
                     jjstateSet[jjnewStateCnt++] = 14;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 18 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
static final int[] jjnextStates = {
   7, 1, 8, 3, 17, 7, 1, 8, 3, 13, 15, 4, 5, 
};

/** Token literal values. */
public static final String[] jjstrLiteralImages = {
"""", null, null, null, null, null, null, null, null, null, 
""\151\156\144\145\146\151\156\151\164\145"", ""\155\157\165\163\145\157\166\145\162"", 
""\167\150\145\156\116\157\164\101\143\164\151\166\145"", null, null, ""\73"", ""\53"", ""\55"", ""\72"", ""\56"", ""\50"", ""\51"", };

/** Lexer state names. */
public static final String[] lexStateNames = {
   ""DEFAULT"",
};
static final long[] jjtoToken = {
   0x3fff01L, 
};
static final long[] jjtoSkip = {
   0x3eL, 
};
protected SimpleCharStream input_stream;
private final int[] jjrounds = new int[18];
private final int[] jjstateSet = new int[36];
protected char curChar;
/** Constructor. */
public AnimTimeParserTokenManager(SimpleCharStream stream){
   if (SimpleCharStream.staticFlag)
      throw new Error(""ERROR: Cannot use a static CharStream class with a non-static lexical analyzer."");
   input_stream = stream;
}

/** Constructor. */
public AnimTimeParserTokenManager(SimpleCharStream stream, int lexState){
   this(stream);
   SwitchTo(lexState);
}

/** Reinitialise parser. */
public void ReInit(SimpleCharStream stream)
{
   jjmatchedPos = jjnewStateCnt = 0;
   curLexState = defaultLexState;
   input_stream = stream;
   ReInitRounds();
}
private void ReInitRounds()
{
   int i;
   jjround = 0x80000001;
   for (i = 18; i-- > 0;)
      jjrounds[i] = 0x80000000;
}

/** Reinitialise parser. */
public void ReInit(SimpleCharStream stream, int lexState)
{
   ReInit(stream);
   SwitchTo(lexState);
}

/** Switch to specified lex state. */
public void SwitchTo(int lexState)
{
   if (lexState >= 1 || lexState < 0)
      throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
   else
      curLexState = lexState;
}

protected Token jjFillToken()
{
   final Token t;
   final String curTokenImage;
   final int beginLine;
   final int endLine;
   final int beginColumn;
   final int endColumn;
   String im = jjstrLiteralImages[jjmatchedKind];
   curTokenImage = (im == null) ? input_stream.GetImage() : im;
   beginLine = input_stream.getBeginLine();
   beginColumn = input_stream.getBeginColumn();
   endLine = input_stream.getEndLine();
   endColumn = input_stream.getEndColumn();
   t = Token.newToken(jjmatchedKind, curTokenImage);

   t.beginLine = beginLine;
   t.endLine = endLine;
   t.beginColumn = beginColumn;
   t.endColumn = endColumn;

   return t;
}

int curLexState = 0;
int defaultLexState = 0;
int jjnewStateCnt;
int jjround;
int jjmatchedPos;
int jjmatchedKind;

/** Get the next Token. */
public Token getNextToken() 
{
  Token matchedToken;
  int curPos = 0;

  EOFLoop :
  for (;;)
  {
   try
   {
      curChar = input_stream.BeginToken();
   }
   catch(java.io.IOException e)
   {
      jjmatchedKind = 0;
      matchedToken = jjFillToken();
      return matchedToken;
   }

   try { input_stream.backup(0);
      while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L)
         curChar = input_stream.BeginToken();
   }
   catch (java.io.IOException e1) { continue EOFLoop; }
   jjmatchedKind = 0x7fffffff;
   jjmatchedPos = 0;
   curPos = jjMoveStringLiteralDfa0_0();
   if (jjmatchedKind != 0x7fffffff)
   {
      if (jjmatchedPos + 1 < curPos)
         input_stream.backup(curPos - jjmatchedPos - 1);
      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
      {
         matchedToken = jjFillToken();
         return matchedToken;
      }
      else
      {
         continue EOFLoop;
      }
   }
   int error_line = input_stream.getEndLine();
   int error_column = input_stream.getEndColumn();
   String error_after = null;
   boolean EOFSeen = false;
   try { input_stream.readChar(); input_stream.backup(1); }
   catch (java.io.IOException e1) {
      EOFSeen = true;
      error_after = curPos <= 1 ? """" : input_stream.GetImage();
      if (curChar == '\n' || curChar == '\r') {
         error_line++;
         error_column = 0;
      }
      else
         error_column++;
   }
   if (!EOFSeen) {
      input_stream.backup(1);
      error_after = curPos <= 1 ? """" : input_stream.GetImage();
   }
   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
  }
}

private void jjCheckNAdd(int state)
{
   if (jjrounds[state] != jjround)
   {
      jjstateSet[jjnewStateCnt++] = state;
      jjrounds[state] = jjround;
   }
}
private void jjAddStates(int start, int end)
{
   do {
      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
   } while (start++ != end);
}
private void jjCheckNAddTwoStates(int state1, int state2)
{
   jjCheckNAdd(state1);
   jjCheckNAdd(state2);
}

private void jjCheckNAddStates(int start, int end)
{
   do {
      jjCheckNAdd(jjnextStates[start]);
   } while (start++ != end);
}

}
"
AnimTimeParserTreeConstants.java,kitfox-6.9.6,"/* Generated By:JavaCC: Do not edit this line. AnimTimeParserTreeConstants.java Version 5.0 */
package com.kitfox.svg.animation.parser;

public interface AnimTimeParserTreeConstants
{
  public int JJTEXPR = 0;
  public int JJTSUM = 1;
  public int JJTTERM = 2;
  public int JJTINDEFINITETIME = 3;
  public int JJTEVENTTIME = 4;
  public int JJTLITERALTIME = 5;
  public int JJTLOOKUPTIME = 6;
  public int JJTPARAMLIST = 7;
  public int JJTNUMBER = 8;
  public int JJTINTEGER = 9;


  public String[] jjtNodeName = {
    ""Expr"",
    ""Sum"",
    ""Term"",
    ""IndefiniteTime"",
    ""EventTime"",
    ""LiteralTime"",
    ""LookupTime"",
    ""ParamList"",
    ""Number"",
    ""Integer"",
  };
}
/* JavaCC - OriginalChecksum=f9b612888b81922f0418b890bad7527d (do not edit this line) */
"
ASTEventTime.java,kitfox-6.9.6,"/* Generated By:JJTree: Do not edit this line. ASTEventTime.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

public
class ASTEventTime extends SimpleNode {
  public ASTEventTime(int id) {
    super(id);
  }

  public ASTEventTime(AnimTimeParser p, int id) {
    super(p, id);
  }

}
/* JavaCC - OriginalChecksum=87793ac7764e55d18e5a52ec210e51c2 (do not edit this line) */
"
ASTExpr.java,kitfox-6.9.6,"/* Generated By:JJTree: Do not edit this line. ASTExpr.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

public
class ASTExpr extends SimpleNode {
  public ASTExpr(int id) {
    super(id);
  }

  public ASTExpr(AnimTimeParser p, int id) {
    super(p, id);
  }

}
/* JavaCC - OriginalChecksum=709e0d187650948e5ab5e2b863f66372 (do not edit this line) */
"
ASTIndefiniteTime.java,kitfox-6.9.6,"/* Generated By:JJTree: Do not edit this line. ASTIndefiniteTime.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

public
class ASTIndefiniteTime extends SimpleNode {
  public ASTIndefiniteTime(int id) {
    super(id);
  }

  public ASTIndefiniteTime(AnimTimeParser p, int id) {
    super(p, id);
  }

}
/* JavaCC - OriginalChecksum=8e9adeaf8df3cf8e58c23a73542164e1 (do not edit this line) */
"
ASTInteger.java,kitfox-6.9.6,"/* Generated By:JJTree: Do not edit this line. ASTInteger.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

public
class ASTInteger extends SimpleNode {
  public ASTInteger(int id) {
    super(id);
  }

  public ASTInteger(AnimTimeParser p, int id) {
    super(p, id);
  }

}
/* JavaCC - OriginalChecksum=69d8fe38aaee89aad552c236d002f91c (do not edit this line) */
"
ASTLiteralTime.java,kitfox-6.9.6,"/* Generated By:JJTree: Do not edit this line. ASTLiteralTime.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

public
class ASTLiteralTime extends SimpleNode {
  public ASTLiteralTime(int id) {
    super(id);
  }

  public ASTLiteralTime(AnimTimeParser p, int id) {
    super(p, id);
  }

}
/* JavaCC - OriginalChecksum=e835e7b1897f635ba59b840fc50ca1a4 (do not edit this line) */
"
ASTLookupTime.java,kitfox-6.9.6,"/* Generated By:JJTree: Do not edit this line. ASTLookupTime.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

public
class ASTLookupTime extends SimpleNode {
  public ASTLookupTime(int id) {
    super(id);
  }

  public ASTLookupTime(AnimTimeParser p, int id) {
    super(p, id);
  }

}
/* JavaCC - OriginalChecksum=388e762dd7d67479f8f900bac51accbf (do not edit this line) */
"
ASTNumber.java,kitfox-6.9.6,"/* Generated By:JJTree: Do not edit this line. ASTNumber.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

public
class ASTNumber extends SimpleNode {
  public ASTNumber(int id) {
    super(id);
  }

  public ASTNumber(AnimTimeParser p, int id) {
    super(p, id);
  }

}
/* JavaCC - OriginalChecksum=d51fc0904e6f137b1717d872a3ebeb92 (do not edit this line) */
"
ASTParamList.java,kitfox-6.9.6,"/* Generated By:JJTree: Do not edit this line. ASTParamList.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

public
class ASTParamList extends SimpleNode {
  public ASTParamList(int id) {
    super(id);
  }

  public ASTParamList(AnimTimeParser p, int id) {
    super(p, id);
  }

}
/* JavaCC - OriginalChecksum=d4e6f23229579e1d2e02b1ffdaba8849 (do not edit this line) */
"
ASTSum.java,kitfox-6.9.6,"/* Generated By:JJTree: Do not edit this line. ASTSum.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

public
class ASTSum extends SimpleNode {
  public ASTSum(int id) {
    super(id);
  }

  public ASTSum(AnimTimeParser p, int id) {
    super(p, id);
  }

}
/* JavaCC - OriginalChecksum=219697ddc7811e985057c491fdca56a7 (do not edit this line) */
"
ASTTerm.java,kitfox-6.9.6,"/* Generated By:JJTree: Do not edit this line. ASTTerm.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

public
class ASTTerm extends SimpleNode {
  public ASTTerm(int id) {
    super(id);
  }

  public ASTTerm(AnimTimeParser p, int id) {
    super(p, id);
  }

}
/* JavaCC - OriginalChecksum=5e0b4c0d123a796baea30c37ef2ff115 (do not edit this line) */
"
JJTAnimTimeParserState.java,kitfox-6.9.6,"/* Generated By:JavaCC: Do not edit this line. JJTAnimTimeParserState.java Version 5.0 */
package com.kitfox.svg.animation.parser;

public class JJTAnimTimeParserState {
  private java.util.List<Node> nodes;
  private java.util.List<Integer> marks;

  private int sp;        // number of nodes on stack
  private int mk;        // current mark
  private boolean node_created;

  public JJTAnimTimeParserState() {
    nodes = new java.util.ArrayList<Node>();
    marks = new java.util.ArrayList<Integer>();
    sp = 0;
    mk = 0;
  }

  /* Determines whether the current node was actually closed and
     pushed.  This should only be called in the final user action of a
     node scope.  */
  public boolean nodeCreated() {
    return node_created;
  }

  /* Call this to reinitialize the node stack.  It is called
     automatically by the parser's ReInit() method. */
  public void reset() {
    nodes.clear();
    marks.clear();
    sp = 0;
    mk = 0;
  }

  /* Returns the root node of the AST.  It only makes sense to call
     this after a successful parse. */
  public Node rootNode() {
    return nodes.get(0);
  }

  /* Pushes a node on to the stack. */
  public void pushNode(Node n) {
    nodes.add(n);
    ++sp;
  }

  /* Returns the node on the top of the stack, and remove it from the
     stack.  */
  public Node popNode() {
    if (--sp < mk) {
      mk = marks.remove(marks.size()-1);
    }
    return nodes.remove(nodes.size()-1);
  }

  /* Returns the node currently on the top of the stack. */
  public Node peekNode() {
    return nodes.get(nodes.size()-1);
  }

  /* Returns the number of children on the stack in the current node
     scope. */
  public int nodeArity() {
    return sp - mk;
  }


  public void clearNodeScope(Node n) {
    while (sp > mk) {
      popNode();
    }
    mk = marks.remove(marks.size()-1);
  }


  public void openNodeScope(Node n) {
    marks.add(mk);
    mk = sp;
    n.jjtOpen();
  }


  /* A definite node is constructed from a specified number of
     children.  That number of nodes are popped from the stack and
     made the children of the definite node.  Then the definite node
     is pushed on to the stack. */
  public void closeNodeScope(Node n, int num) {
    mk = marks.remove(marks.size()-1);
    while (num-- > 0) {
      Node c = popNode();
      c.jjtSetParent(n);
      n.jjtAddChild(c, num);
    }
    n.jjtClose();
    pushNode(n);
    node_created = true;
  }


  /* A conditional node is constructed if its condition is true.  All
     the nodes that have been pushed since the node was opened are
     made children of the conditional node, which is then pushed
     on to the stack.  If the condition is false the node is not
     constructed and they are left on the stack. */
  public void closeNodeScope(Node n, boolean condition) {
    if (condition) {
      int a = nodeArity();
      mk = marks.remove(marks.size()-1);
      while (a-- > 0) {
        Node c = popNode();
        c.jjtSetParent(n);
        n.jjtAddChild(c, a);
      }
      n.jjtClose();
      pushNode(n);
      node_created = true;
    } else {
      mk = marks.remove(marks.size()-1);
      node_created = false;
    }
  }
}
/* JavaCC - OriginalChecksum=279036a94fca72a27ec3ba484301b82c (do not edit this line) */
"
Node.java,kitfox-6.9.6,"/* Generated By:JJTree: Do not edit this line. Node.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

/* All AST nodes must implement this interface.  It provides basic
   machinery for constructing the parent and child relationships
   between nodes. */

public
interface Node {

  /** This method is called after the node has been made the current
    node.  It indicates that child nodes can now be added to it. */
  public void jjtOpen();

  /** This method is called after all the child nodes have been
    added. */
  public void jjtClose();

  /** This pair of methods are used to inform the node of its
    parent. */
  public void jjtSetParent(Node n);
  public Node jjtGetParent();

  /** This method tells the node to add its argument to the node's
    list of children.  */
  public void jjtAddChild(Node n, int i);

  /** This method returns a child node.  The children are numbered
     from zero, left to right. */
  public Node jjtGetChild(int i);

  /** Return the number of children the node has. */
  public int jjtGetNumChildren();
}
/* JavaCC - OriginalChecksum=7350ddf1f197cea959e691429875de4b (do not edit this line) */
"
ParseException.java,kitfox-6.9.6,"/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 5.0 */
/* JavaCCOptions:KEEP_LINE_COL=null */
package com.kitfox.svg.animation.parser;

/**
 * This exception is thrown when parse errors are encountered.
 * You can explicitly create objects of this exception type by
 * calling the method generateParseException in the generated
 * parser.
 *
 * You can modify this class to customize your error reporting
 * mechanisms so long as you retain the public fields.
 */
public class ParseException extends Exception {

  /**
   * The version identifier for this Serializable class.
   * Increment only if the <i>serialized</i> form of the
   * class changes.
   */
  private static final long serialVersionUID = 1L;

  /**
   * This constructor is used by the method ""generateParseException""
   * in the generated parser.  Calling this constructor generates
   * a new object of this type with the fields ""currentToken"",
   * ""expectedTokenSequences"", and ""tokenImage"" set.
   */
  public ParseException(Token currentTokenVal,
                        int[][] expectedTokenSequencesVal,
                        String[] tokenImageVal
                       )
  {
    super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));
    currentToken = currentTokenVal;
    expectedTokenSequences = expectedTokenSequencesVal;
    tokenImage = tokenImageVal;
  }

  /**
   * The following constructors are for use by you for whatever
   * purpose you can think of.  Constructing the exception in this
   * manner makes the exception behave in the normal way - i.e., as
   * documented in the class ""Throwable"".  The fields ""errorToken"",
   * ""expectedTokenSequences"", and ""tokenImage"" do not contain
   * relevant information.  The JavaCC generated code does not use
   * these constructors.
   */

  public ParseException() {
    super();
  }

  /** Constructor with message. */
  public ParseException(String message) {
    super(message);
  }


  /**
   * This is the last token that has been consumed successfully.  If
   * this object has been created due to a parse error, the token
   * followng this token will (therefore) be the first error token.
   */
  public Token currentToken;

  /**
   * Each entry in this array is an array of integers.  Each array
   * of integers represents a sequence of tokens (by their ordinal
   * values) that is expected at this point of the parse.
   */
  public int[][] expectedTokenSequences;

  /**
   * This is a reference to the ""tokenImage"" array of the generated
   * parser within which the parse error occurred.  This array is
   * defined in the generated ...Constants interface.
   */
  public String[] tokenImage;

  /**
   * It uses ""currentToken"" and ""expectedTokenSequences"" to generate a parse
   * error message and returns it.  If this object has been created
   * due to a parse error, and you do not catch it (it gets thrown
   * from the parser) the correct error message
   * gets displayed.
   */
  private static String initialise(Token currentToken,
                           int[][] expectedTokenSequences,
                           String[] tokenImage) {
    String eol = System.getProperty(""line.separator"", ""\n"");
    StringBuffer expected = new StringBuffer();
    int maxSize = 0;
    for (int i = 0; i < expectedTokenSequences.length; i++) {
      if (maxSize < expectedTokenSequences[i].length) {
        maxSize = expectedTokenSequences[i].length;
      }
      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
      }
      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
        expected.append(""..."");
      }
      expected.append(eol).append(""    "");
    }
    String retval = ""Encountered \"""";
    Token tok = currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0) retval += "" "";
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += "" "" + tokenImage[tok.kind];
      retval += "" \"""";
      retval += add_escapes(tok.image);
      retval += "" \"""";
      tok = tok.next;
    }
    retval += ""\"" at line "" + currentToken.next.beginLine + "", column "" + currentToken.next.beginColumn;
    retval += ""."" + eol;
    if (expectedTokenSequences.length == 1) {
      retval += ""Was expecting:"" + eol + ""    "";
    } else {
      retval += ""Was expecting one of:"" + eol + ""    "";
    }
    retval += expected.toString();
    return retval;
  }

  /**
   * The end of line string for this machine.
   */
  protected String eol = System.getProperty(""line.separator"", ""\n"");

  /**
   * Used to convert raw characters to their escaped version
   * when these raw version cannot be used as part of an ASCII
   * string literal.
   */
  static String add_escapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append(""\\b"");
              continue;
           case '\t':
              retval.append(""\\t"");
              continue;
           case '\n':
              retval.append(""\\n"");
              continue;
           case '\f':
              retval.append(""\\f"");
              continue;
           case '\r':
              retval.append(""\\r"");
              continue;
           case '\""':
              retval.append(""\\\"""");
              continue;
           case '\'':
              retval.append(""\\\'"");
              continue;
           case '\\':
              retval.append(""\\\\"");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = ""0000"" + Integer.toString(ch, 16);
                 retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }

}
/* JavaCC - OriginalChecksum=5e0377dcdc9777c5789f906c9f42dbd2 (do not edit this line) */
"
SimpleCharStream.java,kitfox-6.9.6,"/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 5.0 */
/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (without unicode processing).
 */

public class SimpleCharStream
{
/** Whether parser is static. */
  public static final boolean staticFlag = false;
  int bufsize;
  int available;
  int tokenBegin;
/** Position in buffer. */
  public int bufpos = -1;
  protected int bufline[];
  protected int bufcolumn[];

  protected int column = 0;
  protected int line = 1;

  protected boolean prevCharIsCR = false;
  protected boolean prevCharIsLF = false;

  protected java.io.Reader inputStream;

  protected char[] buffer;
  protected int maxNextCharInd = 0;
  protected int inBuf = 0;
  protected int tabSize = 8;

  protected void setTabSize(int i) { tabSize = i; }
  protected int getTabSize(int i) { return tabSize; }


  protected void ExpandBuff(boolean wrapAround)
  {
    char[] newbuffer = new char[bufsize + 2048];
    int newbufline[] = new int[bufsize + 2048];
    int newbufcolumn[] = new int[bufsize + 2048];

    try
    {
      if (wrapAround)
      {
        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
        System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
        buffer = newbuffer;

        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
        System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
        bufline = newbufline;

        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
        System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
        bufcolumn = newbufcolumn;

        maxNextCharInd = (bufpos += (bufsize - tokenBegin));
      }
      else
      {
        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
        buffer = newbuffer;

        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
        bufline = newbufline;

        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
        bufcolumn = newbufcolumn;

        maxNextCharInd = (bufpos -= tokenBegin);
      }
    }
    catch (Throwable t)
    {
      throw new Error(t.getMessage());
    }


    bufsize += 2048;
    available = bufsize;
    tokenBegin = 0;
  }

  protected void FillBuff() throws java.io.IOException
  {
    if (maxNextCharInd == available)
    {
      if (available == bufsize)
      {
        if (tokenBegin > 2048)
        {
          bufpos = maxNextCharInd = 0;
          available = tokenBegin;
        }
        else if (tokenBegin < 0)
          bufpos = maxNextCharInd = 0;
        else
          ExpandBuff(false);
      }
      else if (available > tokenBegin)
        available = bufsize;
      else if ((tokenBegin - available) < 2048)
        ExpandBuff(true);
      else
        available = tokenBegin;
    }

    int i;
    try {
      if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1)
      {
        inputStream.close();
        throw new java.io.IOException();
      }
      else
        maxNextCharInd += i;
      return;
    }
    catch(java.io.IOException e) {
      --bufpos;
      backup(0);
      if (tokenBegin == -1)
        tokenBegin = bufpos;
      throw e;
    }
  }

/** Start. */
  public char BeginToken() throws java.io.IOException
  {
    tokenBegin = -1;
    char c = readChar();
    tokenBegin = bufpos;

    return c;
  }

  protected void UpdateLineColumn(char c)
  {
    column++;

    if (prevCharIsLF)
    {
      prevCharIsLF = false;
      line += (column = 1);
    }
    else if (prevCharIsCR)
    {
      prevCharIsCR = false;
      if (c == '\n')
      {
        prevCharIsLF = true;
      }
      else
        line += (column = 1);
    }

    switch (c)
    {
      case '\r' :
        prevCharIsCR = true;
        break;
      case '\n' :
        prevCharIsLF = true;
        break;
      case '\t' :
        column--;
        column += (tabSize - (column % tabSize));
        break;
      default :
        break;
    }

    bufline[bufpos] = line;
    bufcolumn[bufpos] = column;
  }

/** Read a character. */
  public char readChar() throws java.io.IOException
  {
    if (inBuf > 0)
    {
      --inBuf;

      if (++bufpos == bufsize)
        bufpos = 0;

      return buffer[bufpos];
    }

    if (++bufpos >= maxNextCharInd)
      FillBuff();

    char c = buffer[bufpos];

    UpdateLineColumn(c);
    return c;
  }

  @Deprecated
  /**
   * @deprecated
   * @see #getEndColumn
   */

  public int getColumn() {
    return bufcolumn[bufpos];
  }

  @Deprecated
  /**
   * @deprecated
   * @see #getEndLine
   */

  public int getLine() {
    return bufline[bufpos];
  }

  /** Get token end column number. */
  public int getEndColumn() {
    return bufcolumn[bufpos];
  }

  /** Get token end line number. */
  public int getEndLine() {
     return bufline[bufpos];
  }

  /** Get token beginning column number. */
  public int getBeginColumn() {
    return bufcolumn[tokenBegin];
  }

  /** Get token beginning line number. */
  public int getBeginLine() {
    return bufline[tokenBegin];
  }

/** Backup a number of characters. */
  public void backup(int amount) {

    inBuf += amount;
    if ((bufpos -= amount) < 0)
      bufpos += bufsize;
  }

  /** Constructor. */
  public SimpleCharStream(java.io.Reader dstream, int startline,
  int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;

    available = bufsize = buffersize;
    buffer = new char[buffersize];
    bufline = new int[buffersize];
    bufcolumn = new int[buffersize];
  }

  /** Constructor. */
  public SimpleCharStream(java.io.Reader dstream, int startline,
                          int startcolumn)
  {
    this(dstream, startline, startcolumn, 4096);
  }

  /** Constructor. */
  public SimpleCharStream(java.io.Reader dstream)
  {
    this(dstream, 1, 1, 4096);
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader dstream, int startline,
  int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;

    if (buffer == null || buffersize != buffer.length)
    {
      available = bufsize = buffersize;
      buffer = new char[buffersize];
      bufline = new int[buffersize];
      bufcolumn = new int[buffersize];
    }
    prevCharIsLF = prevCharIsCR = false;
    tokenBegin = inBuf = maxNextCharInd = 0;
    bufpos = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader dstream, int startline,
                     int startcolumn)
  {
    ReInit(dstream, startline, startcolumn, 4096);
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader dstream)
  {
    ReInit(dstream, 1, 1, 4096);
  }
  /** Constructor. */
  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
  {
    this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
  }

  /** Constructor. */
  public SimpleCharStream(java.io.InputStream dstream, int startline,
  int startcolumn, int buffersize)
  {
    this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
  }

  /** Constructor. */
  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,
                          int startcolumn) throws java.io.UnsupportedEncodingException
  {
    this(dstream, encoding, startline, startcolumn, 4096);
  }

  /** Constructor. */
  public SimpleCharStream(java.io.InputStream dstream, int startline,
                          int startcolumn)
  {
    this(dstream, startline, startcolumn, 4096);
  }

  /** Constructor. */
  public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
  {
    this(dstream, encoding, 1, 1, 4096);
  }

  /** Constructor. */
  public SimpleCharStream(java.io.InputStream dstream)
  {
    this(dstream, 1, 1, 4096);
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
                          int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
  {
    ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream dstream, int startline,
                          int startcolumn, int buffersize)
  {
    ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
  {
    ReInit(dstream, encoding, 1, 1, 4096);
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream dstream)
  {
    ReInit(dstream, 1, 1, 4096);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
                     int startcolumn) throws java.io.UnsupportedEncodingException
  {
    ReInit(dstream, encoding, startline, startcolumn, 4096);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream dstream, int startline,
                     int startcolumn)
  {
    ReInit(dstream, startline, startcolumn, 4096);
  }
  /** Get token literal value. */
  public String GetImage()
  {
    if (bufpos >= tokenBegin)
      return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
    else
      return new String(buffer, tokenBegin, bufsize - tokenBegin) +
                            new String(buffer, 0, bufpos + 1);
  }

  /** Get the suffix. */
  public char[] GetSuffix(int len)
  {
    char[] ret = new char[len];

    if ((bufpos + 1) >= len)
      System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
    else
    {
      System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
                                                        len - bufpos - 1);
      System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
    }

    return ret;
  }

  /** Reset buffer when finished. */
  public void Done()
  {
    buffer = null;
    bufline = null;
    bufcolumn = null;
  }

  /**
   * Method to adjust line and column numbers for the start of a token.
   */
  public void adjustBeginLineColumn(int newLine, int newCol)
  {
    int start = tokenBegin;
    int len;

    if (bufpos >= tokenBegin)
    {
      len = bufpos - tokenBegin + inBuf + 1;
    }
    else
    {
      len = bufsize - tokenBegin + bufpos + 1 + inBuf;
    }

    int i = 0, j = 0, k = 0;
    int nextColDiff = 0, columnDiff = 0;

    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
    {
      bufline[j] = newLine;
      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
      bufcolumn[j] = newCol + columnDiff;
      columnDiff = nextColDiff;
      i++;
    }

    if (i < len)
    {
      bufline[j] = newLine++;
      bufcolumn[j] = newCol + columnDiff;

      while (i++ < len)
      {
        if (bufline[j = start % bufsize] != bufline[++start % bufsize])
          bufline[j] = newLine++;
        else
          bufline[j] = newLine;
      }
    }

    line = bufline[j];
    column = bufcolumn[j];
  }

}
/* JavaCC - OriginalChecksum=749f319e0b6f8453645cc9007f23d97d (do not edit this line) */
"
SimpleNode.java,kitfox-6.9.6,"/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

public
class SimpleNode implements Node {

  protected Node parent;
  protected Node[] children;
  protected int id;
  protected Object value;
  protected AnimTimeParser parser;

  public SimpleNode(int i) {
    id = i;
  }

  public SimpleNode(AnimTimeParser p, int i) {
    this(i);
    parser = p;
  }

  public void jjtOpen() {
  }

  public void jjtClose() {
  }

  public void jjtSetParent(Node n) { parent = n; }
  public Node jjtGetParent() { return parent; }

  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node c[] = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = n;
  }

  public Node jjtGetChild(int i) {
    return children[i];
  }

  public int jjtGetNumChildren() {
    return (children == null) ? 0 : children.length;
  }

  public void jjtSetValue(Object value) { this.value = value; }
  public Object jjtGetValue() { return value; }

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */

  public String toString() { return AnimTimeParserTreeConstants.jjtNodeName[id]; }
  public String toString(String prefix) { return prefix + toString(); }

  /* Override this method if you want to customize how the node dumps
     out its children. */

  public void dump(String prefix) {
    System.out.println(toString(prefix));
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        SimpleNode n = (SimpleNode)children[i];
        if (n != null) {
          n.dump(prefix + "" "");
        }
      }
    }
  }
}

/* JavaCC - OriginalChecksum=98eeb955d0a77c0bc63dc0ae73e987ee (do not edit this line) */
"
Token.java,kitfox-6.9.6,"/* Generated By:JavaCC: Do not edit this line. Token.java Version 5.0 */
/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.kitfox.svg.animation.parser;

/**
 * Describes the input token stream.
 */

public class Token implements java.io.Serializable {

  /**
   * The version identifier for this Serializable class.
   * Increment only if the <i>serialized</i> form of the
   * class changes.
   */
  private static final long serialVersionUID = 1L;

  /**
   * An integer that describes the kind of this token.  This numbering
   * system is determined by JavaCCParser, and a table of these numbers is
   * stored in the file ...Constants.java.
   */
  public int kind;

  /** The line number of the first character of this Token. */
  public int beginLine;
  /** The column number of the first character of this Token. */
  public int beginColumn;
  /** The line number of the last character of this Token. */
  public int endLine;
  /** The column number of the last character of this Token. */
  public int endColumn;

  /**
   * The string image of the token.
   */
  public String image;

  /**
   * A reference to the next regular (non-special) token from the input
   * stream.  If this is the last token from the input stream, or if the
   * token manager has not read tokens beyond this one, this field is
   * set to null.  This is true only if this token is also a regular
   * token.  Otherwise, see below for a description of the contents of
   * this field.
   */
  public Token next;

  /**
   * This field is used to access special tokens that occur prior to this
   * token, but after the immediately preceding regular (non-special) token.
   * If there are no such special tokens, this field is set to null.
   * When there are more than one such special token, this field refers
   * to the last of these special tokens, which in turn refers to the next
   * previous special token through its specialToken field, and so on
   * until the first special token (whose specialToken field is null).
   * The next fields of special tokens refer to other special tokens that
   * immediately follow it (without an intervening regular token).  If there
   * is no such token, this field is null.
   */
  public Token specialToken;

  /**
   * An optional attribute value of the Token.
   * Tokens which are not used as syntactic sugar will often contain
   * meaningful values that will be used later on by the compiler or
   * interpreter. This attribute value is often different from the image.
   * Any subclass of Token that actually wants to return a non-null value can
   * override this method as appropriate.
   */
  public Object getValue() {
    return null;
  }

  /**
   * No-argument constructor
   */
  public Token() {}

  /**
   * Constructs a new token for the specified Image.
   */
  public Token(int kind)
  {
    this(kind, null);
  }

  /**
   * Constructs a new token for the specified Image and Kind.
   */
  public Token(int kind, String image)
  {
    this.kind = kind;
    this.image = image;
  }

  /**
   * Returns the image.
   */
  public String toString()
  {
    return image;
  }

  /**
   * Returns a new Token object, by default. However, if you want, you
   * can create and return subclass objects based on the value of ofKind.
   * Simply add the cases to the switch for all those special cases.
   * For example, if you have a subclass of Token called IDToken that
   * you want to create if ofKind is ID, simply add something like :
   *
   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
   *
   * to the following switch statement. Then you can cast matchedToken
   * variable to the appropriate type and use sit in your lexical actions.
   */
  public static Token newToken(int ofKind, String image)
  {
    switch(ofKind)
    {
      default : return new Token(ofKind, image);
    }
  }

  public static Token newToken(int ofKind)
  {
    return newToken(ofKind, null);
  }

}
/* JavaCC - OriginalChecksum=14ff94460e829fa12c0a66b5fcf75250 (do not edit this line) */
"
TokenMgrError.java,kitfox-6.9.6,"/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 5.0 */
/* JavaCCOptions: */
package com.kitfox.svg.animation.parser;

/** Token Manager Error. */
public class TokenMgrError extends Error
{

  /**
   * The version identifier for this Serializable class.
   * Increment only if the <i>serialized</i> form of the
   * class changes.
   */
  private static final long serialVersionUID = 1L;

  /*
   * Ordinals for various reasons why an Error of this type can be thrown.
   */

  /**
   * Lexical error occurred.
   */
  static final int LEXICAL_ERROR = 0;

  /**
   * An attempt was made to create a second instance of a static token manager.
   */
  static final int STATIC_LEXER_ERROR = 1;

  /**
   * Tried to change to an invalid lexical state.
   */
  static final int INVALID_LEXICAL_STATE = 2;

  /**
   * Detected (and bailed out of) an infinite loop in the token manager.
   */
  static final int LOOP_DETECTED = 3;

  /**
   * Indicates the reason why the exception is thrown. It will have
   * one of the above 4 values.
   */
  int errorCode;

  /**
   * Replaces unprintable characters by their escaped (or unicode escaped)
   * equivalents in the given string
   */
  protected static final String addEscapes(String str) {
    StringBuffer retval = new StringBuffer();
    char ch;
    for (int i = 0; i < str.length(); i++) {
      switch (str.charAt(i))
      {
        case 0 :
          continue;
        case '\b':
          retval.append(""\\b"");
          continue;
        case '\t':
          retval.append(""\\t"");
          continue;
        case '\n':
          retval.append(""\\n"");
          continue;
        case '\f':
          retval.append(""\\f"");
          continue;
        case '\r':
          retval.append(""\\r"");
          continue;
        case '\""':
          retval.append(""\\\"""");
          continue;
        case '\'':
          retval.append(""\\\'"");
          continue;
        case '\\':
          retval.append(""\\\\"");
          continue;
        default:
          if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
            String s = ""0000"" + Integer.toString(ch, 16);
            retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
          } else {
            retval.append(ch);
          }
          continue;
      }
    }
    return retval.toString();
  }

  /**
   * Returns a detailed message for the Error when it is thrown by the
   * token manager to indicate a lexical error.
   * Parameters :
   *    EOFSeen     : indicates if EOF caused the lexical error
   *    curLexState : lexical state in which this error occurred
   *    errorLine   : line number when the error occurred
   *    errorColumn : column number when the error occurred
   *    errorAfter  : prefix that was seen before this error occurred
   *    curchar     : the offending character
   * Note: You can customize the lexical error message by modifying this method.
   */
  protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
    return(""Lexical error at line "" +
          errorLine + "", column "" +
          errorColumn + "".  Encountered: "" +
          (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""") + "" ("" + (int)curChar + ""), "") +
          ""after : \"""" + addEscapes(errorAfter) + ""\"""");
  }

  /**
   * You can also modify the body of this method to customize your error messages.
   * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
   * of end-users concern, so you can return something like :
   *
   *     ""Internal Error : Please file a bug report .... ""
   *
   * from this method for such cases in the release version of your parser.
   */
  public String getMessage() {
    return super.getMessage();
  }

  /*
   * Constructors of various flavors follow.
   */

  /** No arg constructor. */
  public TokenMgrError() {
  }

  /** Constructor with message and reason. */
  public TokenMgrError(String message, int reason) {
    super(message);
    errorCode = reason;
  }

  /** Full Constructor. */
  public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
    this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
  }
}
/* JavaCC - OriginalChecksum=7b1099e972c6991e1ec30fc332fdc407 (do not edit this line) */
"
SetSmil.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 2:51 AM
 */

package com.kitfox.svg.animation;

import com.kitfox.svg.SVGElement;
import com.kitfox.svg.SVGException;
import com.kitfox.svg.SVGLoaderHelper;
import com.kitfox.svg.animation.parser.AnimTimeParser;
import com.kitfox.svg.xml.StyleAttribute;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;


/**
 * Set is used to set a textual value; most likely for a style element.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class SetSmil extends AnimationElement
{
    public static final String TAG_NAME = ""set"";
    
    String toValue;
    
    /** Creates a new instance of Set */
    public SetSmil()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    public void loaderStartElement(SVGLoaderHelper helper, Attributes attrs, SVGElement parent) throws SAXException
    {
		//Load style string
        super.loaderStartElement(helper, attrs, parent);

        toValue = attrs.getValue(""to"");
    }

    protected void rebuild(AnimTimeParser animTimeParser) throws SVGException
    {
        super.rebuild(animTimeParser);

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""to"")))
        {
            String newVal = sty.getStringValue();
            toValue = newVal;
        }
    }
}
"
TimeBase.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 3:31 AM
 */

package com.kitfox.svg.animation;

import java.util.regex.*;

/**
 * SVG has a complicated way of specifying time.  Potentially, a time could
 * be represened as a summation of discrete times and times of other animation
 * events.  This provides a root for the many elements we will need to define
 * time.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
abstract public class TimeBase
{
    static final Matcher matchIndefinite = Pattern.compile(""\\s*indefinite\\s*"").matcher("""");
    static final Matcher matchUnitTime = Pattern.compile(""\\s*([-+]?((\\d*\\.\\d+)|(\\d+))([-+]?[eE]\\d+)?)\\s*(h|min|s|ms)?\\s*"").matcher("""");
    
    /*
    public static TimeBase parseTime(String text) 
    { 
        if (text == null) return null;
        
        if (text.indexOf('+') == -1)
        {
            return parseTimeComponent(text);
        }
        
        return new TimeCompound(text);
    }
     */
    
    protected static TimeBase parseTimeComponent(String text)
    {
        matchIndefinite.reset(text);
        if (matchIndefinite.matches()) return new TimeIndefinite();
        
        matchUnitTime.reset(text);
        if (matchUnitTime.matches())
        {
            String val = matchUnitTime.group(1);
            String units = matchUnitTime.group(6);
            
            double time = 0;
            try { time = Double.parseDouble(val); }
            catch (Exception e) {}
            
            if (units.equals(""ms"")) time *= .001;
            else if (units.equals(""min"")) time *= 60;
            else if (units.equals(""h"")) time *= 3600;
            
            return new TimeDiscrete(time);
        }
        
        return null;
    }
    
    /**
     * Calculates the (greater than or equal to 0) time in seconds this 
     * time represents.  If the time cannot be determined, returns 
     * Double.NaN.  If this represents an infinte amount of time, returns 
     * Double.POSITIVE_INFINITY.
     */
    abstract public double evalTime();
    
    /**
     * Some time elements need to refer to the animation element that contains 
     * them to evaluate correctly
     */
    public void setParentElement(AnimationElement ele)
    {
    }
}
"
TimeCompound.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 3:33 AM
 */

package com.kitfox.svg.animation;

import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Pattern;


/**
 * This represents a summation of other time elements.  It is used for complex
 * timing events with offsets.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class TimeCompound extends TimeBase
{
    static final Pattern patPlus = Pattern.compile(""\\+"");
    
    /**
     * This is a list of times.  This element's time is calculated as the greatest
     * member that is less than the current time.
    */
    final List componentTimes;

    private AnimationElement parent;
    
    /** Creates a new instance of TimeDiscrete */
    public TimeCompound(List timeBases)
    {
        componentTimes = Collections.unmodifiableList(timeBases);
    }
    
    public double evalTime()
    {
        double agg = 0.0;
        
        for (Iterator it = componentTimes.iterator(); it.hasNext();)
        {
            TimeBase timeEle = (TimeBase)it.next();
            double time = timeEle.evalTime();
            agg += time;
        }
        
        return agg;
    }
    
    public void setParentElement(AnimationElement ele)
    {
        this.parent = ele;
        
        for (Iterator it = componentTimes.iterator(); it.hasNext();)
        {
            TimeBase timeEle = (TimeBase)it.next();
            timeEle.setParentElement(ele);
        }
    }
}
"
TimeDiscrete.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 3:33 AM
 */

package com.kitfox.svg.animation;

/**
 * This is a time that represents a specific number of milliseconds
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class TimeDiscrete extends TimeBase
{
    //Milliseconds of delay
    double secs;
    
    /** Creates a new instance of TimeDiscrete */
    public TimeDiscrete(double secs)
    {
        this.secs = secs;
    }
    
    public double evalTime()
    {
        return secs;
    }
    
}
"
TimeIndefinite.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 3:33 AM
 */

package com.kitfox.svg.animation;

/**
 * This represents the indefinite (infinite) amount of time.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class TimeIndefinite extends TimeBase
{
    
    /** Creates a new instance of TimeDiscrete */
    public TimeIndefinite()
    {
    }
    
    public double evalTime()
    {
        return Double.POSITIVE_INFINITY;
    }
    
}
"
TimeLookup.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 3:33 AM
 */

package com.kitfox.svg.animation;

/**
 * This is a time that represents a specific number of milliseconds
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class TimeLookup extends TimeBase
{
    /** 
     * This time can only be resolved in relation to it's parent
     */
    private AnimationElement parent;
    
    /**
     * Node this lookup acts upon
     */
    String node;
    
    /**
     * Event to evalutae on this node
     */
    String event;
    
    /**
     * Optional parameter used by some events
     */
    String paramList;
    
    /** Creates a new instance of TimeDiscrete */
    public TimeLookup(AnimationElement parent, String node, String event, String paramList)
    {
        this.parent = parent;
        this.node = node;
        this.event = event;
        this.paramList = paramList;
    }
    
    public double evalTime()
    {
        return 0.0;
    }
    
    public void setParentElement(AnimationElement ele)
    {
        parent = ele;
    }
}
"
TimeSum.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 3:33 AM
 */

package com.kitfox.svg.animation;

/**
 * This is a time that represents a specific number of milliseconds
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class TimeSum extends TimeBase
{
    //Milliseconds of delay
    TimeBase t1;
    TimeBase t2;
    boolean add;
    
    /** Creates a new instance of TimeDiscrete */
    public TimeSum(TimeBase t1, TimeBase t2, boolean add)
    {
        this.t1 = t1;
        this.t2 = t2;
        this.add = add;
    }
    
    public double evalTime()
    {
        return add ? t1.evalTime() + t2.evalTime() : t1.evalTime() - t2.evalTime();
    }
    
    public void setParentElement(AnimationElement ele)
    {
        t1.setParentElement(ele);
        t2.setParentElement(ele);
    }
}
"
TrackBase.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 11:34 PM
 */

package com.kitfox.svg.animation;

import java.util.*;

import com.kitfox.svg.xml.*;
import com.kitfox.svg.*;

/**
 * A track holds the animation events for a single parameter of a single SVG 
 * element.  It also contains the default value for the element, should the
 * user want to see the 'unanimated' value.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
abstract public class TrackBase
{
    protected final String attribName;
    protected final int attribType;  //AnimationElement.AT_*
 
    /** Element we're animating */
    protected final SVGElement parent;
    
    //It doesn't make sense to sort this, since some events will depend on
    // other events - in many cases, there will be no meaningful sorted order.
    final ArrayList animEvents = new ArrayList();
    
    /** Creates a new instance of TrackManager */
//    public TrackBase(SVGElement parent)
//    {
//        this(parent, """", AnimationElement.AT_AUTO);
//    }
    
    /**
     * Creates a track that would be valid for the name and type of element
     * passed in.  Does not actually add this elemnt to the track.
     */
    public TrackBase(SVGElement parent, AnimationElement ele) throws SVGElementException
    {
        this(parent, ele.getAttribName(), ele.getAttribType());
    }
    
    public TrackBase(SVGElement parent, String attribName, int attribType) throws SVGElementException
    {
        this.parent = parent;
        this.attribName = attribName;
        this.attribType = attribType;
        
        //Make sure parent has an attribute we will write to
        if (attribType == AnimationElement.AT_AUTO 
            && !parent.hasAttribute(attribName, AnimationElement.AT_CSS)
            && !parent.hasAttribute(attribName, AnimationElement.AT_XML))
        {
            parent.addAttribute(attribName, AnimationElement.AT_CSS, """");
        }
        else if (!parent.hasAttribute(attribName, attribType))
        {
            parent.addAttribute(attribName, attribType, """");
        }
    }
    
    public String getAttribName() { return attribName; }
    public int getAttribType() { return attribType; }
    
    public void addElement(AnimationElement ele)
    {
        animEvents.add(ele);
    }
    
    /**
     * Returns a StyleAttribute representing the value of this track at the
     * passed time.  If this track does not apply, returns null.
     * @return - True if successful, false if a value could not be obtained
     */
    abstract public boolean getValue(StyleAttribute attrib, double curTime) throws SVGException;
    
}
"
TrackColor.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 21, 2004, 11:34 PM
 */

package com.kitfox.svg.animation;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.*;
import java.util.*;

import com.kitfox.svg.*;
import com.kitfox.svg.xml.*;

/**
 * A track holds the animation events for a single parameter of a single SVG
 * element.  It also contains the default value for the element, should the
 * user want to see the 'unanimated' value.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class TrackColor extends TrackBase
{

    public TrackColor(AnimationElement ele) throws SVGElementException
    {
        super(ele.getParent(), ele);
    }

    public boolean getValue(StyleAttribute attrib, double curTime)
    {
        Color col = getValue(curTime);
        if (col == null) return false;

        attrib.setStringValue(""#"" + Integer.toHexString(col.getRGB()));
        return true;
    }

    public Color getValue(double curTime)
    {
        Color retVal = null;
        AnimationTimeEval state = new AnimationTimeEval();

        for (Iterator it = animEvents.iterator(); it.hasNext();)
        {
            AnimateBase ele = (AnimateBase)it.next();
            AnimateColorIface eleColor = (AnimateColorIface)ele;
            ele.evalParametric(state, curTime);

            //Reject value if it is in the invalid state
            if (Double.isNaN(state.interp)) continue;

            if (retVal == null)
            {
                retVal = eleColor.evalColor(state.interp);
                continue;
            }
            
            Color curCol = eleColor.evalColor(state.interp);
            switch (ele.getAdditiveType())
            {
                case AnimationElement.AD_REPLACE:
                    retVal = curCol;
                    break;
                case AnimationElement.AD_SUM:
                    retVal = new Color(curCol.getRed() + retVal.getRed(), curCol.getGreen() + retVal.getGreen(), curCol.getBlue() + retVal.getBlue());
                    break;
            }
        }

        return retVal;
    }
}
"
TrackDouble.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 11:34 PM
 */

package com.kitfox.svg.animation;

import com.kitfox.svg.xml.StyleAttribute;
import java.util.*;

import com.kitfox.svg.*;
import com.kitfox.svg.xml.*;

/**
 * A track holds the animation events for a single parameter of a single SVG
 * element.  It also contains the default value for the element, should the
 * user want to see the 'unanimated' value.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class TrackDouble extends TrackBase
{
    public TrackDouble(AnimationElement ele) throws SVGElementException
    {
        super(ele.getParent(), ele);
    }

    public boolean getValue(StyleAttribute attrib, double curTime)
    {
        double val = getValue(curTime);
        if (Double.isNaN(val)) return false;

        attrib.setStringValue("""" + val);
        return true;
    }

    public double getValue(double curTime)
    {
        double retVal = Double.NaN;
        
        StyleAttribute attr = null;
        switch (attribType)
        {
            case AnimationElement.AT_CSS:
                attr = parent.getStyleAbsolute(attribName);
                retVal = attr.getDoubleValue();
                break;
            case AnimationElement.AT_XML:
                attr = parent.getPresAbsolute(attribName);
                retVal = attr.getDoubleValue();
                break;
            case AnimationElement.AT_AUTO:
                attr = parent.getStyleAbsolute(attribName);
                if (attr == null) attr = parent.getPresAbsolute(attribName);
                retVal = attr.getDoubleValue();
                break;
        }
        
        
        
        AnimationTimeEval state = new AnimationTimeEval();
//        boolean pastEnd = true;

        for (Iterator it = animEvents.iterator(); it.hasNext();)
        {
            Animate ele = (Animate)it.next();
            ele.evalParametric(state, curTime);

            //Go to next element if this one does not affect processing
            if (Double.isNaN(state.interp)) continue;

            switch (ele.getAdditiveType())
            {
                case AnimationElement.AD_SUM:
                    retVal += ele.eval(state.interp);
                    break;
                case AnimationElement.AD_REPLACE:
                    retVal = ele.eval(state.interp);
                    break;
            }
            
            //Evalutae accumulation if applicable
            if (state.rep > 0)
            {
                switch (ele.getAccumulateType())
                {
                    case AnimationElement.AC_SUM:
                        retVal += ele.repeatSkipSize(state.rep);
                        break;
                }
                
            }
        }

        return retVal;
    }
}
"
TrackManager.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on August 15, 2004, 11:34 PM
 */

package com.kitfox.svg.animation;

import java.util.*;

import com.kitfox.svg.*;
import java.io.Serializable;

/**
 * Every element contains tracks, which manage the animation.  There is one track
 * for every parameter with animation, and each track in turn is composed of
 * many events.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class TrackManager implements Serializable
{
    public static final long serialVersionUID = 0;
    
    static class TrackKey
    {
        String name;
        int type;
        
        TrackKey(AnimationElement base)
        {
            this(base.getAttribName(), base.getAttribType());
        }
        
        TrackKey(String name, int type)
        {
            this.name = name;
            this.type = type;
        }
        
        public int hashCode()
        {
            int hash = name == null ? 0 : name.hashCode();
            hash = hash * 97 + type;
            return hash;
        }

        public boolean equals(Object obj) 
        {
            if (!(obj instanceof TrackKey)) return false;
            TrackKey key = (TrackKey)obj;
            return key.type == type && key.name.equals(name);
        }
    }
    
    HashMap tracks = new HashMap();
    
    /** Creates a new instance of TrackManager */
    public TrackManager()
    {
    }
    
    /**
     * Adds a new animation element to this track
     */
    public void addTrackElement(AnimationElement element) throws SVGElementException
    {
        TrackKey key = new TrackKey(element);
        
        TrackBase track = (TrackBase)tracks.get(key);
        
        if (track == null)
        {
            //Create a track for this element
            if (element instanceof Animate)
            {
                switch (((Animate)element).getDataType())
                {
                    case Animate.DT_REAL:
                        track = new TrackDouble(element);
                        break;
                    case Animate.DT_COLOR:
                        track = new TrackColor(element);
                        break;
                    case Animate.DT_PATH:
                        track = new TrackPath(element);
                        break;
                    default:
                        throw new RuntimeException("""");
                }
            }
            else if (element instanceof AnimateColor)
            {
                track = new TrackColor(element);
            }
            else if (element instanceof AnimateTransform || element instanceof AnimateMotion)
            {
                track = new TrackTransform(element);
            }
            
            tracks.put(key, track);
        }
  
        track.addElement(element);
    }
    
    public TrackBase getTrack(String name, int type)
    {
        //Handle AUTO, which will match either CSS or XML (in that order)
        if (type == AnimationElement.AT_AUTO)
        {
            TrackBase t = getTrack(name, AnimationElement.AT_CSS);
            if (t != null) return t;
            t = getTrack(name, AnimationElement.AT_XML);
            if (t != null) return t;
            return null;
        }
        
        //Get requested attribute
        TrackKey key = new TrackKey(name, type);
        TrackBase t = (TrackBase)tracks.get(key);
        if (t != null) return t;
        
        //If that didn't exist, see if one exists of type AUTO
        key = new TrackKey(name, AnimationElement.AT_AUTO);
        return (TrackBase)tracks.get(key);
    }
    
    public int getNumTracks()
    {
        return tracks.size();
    }
    
    public Iterator iterator()
    {
        return tracks.values().iterator();
    }
}
"
TrackMotion.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 21, 2004, 11:34 PM
 */

package com.kitfox.svg.animation;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.geom.*;
import java.util.*;

import com.kitfox.svg.*;
import com.kitfox.svg.xml.*;

/**
 * A track holds the animation events for a single parameter of a single SVG
 * element.  It also contains the default value for the element, should the
 * user want to see the 'unanimated' value.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class TrackMotion extends TrackBase
{
    public TrackMotion(AnimationElement ele) throws SVGElementException
    {
        //The motion element implies a CSS attribute of transform
//        super(ele.getParent(), ""transform"", AnimationElement.AT_CSS);
        super(ele.getParent(), ele);
    }

    public boolean getValue(StyleAttribute attrib, double curTime) throws SVGException
    {
        AffineTransform retVal = new AffineTransform();
        retVal = getValue(retVal, curTime);
//        AffineTransform val = getValue(curTime);
//        if (val == null) return false;

        double[] mat = new double[6];
        retVal.getMatrix(mat);
        attrib.setStringValue(""matrix("" + mat[0] + "" "" + mat[1] + "" "" + mat[2] + "" "" + mat[3] + "" "" + mat[4] + "" "" + mat[5] + "")"");
        return true;
    }

    public AffineTransform getValue(AffineTransform retVal, double curTime) throws SVGException
    {
        //Init transform with default state
        StyleAttribute attr = null;
        switch (attribType)
        {
            case AnimationElement.AT_CSS:
                attr = parent.getStyleAbsolute(attribName);
                retVal.setTransform(SVGElement.parseSingleTransform(attr.getStringValue()));
                break;
            case AnimationElement.AT_XML:
                attr = parent.getPresAbsolute(attribName);
                retVal.setTransform(SVGElement.parseSingleTransform(attr.getStringValue()));
                break;
            case AnimationElement.AT_AUTO:
                attr = parent.getStyleAbsolute(attribName);
                if (attr == null) attr = parent.getPresAbsolute(attribName);
                retVal.setTransform(SVGElement.parseSingleTransform(attr.getStringValue()));
                break;
        }


        //Update transform with time based information
        AnimationTimeEval state = new AnimationTimeEval();
        AffineTransform xform = new AffineTransform();
//        boolean pastEnd = true;

        for (Iterator it = animEvents.iterator(); it.hasNext();)
        {
            AnimateMotion ele = (AnimateMotion)it.next();
            ele.evalParametric(state, curTime);

            //Go to next element if this one does not affect processing
            if (Double.isNaN(state.interp)) continue;

            switch (ele.getAdditiveType())
            {
                case AnimationElement.AD_SUM:
                    retVal.concatenate(ele.eval(xform, state.interp));
                    break;
                case AnimationElement.AD_REPLACE:
                    retVal.setTransform(ele.eval(xform, state.interp));
                    break;
            }

            //Evaluate accumulation if applicable
/*
            if (state.rep > 0)
            {
                switch (ele.getAccumulateType())
                {
                    case AnimationElement.AC_SUM:
                        retVal += ele.repeatSkipSize(state.rep);
                        break;
                }

            }
*/
        }

        return retVal;
    }
}
"
TrackPath.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 21, 2004, 11:34 PM
 */

package com.kitfox.svg.animation;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.*;
import java.awt.geom.*;
import java.util.*;

import com.kitfox.svg.pathcmd.*;
import com.kitfox.svg.*;
import com.kitfox.svg.xml.*;

/**
 * A track holds the animation events for a single parameter of a single SVG
 * element.  It also contains the default value for the element, should the
 * user want to see the 'unanimated' value.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class TrackPath extends TrackBase
{

    public TrackPath(AnimationElement ele) throws SVGElementException
    {
        super(ele.getParent(), ele);
    }

    public boolean getValue(StyleAttribute attrib, double curTime)
    {
        GeneralPath path = getValue(curTime);
        if (path == null) return false;

        attrib.setStringValue(PathUtil.buildPathString(path));
        return true;
    }

    public GeneralPath getValue(double curTime)
    {
        GeneralPath retVal = null;
        AnimationTimeEval state = new AnimationTimeEval();

        for (Iterator it = animEvents.iterator(); it.hasNext();)
        {
            AnimateBase ele = (AnimateBase)it.next();
            Animate eleAnim = (Animate)ele;
            ele.evalParametric(state, curTime);

            //Reject value if it is in the invalid state
            if (Double.isNaN(state.interp)) continue;

            if (retVal == null)
            {
                retVal = eleAnim.evalPath(state.interp);
                continue;
            }
            
            GeneralPath curPath = eleAnim.evalPath(state.interp);
            switch (ele.getAdditiveType())
            {
                case AnimationElement.AD_REPLACE:
                    retVal = curPath;
                    break;
                case AnimationElement.AD_SUM:
                    throw new RuntimeException(""Not implemented"");
//                    retVal = new Color(curCol.getRed() + retVal.getRed(), curCol.getGreen() + retVal.getGreen(), curCol.getBlue() + retVal.getBlue());
//                    break;
                default:
                    throw new RuntimeException();
            }
        }

        return retVal;
    }
}
"
TrackTransform.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 21, 2004, 11:34 PM
 */

package com.kitfox.svg.animation;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.geom.*;
import java.util.*;

import com.kitfox.svg.*;
import com.kitfox.svg.xml.*;

/**
 * A track holds the animation events for a single parameter of a single SVG
 * element.  It also contains the default value for the element, should the
 * user want to see the 'unanimated' value.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class TrackTransform extends TrackBase
{
    public TrackTransform(AnimationElement ele) throws SVGElementException
    {
        super(ele.getParent(), ele);
    }

    public boolean getValue(StyleAttribute attrib, double curTime) throws SVGException
    {
        AffineTransform retVal = new AffineTransform();
        retVal = getValue(retVal, curTime);
//        AffineTransform val = getValue(curTime);
//        if (val == null) return false;

        double[] mat = new double[6];
        retVal.getMatrix(mat);
        attrib.setStringValue(""matrix("" + mat[0] + "" "" + mat[1] + "" "" + mat[2] + "" "" + mat[3] + "" "" + mat[4] + "" "" + mat[5] + "")"");
        return true;
    }

    public AffineTransform getValue(AffineTransform retVal, double curTime) throws SVGException
    {
        //Init transform with default state
        StyleAttribute attr = null;
        switch (attribType)
        {
            case AnimationElement.AT_CSS:
                attr = parent.getStyleAbsolute(attribName);
                retVal.setTransform(SVGElement.parseSingleTransform(attr.getStringValue()));
                break;
            case AnimationElement.AT_XML:
                attr = parent.getPresAbsolute(attribName);
                retVal.setTransform(SVGElement.parseSingleTransform(attr.getStringValue()));
                break;
            case AnimationElement.AT_AUTO:
                attr = parent.getStyleAbsolute(attribName);
                if (attr == null) attr = parent.getPresAbsolute(attribName);
                retVal.setTransform(SVGElement.parseSingleTransform(attr.getStringValue()));
                break;
        }


        //Update transform with time based information
        AnimationTimeEval state = new AnimationTimeEval();
        AffineTransform xform = new AffineTransform();

        for (Iterator it = animEvents.iterator(); it.hasNext();)
        {
            AnimateXform ele = (AnimateXform)it.next();
            ele.evalParametric(state, curTime);

            //Go to next element if this one does not affect processing
            if (Double.isNaN(state.interp)) continue;

            switch (ele.getAdditiveType())
            {
                case AnimationElement.AD_SUM:
                    retVal.concatenate(ele.eval(xform, state.interp));
                    break;
                case AnimationElement.AD_REPLACE:
                    retVal.setTransform(ele.eval(xform, state.interp));
                    break;
            }

        }

        return retVal;
    }
}
"
SVGToImageAntTask.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 22, 2005, 10:30 AM
 */

package com.kitfox.svg.app.ant;

import java.awt.*;
import java.awt.image.*;
import java.util.*;
import java.util.regex.*;
import java.io.*;
import javax.imageio.*;

//import com.kitfox.util.*;
//import com.kitfox.util.indexedObject.*;

import org.apache.tools.ant.*;
import org.apache.tools.ant.types.*;

import com.kitfox.svg.app.beans.*;
import com.kitfox.svg.*;
import com.kitfox.svg.xml.ColorTable;

/**
 * <p>Translates a group of SVG files into images.</p>
 * 
 * <p>Parameters:</p>
 * <p><ul>
 * <li/>destDir - If present, specifices a directory to write SVG files to.  Otherwise
 * writes images to directory SVG file was found in
 * verbose - If true, prints processing information to the console
 * <li/>format - File format for output images.  The java core javax.imageio.ImageIO
 * class is used for creating images, so format strings will depend on what
 * files your system is configured to handle.  By default, ""gif"", ""jpg"" and ""png""
 * files are guaranteed to be present.  If omitted, ""png"" is used by default.
 * <li/>backgroundColor - Optional background color.  Color can be specified as a standard 
 * HTML color.  That is, as the name of a standard color such as ""blue"" or 
 * ""limegreen"", using the # notaion as in #ff00ff for magenta, or in rgb format
 * listing the components as in rgb(255, 192, 192) for pink.  If omitted,
 * background is transparent.
 * <li/>antiAlias - If set, shapes are drawn using antialiasing.  Defaults to true.
 * <li/>interpolation - String describing image interpolation alrogithm.  Can
 * be one of ""nearest neighbor"", ""bilinear"" or ""bicubic"".  Defaults to ""bicubic"".
 * <li/>width - If greater than 0, determines the width of the written image.  Otherwise,
 * the width is obtained from the SVG document.  Defaults to -1;
 * <li/>height - If greater than 0, determines the height of the written image.  Otherwise,
 * the height is obtained from the SVG document.  Defaults to -1.
 * <li/>sizeToFit - If true and the width and height of the output image differ
 * from that of the SVG image, the valid area of the SVG image will be resized 
 * to fit the specified size.
 * <li/>verbose - IF true, prints out diagnostic infromation about processing.  
 * Defaults to false.
 * </ul></p>
 * 
 * Example:
 * &lt;SVGToImage destDir=""${index.java}"" format=""jpg"" verbose=""true""&gt;
 *    &lt;fileset dir=""${dir1}""&gt;
 *        &lt;include name=""*.svg""/&gt;
 *    &lt;/fileset&gt;
 *    &lt;fileset dir=""${dir2}""&gt;
 *        &lt;include name=""*.svg""/&gt;
 *    &lt;/fileset&gt;
 * &lt;/SVGToImage&gt;
 * 
 * 
 * 
 * @author kitfox
 */
public class SVGToImageAntTask extends Task
{
    private ArrayList filesets = new ArrayList();
    boolean verbose = false;
    File destDir;
    private String format = ""png"";
    Color backgroundColor = null;
    int width = -1;
    int height = -1;
    boolean antiAlias = true;
    String interpolation = ""bicubic"";
    boolean clipToViewBox = false;
    boolean sizeToFit = true;
    
    /** Creates a new instance of IndexLoadObjectsAntTask */
    public SVGToImageAntTask()
    {
    }
    
    
    public String getFormat()
    {
        return format;
    }
    
    public void setFormat(String format)
    {
        this.format = format;
    }
    
    public void setBackgroundColor(String bgColor)
    {
        this.backgroundColor = ColorTable.parseColor(bgColor);
    }
    
    public void setHeight(int height)
    {
        this.height = height;
    }
    
    public void setWidth(int width)
    {
        this.width = width;
    }
    
    public void setAntiAlias(boolean antiAlias)
    {
        this.antiAlias = antiAlias;
    }
    
    public void setInterpolation(String interpolation)
    {
        this.interpolation = interpolation;
    }
    
    public void setSizeToFit(boolean sizeToFit)
    {
        this.sizeToFit = sizeToFit;
    }
    
    public void setClipToViewBox(boolean clipToViewBox)
    {
        this.clipToViewBox = clipToViewBox;
    }
    
    public void setVerbose(boolean verbose)
    {
        this.verbose = verbose;
    }
    
    public void setDestDir(File destDir)
    {
        this.destDir = destDir;
    }
    
    /**
     * Adds a set of files.
     */
    public void addFileset(FileSet set)
    {
        filesets.add(set);
    }
    
    
    
    public void execute()
    {
        if (verbose) log(""Building SVG images"");
        
        for (Iterator it = filesets.iterator(); it.hasNext();)
        {
            FileSet fs = (FileSet)it.next();
            FileScanner scanner = fs.getDirectoryScanner(getProject());
            String[] files = scanner.getIncludedFiles();
            
            try
            {
                File basedir = scanner.getBasedir();
                
                if (verbose) log(""Scaning "" + basedir);
                
                for (int i = 0; i < files.length; i++)
                {
//System.out.println(""File "" + files[i]);
//System.out.println(""BaseDir "" + basedir);
                    translate(basedir, files[i]);
                }
            }
            catch (Exception e)
            {
                throw new BuildException(e);
            }
        }
    }
    
    private void translate(File baseDir, String shortName) throws BuildException
    {
        File source = new File(baseDir, shortName);
        
        if (verbose) log(""Reading file: "" + source);
        
        Matcher matchName = Pattern.compile(""(.*)\\.svg"", Pattern.CASE_INSENSITIVE).matcher(shortName);
        if (matchName.matches())
        {
            shortName = matchName.group(1);
        }
        shortName += ""."" + format;
        
        SVGIcon icon = new SVGIcon();
        icon.setSvgURI(source.toURI());
        icon.setAntiAlias(antiAlias);
        if (interpolation.equals(""nearest neighbor""))
        {
            icon.setInterpolation(SVGIcon.INTERP_NEAREST_NEIGHBOR);
        }
        else if (interpolation.equals(""bilinear""))
        {
            icon.setInterpolation(SVGIcon.INTERP_BILINEAR);
        }
        else if (interpolation.equals(""bicubic""))
        {
            icon.setInterpolation(SVGIcon.INTERP_BICUBIC);
        }
        
        int iconWidth = width > 0 ? width : icon.getIconWidth();
        int iconHeight = height > 0 ? height : icon.getIconHeight();
        icon.setClipToViewbox(clipToViewBox);
        icon.setPreferredSize(new Dimension(iconWidth, iconHeight));
        icon.setScaleToFit(sizeToFit);
        BufferedImage image = new BufferedImage(iconWidth, iconHeight, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = image.createGraphics();
        
        if (backgroundColor != null)
        {
            g.setColor(backgroundColor);
            g.fillRect(0, 0, iconWidth, iconHeight);
        }
        
        g.setClip(0, 0, iconWidth, iconHeight);
//        g.fillRect(10, 10, 100, 100);
        icon.paintIcon(null, g, 0, 0);
        g.dispose();
        
        File outFile = destDir == null ? new File(baseDir, shortName) : new File(destDir, shortName);
        if (verbose) log(""Writing file: "" + outFile);
        
        try
        {
            ImageIO.write(image, format, outFile);
        }
        catch (IOException e)
        {
            log(""Error writing image: "" + e.getMessage());
            throw new BuildException(e);
        }
        
        
        SVGCache.getSVGUniverse().clear();
    }
    
}
"
ProportionalLayoutPanel.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on May 7, 2005, 4:15 AM
 */

package com.kitfox.svg.app.beans;

import java.awt.*;
import java.util.*;
import javax.swing.*;

/**
 * Panel based on the null layout.  Allows editing with absolute layout.  When
 * instanced, records layout dimensions of all subcomponents.  Then, if the
 * panel is ever resized, scales all children to fit new size.
 *
 * @author  kitfox
 */
public class ProportionalLayoutPanel extends javax.swing.JPanel
{
    public static final long serialVersionUID = 1;

    //Margins to leave on sides of panel, expressed in fractions [0 1]
    float topMargin;
    float bottomMargin;
    float leftMargin;
    float rightMargin;
    
    /** Creates new form ProportionalLayoutPanel */
    public ProportionalLayoutPanel()
    {
        initComponents();
    }
    
    public void addNotify()
    {
        super.addNotify();
        
        Rectangle rect = this.getBounds();
        JOptionPane.showMessageDialog(this, """" + rect);
    }
    
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate=""collapsed"" desc="" Generated Code "">//GEN-BEGIN:initComponents
    private void initComponents()
    {
        jPanel1 = new javax.swing.JPanel();

        setLayout(null);

        addComponentListener(new java.awt.event.ComponentAdapter()
        {
            public void componentResized(java.awt.event.ComponentEvent evt)
            {
                formComponentResized(evt);
            }
            public void componentShown(java.awt.event.ComponentEvent evt)
            {
                formComponentShown(evt);
            }
        });

        add(jPanel1);
        jPanel1.setBounds(80, 90, 280, 160);

    }
    // </editor-fold>//GEN-END:initComponents

    private void formComponentShown(java.awt.event.ComponentEvent evt)//GEN-FIRST:event_formComponentShown
    {//GEN-HEADEREND:event_formComponentShown
        JOptionPane.showMessageDialog(this, """" + getWidth() + "", "" + getHeight());

    }//GEN-LAST:event_formComponentShown

    private void formComponentResized(java.awt.event.ComponentEvent evt)//GEN-FIRST:event_formComponentResized
    {//GEN-HEADEREND:event_formComponentResized
// TODO add your handling code here:
    }//GEN-LAST:event_formComponentResized
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jPanel1;
    // End of variables declaration//GEN-END:variables
    
}
"
SVGIcon.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on April 21, 2005, 10:45 AM
 */

package com.kitfox.svg.app.beans;

import com.kitfox.svg.*;
import java.awt.*;
import java.awt.geom.*;
import java.beans.*;
import java.net.*;
import javax.swing.*;

/**
 *
 * @author kitfox
 */
public class SVGIcon implements Icon
{
    public static final long serialVersionUID = 1;

    public static final String PROP_AUTOSIZE = ""PROP_AUTOSIZE"";
    
    private PropertyChangeSupport changes = new PropertyChangeSupport(this);
    
    SVGUniverse svgUniverse = SVGCache.getSVGUniverse();
    public static final int INTERP_NEAREST_NEIGHBOR = 0;
    public static final int INTERP_BILINEAR = 1;
    public static final int INTERP_BICUBIC = 2;
    
    private boolean antiAlias;
    private int interpolation = INTERP_NEAREST_NEIGHBOR;
    private boolean clipToViewbox;
    
//    private String svgPath;
    URI svgURI;
    
//    private boolean scaleToFit;
    AffineTransform scaleXform = new AffineTransform();

    public static final int AUTOSIZE_NONE = 0;
    public static final int AUTOSIZE_HORIZ = 1;
    public static final int AUTOSIZE_VERT = 2;
    public static final int AUTOSIZE_BESTFIT = 3;
    public static final int AUTOSIZE_STRETCH = 4;
    private int autosize = AUTOSIZE_NONE;
    
//    Dimension preferredSize = new Dimension(100, 100);
    Dimension preferredSize;
    
    /** Creates a new instance of SVGIcon */
    public SVGIcon()
    {
    }
    
    public void addPropertyChangeListener(PropertyChangeListener p)
    {
        changes.addPropertyChangeListener(p);
    }
    
    public void removePropertyChangeListener(PropertyChangeListener p)
    {
        changes.removePropertyChangeListener(p);
    }
    
    /**
     * @return height of this icon
     */
    public int getIconHeight()
    {
        if (preferredSize != null &&
                (autosize == AUTOSIZE_VERT || autosize == AUTOSIZE_STRETCH 
                || autosize == AUTOSIZE_BESTFIT))
        {
            return preferredSize.height;
        }
        
        SVGDiagram diagram = svgUniverse.getDiagram(svgURI);
        if (diagram == null)
        {
            return 0;
        }
        return (int)diagram.getHeight();
    }
    
    /**
     * @return width of this icon
     */
    public int getIconWidth()
    {
        if (preferredSize != null &&
                (autosize == AUTOSIZE_HORIZ || autosize == AUTOSIZE_STRETCH 
                || autosize == AUTOSIZE_BESTFIT))
        {
            return preferredSize.width;
        }
        
        SVGDiagram diagram = svgUniverse.getDiagram(svgURI);
        if (diagram == null)
        {
            return 0;
        }
        return (int)diagram.getWidth();
    }
    
    /**
     * Draws the icon to the specified component.
     * @param comp - Component to draw icon to.  This is ignored by SVGIcon, and can be set to null; only gg is used for drawing the icon
     * @param gg - Graphics context to render SVG content to
     * @param x - X coordinate to draw icon
     * @param y - Y coordinate to draw icon
     */
    public void paintIcon(Component comp, Graphics gg, int x, int y)
    {
        //Copy graphics object so that 
        Graphics2D g = (Graphics2D)gg.create();
        paintIcon(comp, g, x, y);
        g.dispose();
    }
    
    private void paintIcon(Component comp, Graphics2D g, int x, int y)
    {
        Object oldAliasHint = g.getRenderingHint(RenderingHints.KEY_ANTIALIASING);
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, antiAlias ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
        
        Object oldInterpolationHint = g.getRenderingHint(RenderingHints.KEY_INTERPOLATION);
        switch (interpolation)
        {
            case INTERP_NEAREST_NEIGHBOR:
                g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);
                break;
            case INTERP_BILINEAR:
                g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
                break;
            case INTERP_BICUBIC:
                g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
                break;
        }
        
        
        SVGDiagram diagram = svgUniverse.getDiagram(svgURI);
        if (diagram == null)
        {
            return;
        }
        
        g.translate(x, y);
        diagram.setIgnoringClipHeuristic(!clipToViewbox);
        if (clipToViewbox)
        {
            g.setClip(new Rectangle2D.Float(0, 0, diagram.getWidth(), diagram.getHeight()));
        }
        
        
        
        if (autosize == AUTOSIZE_NONE)
        {
            try
            {
                diagram.render(g);
                g.translate(-x, -y);
                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, oldAliasHint);
            }
            catch (Exception e)
            {
                throw new RuntimeException(e);
            }
            return;
        }
        
        final int width = getIconWidth();
        final int height = getIconHeight();
//        int width = getWidth();
//        int height = getHeight();
        
        if (width == 0 || height == 0)
        {
            return;
        }
        
//        if (width == 0 || height == 0)
//        {
//           //Chances are we're rendering offscreen
//            Dimension dim = getSize();
//            width = dim.width;
//            height = dim.height;
//            return;
//        }
        
//        g.setClip(0, 0, width, height);
        
        
//        final Rectangle2D.Double rect = new Rectangle2D.Double();
//        diagram.getViewRect(rect);
//        
//        scaleXform.setToScale(width / rect.width, height / rect.height);
        double diaWidth = diagram.getWidth();
        double diaHeight = diagram.getHeight();
        
        double scaleW = 1;
        double scaleH = 1;
        if (autosize == AUTOSIZE_BESTFIT)
        {
            scaleW = scaleH = (height / diaHeight < width / diaWidth) 
                    ? height / diaHeight : width / diaWidth;
        }
        else if (autosize == AUTOSIZE_HORIZ)
        {
            scaleW = scaleH = width / diaWidth;
        }
        else if (autosize == AUTOSIZE_VERT)
        {
            scaleW = scaleH = height / diaHeight;
        }
        else if (autosize == AUTOSIZE_STRETCH)
        {
            scaleW = width / diaWidth;
            scaleH = height / diaHeight;
        }
        scaleXform.setToScale(scaleW, scaleH);
        
        AffineTransform oldXform = g.getTransform();
        g.transform(scaleXform);
        
        try
        {
            diagram.render(g);
        }
        catch (SVGException e)
        {
            throw new RuntimeException(e);
        }
        
        g.setTransform(oldXform);
        
        
        g.translate(-x, -y);
        
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, oldAliasHint);
        if (oldInterpolationHint != null)
        {
            g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, oldInterpolationHint);
        }
    }
    
    /**
     * @return the universe this icon draws it's SVGDiagrams from
     */
    public SVGUniverse getSvgUniverse()
    {
        return svgUniverse;
    }
    
    public void setSvgUniverse(SVGUniverse svgUniverse)
    {
        SVGUniverse old = this.svgUniverse;
        this.svgUniverse = svgUniverse;
        changes.firePropertyChange(""svgUniverse"", old, svgUniverse);
    }
    
    /**
     * @return the uni of the document being displayed by this icon
     */
    public URI getSvgURI()
    {
        return svgURI;
    }
    
    /**
     * Loads an SVG document from a URI.
     * @param svgURI - URI to load document from
     */
    public void setSvgURI(URI svgURI)
    {
        URI old = this.svgURI;
        this.svgURI = svgURI;
        
        SVGDiagram diagram = svgUniverse.getDiagram(svgURI);
        if (diagram != null)
        {
            Dimension size = getPreferredSize();
            if (size == null)
            {
                size = new Dimension((int)diagram.getRoot().getDeviceWidth(), (int)diagram.getRoot().getDeviceHeight());
            }
            diagram.setDeviceViewport(new Rectangle(0, 0, size.width, size.height));
        }
        
        changes.firePropertyChange(""svgURI"", old, svgURI);
    }
    
    /**
     * Loads an SVG document from the classpath.  This function is equivilant to
     * setSvgURI(new URI(getClass().getResource(resourcePath).toString());
     * @param resourcePath - resource to load
     */
    public void setSvgResourcePath(String resourcePath)
    {
        URI old = this.svgURI;
        
        try
        {
            svgURI = new URI(getClass().getResource(resourcePath).toString());
            changes.firePropertyChange(""svgURI"", old, svgURI);
            
            SVGDiagram diagram = svgUniverse.getDiagram(svgURI);
            if (diagram != null)
            {
                diagram.setDeviceViewport(new Rectangle(0, 0, preferredSize.width, preferredSize.height));
            }
            
        }
        catch (Exception e)
        {
            svgURI = old;
        }
    }
    
    /**
     * If this SVG document has a viewbox, if scaleToFit is set, will scale the viewbox to match the
     * preferred size of this icon
     * @deprecated 
     * @return 
     */
    public boolean isScaleToFit()
    {
        return autosize == AUTOSIZE_STRETCH;
    }
    
    /**
     * @deprecated 
     * @return 
     */
    public void setScaleToFit(boolean scaleToFit)
    {
        setAutosize(AUTOSIZE_STRETCH);
//        boolean old = this.scaleToFit;
//        this.scaleToFit = scaleToFit;
//        firePropertyChange(""scaleToFit"", old, scaleToFit);
    }
    
    public Dimension getPreferredSize()
    {
        if (preferredSize == null)
        {
            SVGDiagram diagram = svgUniverse.getDiagram(svgURI);
            if (diagram != null)
            {
                //preferredSize = new Dimension((int)diagram.getWidth(), (int)diagram.getHeight());
                setPreferredSize(new Dimension((int)diagram.getWidth(), (int)diagram.getHeight()));
            }
        }
        
        return new Dimension(preferredSize);
    }
    
    public void setPreferredSize(Dimension preferredSize)
    {
        Dimension old = this.preferredSize;
        this.preferredSize = preferredSize;
        
        SVGDiagram diagram = svgUniverse.getDiagram(svgURI);
        if (diagram != null)
        {
            diagram.setDeviceViewport(new Rectangle(0, 0, preferredSize.width, preferredSize.height));
        }
        
        changes.firePropertyChange(""preferredSize"", old, preferredSize);
    }
    
    
    /**
     * @return true if antiAliasing is turned on.
     * @deprecated
     */
    public boolean getUseAntiAlias()
    {
        return getAntiAlias();
    }
    
    /**
     * @param antiAlias true to use antiAliasing.
     * @deprecated
     */
    public void setUseAntiAlias(boolean antiAlias)
    {
        setAntiAlias(antiAlias);
    }
    
    /**
     * @return true if antiAliasing is turned on.
     */
    public boolean getAntiAlias()
    {
        return antiAlias;
    }
    
    /**
     * @param antiAlias true to use antiAliasing.
     */
    public void setAntiAlias(boolean antiAlias)
    {
        boolean old = this.antiAlias;
        this.antiAlias = antiAlias;
        changes.firePropertyChange(""antiAlias"", old, antiAlias);
    }
    
    /**
     * @return interpolation used in rescaling images
     */
    public int getInterpolation()
    {
        return interpolation;
    }
    
    /**
     * @param interpolation Interpolation value used in rescaling images.
     * Should be one of
     *    INTERP_NEAREST_NEIGHBOR - Fastest, one pixel resampling, poor quality
     *    INTERP_BILINEAR - four pixel resampling
     *    INTERP_BICUBIC - Slowest, nine pixel resampling, best quality
     */
    public void setInterpolation(int interpolation)
    {
        int old = this.interpolation;
        this.interpolation = interpolation;
        changes.firePropertyChange(""interpolation"", old, interpolation);
    }
    
    /**
     * clipToViewbox will set a clip box equivilant to the SVG's viewbox before
     * rendering.
     */
    public boolean isClipToViewbox()
    {
        return clipToViewbox;
    }
    
    public void setClipToViewbox(boolean clipToViewbox)
    {
        this.clipToViewbox = clipToViewbox;
    }

    /**
     * @return the autosize
     */
    public int getAutosize()
    {
        return autosize;
    }

    /**
     * @param autosize the autosize to set
     */
    public void setAutosize(int autosize)
    {
        int oldAutosize = this.autosize;
        this.autosize = autosize;
        changes.firePropertyChange(PROP_AUTOSIZE, oldAutosize, autosize);
    }
        
}
"
SVGPanel.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on April 21, 2005, 10:43 AM
 */

package com.kitfox.svg.app.beans;

import com.kitfox.svg.*;
import java.awt.*;
import java.awt.geom.*;
import java.net.*;
import javax.swing.*;

/**
 *
 * @author  kitfox
 */
public class SVGPanel extends JPanel
{
    public static final long serialVersionUID = 1;
    public static final String PROP_AUTOSIZE = ""PROP_AUTOSIZE"";

    SVGUniverse svgUniverse = SVGCache.getSVGUniverse();
    
    private boolean antiAlias;
    
//    private String svgPath;
    URI svgURI;

//    private boolean scaleToFit;
    AffineTransform scaleXform = new AffineTransform();

    public static final int AUTOSIZE_NONE = 0;
    public static final int AUTOSIZE_HORIZ = 1;
    public static final int AUTOSIZE_VERT = 2;
    public static final int AUTOSIZE_BESTFIT = 3;
    public static final int AUTOSIZE_STRETCH = 4;
    private int autosize = AUTOSIZE_NONE;
    
    /** Creates new form SVGIcon */
    public SVGPanel()
    {
        initComponents();
    }
        
    public int getSVGHeight()
    {
        if (autosize == AUTOSIZE_VERT || autosize == AUTOSIZE_STRETCH 
                || autosize == AUTOSIZE_BESTFIT)
        {
            return getPreferredSize().height;
        }
        
        SVGDiagram diagram = svgUniverse.getDiagram(svgURI);
        if (diagram == null)
        {
            return 0;
        }
        return (int)diagram.getHeight();
    }
    
    public int getSVGWidth()
    {
        if (autosize == AUTOSIZE_HORIZ || autosize == AUTOSIZE_STRETCH 
                || autosize == AUTOSIZE_BESTFIT)
        {
            return getPreferredSize().width;
        }
        
        SVGDiagram diagram = svgUniverse.getDiagram(svgURI);
        if (diagram == null)
        {
            return 0;
        }
        return (int)diagram.getWidth();
    }
    
    public void paintComponent(Graphics gg)
    {
        super.paintComponent(gg);

        Graphics2D g = (Graphics2D)gg.create();
        paintComponent(g);
        g.dispose();
    }
    
    private void paintComponent(Graphics2D g)
    {
        Object oldAliasHint = g.getRenderingHint(RenderingHints.KEY_ANTIALIASING);
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, antiAlias ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);

        
        SVGDiagram diagram = svgUniverse.getDiagram(svgURI);
        if (diagram == null)
        {
            return;
        }
        
        if (autosize == AUTOSIZE_NONE)
        {
            try
            {
                diagram.render(g);
                g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, oldAliasHint);
            }
            catch (SVGException e)
            {
                throw new RuntimeException(e);
            }
            return;
        }
        
        Dimension dim = getSize();
        final int width = dim.width;
        final int height = dim.height;
            
//        final Rectangle2D.Double rect = new Rectangle2D.Double();
//        diagram.getViewRect(rect);
        
        double diaWidth = diagram.getWidth();
        double diaHeight = diagram.getHeight();
        
        double scaleW = 1;
        double scaleH = 1;
        if (autosize == AUTOSIZE_BESTFIT)
        {
            scaleW = scaleH = (height / diaHeight < width / diaWidth) 
                    ? height / diaHeight : width / diaWidth;
        }
        else if (autosize == AUTOSIZE_HORIZ)
        {
            scaleW = scaleH = width / diaWidth;
        }
        else if (autosize == AUTOSIZE_VERT)
        {
            scaleW = scaleH = height / diaHeight;
        }
        else if (autosize == AUTOSIZE_STRETCH)
        {
            scaleW = width / diaWidth;
            scaleH = height / diaHeight;
        }
        scaleXform.setToScale(scaleW, scaleH);
        
        AffineTransform oldXform = g.getTransform();
        g.transform(scaleXform);

        try
        {
            diagram.render(g);
        }
        catch (SVGException e)
        {
            throw new RuntimeException(e);
        }
        
        g.setTransform(oldXform);
        
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, oldAliasHint);
    }
    
    public SVGUniverse getSvgUniverse()
    {
        return svgUniverse;
    }

    public void setSvgUniverse(SVGUniverse svgUniverse)
    {
        SVGUniverse old = this.svgUniverse;
        this.svgUniverse = svgUniverse;
        firePropertyChange(""svgUniverse"", old, svgUniverse);
    }

    public URI getSvgURI()
    {
        return svgURI;
    }

    public void setSvgURI(URI svgURI)
    {
        URI old = this.svgURI;
        this.svgURI = svgURI;
        firePropertyChange(""svgURI"", old, svgURI);
    }
    
    /**
     * Most resources your component will want to access will be resources on your classpath.  
     * This method will interpret the passed string as a path in the classpath and use
     * Class.getResource() to determine the URI of the SVG.
     */
    public void setSvgResourcePath(String resourcePath) throws SVGException
    {
        URI old = this.svgURI;
        
        try
        {
            svgURI = new URI(getClass().getResource(resourcePath).toString());
//System.err.println(""SVGPanel: new URI "" + svgURI + "" from path "" + resourcePath);
            
            firePropertyChange(""svgURI"", old, svgURI);
            
            repaint();
        }
        catch (Exception e)
        {
            throw new SVGException(""Could not resolve path "" + resourcePath, e);
//            svgURI = old;
        }
    }
    
    /**
     * If this SVG document has a viewbox, if scaleToFit is set, will scale the viewbox to match the
     * preferred size of this icon
     * @deprecated 
     * @return 
     */
    public boolean isScaleToFit()
    {
        return autosize == AUTOSIZE_STRETCH;
    }
    
    /**
     * @deprecated 
     * @return 
     */
    public void setScaleToFit(boolean scaleToFit)
    {
        setAutosize(AUTOSIZE_STRETCH);
//        boolean old = this.scaleToFit;
//        this.scaleToFit = scaleToFit;
//        firePropertyChange(""scaleToFit"", old, scaleToFit);
    }
    
    /**
     * @return true if antiAliasing is turned on.
     * @deprecated
     */
    public boolean getUseAntiAlias()
    {
        return getAntiAlias();
    }

    /**
     * @param antiAlias true to use antiAliasing.
     * @deprecated
     */
    public void setUseAntiAlias(boolean antiAlias)
    {
        setAntiAlias(antiAlias);
    }
    
    /**
     * @return true if antiAliasing is turned on.
     */
    public boolean getAntiAlias()
    {
        return antiAlias;
    }

    /**
     * @param antiAlias true to use antiAliasing.
     */
    public void setAntiAlias(boolean antiAlias)
    {
        boolean old = this.antiAlias;
        this.antiAlias = antiAlias;
        firePropertyChange(""antiAlias"", old, antiAlias);
    }

    /**
     * @return the autosize
     */
    public int getAutosize()
    {
        return autosize;
    }

    /**
     * @param autosize the autosize to set
     */
    public void setAutosize(int autosize)
    {
        int oldAutosize = this.autosize;
        this.autosize = autosize;
        firePropertyChange(PROP_AUTOSIZE, oldAutosize, autosize);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate=""collapsed"" desc="" Generated Code "">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        setLayout(new java.awt.BorderLayout());

    }
    // </editor-fold>//GEN-END:initComponents
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    
}
"
Handler.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 */

package com.kitfox.svg.app.data;

import com.kitfox.svg.SVGConst;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author kitfox
 */
public class Handler extends URLStreamHandler
{
    class Connection extends URLConnection
    {
        String mime;
        byte[] buf;

        public Connection(URL url)
        {
            super(url);

            String path = url.getPath();
            int idx = path.indexOf(';');
            mime = path.substring(0, idx);
            String content = path.substring(idx + 1);

            if (content.startsWith(""base64,""))
            {
                content = content.substring(7);
                try
                {
                    buf = new sun.misc.BASE64Decoder().decodeBuffer(content);
                }
                catch (IOException e)
                {
                    Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
                }
            }
        }
        
        public void connect() throws IOException
        {
        }

        public String getHeaderField(String name)
        {
            if (""content-type"".equals(name))
            {
                return mime;
            }

            return super.getHeaderField(name);
        }

        public InputStream getInputStream() throws IOException
        {
            return new ByteArrayInputStream(buf);
        }

//        public Object getContent() throws IOException
//        {
//            BufferedImage img = ImageIO.read(getInputStream());
//        }
    }

    protected URLConnection openConnection(URL u) throws IOException
    {
        return new Connection(u);
    }

}
"
HandlerFactory.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 */

package com.kitfox.svg.app.data;

import java.net.URLStreamHandler;
import java.net.URLStreamHandlerFactory;

/**
 *
 * @author kitfox
 */
public class HandlerFactory implements URLStreamHandlerFactory
{
    static Handler handler = new Handler();

    public URLStreamHandler createURLStreamHandler(String protocol)
    {
        if (""data"".equals(protocol))
        {
            return handler;
        }
        return null;
    }
}
"
MainFrame.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 6, 2004, 1:19 AM
 */

package com.kitfox.svg.app;

/**
 *
 * @author  kitfox
 */
public class MainFrame extends javax.swing.JFrame
{
    public static final long serialVersionUID = 1;
    
    /** Creates new form MainFrame */
    public MainFrame()
    {
        initComponents();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents()//GEN-BEGIN:initComponents
    {
        jPanel1 = new javax.swing.JPanel();
        bn_svgViewer = new javax.swing.JButton();
        bn_svgViewer1 = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        bn_quit = new javax.swing.JButton();

        setTitle(""SVG Salamander - Application Launcher"");
        addWindowListener(new java.awt.event.WindowAdapter()
        {
            public void windowClosing(java.awt.event.WindowEvent evt)
            {
                exitForm(evt);
            }
        });

        jPanel1.setLayout(new javax.swing.BoxLayout(jPanel1, javax.swing.BoxLayout.Y_AXIS));

        bn_svgViewer.setText(""SVG Viewer (No animation)"");
        bn_svgViewer.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                bn_svgViewerActionPerformed(evt);
            }
        });

        jPanel1.add(bn_svgViewer);

        bn_svgViewer1.setText(""SVG Player (Animation)"");
        bn_svgViewer1.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                bn_svgViewer1ActionPerformed(evt);
            }
        });

        jPanel1.add(bn_svgViewer1);

        getContentPane().add(jPanel1, java.awt.BorderLayout.CENTER);

        bn_quit.setText(""Quit"");
        bn_quit.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                bn_quitActionPerformed(evt);
            }
        });

        jPanel2.add(bn_quit);

        getContentPane().add(jPanel2, java.awt.BorderLayout.SOUTH);

        pack();
    }//GEN-END:initComponents

    private void bn_svgViewer1ActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_bn_svgViewer1ActionPerformed
    {//GEN-HEADEREND:event_bn_svgViewer1ActionPerformed
        SVGPlayer.main(null);

        close();
    }//GEN-LAST:event_bn_svgViewer1ActionPerformed

    private void bn_svgViewerActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_bn_svgViewerActionPerformed
    {//GEN-HEADEREND:event_bn_svgViewerActionPerformed
        SVGViewer.main(null);

        close();
    }//GEN-LAST:event_bn_svgViewerActionPerformed

    private void bn_quitActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_bn_quitActionPerformed
    {//GEN-HEADEREND:event_bn_quitActionPerformed
        exitForm(null);
    }//GEN-LAST:event_bn_quitActionPerformed
    
    /** Exit the Application */
    private void exitForm(java.awt.event.WindowEvent evt)//GEN-FIRST:event_exitForm
    {
        System.exit(0);
    }//GEN-LAST:event_exitForm
    
    private void close()
    {
        this.setVisible(false);
        this.dispose();
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[])
    {
        new MainFrame().setVisible(true);
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton bn_quit;
    private javax.swing.JButton bn_svgViewer;
    private javax.swing.JButton bn_svgViewer1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    // End of variables declaration//GEN-END:variables
    
}
"
PlayerDialog.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 28, 2004, 9:56 PM
 */

package com.kitfox.svg.app;

/**
 *
 * @author  kitfox
 */
public class PlayerDialog extends javax.swing.JDialog implements PlayerThreadListener
{
    public static final long serialVersionUID = 1;
    
    PlayerThread thread;
    
    final SVGPlayer parent;
    
    /** Creates new form PlayerDialog */
    public PlayerDialog(SVGPlayer parent)
    {
        super(parent, false);
        initComponents();
        
        this.parent = parent;
        
        thread = new PlayerThread();
        thread.addListener(this);
        
        text_timeStepActionPerformed(null);
    }
    
    public void updateTime(double curTime, double timeStep, int playState)
    {
        if (playState == PlayerThread.PS_STOP) return;
        
        text_curTime.setText("""" + (float)curTime);
        parent.updateTime(curTime);
//        text_timeStep.setText("""" + (int)(1.0 / timeStep));
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate=""collapsed"" desc="" Generated Code "">//GEN-BEGIN:initComponents
    private void initComponents()
    {
        jPanel1 = new javax.swing.JPanel();
        bn_playBack = new javax.swing.JButton();
        bn_stop = new javax.swing.JButton();
        bn_playFwd = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jPanel3 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        text_curTime = new javax.swing.JTextField();
        bn_time0 = new javax.swing.JButton();
        jPanel4 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        text_timeStep = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle(""Player"");
        addWindowListener(new java.awt.event.WindowAdapter()
        {
            public void windowClosed(java.awt.event.WindowEvent evt)
            {
                formWindowClosed(evt);
            }
        });

        bn_playBack.setText(""<"");
        bn_playBack.setToolTipText(""Play backwards"");
        bn_playBack.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                bn_playBackActionPerformed(evt);
            }
        });

        jPanel1.add(bn_playBack);

        bn_stop.setText(""||"");
        bn_stop.setToolTipText(""Stop playback"");
        bn_stop.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                bn_stopActionPerformed(evt);
            }
        });

        jPanel1.add(bn_stop);

        bn_playFwd.setText("">"");
        bn_playFwd.setToolTipText(""Play Forwards"");
        bn_playFwd.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                bn_playFwdActionPerformed(evt);
            }
        });

        jPanel1.add(bn_playFwd);

        getContentPane().add(jPanel1, java.awt.BorderLayout.NORTH);

        jPanel2.setLayout(new javax.swing.BoxLayout(jPanel2, javax.swing.BoxLayout.Y_AXIS));

        jLabel1.setText(""Cur Time"");
        jPanel3.add(jLabel1);

        text_curTime.setHorizontalAlignment(javax.swing.JTextField.LEFT);
        text_curTime.setText(""0"");
        text_curTime.setPreferredSize(new java.awt.Dimension(100, 21));
        text_curTime.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                text_curTimeActionPerformed(evt);
            }
        });
        text_curTime.addFocusListener(new java.awt.event.FocusAdapter()
        {
            public void focusLost(java.awt.event.FocusEvent evt)
            {
                text_curTimeFocusLost(evt);
            }
        });

        jPanel3.add(text_curTime);

        bn_time0.setText(""Time 0"");
        bn_time0.setToolTipText(""Reset time to first frame"");
        bn_time0.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                bn_time0ActionPerformed(evt);
            }
        });

        jPanel3.add(bn_time0);

        jPanel2.add(jPanel3);

        jLabel2.setText(""Frames Per Second"");
        jPanel4.add(jLabel2);

        text_timeStep.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        text_timeStep.setText(""60"");
        text_timeStep.setPreferredSize(new java.awt.Dimension(100, 21));
        text_timeStep.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                text_timeStepActionPerformed(evt);
            }
        });
        text_timeStep.addFocusListener(new java.awt.event.FocusAdapter()
        {
            public void focusLost(java.awt.event.FocusEvent evt)
            {
                text_timeStepFocusLost(evt);
            }
        });

        jPanel4.add(text_timeStep);

        jPanel2.add(jPanel4);

        getContentPane().add(jPanel2, java.awt.BorderLayout.CENTER);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void bn_time0ActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_bn_time0ActionPerformed
    {//GEN-HEADEREND:event_bn_time0ActionPerformed
        thread.setCurTime(0);
    }//GEN-LAST:event_bn_time0ActionPerformed

    private void bn_playFwdActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_bn_playFwdActionPerformed
    {//GEN-HEADEREND:event_bn_playFwdActionPerformed
        thread.setPlayState(PlayerThread.PS_PLAY_FWD);
    }//GEN-LAST:event_bn_playFwdActionPerformed

    private void bn_stopActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_bn_stopActionPerformed
    {//GEN-HEADEREND:event_bn_stopActionPerformed
        thread.setPlayState(PlayerThread.PS_STOP);
    }//GEN-LAST:event_bn_stopActionPerformed

    private void bn_playBackActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_bn_playBackActionPerformed
    {//GEN-HEADEREND:event_bn_playBackActionPerformed
        thread.setPlayState(PlayerThread.PS_PLAY_BACK);
    }//GEN-LAST:event_bn_playBackActionPerformed

    private void formWindowClosed(java.awt.event.WindowEvent evt)//GEN-FIRST:event_formWindowClosed
    {//GEN-HEADEREND:event_formWindowClosed
//        thread.exit();
    }//GEN-LAST:event_formWindowClosed

    private void text_timeStepFocusLost(java.awt.event.FocusEvent evt)//GEN-FIRST:event_text_timeStepFocusLost
    {//GEN-HEADEREND:event_text_timeStepFocusLost
        text_timeStepActionPerformed(null);
    }//GEN-LAST:event_text_timeStepFocusLost

    private void text_timeStepActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_text_timeStepActionPerformed
    {//GEN-HEADEREND:event_text_timeStepActionPerformed
        try
        {
            int val = Integer.parseInt(text_timeStep.getText());
            thread.setTimeStep(1.0 / val);
        }
        catch (Exception e)
        {
        }
        
        double d = thread.getTimeStep();
        String newStrn = """" + (int)(1f / d);
        if (newStrn.equals(text_timeStep.getText())) return;
        text_timeStep.setText(newStrn);
        
//        text_timeStepActionPerformed(null);
    }//GEN-LAST:event_text_timeStepActionPerformed

    private void text_curTimeActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_text_curTimeActionPerformed
    {//GEN-HEADEREND:event_text_curTimeActionPerformed
        try
        {
            double val = Double.parseDouble(text_curTime.getText());
            thread.setCurTime(val);
        }
        catch (Exception e)
        {
        }
        
        double d = thread.getCurTime();
        text_curTime.setText("""" + (float)d);
        
        text_timeStepActionPerformed(null);
    }//GEN-LAST:event_text_curTimeActionPerformed

    private void text_curTimeFocusLost(java.awt.event.FocusEvent evt)//GEN-FIRST:event_text_curTimeFocusLost
    {//GEN-HEADEREND:event_text_curTimeFocusLost
        text_curTimeActionPerformed(null);
    }//GEN-LAST:event_text_curTimeFocusLost
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton bn_playBack;
    private javax.swing.JButton bn_playFwd;
    private javax.swing.JButton bn_stop;
    private javax.swing.JButton bn_time0;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JTextField text_curTime;
    private javax.swing.JTextField text_timeStep;
    // End of variables declaration//GEN-END:variables
    
}
"
PlayerThread.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 28, 2004, 10:07 PM
 */


package com.kitfox.svg.app;

import java.util.*;

/**
 *
 * @author  kitfox
 */
public class PlayerThread implements Runnable
{
    HashSet listeners = new HashSet();
    
    double curTime = 0;
    double timeStep = .2;
    
    public static final int PS_STOP = 0;
    public static final int PS_PLAY_FWD = 1;
    public static final int PS_PLAY_BACK = 2;
    
    int playState = PS_STOP;
    
    Thread thread;
    
    /** Creates a new instance of PlayerThread */
    public PlayerThread()
    {
        thread = new Thread(this);
        thread.start();
    }
    
    public void run()
    {
        while (thread != null)
        {
            synchronized (this)
            {
                switch (playState)
                {
                    case PS_PLAY_FWD:
                        curTime += timeStep;
                        break;
                    case PS_PLAY_BACK:
                        curTime -= timeStep;
                        if (curTime < 0) curTime = 0;
                        break;
                    default:
                    case PS_STOP:
                        break;
                }
                
                fireTimeUpdateEvent();
            }
            
            try
            {
                Thread.sleep((long)(timeStep * 1000));
            }
            catch (Exception e) 
            { 
                throw new RuntimeException(e); 
            }
        }
    }
    
    public void exit() { thread = null; }
    public synchronized void addListener(PlayerThreadListener listener) 
    {
        listeners.add(listener); 
    }
    
    public synchronized double getCurTime() { return curTime; }
    
    public synchronized void setCurTime(double time)
    {
        curTime = time;
    }
    
    public synchronized double getTimeStep() { return timeStep; }
    
    public synchronized void setTimeStep(double time)
    {
        timeStep = time;
        if (timeStep < .01) timeStep = .01;
    }
    
    public synchronized int getPlayState() { return playState; }
    
    public synchronized void setPlayState(int playState)
    {
        this.playState = playState;
    }
    
    private void fireTimeUpdateEvent()
    {
        for (Iterator it = listeners.iterator(); it.hasNext();)
        {
            PlayerThreadListener listener = (PlayerThreadListener)it.next();
            listener.updateTime(curTime, timeStep, playState);
        }
    }
}
"
PlayerThreadListener.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 28, 2004, 10:15 PM
 */

package com.kitfox.svg.app;

/**
 *
 * @author  kitfox
 */
public interface PlayerThreadListener
{
    public void updateTime(double curTime, double timeStep, int playState);
}
"
SVGPlayer.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on April 3, 2004, 5:28 PM
 */

package com.kitfox.svg.app;


import com.kitfox.svg.SVGConst;
import com.kitfox.svg.SVGDiagram;
import com.kitfox.svg.SVGDisplayPanel;
import com.kitfox.svg.SVGElement;
import com.kitfox.svg.SVGException;
import com.kitfox.svg.SVGUniverse;
import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;
import java.io.File;
import java.io.InputStream;
import java.net.URI;
import java.net.URL;
import java.net.URLEncoder;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class SVGPlayer extends javax.swing.JFrame
{
    public static final long serialVersionUID = 1;

    SVGDisplayPanel svgDisplayPanel = new SVGDisplayPanel();

    final PlayerDialog playerDialog;
    
    SVGUniverse universe;
    
    /** FileChooser for running in trusted environments */
    final JFileChooser fileChooser;
    {
//        fileChooser = new JFileChooser(new File("".""));
        JFileChooser fc = null;
        try
        {
            fc = new JFileChooser();
            fc.setFileFilter(
                new javax.swing.filechooser.FileFilter() {
                    final Matcher matchLevelFile = Pattern.compile("".*\\.svg[z]?"").matcher("""");

                    public boolean accept(File file)
                    {
                        if (file.isDirectory()) return true;

                        matchLevelFile.reset(file.getName());
                        return matchLevelFile.matches();
                    }

                    public String getDescription() { return ""SVG file (*.svg, *.svgz)""; }
                }
            );
        }
        catch (AccessControlException ex)
        {
            //Do not create file chooser if webstart refuses permissions
        }
        fileChooser = fc;
    }

    /** Backup file service for opening files in WebStart situations */
    /*
    final FileOpenService fileOpenService;
    {
        try 
        { 
            fileOpenService = (FileOpenService)ServiceManager.lookup(""javax.jnlp.FileOpenService""); 
        } 
        catch (UnavailableServiceException e) 
        { 
            fileOpenService = null; 
        } 
    }
     */
    
    /** Creates new form SVGViewer */
    public SVGPlayer() {
        initComponents();

        setSize(800, 600);

        svgDisplayPanel.setBgColor(Color.white);
        svgDisplayPanel.addMouseListener(new MouseAdapter()
        {
            public void mouseClicked(MouseEvent evt)
            {
                SVGDiagram diagram = svgDisplayPanel.getDiagram();
                if (diagram == null) return;
                
                System.out.println(""Picking at cursor ("" + evt.getX() + "", "" + evt.getY() + "")"");
                try
                {
                    List paths = diagram.pick(new Point2D.Float(evt.getX(), evt.getY()), null);
                    for (int i = 0; i < paths.size(); i++)
                    {
                        ArrayList path = (ArrayList)paths.get(i);
                        System.out.println(pathToString(path));
                    }
                }
                catch (SVGException ex)
                {
                    Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, 
                        ""Could not pick"", ex);
                }
            }
        }
        );
        
        svgDisplayPanel.setPreferredSize(getSize());
        scrollPane_svgArea.setViewportView(svgDisplayPanel);
        
        playerDialog = new PlayerDialog(this);
    }
    
    private String pathToString(List path)
    {
        if (path.size() == 0) return """";
        
        StringBuffer sb = new StringBuffer();
        sb.append(path.get(0));
        for (int i = 1; i < path.size(); i++)
        {
            sb.append(""/"");
            sb.append(((SVGElement)path.get(i)).getId());
        }
        return sb.toString();
    }
    
    public void updateTime(double curTime)
    {
        try
        {
            if (universe != null)
            {
                universe.setCurTime(curTime);
                universe.updateTime();
    //            svgDisplayPanel.updateTime(curTime);
                repaint();
            }
        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
        }
    }

    private void loadURL(URL url)
    {
        boolean verbose = cmCheck_verbose.isSelected();

        universe = new SVGUniverse();
        universe.setVerbose(verbose);
        SVGDiagram diagram = null;

        if (!CheckBoxMenuItem_anonInputStream.isSelected())
        {
            //Load from a disk with a valid URL
            URI uri = universe.loadSVG(url);

            if (verbose) System.err.println(uri.toString());

            diagram = universe.getDiagram(uri);
        }
        else
        {
            //Load from a stream with no particular valid URL
            try
            {
                InputStream is = url.openStream();
                URI uri = universe.loadSVG(is, ""defaultName"");

                if (verbose) System.err.println(uri.toString());

                diagram = universe.getDiagram(uri);
            }
            catch (Exception e)
            {
                Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
            }
        }

        svgDisplayPanel.setDiagram(diagram);
        repaint();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate=""collapsed"" desc="" Generated Code "">//GEN-BEGIN:initComponents
    private void initComponents()
    {
        scrollPane_svgArea = new javax.swing.JScrollPane();
        jMenuBar1 = new javax.swing.JMenuBar();
        menu_file = new javax.swing.JMenu();
        cm_loadFile = new javax.swing.JMenuItem();
        cm_loadUrl = new javax.swing.JMenuItem();
        menu_window = new javax.swing.JMenu();
        cm_player = new javax.swing.JMenuItem();
        jSeparator2 = new javax.swing.JSeparator();
        cm_800x600 = new javax.swing.JMenuItem();
        CheckBoxMenuItem_anonInputStream = new javax.swing.JCheckBoxMenuItem();
        cmCheck_verbose = new javax.swing.JCheckBoxMenuItem();
        menu_help = new javax.swing.JMenu();
        cm_about = new javax.swing.JMenuItem();

        setTitle(""SVG Player - Salamander Project"");
        addWindowListener(new java.awt.event.WindowAdapter()
        {
            public void windowClosing(java.awt.event.WindowEvent evt)
            {
                exitForm(evt);
            }
        });

        getContentPane().add(scrollPane_svgArea, java.awt.BorderLayout.CENTER);

        menu_file.setMnemonic('f');
        menu_file.setText(""File"");
        cm_loadFile.setMnemonic('l');
        cm_loadFile.setText(""Load File..."");
        cm_loadFile.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                cm_loadFileActionPerformed(evt);
            }
        });

        menu_file.add(cm_loadFile);

        cm_loadUrl.setText(""Load URL..."");
        cm_loadUrl.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                cm_loadUrlActionPerformed(evt);
            }
        });

        menu_file.add(cm_loadUrl);

        jMenuBar1.add(menu_file);

        menu_window.setText(""Window"");
        cm_player.setText(""Player"");
        cm_player.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                cm_playerActionPerformed(evt);
            }
        });

        menu_window.add(cm_player);

        menu_window.add(jSeparator2);

        cm_800x600.setText(""800 x 600"");
        cm_800x600.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                cm_800x600ActionPerformed(evt);
            }
        });

        menu_window.add(cm_800x600);

        CheckBoxMenuItem_anonInputStream.setText(""Anonymous Input Stream"");
        menu_window.add(CheckBoxMenuItem_anonInputStream);

        cmCheck_verbose.setText(""Verbose"");
        cmCheck_verbose.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                cmCheck_verboseActionPerformed(evt);
            }
        });

        menu_window.add(cmCheck_verbose);

        jMenuBar1.add(menu_window);

        menu_help.setText(""Help"");
        cm_about.setText(""About..."");
        cm_about.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                cm_aboutActionPerformed(evt);
            }
        });

        menu_help.add(cm_about);

        jMenuBar1.add(menu_help);

        setJMenuBar(jMenuBar1);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void cm_loadUrlActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_cm_loadUrlActionPerformed
    {//GEN-HEADEREND:event_cm_loadUrlActionPerformed
        String urlStrn = JOptionPane.showInputDialog(this, ""Enter URL of SVG file"");
        if (urlStrn == null) return;
        
        try
        {
            URL url = new URL(URLEncoder.encode(urlStrn, ""UTF-8""));
            loadURL(url);
        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
        }

    }//GEN-LAST:event_cm_loadUrlActionPerformed

    private void cmCheck_verboseActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_cmCheck_verboseActionPerformed
    {//GEN-HEADEREND:event_cmCheck_verboseActionPerformed
// TODO add your handling code here:
    }//GEN-LAST:event_cmCheck_verboseActionPerformed

    private void cm_playerActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_cm_playerActionPerformed
    {//GEN-HEADEREND:event_cm_playerActionPerformed
        playerDialog.setVisible(true);
    }//GEN-LAST:event_cm_playerActionPerformed

    private void cm_aboutActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_cm_aboutActionPerformed
    {//GEN-HEADEREND:event_cm_aboutActionPerformed
        VersionDialog dia = new VersionDialog(this, true, cmCheck_verbose.isSelected());
        dia.setVisible(true);
//        JOptionPane.showMessageDialog(this, ""Salamander SVG - Created by Mark McKay\nhttp://www.kitfox.com"");
    }//GEN-LAST:event_cm_aboutActionPerformed

    private void cm_800x600ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cm_800x600ActionPerformed
        setSize(800, 600);
    }//GEN-LAST:event_cm_800x600ActionPerformed
    
    private void cm_loadFileActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_cm_loadFileActionPerformed
    {//GEN-HEADEREND:event_cm_loadFileActionPerformed
        boolean verbose = cmCheck_verbose.isSelected();
        
        try
        {
            int retVal = fileChooser.showOpenDialog(this);
            if (retVal == JFileChooser.APPROVE_OPTION)
            {
                File chosenFile = fileChooser.getSelectedFile();

                URL url = chosenFile.toURI().toURL();

                loadURL(url);
            }
        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
        }

    }//GEN-LAST:event_cm_loadFileActionPerformed

    /** Exit the Application */
    private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
        System.exit(0);
    }//GEN-LAST:event_exitForm

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        new SVGPlayer().setVisible(true);
    }

    public void updateTime(double curTime, double timeStep, int playState)
    {
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBoxMenuItem CheckBoxMenuItem_anonInputStream;
    private javax.swing.JCheckBoxMenuItem cmCheck_verbose;
    private javax.swing.JMenuItem cm_800x600;
    private javax.swing.JMenuItem cm_about;
    private javax.swing.JMenuItem cm_loadFile;
    private javax.swing.JMenuItem cm_loadUrl;
    private javax.swing.JMenuItem cm_player;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JMenu menu_file;
    private javax.swing.JMenu menu_help;
    private javax.swing.JMenu menu_window;
    private javax.swing.JScrollPane scrollPane_svgArea;
    // End of variables declaration//GEN-END:variables

}
"
SVGViewer.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on April 3, 2004, 5:28 PM
 */

package com.kitfox.svg.app;

import com.kitfox.svg.SVGCache;
import com.kitfox.svg.SVGConst;
import com.kitfox.svg.SVGDiagram;
import com.kitfox.svg.SVGDisplayPanel;
import com.kitfox.svg.SVGElement;
import com.kitfox.svg.SVGException;
import com.kitfox.svg.SVGUniverse;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Point;
import java.io.File;
import java.io.InputStream;
import java.net.URI;
import java.net.URL;
import java.net.URLEncoder;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;


/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class SVGViewer extends javax.swing.JFrame 
{
    public static final long serialVersionUID = 1;

    SVGDisplayPanel svgDisplayPanel = new SVGDisplayPanel();

    /** FileChooser for running in trusted environments */
    final JFileChooser fileChooser;
    {
//        fileChooser = new JFileChooser(new File("".""));
        JFileChooser fc = null;
        try
        {
            fc = new JFileChooser();
            fc.setFileFilter(
                new javax.swing.filechooser.FileFilter() {
                    final Matcher matchLevelFile = Pattern.compile("".*\\.svg[z]?"").matcher("""");

                    public boolean accept(File file)
                    {
                        if (file.isDirectory()) return true;

                        matchLevelFile.reset(file.getName());
                        return matchLevelFile.matches();
                    }

                    public String getDescription() { return ""SVG file (*.svg, *.svgz)""; }
                }
            );
        }
        catch (AccessControlException ex)
        {
            //Do not create file chooser if webstart refuses permissions
        }
        fileChooser = fc;
    }

    /** Backup file service for opening files in WebStart situations */
    /*
    final FileOpenService fileOpenService;
    {
        try 
        { 
            fileOpenService = (FileOpenService)ServiceManager.lookup(""javax.jnlp.FileOpenService""); 
        } 
        catch (UnavailableServiceException e) 
        { 
            fileOpenService = null; 
        } 
    }
     */
    
    /** Creates new form SVGViewer */
    public SVGViewer() {
        initComponents();

        setSize(800, 600);

        svgDisplayPanel.setBgColor(Color.white);

        svgDisplayPanel.setPreferredSize(getSize());
        panel_svgArea.add(svgDisplayPanel, BorderLayout.CENTER);
//        scrollPane_svgArea.setViewportView(svgDisplayPanel);
    }

    private void loadURL(URL url)
    {
        boolean verbose = cmCheck_verbose.isSelected();
        
//                SVGUniverse universe = new SVGUniverse();
        SVGUniverse universe = SVGCache.getSVGUniverse();
        SVGDiagram diagram = null;
        URI uri;

        if (!CheckBoxMenuItem_anonInputStream.isSelected())
        {
            //Load from a disk with a valid URL
            uri = universe.loadSVG(url);

            if (verbose) System.err.println(""Loading document "" + uri.toString());

            diagram = universe.getDiagram(uri);
        }
        else
        {
            //Load from a stream with no particular valid URL
            try
            {
                InputStream is = url.openStream();
                uri = universe.loadSVG(is, ""defaultName"");

                if (verbose) System.err.println(""Loading document "" + uri.toString());
            }
            catch (Exception e)
            {
                Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
                return;
            }
        }
/*
ByteArrayOutputStream bs = new ByteArrayOutputStream();
ObjectOutputStream os = new ObjectOutputStream(bs);
os.writeObject(universe);
os.close();

ByteArrayInputStream bin = new ByteArrayInputStream(bs.toByteArray());
ObjectInputStream is = new ObjectInputStream(bin);
universe = (SVGUniverse)is.readObject();
is.close();
*/

        diagram = universe.getDiagram(uri);

        svgDisplayPanel.setDiagram(diagram);
        repaint();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate=""collapsed"" desc="" Generated Code "">//GEN-BEGIN:initComponents
    private void initComponents()
    {
        scrollPane_svgArea = new javax.swing.JScrollPane();
        panel_svgArea = new javax.swing.JPanel();
        jMenuBar1 = new javax.swing.JMenuBar();
        menu_file = new javax.swing.JMenu();
        cm_loadFile = new javax.swing.JMenuItem();
        cm_loadUrl = new javax.swing.JMenuItem();
        menu_window = new javax.swing.JMenu();
        cm_800x600 = new javax.swing.JMenuItem();
        CheckBoxMenuItem_anonInputStream = new javax.swing.JCheckBoxMenuItem();
        cmCheck_verbose = new javax.swing.JCheckBoxMenuItem();
        menu_help = new javax.swing.JMenu();
        cm_about = new javax.swing.JMenuItem();

        setTitle(""SVG Viewer - Salamander Project"");
        addWindowListener(new java.awt.event.WindowAdapter()
        {
            public void windowClosing(java.awt.event.WindowEvent evt)
            {
                exitForm(evt);
            }
        });

        panel_svgArea.setLayout(new java.awt.BorderLayout());

        panel_svgArea.addMouseListener(new java.awt.event.MouseAdapter()
        {
            public void mousePressed(java.awt.event.MouseEvent evt)
            {
                panel_svgAreaMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt)
            {
                panel_svgAreaMouseReleased(evt);
            }
        });

        scrollPane_svgArea.setViewportView(panel_svgArea);

        getContentPane().add(scrollPane_svgArea, java.awt.BorderLayout.CENTER);

        menu_file.setMnemonic('f');
        menu_file.setText(""File"");
        cm_loadFile.setMnemonic('l');
        cm_loadFile.setText(""Load File..."");
        cm_loadFile.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                cm_loadFileActionPerformed(evt);
            }
        });

        menu_file.add(cm_loadFile);

        cm_loadUrl.setText(""Load URL..."");
        cm_loadUrl.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                cm_loadUrlActionPerformed(evt);
            }
        });

        menu_file.add(cm_loadUrl);

        jMenuBar1.add(menu_file);

        menu_window.setText(""Window"");
        cm_800x600.setText(""800 x 600"");
        cm_800x600.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                cm_800x600ActionPerformed(evt);
            }
        });

        menu_window.add(cm_800x600);

        CheckBoxMenuItem_anonInputStream.setText(""Anonymous Input Stream"");
        menu_window.add(CheckBoxMenuItem_anonInputStream);

        cmCheck_verbose.setText(""Verbose"");
        cmCheck_verbose.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                cmCheck_verboseActionPerformed(evt);
            }
        });

        menu_window.add(cmCheck_verbose);

        jMenuBar1.add(menu_window);

        menu_help.setText(""Help"");
        cm_about.setText(""About..."");
        cm_about.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                cm_aboutActionPerformed(evt);
            }
        });

        menu_help.add(cm_about);

        jMenuBar1.add(menu_help);

        setJMenuBar(jMenuBar1);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void cm_loadUrlActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_cm_loadUrlActionPerformed
    {//GEN-HEADEREND:event_cm_loadUrlActionPerformed
        String urlStrn = JOptionPane.showInputDialog(this, ""Enter URL of SVG file"");
        if (urlStrn == null) return;
        
        try
        {
            URL url = new URL(URLEncoder.encode(urlStrn, ""UTF-8""));
            loadURL(url);
        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
        }

    }//GEN-LAST:event_cm_loadUrlActionPerformed

    private void panel_svgAreaMouseReleased(java.awt.event.MouseEvent evt)//GEN-FIRST:event_panel_svgAreaMouseReleased
    {//GEN-HEADEREND:event_panel_svgAreaMouseReleased
        SVGDiagram diagram = svgDisplayPanel.getDiagram();
        List pickedElements;
        try
        {
            pickedElements = diagram.pick(new Point(evt.getX(), evt.getY()), null);
        } 
        catch (SVGException e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
            return;
        }
        
        System.out.println(""Pick results:"");
        for (Iterator it = pickedElements.iterator(); it.hasNext();)
        {
            ArrayList path = (ArrayList)it.next();
            
            System.out.print(""  Path: "");
            
            for (Iterator it2 = path.iterator(); it2.hasNext();)
            {
                SVGElement ele = (SVGElement)it2.next();

                System.out.print("""" + ele.getId() + ""("" + ele.getClass().getName() + "") "");
            }
            System.out.println();
        }
    }//GEN-LAST:event_panel_svgAreaMouseReleased

    private void panel_svgAreaMousePressed(java.awt.event.MouseEvent evt)//GEN-FIRST:event_panel_svgAreaMousePressed
    {//GEN-HEADEREND:event_panel_svgAreaMousePressed

    }//GEN-LAST:event_panel_svgAreaMousePressed

    private void cmCheck_verboseActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_cmCheck_verboseActionPerformed
    {//GEN-HEADEREND:event_cmCheck_verboseActionPerformed
        SVGCache.getSVGUniverse().setVerbose(cmCheck_verbose.isSelected());
    }//GEN-LAST:event_cmCheck_verboseActionPerformed

    private void cm_aboutActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_cm_aboutActionPerformed
    {//GEN-HEADEREND:event_cm_aboutActionPerformed
        //JOptionPane.showMessageDialog(this, ""Salamander SVG - Created by Mark McKay\nhttp://www.kitfox.com"");
        VersionDialog dlg = new VersionDialog(this, true, cmCheck_verbose.isSelected());
        dlg.setVisible(true);
    }//GEN-LAST:event_cm_aboutActionPerformed

    private void cm_800x600ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cm_800x600ActionPerformed
        setSize(800, 600);
    }//GEN-LAST:event_cm_800x600ActionPerformed
    
    private void cm_loadFileActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_cm_loadFileActionPerformed
    {//GEN-HEADEREND:event_cm_loadFileActionPerformed
        try
        {
            int retVal = fileChooser.showOpenDialog(this);
            if (retVal == JFileChooser.APPROVE_OPTION)
            {
                File chosenFile = fileChooser.getSelectedFile();

                URL url = chosenFile.toURI().toURL();

                loadURL(url);
            }
        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
        }

    }//GEN-LAST:event_cm_loadFileActionPerformed

    /** Exit the Application */
    private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
//        setVisible(false);
//        dispose();
        System.exit(0);
    }//GEN-LAST:event_exitForm

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        new SVGViewer().setVisible(true);
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBoxMenuItem CheckBoxMenuItem_anonInputStream;
    private javax.swing.JCheckBoxMenuItem cmCheck_verbose;
    private javax.swing.JMenuItem cm_800x600;
    private javax.swing.JMenuItem cm_about;
    private javax.swing.JMenuItem cm_loadFile;
    private javax.swing.JMenuItem cm_loadUrl;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenu menu_file;
    private javax.swing.JMenu menu_help;
    private javax.swing.JMenu menu_window;
    private javax.swing.JPanel panel_svgArea;
    private javax.swing.JScrollPane scrollPane_svgArea;
    // End of variables declaration//GEN-END:variables

}
"
VersionDialog.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 13, 2005, 7:23 AM
 */

package com.kitfox.svg.app;

import com.kitfox.svg.SVGConst;
import java.net.*;
import java.io.*;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.event.*;
import javax.swing.*;
import javax.swing.text.html.*;


/**
 *
 * @author  kitfox
 */
public class VersionDialog extends javax.swing.JDialog
{
    public static final long serialVersionUID = 1;
    
    final boolean verbose;
    
    /** Creates new form VersionDialog */
    public VersionDialog(java.awt.Frame parent, boolean modal, boolean verbose)
    {
        super(parent, modal);
        initComponents();
        
        this.verbose = verbose;
        
        textpane_text.setContentType(""text/html"");
        
        StringBuffer sb = new StringBuffer();
        try
        {
            URL url = getClass().getResource(""/res/help/about/about.html"");
            if (verbose)
            {
                System.err.println("""" + getClass() + "" trying to load about html "" + url);
            }
            
            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
            while (true)
            {
                String line = reader.readLine();
                if (line == null) break;
                sb.append(line);
            }
            
            textpane_text.setText(sb.toString());
        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
        }
        
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate=""collapsed"" desc="" Generated Code "">//GEN-BEGIN:initComponents
    private void initComponents()
    {
        jPanel1 = new javax.swing.JPanel();
        textpane_text = new javax.swing.JTextPane();
        jPanel2 = new javax.swing.JPanel();
        bn_close = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle(""About SVG Salamander"");
        jPanel1.setLayout(new java.awt.BorderLayout());

        textpane_text.setEditable(false);
        textpane_text.setPreferredSize(new java.awt.Dimension(400, 300));
        jPanel1.add(textpane_text, java.awt.BorderLayout.CENTER);

        getContentPane().add(jPanel1, java.awt.BorderLayout.CENTER);

        bn_close.setText(""Close"");
        bn_close.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                bn_closeActionPerformed(evt);
            }
        });

        jPanel2.add(bn_close);

        getContentPane().add(jPanel2, java.awt.BorderLayout.SOUTH);

        pack();
    }
    // </editor-fold>//GEN-END:initComponents

    private void bn_closeActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_bn_closeActionPerformed
    {//GEN-HEADEREND:event_bn_closeActionPerformed
        setVisible(false);
        dispose();
    }//GEN-LAST:event_bn_closeActionPerformed
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[])
    {
        java.awt.EventQueue.invokeLater(new Runnable()
        {
            public void run()
            {
                new VersionDialog(new javax.swing.JFrame(), true, true).setVisible(true);
            }
        });
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton bn_close;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JTextPane textpane_text;
    // End of variables declaration//GEN-END:variables
    
}
"
GraphicsUtil.java,kitfox-6.9.6,"/*****************************************************************************
 * Copyright (C) The Apache Software Foundation. All rights reserved.        *
 * ------------------------------------------------------------------------- *
 * This software is published under the terms of the Apache Software License *
 * version 1.1, a copy of which has been included with this distribution in  *
 * the LICENSE file.                                                         *
 *****************************************************************************/

package com.kitfox.svg.batik;

import java.awt.Color;
import java.awt.Composite;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.color.ColorSpace;
import java.awt.geom.AffineTransform;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.ComponentSampleModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferByte;
import java.awt.image.DataBufferInt;
import java.awt.image.DataBufferShort;
import java.awt.image.DataBufferUShort;
import java.awt.image.DirectColorModel;
import java.awt.image.Raster;
import java.awt.image.RenderedImage;
import java.awt.image.SampleModel;
import java.awt.image.SinglePixelPackedSampleModel;
import java.awt.image.WritableRaster;
import java.awt.image.renderable.RenderContext;
import java.awt.image.renderable.RenderableImage;
import java.lang.ref.Reference;
import java.lang.ref.WeakReference;

/**
 *
 * @author  kitfox
 */
public class GraphicsUtil
{
    
    /** Creates a new instance of GraphicsUtil */
    public GraphicsUtil()
    {
    }
    
    /**
     * Create a new ColorModel with it's alpha premultiplied state matching
     * newAlphaPreMult.
     * @param cm The ColorModel to change the alpha premult state of.
     * @param newAlphaPreMult The new state of alpha premult.
     * @return   A new colorModel that has isAlphaPremultiplied()
     *           equal to newAlphaPreMult.
     */
    public static ColorModel coerceColorModel(ColorModel cm, boolean newAlphaPreMult)
    {
        if (cm.isAlphaPremultiplied() == newAlphaPreMult)
            return cm;
        
        // Easiest way to build proper colormodel for new Alpha state...
        // Eventually this should switch on known ColorModel types and
        // only fall back on this hack when the CM type is unknown.
        WritableRaster wr = cm.createCompatibleWritableRaster(1,1);
        return cm.coerceData(wr, newAlphaPreMult);
    }
    
    /**
     * Coerces data within a bufferedImage to match newAlphaPreMult,
     * Note that this can not change the colormodel of bi so you
     *
     * @param wr The raster to change the state of.
     * @param cm The colormodel currently associated with data in wr.
     * @param newAlphaPreMult The desired state of alpha Premult for raster.
     * @return A new colormodel that matches newAlphaPreMult.
     */
    public static ColorModel coerceData(WritableRaster wr, ColorModel cm, boolean newAlphaPreMult)
    {
        
        // System.out.println(""CoerceData: "" + cm.isAlphaPremultiplied() +
        //                    "" Out: "" + newAlphaPreMult);
        if (cm.hasAlpha()== false)
            // Nothing to do no alpha channel
            return cm;
        
        if (cm.isAlphaPremultiplied() == newAlphaPreMult)
            // nothing to do alpha state matches...
            return cm;
        
        // System.out.println(""CoerceData: "" + wr.getSampleModel());
        
        int [] pixel = null;
        int    bands = wr.getNumBands();
        float  norm;
        if (newAlphaPreMult)
        {
            if (is_BYTE_COMP_Data(wr.getSampleModel()))
                mult_BYTE_COMP_Data(wr);
            else if (is_INT_PACK_Data(wr.getSampleModel(), true))
                mult_INT_PACK_Data(wr);
            else
            {
                norm = 1f/255f;
                int x0, x1, y0, y1, a, b;
                float alpha;
                x0 = wr.getMinX();
                x1 = x0+wr.getWidth();
                y0 = wr.getMinY();
                y1 = y0+wr.getHeight();
                for (int y=y0; y<y1; y++)
                    for (int x=x0; x<x1; x++)
                    {
                        pixel = wr.getPixel(x,y,pixel);
                        a = pixel[bands-1];
                        if ((a >= 0) && (a < 255))
                        {
                            alpha = a*norm;
                            for (b=0; b<bands-1; b++)
                                pixel[b] = (int)(pixel[b]*alpha+0.5f);
                            wr.setPixel(x,y,pixel);
                        }
                    }
            }
        } else
        {
            if (is_BYTE_COMP_Data(wr.getSampleModel()))
                divide_BYTE_COMP_Data(wr);
            else if (is_INT_PACK_Data(wr.getSampleModel(), true))
                divide_INT_PACK_Data(wr);
            else
            {
                int x0, x1, y0, y1, a, b;
                float ialpha;
                x0 = wr.getMinX();
                x1 = x0+wr.getWidth();
                y0 = wr.getMinY();
                y1 = y0+wr.getHeight();
                for (int y=y0; y<y1; y++)
                    for (int x=x0; x<x1; x++)
                    {
                        pixel = wr.getPixel(x,y,pixel);
                        a = pixel[bands-1];
                        if ((a > 0) && (a < 255))
                        {
                            ialpha = 255/(float)a;
                            for (b=0; b<bands-1; b++)
                                pixel[b] = (int)(pixel[b]*ialpha+0.5f);
                            wr.setPixel(x,y,pixel);
                        }
                    }
            }
        }
        
        return coerceColorModel(cm, newAlphaPreMult);
    }
    
    
    public static boolean is_INT_PACK_Data(SampleModel sm,
    boolean requireAlpha)
    {
        // Check ColorModel is of type DirectColorModel
        if(!(sm instanceof SinglePixelPackedSampleModel)) return false;
        
        // Check transfer type
        if(sm.getDataType() != DataBuffer.TYPE_INT)       return false;
        
        SinglePixelPackedSampleModel sppsm;
        sppsm = (SinglePixelPackedSampleModel)sm;
        
        int [] masks = sppsm.getBitMasks();
        if (masks.length == 3)
        {
            if (requireAlpha) return false;
        } else if (masks.length != 4)
            return false;
        
        if(masks[0] != 0x00ff0000) return false;
        if(masks[1] != 0x0000ff00) return false;
        if(masks[2] != 0x000000ff) return false;
        if ((masks.length == 4) &&
        (masks[3] != 0xff000000)) return false;
        
        return true;
    }
    
    protected static void mult_INT_PACK_Data(WritableRaster wr)
    {
        // System.out.println(""Multiply Int: "" + wr);
        
        SinglePixelPackedSampleModel sppsm;
        sppsm = (SinglePixelPackedSampleModel)wr.getSampleModel();
        
        final int width = wr.getWidth();
        
        final int scanStride = sppsm.getScanlineStride();
        DataBufferInt db = (DataBufferInt)wr.getDataBuffer();
        final int base
        = (db.getOffset() +
        sppsm.getOffset(wr.getMinX()-wr.getSampleModelTranslateX(),
        wr.getMinY()-wr.getSampleModelTranslateY()));
        int n=0;
        // Access the pixel data array
        final int pixels[] = db.getBankData()[0];
        for (int y=0; y<wr.getHeight(); y++)
        {
            int sp = base + y*scanStride;
            final int end = sp + width;
            while (sp < end)
            {
                int pixel = pixels[sp];
                int a = pixel>>>24;
                if ((a>=0) && (a<255))
                {
                    pixels[sp] = ((a << 24) |
                    ((((pixel&0xFF0000)*a)>>8)&0xFF0000) |
                    ((((pixel&0x00FF00)*a)>>8)&0x00FF00) |
                    ((((pixel&0x0000FF)*a)>>8)&0x0000FF));
                }
                sp++;
            }
        }
    }
    
    protected static void divide_INT_PACK_Data(WritableRaster wr)
    {
        // System.out.println(""Divide Int"");
        
        SinglePixelPackedSampleModel sppsm;
        sppsm = (SinglePixelPackedSampleModel)wr.getSampleModel();
        
        final int width = wr.getWidth();
        
        final int scanStride = sppsm.getScanlineStride();
        DataBufferInt db = (DataBufferInt)wr.getDataBuffer();
        final int base
        = (db.getOffset() +
        sppsm.getOffset(wr.getMinX()-wr.getSampleModelTranslateX(),
        wr.getMinY()-wr.getSampleModelTranslateY()));
        int pixel, a, aFP, n=0;
        // Access the pixel data array
        final int pixels[] = db.getBankData()[0];
        for (int y=0; y<wr.getHeight(); y++)
        {
            int sp = base + y*scanStride;
            final int end = sp + width;
            while (sp < end)
            {
                pixel = pixels[sp];
                a = pixel>>>24;
                if (a<=0)
                {
                    pixels[sp] = 0x00FFFFFF;
                }
                else if (a<255)
                {
                    aFP = (0x00FF0000/a);
                    pixels[sp] =
                    ((a << 24) |
                    (((((pixel&0xFF0000)>>16)*aFP)&0xFF0000)    ) |
                    (((((pixel&0x00FF00)>>8) *aFP)&0xFF0000)>>8 ) |
                    (((((pixel&0x0000FF))    *aFP)&0xFF0000)>>16));
                }
                sp++;
            }
        }
    }
    
    public static boolean is_BYTE_COMP_Data(SampleModel sm)
    {
        // Check ColorModel is of type DirectColorModel
        if(!(sm instanceof ComponentSampleModel))    return false;
        
        // Check transfer type
        if(sm.getDataType() != DataBuffer.TYPE_BYTE) return false;
        
        return true;
    }
    
    protected static void mult_BYTE_COMP_Data(WritableRaster wr)
    {
        // System.out.println(""Multiply Int: "" + wr);
        
        ComponentSampleModel csm;
        csm = (ComponentSampleModel)wr.getSampleModel();
        
        final int width = wr.getWidth();
        
        final int scanStride = csm.getScanlineStride();
        final int pixStride  = csm.getPixelStride();
        final int [] bandOff = csm.getBandOffsets();
        
        DataBufferByte db = (DataBufferByte)wr.getDataBuffer();
        final int base
        = (db.getOffset() +
        csm.getOffset(wr.getMinX()-wr.getSampleModelTranslateX(),
        wr.getMinY()-wr.getSampleModelTranslateY()));
        
        
        int a=0;
        int aOff = bandOff[bandOff.length-1];
        int bands = bandOff.length-1;
        int b, i;
        
        // Access the pixel data array
        final byte pixels[] = db.getBankData()[0];
        for (int y=0; y<wr.getHeight(); y++)
        {
            int sp = base + y*scanStride;
            final int end = sp + width*pixStride;
            while (sp < end)
            {
                a = pixels[sp+aOff]&0xFF;
                if (a!=0xFF)
                    for (b=0; b<bands; b++)
                    {
                        i = sp+bandOff[b];
                        pixels[i] = (byte)(((pixels[i]&0xFF)*a)>>8);
                    }
                sp+=pixStride;
            }
        }
    }
    
    protected static void divide_BYTE_COMP_Data(WritableRaster wr)
    {
        // System.out.println(""Multiply Int: "" + wr);
        
        ComponentSampleModel csm;
        csm = (ComponentSampleModel)wr.getSampleModel();
        
        final int width = wr.getWidth();
        
        final int scanStride = csm.getScanlineStride();
        final int pixStride  = csm.getPixelStride();
        final int [] bandOff = csm.getBandOffsets();
        
        DataBufferByte db = (DataBufferByte)wr.getDataBuffer();
        final int base
        = (db.getOffset() +
        csm.getOffset(wr.getMinX()-wr.getSampleModelTranslateX(),
        wr.getMinY()-wr.getSampleModelTranslateY()));
        
        
        int a=0;
        int aOff = bandOff[bandOff.length-1];
        int bands = bandOff.length-1;
        int b, i;
        // Access the pixel data array
        final byte pixels[] = db.getBankData()[0];
        for (int y=0; y<wr.getHeight(); y++)
        {
            int sp = base + y*scanStride;
            final int end = sp + width*pixStride;
            while (sp < end)
            {
                a = pixels[sp+aOff]&0xFF;
                if (a==0)
                {
                    for (b=0; b<bands; b++)
                        pixels[sp+bandOff[b]] = (byte)0xFF;
                } else if (a<255)
                {
                    int aFP = (0x00FF0000/a);
                    for (b=0; b<bands; b++)
                    {
                        i = sp+bandOff[b];
                        pixels[i] = (byte)(((pixels[i]&0xFF)*aFP)>>>16);
                    }
                }
                sp+=pixStride;
            }
        }
    }
    
    
}
"
LinearGradientPaint.java,kitfox-6.9.6,"/*****************************************************************************
 * Copyright (C) The Apache Software Foundation. All rights reserved.        *
 * ------------------------------------------------------------------------- *
 * This software is published under the terms of the Apache Software License *
 * version 1.1, a copy of which has been included with this distribution in  *
 * the LICENSE file.                                                         *
 *****************************************************************************/

package com.kitfox.svg.batik;

import com.kitfox.svg.SVGConst;
import java.awt.Color;
import java.awt.PaintContext;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.ColorModel;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * The <code>LinearGradientPaint</code> class provides a way to fill
 * a {@link java.awt.Shape} with a linear color gradient pattern.  The user may
 * specify 2 or more gradient colors, and this paint will provide an
 * interpolation between each color.  The user also specifies start and end
 * points which define where in user space the color gradient should begin 
 * and end.
 * <p>
 * The user must provide an array of floats specifying how to distribute the
 * colors along the gradient.  These values should range from 0.0 to 1.0 and 
 * act like keyframes along the gradient (they mark where the gradient should 
 * be exactly a particular color).
 * <p>
 * For example:
 * <br>
 * <code>
 * <p>
 * Point2D start = new Point2D.Float(0, 0);<br>
 * Point2D end = new Point2D.Float(100,100);<br>
 * float[] dist = {0.0, 0.2, 1.0};<br>
 * Color[] colors = {Color.red, Color.white, Color.blue};<br>
 * LinearGradientPaint p = new LinearGradientPaint(start, end, dist, colors);
 * </code>
 *<p>
 * This code will create a LinearGradientPaint which interpolates between 
 * red and white for the first 20% of the gradient and between white and blue 
 * for the remaining 80%.
 *
 * <p> In the event that the user does not set the first keyframe value equal
 * to 0 and the last keyframe value equal to 1, keyframes will be created at
 * these positions and the first and last colors will be replicated there.
 * So, if a user specifies the following arrays to construct a gradient:<br>
 * {Color.blue, Color.red}, {.3, .7}<br>
 * this will be converted to a gradient with the following keyframes:
 * {Color.blue, Color.blue, Color.red, Color.red}, {0, .3, .7, 1}
 *
 * <p>
 * The user may also select what action the LinearGradientPaint should take
 * when filling color outside the start and end points. If no cycle method is
 * specified, NO_CYCLE will be chosen by default, so the endpoint colors 
 * will be used to fill the remaining area.  
 *
 * <p> The following image demonstrates the options NO_CYCLE and REFLECT.
 *
 * <p>
 * <img src = ""cyclic.jpg"">
 *
 * <p> The colorSpace parameter allows the user to specify in which colorspace
 *  the interpolation should be performed, default sRGB or linearized RGB.
 *  
 *
 * @author Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans
 * @author <a href=""mailto:vincent.hardy@eng.sun.com"">Vincent Hardy</a>
 * @version $Id: LinearGradientPaint.java,v 1.2 2004/09/27 09:27:27 kitfox Exp $
 * @see java.awt.Paint
 * @see java.awt.Graphics2D#setPaint
 *
 */

public final class LinearGradientPaint extends MultipleGradientPaint {

    /** Gradient start and end points. */
    private Point2D start, end;   
       
    /**<p>
     * Constructs an <code>LinearGradientPaint</code> with the default 
     * NO_CYCLE repeating method and SRGB colorspace.
     *
     * @param startX the x coordinate of the gradient axis start point 
     * in user space
     *
     * @param startY the y coordinate of the gradient axis start point 
     * in user space
     *
     * @param endX the x coordinate of the gradient axis end point 
     * in user space
     *
     * @param endY the y coordinate of the gradient axis end point 
     * in user space
     *
     * @param fractions numbers ranging from 0.0 to 1.0 specifying the 
     * distribution of colors along the gradient
     *
     * @param colors array of colors corresponding to each fractional value
     *     
     *
     * @throws IllegalArgumentException if start and end points are the 
     * same points, or if fractions.length != colors.length, or if colors 
     * is less than 2 in size.
     *
     */
    public LinearGradientPaint(float startX, float startY, 
                               float endX, float endY, 
                               float[] fractions, Color[] colors) {

        this(new Point2D.Float(startX, startY),
             new Point2D.Float(endX, endY), 
             fractions, 
             colors,
             NO_CYCLE,
             SRGB);
    }

    /**<p>
     * Constructs an <code>LinearGradientPaint</code> with default SRGB 
     * colorspace.
     *
     * @param startX the x coordinate of the gradient axis start point 
     * in user space
     *
     * @param startY the y coordinate of the gradient axis start point 
     * in user space
     *
     * @param endX the x coordinate of the gradient axis end point 
     * in user space
     * 
     * @param endY the y coordinate of the gradient axis end point 
     * in user space
     *
     * @param fractions numbers ranging from 0.0 to 1.0 specifying the 
     * distribution of colors along the gradient
     *
     * @param colors array of colors corresponding to each fractional value
     *
     * @param cycleMethod either NO_CYCLE, REFLECT, or REPEAT
     *
     * @throws IllegalArgumentException if start and end points are the 
     * same points, or if fractions.length != colors.length, or if colors 
     * is less than 2 in size.
     *
     */
    public LinearGradientPaint(float startX, float startY, 
                               float endX, float endY, 
                               float[] fractions, Color[] colors, 
                               CycleMethodEnum cycleMethod) {
        this(new Point2D.Float(startX, startY), 
             new Point2D.Float(endX, endY), 
             fractions, 
             colors,
             cycleMethod,
             SRGB);
    }

    /**<p>
     * Constructs a <code>LinearGradientPaint</code> with the default 
     * NO_CYCLE repeating method and SRGB colorspace.
     *
     * @param start the gradient axis start <code>Point</code> in user space
     *
     * @param end the gradient axis end <code>Point</code> in user space
     *
     * @param fractions numbers ranging from 0.0 to 1.0 specifying the 
     * distribution of colors along the gradient
     *
     * @param colors array of colors corresponding to each fractional value
     *
     * @throws NullPointerException if one of the points is null
     *
     * @throws IllegalArgumentException if start and end points are the 
     * same points, or if fractions.length != colors.length, or if colors 
     * is less than 2 in size.
     *
     */
    public LinearGradientPaint(Point2D start, Point2D end, float[] fractions,
                               Color[] colors) {

        this(start, end, fractions, colors, NO_CYCLE, SRGB);
    }
    
    /**<p>
     * Constructs a <code>LinearGradientPaint</code>.
     *
     * @param start the gradient axis start <code>Point</code> in user space
     *
     * @param end the gradient axis end <code>Point</code> in user space
     *
     * @param fractions numbers ranging from 0.0 to 1.0 specifying the 
     * distribution of colors along the gradient
     *
     * @param colors array of colors corresponding to each fractional value
     *
     * @param cycleMethod either NO_CYCLE, REFLECT, or REPEAT
     *
     * @param colorSpace which colorspace to use for interpolation, 
     * either SRGB or LINEAR_RGB
     *   
     * @throws NullPointerException if one of the points is null
     *
     * @throws IllegalArgumentException if start and end points are the 
     * same points, or if fractions.length != colors.length, or if colors 
     * is less than 2 in size.
     *
     */
    public LinearGradientPaint(Point2D start, Point2D end, float[] fractions,
                               Color[] colors, 
                               CycleMethodEnum cycleMethod, 
                               ColorSpaceEnum colorSpace) {
	
        this(start, end, fractions, colors, cycleMethod, colorSpace, 
             new AffineTransform());
	
    }
    
    /**<p>
     * Constructs a <code>LinearGradientPaint</code>.
     *
     * @param start the gradient axis start <code>Point</code> in user space
     *
     * @param end the gradient axis end <code>Point</code> in user space
     *
     * @param fractions numbers ranging from 0.0 to 1.0 specifying the 
     * distribution of colors along the gradient
     *
     * @param colors array of colors corresponding to each fractional value
     *
     * @param cycleMethod either NO_CYCLE, REFLECT, or REPEAT
     *
     * @param colorSpace which colorspace to use for interpolation, 
     * either SRGB or LINEAR_RGB
     *
     * @param gradientTransform transform to apply to the gradient
     *     
     * @throws NullPointerException if one of the points is null, 
     * or gradientTransform is null
     *
     * @throws IllegalArgumentException if start and end points are the 
     * same points, or if fractions.length != colors.length, or if colors 
     * is less than 2 in size.
     *
     */
    public LinearGradientPaint(Point2D start, Point2D end, float[] fractions,
                               Color[] colors,
                               CycleMethodEnum cycleMethod, 
                               ColorSpaceEnum colorSpace, 
                               AffineTransform gradientTransform) {
        super(fractions, colors, cycleMethod, colorSpace, gradientTransform);

        //
        // Check input parameters
        //	
        if (start == null || end == null) {
            throw new NullPointerException(""Start and end points must be"" +
                                           ""non-null"");
        }

        if (start.equals(end)) {
            throw new IllegalArgumentException(""Start point cannot equal"" +
                                               ""endpoint"");
        }

        //copy the points...
        this.start = (Point2D)start.clone();

        this.end = (Point2D)end.clone();
	
    }
    
    /**
     * Creates and returns a PaintContext used to generate the color pattern,
     * for use by the internal rendering engine.
     *
     * @param cm {@link ColorModel} that receives
     * the <code>Paint</code> data. This is used only as a hint.
     *
     * @param deviceBounds the device space bounding box of the 
     * graphics primitive being rendered
     *
     * @param userBounds the user space bounding box of the 
     * graphics primitive being rendered
     *
     * @param transform the {@link AffineTransform} from user
     * space into device space
     *
     * @param hints the hints that the context object uses to choose
     * between rendering alternatives
     *
     * @return the {@link PaintContext} that generates color patterns.
     *
     * @see PaintContext
     */
    public PaintContext createContext(ColorModel cm,
                                      Rectangle deviceBounds,
                                      Rectangle2D userBounds,
                                      AffineTransform transform,
                                      RenderingHints hints) {

        // Can't modify the transform passed in...
        transform = new AffineTransform(transform);
        //incorporate the gradient transform
        transform.concatenate(gradientTransform); 

        try {
            return new LinearGradientPaintContext(cm, 
                                                  deviceBounds,
                                                  userBounds, 
                                                  transform,
                                                  hints,
                                                  start, 
                                                  end,
                                                  fractions,
                                                  this.getColors(),
                                                  cycleMethod,
                                                  colorSpace);
        }
        catch(NoninvertibleTransformException e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
            throw new IllegalArgumentException(""transform should be"" + 
                                               ""invertible"");
        }
    }
    
    /**
     * Returns a copy of the start point of the gradient axis
     * @return a {@link Point2D} object that is a copy of the point
     * that anchors the first color of this 
     * <code>LinearGradientPaint</code>.  
     */
    public Point2D getStartPoint() {
        return new Point2D.Double(start.getX(), start.getY());
    }
    
    /** Returns a copy of the end point of the gradient axis
     * @return a {@link Point2D} object that is a copy of the point
     * that anchors the last color of this 
     * <code>LinearGradientPaint</code>.  
     */
    public Point2D getEndPoint() {
        return new Point2D.Double(end.getX(), end.getY());
    }
        
}


"
LinearGradientPaintContext.java,kitfox-6.9.6,"/*****************************************************************************
 * Copyright (C) The Apache Software Foundation. All rights reserved.        *
 * ------------------------------------------------------------------------- *
 * This software is published under the terms of the Apache Software License *
 * version 1.1, a copy of which has been included with this distribution in  *
 * the LICENSE file.                                                         *
 *****************************************************************************/

package com.kitfox.svg.batik;

import java.awt.Color;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.ColorModel;

/**
 * Provides the actual implementation for the LinearGradientPaint
 * This is where the pixel processing is done.
 * 
 * @author Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans
 * @author <a href=""mailto:vincent.hardy@eng.sun.com"">Vincent Hardy</a>
 * @version $Id: LinearGradientPaintContext.java,v 1.2 2007/02/04 01:28:05 kitfox Exp $
 * @see java.awt.PaintContext
 * @see java.awt.Paint
 * @see java.awt.GradientPaint
 */
final class LinearGradientPaintContext extends MultipleGradientPaintContext {
    
    /**
     * The following invariants are used to process the gradient value from 
     * a device space coordinate, (X, Y):
     * g(X, Y) = dgdX*X + dgdY*Y + gc
     */
    private float dgdX, dgdY, gc, pixSz;    
           
    private static final int DEFAULT_IMPL = 1;
    private static final int ANTI_ALIAS_IMPL  = 3;

    private int fillMethod;

    /** 
     * Constructor for LinearGradientPaintContext.
     *
     *  @param cm {@link ColorModel} that receives
     *  the <code>Paint</code> data. This is used only as a hint.
     *
     *  @param deviceBounds the device space bounding box of the 
     *  graphics primitive being rendered
     *
     *  @param userBounds the user space bounding box of the 
     *  graphics primitive being rendered
     * 
     *  @param t the {@link AffineTransform} from user
     *  space into device space (gradientTransform should be 
     *  concatenated with this)
     *
     *  @param hints the hints that the context object uses to choose
     *  between rendering alternatives
     *
     *  @param start gradient start point, in user space
     *
     *  @param end gradient end point, in user space
     *
     *  @param fractions the fractions specifying the gradient distribution
     *
     *  @param colors the gradient colors
     *
     *  @param cycleMethod either NO_CYCLE, REFLECT, or REPEAT
     *
     *  @param colorSpace which colorspace to use for interpolation, 
     *  either SRGB or LINEAR_RGB
     *
     */
    public LinearGradientPaintContext(ColorModel cm,
                                      Rectangle deviceBounds,
                                      Rectangle2D userBounds,
                                      AffineTransform t,
                                      RenderingHints hints,
                                      Point2D dStart,
                                      Point2D dEnd,
                                      float[] fractions,
                                      Color[] colors, 
                                      MultipleGradientPaint.CycleMethodEnum 
                                      cycleMethod,
                                      MultipleGradientPaint.ColorSpaceEnum 
                                      colorSpace)
        throws NoninvertibleTransformException
    {	
        super(cm, deviceBounds, userBounds, t, hints, fractions, 
              colors, cycleMethod, colorSpace);
        
        // Use single precision floating points
        Point2D.Float start = new Point2D.Float((float)dStart.getX(),
                                                (float)dStart.getY());
        Point2D.Float end = new Point2D.Float((float)dEnd.getX(),
                                              (float)dEnd.getY());
        
        // A given point in the raster should take on the same color as its
        // projection onto the gradient vector.
        // Thus, we want the projection of the current position vector
        // onto the gradient vector, then normalized with respect to the
        // length of the gradient vector, giving a value which can be mapped into
        // the range 0-1.
        // projection = currentVector dot gradientVector / length(gradientVector)
        // normalized = projection / length(gradientVector)

        float dx = end.x - start.x; // change in x from start to end
        float dy = end.y - start.y; // change in y from start to end
        float dSq = dx*dx + dy*dy; // total distance squared
	
        //avoid repeated calculations by doing these divides once.
        float constX = dx/dSq;
        float constY = dy/dSq;
	
        //incremental change along gradient for +x
        dgdX = a00*constX + a10*constY;
        //incremental change along gradient for +y
        dgdY = a01*constX + a11*constY;
        
        float dgdXAbs = Math.abs(dgdX);
        float dgdYAbs = Math.abs(dgdY);
        if (dgdXAbs > dgdYAbs)  pixSz = dgdXAbs;
        else                    pixSz = dgdYAbs;

        //constant, incorporates the translation components from the matrix
        gc = (a02-start.x)*constX + (a12-start.y)*constY;	       	

        Object colorRend = hints == null ? RenderingHints.VALUE_COLOR_RENDER_SPEED : hints.get(RenderingHints.KEY_COLOR_RENDERING);
        Object rend      = hints == null ? RenderingHints.VALUE_RENDER_SPEED : hints.get(RenderingHints.KEY_RENDERING);

        fillMethod = DEFAULT_IMPL;

        if ((cycleMethod == MultipleGradientPaint.REPEAT) ||
            hasDiscontinuity) {
            if (rend      == RenderingHints.VALUE_RENDER_QUALITY)
                fillMethod = ANTI_ALIAS_IMPL;
            // ColorRend overrides rend.
            if (colorRend == RenderingHints.VALUE_COLOR_RENDER_SPEED)
                fillMethod = DEFAULT_IMPL;
            else if (colorRend == RenderingHints.VALUE_COLOR_RENDER_QUALITY)
                fillMethod = ANTI_ALIAS_IMPL;
        } 
    }

    protected void fillHardNoCycle(int[] pixels, int off, int adjust, 
                              int x, int y, int w, int h) {

        //constant which can be pulled out of the inner loop
        final float initConst = (dgdX*x) + gc;

        for(int i=0; i<h; i++) { //for every row
            //initialize current value to be start.
            float g = initConst + dgdY*(y+i); 
            final int rowLimit = off+w;  // end of row iteration

            if (dgdX == 0) {
                // System.out.println(""In fillHard: "" + g);
                final int val;
                if (g <= 0) 
                    val = gradientUnderflow;
                else if (g >= 1)
                    val = gradientOverflow;
                else {
                    // Could be a binary search...
                    int gradIdx = 0;
                    while (gradIdx < gradientsLength-1) {
                        if (g < fractions[gradIdx+1])
                            break;
                        gradIdx++;
                    }
                    float delta = (g-fractions[gradIdx]);
                    float idx  = ((delta*GRADIENT_SIZE_INDEX)
                                  /normalizedIntervals[gradIdx])+0.5f;
                    val = gradients[gradIdx][(int)idx];
                }

                while (off < rowLimit) {
                    pixels[off++] = val;
                }
            } else {
                // System.out.println(""In fillHard2: "" + g);
                int gradSteps;
                int preGradSteps;
                final int preVal, postVal;
                if (dgdX >= 0) {
                    gradSteps    = (int)         ((1-g)/dgdX);
                    preGradSteps = (int)Math.ceil((0-g)/dgdX);
                    preVal  = gradientUnderflow;
                    postVal = gradientOverflow;
                } else { // dgdX < 0
                    gradSteps    = (int)         ((0-g)/dgdX);
                    preGradSteps = (int)Math.ceil((1-g)/dgdX);
                    preVal  = gradientOverflow;
                    postVal = gradientUnderflow;
                }

                if (gradSteps > w) 
                    gradSteps = w;

                final int gradLimit    = off + gradSteps;
                if (preGradSteps > 0) {
                    if (preGradSteps > w)
                        preGradSteps = w;
                    final int preGradLimit = off + preGradSteps;

                    while (off < preGradLimit) {
                        pixels[off++] = preVal;
                    }
                    g += dgdX*preGradSteps;
                }
                        
                if (dgdX > 0) {
                    // Could be a binary search...
                    int gradIdx = 0;
                    while (gradIdx < gradientsLength-1) {
                        if (g < fractions[gradIdx+1])
                            break;
                        gradIdx++;
                    }
                    
                    while (off < gradLimit) {
                        float delta = (g-fractions[gradIdx]);
                        final int [] grad = gradients[gradIdx];

                        int steps = 
                            (int)Math.ceil((fractions[gradIdx+1]-g)/dgdX);
                        int subGradLimit = off + steps;
                        if (subGradLimit > gradLimit)
                            subGradLimit = gradLimit;

                        int idx  = (int)(((delta*GRADIENT_SIZE_INDEX)
                                          /normalizedIntervals[gradIdx])
                                         *(1<<16)) + (1<<15);
                        int step = (int)(((dgdX*GRADIENT_SIZE_INDEX)
                                          /normalizedIntervals[gradIdx])
                                         *(1<<16));
                        while (off < subGradLimit) {
                            pixels[off++] = grad[idx>>16];
                            idx += step;
                        }
                        g+=dgdX*steps;
                        gradIdx++;
                    }
                } else {
                    // Could be a binary search...
                    int gradIdx = gradientsLength-1;
                    while (gradIdx > 0) {
                        if (g > fractions[gradIdx])
                            break;
                        gradIdx--;
                    }
                    
                    while (off < gradLimit) {
                        float delta = (g-fractions[gradIdx]);
                        final int [] grad = gradients[gradIdx];

                        int steps        = (int)Math.ceil(delta/-dgdX);
                        int subGradLimit = off + steps;
                        if (subGradLimit > gradLimit)
                            subGradLimit = gradLimit;

                        int idx  = (int)(((delta*GRADIENT_SIZE_INDEX)
                                          /normalizedIntervals[gradIdx])
                                         *(1<<16)) + (1<<15);
                        int step = (int)(((dgdX*GRADIENT_SIZE_INDEX)
                                          /normalizedIntervals[gradIdx])
                                         *(1<<16));
                        while (off < subGradLimit) {
                            pixels[off++] = grad[idx>>16];
                            idx += step;
                        }
                        g+=dgdX*steps;
                        gradIdx--;
                    }
                }

                while (off < rowLimit) {
                    pixels[off++] = postVal;
                }
            }
            off += adjust; //change in off from row to row
        }
    }

    protected void fillSimpleNoCycle(int[] pixels, int off, int adjust, 
                                int x, int y, int w, int h) {
        //constant which can be pulled out of the inner loop
        final float initConst = (dgdX*x) + gc;
        final float      step = dgdX*fastGradientArraySize;
        final int      fpStep = (int)(step*(1<<16));  // fix point step

        final int [] grad = gradient;

        for(int i=0; i<h; i++){ //for every row
            //initialize current value to be start.
            float g = initConst + dgdY*(y+i); 
            g *= fastGradientArraySize;
            g += 0.5; // rounding factor...

            final int rowLimit = off+w;  // end of row iteration

            if (dgdX == 0) {
                // System.out.println(""In fillSimpleNC: "" + g);
                final int val;
                if (g<=0) 
                    val = gradientUnderflow;
                else if (g>=fastGradientArraySize) 
                    val = gradientOverflow;
                else 
                    val = grad[(int)g];
                while (off < rowLimit) {
                    pixels[off++] = val;
                }
            } else {
                // System.out.println(""In fillSimpleNC2: "" + g);
                int gradSteps;
                int preGradSteps;
                final int preVal, postVal;
                if (dgdX > 0) {
                    gradSteps = (int)((fastGradientArraySize-g)/step);
                    preGradSteps = (int)Math.ceil(0-g/step);
                    preVal  = gradientUnderflow;
                    postVal = gradientOverflow;

                } else { // dgdX < 0
                    gradSteps    = (int)((0-g)/step);
                    preGradSteps = 
                        (int)Math.ceil((fastGradientArraySize-g)/step);
                    preVal  = gradientOverflow;
                    postVal = gradientUnderflow;
                }

                if (gradSteps > w) 
                    gradSteps = w;
                final int gradLimit    = off + gradSteps;

                if (preGradSteps > 0) {
                    if (preGradSteps > w)
                        preGradSteps = w;
                    final int preGradLimit = off + preGradSteps;

                    while (off < preGradLimit) {
                        pixels[off++] = preVal;
                    }
                    g += step*preGradSteps;
                }
                        
                int fpG = (int)(g*(1<<16));
                while (off < gradLimit) {
                    pixels[off++] = grad[fpG>>16];
                    fpG += fpStep;
                }
                        
                while (off < rowLimit) {
                    pixels[off++] = postVal;
                }
            }
            off += adjust; //change in off from row to row
        }
    }
    
    protected void fillSimpleRepeat(int[] pixels, int off, int adjust, 
                               int x, int y, int w, int h) {

        final float initConst = (dgdX*x) + gc;

        // Limit step to fractional part of
        // fastGradientArraySize (the non fractional part has
        // no affect anyways, and would mess up lots of stuff
        // below).
        float step = (dgdX - (int)dgdX)*fastGradientArraySize;

                // Make it a Positive step (a small negative step is
                // the same as a positive step slightly less than
                // fastGradientArraySize.
        if (step < 0) 
            step += fastGradientArraySize;

        final int [] grad = gradient;

        for(int i=0; i<h; i++) { //for every row
            //initialize current value to be start.
            float g = initConst + dgdY*(y+i); 

            // now Limited between -1 and 1.
            g = g-(int)g;
            // put in the positive side.
            if (g < 0)
                g += 1;
                        
            // scale for gradient array... 
            g *= fastGradientArraySize;
            g += 0.5; // rounding factor
            final int rowLimit = off+w;  // end of row iteration
            while (off < rowLimit) {
                int idx = (int)g;
                if (idx >= fastGradientArraySize) {
                    g   -= fastGradientArraySize;
                    idx -= fastGradientArraySize; 
                }
                pixels[off++] = grad[idx];
                g += step;
            }

            off += adjust; //change in off from row to row
        }
    }


    protected void fillSimpleReflect(int[] pixels, int off, int adjust, 
                                int x, int y, int w, int h) {
        final float initConst = (dgdX*x) + gc;

        final int [] grad = gradient;

        for (int i=0; i<h; i++) { //for every row
            //initialize current value to be start.
            float g = initConst + dgdY*(y+i); 

            // now limited g to -2<->2
            g = g - 2*((int)(g/2.0f));

            float step = dgdX;
            // Pull it into the positive half
            if (g < 0) {
                g = -g; //take absolute value
                step = - step;  // Change direction..
            }

            // Now do the same for dgdX. This is safe because
            // any step that is a multiple of 2.0 has no
            // affect, hence we can remove it which the first
            // part does.  The second part simply adds 2.0
            // (which has no affect due to the cylcle) to move
            // all negative step values into the positive
            // side.
            step = step - 2*((int)step/2.0f);
            if (step < 0) 
                step += 2.0;
            final int reflectMax = 2*fastGradientArraySize;

            // Scale for gradient array.
            g    *= fastGradientArraySize;
            g    += 0.5;
            step *= fastGradientArraySize;
            final int rowLimit = off+w;  // end of row iteration
            while (off < rowLimit) {
                int idx = (int)g;
                if (idx >= reflectMax) {
                    g   -= reflectMax;
                    idx -= reflectMax;
                }

                if (idx <= fastGradientArraySize)
                    pixels[off++] = grad[idx];
                else
                    pixels[off++] = grad[reflectMax-idx];
                g+= step;
            }

            off += adjust; //change in off from row to row
        }
    }
        
    /**
     * Return a Raster containing the colors generated for the graphics
     * operation.  This is where the area is filled with colors distributed
     * linearly.
     *
     * @param x,y,w,h The area in device space for which colors are
     * generated.
     *
     */
    protected void fillRaster(int[] pixels, int off, int adjust, 
                              int x, int y, int w, int h) {
	
        //constant which can be pulled out of the inner loop
        final float initConst = (dgdX*x) + gc;

        if (fillMethod == ANTI_ALIAS_IMPL) {
            //initialize current value to be start.
            for(int i=0; i<h; i++){ //for every row
                float g = initConst + dgdY*(y+i);
                
                final int rowLimit = off+w;  // end of row iteration
                while(off < rowLimit){ //for every pixel in this row.
                    //get the color
                    pixels[off++] = indexGradientAntiAlias(g, pixSz); 
                    g += dgdX; //incremental change in g
                }
                off += adjust; //change in off from row to row
            }
        }
        else if (!isSimpleLookup) {
            if (cycleMethod == MultipleGradientPaint.NO_CYCLE) {
                fillHardNoCycle(pixels, off, adjust, x, y, w, h);
            }
            else {
                //initialize current value to be start.
                for(int i=0; i<h; i++){ //for every row
                    float g = initConst + dgdY*(y+i); 
                
                    final int rowLimit = off+w;  // end of row iteration
                    while(off < rowLimit){ //for every pixel in this row.
                        //get the color
                        pixels[off++] = indexIntoGradientsArrays(g); 
                        g += dgdX; //incremental change in g
                    }
                    off += adjust; //change in off from row to row
                }
            }
        } else {
            // Simple implementations: just scale index by array size
            
            if (cycleMethod == MultipleGradientPaint.NO_CYCLE)
                fillSimpleNoCycle(pixels, off, adjust, x, y, w, h);
            else if (cycleMethod == MultipleGradientPaint.REPEAT)
                fillSimpleRepeat(pixels, off, adjust, x, y, w, h);
            else //cycleMethod == MultipleGradientPaint.REFLECT
                fillSimpleReflect(pixels, off, adjust, x, y, w, h);
        }
    }
    
    
}
"
MultipleGradientPaint.java,kitfox-6.9.6,"/*****************************************************************************
 * Copyright (C) The Apache Software Foundation. All rights reserved.        *
 * ------------------------------------------------------------------------- *
 * This software is published under the terms of the Apache Software License *
 * version 1.1, a copy of which has been included with this distribution in  *
 * the LICENSE file.                                                         *
 *****************************************************************************/

package com.kitfox.svg.batik;

import java.awt.Color;
import java.awt.Paint;
import java.awt.geom.AffineTransform;

/** This is the superclass for Paints which use a multiple color
 * gradient to fill in their raster.  It provides storage for variables and
 * enumerated values common to LinearGradientPaint and RadialGradientPaint.
 *
 *
 * @author Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans
 * @author <a href=""mailto:vincent.hardy@eng.sun.com"">Vincent Hardy</a>
 * @version $Id: MultipleGradientPaint.java,v 1.2 2004/09/27 09:27:27 kitfox Exp $
 *
 */

public abstract class MultipleGradientPaint implements Paint {

    /** Transparency. */
    protected int transparency;

    /** Gradient keyframe values in the range 0 to 1. */
    protected float[] fractions;

    /** Gradient colors. */
    protected Color[] colors;

    /** Transform to apply to gradient. */
    protected AffineTransform gradientTransform;

    /** The method to use when painting out of the gradient bounds. */
    protected CycleMethodEnum cycleMethod;

    /** The colorSpace in which to perform the interpolation. */
    protected ColorSpaceEnum colorSpace;

    /** Inner class to allow for typesafe enumerated ColorSpace values. */
    public static class ColorSpaceEnum {
    }

    /** Inner class to allow for typesafe enumerated CycleMethod values. */
    public static class CycleMethodEnum {
    }

    /** Indicates (if the gradient starts or ends inside the target region)
     *  to use the terminal colors to fill the remaining area. (default)
     */
    public static final CycleMethodEnum NO_CYCLE = new CycleMethodEnum();

    /** Indicates (if the gradient starts or ends inside the target region),
     *  to cycle the gradient colors start-to-end, end-to-start to fill the
     *  remaining area.
     */
    public static final CycleMethodEnum REFLECT = new CycleMethodEnum();

    /** Indicates (if the gradient starts or ends inside the target region),
     *  to cycle the gradient colors start-to-end, start-to-end to fill the
     *  remaining area.
     */
    public static final CycleMethodEnum REPEAT = new CycleMethodEnum();

    /** Indicates that the color interpolation should occur in sRGB space.
     *  (default)
     */
    public static final ColorSpaceEnum SRGB = new ColorSpaceEnum();

    /** Indicates that the color interpolation should occur in linearized
     *  RGB space.
     */
    public static final ColorSpaceEnum LINEAR_RGB = new ColorSpaceEnum();


     /**
     * Superclass constructor, typical user should never have to call this.
     *
     * @param fractions numbers ranging from 0.0 to 1.0 specifying the
     * distribution of colors along the gradient
     *
     * @param colors array of colors corresponding to each fractional value
     *
     * @param cycleMethod either NO_CYCLE, REFLECT, or REPEAT
     *
     * @param colorSpace which colorspace to use for interpolation,
     * either SRGB or LINEAR_RGB
     *
     * @param gradientTransform transform to apply to the gradient
     *
     * @throws NullPointerException if arrays are null, or
     * gradientTransform is null
     *
     * @throws IllegalArgumentException if fractions.length != colors.length,
     * or if colors is less than 2 in size, or if an enumerated value is bad.
     *
     * @see java.awt.PaintContext
     */
    public MultipleGradientPaint(float[] fractions,
                                 Color[] colors,
                                 CycleMethodEnum cycleMethod,
                                 ColorSpaceEnum colorSpace,
                                 AffineTransform gradientTransform) {

        if (fractions == null) {
            throw new IllegalArgumentException(""Fractions array cannot be "" +
                                               ""null"");
        }

        if (colors == null) {
            throw new IllegalArgumentException(""Colors array cannot be null"");
        }

        if (fractions.length != colors.length) {
            throw new IllegalArgumentException(""Colors and fractions must "" +
                                               ""have equal size"");
        }

        if (colors.length < 2) {
            throw new IllegalArgumentException(""User must specify at least "" +
                                               ""2 colors"");
        }

        if ((colorSpace != LINEAR_RGB) &&
            (colorSpace != SRGB)) {
            throw new IllegalArgumentException(""Invalid colorspace for "" +
                                               ""interpolation."");
        }

        if ((cycleMethod != NO_CYCLE) &&
            (cycleMethod != REFLECT) &&
            (cycleMethod != REPEAT)) {
            throw new IllegalArgumentException(""Invalid cycle method."");
        }

        if (gradientTransform == null) {
            throw new IllegalArgumentException(""Gradient transform cannot be ""+
                                               ""null."");
        }

        //copy the fractions array
        this.fractions = new float[fractions.length];
        System.arraycopy(fractions, 0, this.fractions, 0, fractions.length);

        //copy the colors array
        this.colors = new Color[colors.length];
        System.arraycopy(colors, 0, this.colors, 0, colors.length);

        //copy some flags
        this.colorSpace = colorSpace;
        this.cycleMethod = cycleMethod;

        //copy the gradient transform
        this.gradientTransform = (AffineTransform)gradientTransform.clone();

        // Process transparency
        boolean opaque = true;
        for(int i=0; i<colors.length; i++){
            opaque = opaque && (colors[i].getAlpha()==0xff);
        }

        if(opaque) {
            transparency = OPAQUE;
        }

        else {
            transparency = TRANSLUCENT;
        }
    }

    /**
     * Returns a copy of the array of colors used by this gradient.
     * @return a copy of the array of colors used by this gradient
     *
     */
    public Color[] getColors() {
        Color colors[] = new Color[this.colors.length];
        System.arraycopy(this.colors, 0, colors, 0, this.colors.length);
        return colors;
    }

    /**
     * Returns a copy of the array of floats used by this gradient
     * to calculate color distribution.
     * @return a copy of the array of floats used by this gradient to
     * calculate color distribution
     *
     */
    public float[] getFractions() {
        float fractions[] = new float[this.fractions.length];
        System.arraycopy(this.fractions, 0, fractions, 0, this.fractions.length);
        return fractions;
    }

    /**
     * Returns the transparency mode for this LinearGradientPaint.
     * @return an integer value representing this LinearGradientPaint object's
     * transparency mode.
     * @see java.awt.Transparency
     */
    public int getTransparency() {
        return transparency;
    }

    /**
     * Returns the enumerated type which specifies cycling behavior.
     * @return the enumerated type which specifies cycling behavior
     */
    public CycleMethodEnum getCycleMethod() {
        return cycleMethod;
    }

    /**
     * Returns the enumerated type which specifies color space for
     * interpolation.
     * @return the enumerated type which specifies color space for
     * interpolation
     */
    public ColorSpaceEnum getColorSpace() {
        return colorSpace;
    }

    /**
     * Returns a copy of the transform applied to the gradient.
     * @return a copy of the transform applied to the gradient.
     */
    public AffineTransform getTransform() {
        return (AffineTransform)gradientTransform.clone();
    }
}
"
MultipleGradientPaintContext.java,kitfox-6.9.6,"/*****************************************************************************
 * Copyright (C) The Apache Software Foundation. All rights reserved.        *
 * ------------------------------------------------------------------------- *
 * This software is published under the terms of the Apache Software License *
 * version 1.1, a copy of which has been included with this distribution in  *
 * the LICENSE file.                                                         *
 *****************************************************************************/

package com.kitfox.svg.batik;

import java.awt.Color;
import java.awt.PaintContext;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.color.ColorSpace;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Rectangle2D;
import java.awt.image.ColorModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferInt;
import java.awt.image.DirectColorModel;
import java.awt.image.Raster;
import java.awt.image.SinglePixelPackedSampleModel;
import java.awt.image.WritableRaster;
import java.lang.ref.WeakReference;

//import org.apache.batik.ext.awt.image.GraphicsUtil;

/** This is the superclass for all PaintContexts which use a multiple color
 * gradient to fill in their raster. It provides the actual color interpolation
 * functionality.  Subclasses only have to deal with using the gradient to fill
 * pixels in a raster.
 *
 * @author Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans
 * @author <a href=""mailto:vincent.hardy@eng.sun.com"">Vincent Hardy</a>
 * @version $Id: MultipleGradientPaintContext.java,v 1.1 2004/09/06 19:35:39 kitfox Exp $
 *
 */
abstract class MultipleGradientPaintContext implements PaintContext {

    protected final static boolean DEBUG = false;

    /**
     * The color model data is generated in (always un premult).
     */
    protected ColorModel dataModel;
    /**
     * PaintContext's output ColorModel ARGB if colors are not all
     * opaque, RGB otherwise.  Linear and premult are matched to
     * output ColorModel.
     */
    protected ColorModel model;

    /** Color model used if gradient colors are all opaque */
    private static ColorModel lrgbmodel_NA = new DirectColorModel
        (ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB),
         24, 0xff0000, 0xFF00, 0xFF, 0x0,
         false, DataBuffer.TYPE_INT);

    private static ColorModel srgbmodel_NA = new DirectColorModel
        (ColorSpace.getInstance(ColorSpace.CS_sRGB),
         24, 0xff0000, 0xFF00, 0xFF, 0x0,
         false, DataBuffer.TYPE_INT);

    /** Color model used if some gradient colors are transparent */
    private static ColorModel lrgbmodel_A = new DirectColorModel
        (ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB),
         32, 0xff0000, 0xFF00, 0xFF, 0xFF000000,
         false, DataBuffer.TYPE_INT);

    private static ColorModel srgbmodel_A = new DirectColorModel
        (ColorSpace.getInstance(ColorSpace.CS_sRGB),
         32, 0xff0000, 0xFF00, 0xFF, 0xFF000000,
         false, DataBuffer.TYPE_INT);

     /** The cached colorModel */
    protected static ColorModel cachedModel;

    /** The cached raster, which is reusable among instances */
    protected static WeakReference cached;

    /** Raster is reused whenever possible */
    protected WritableRaster saved;

    /** The method to use when painting out of the gradient bounds. */
    protected MultipleGradientPaint.CycleMethodEnum cycleMethod;

    /** The colorSpace in which to perform the interpolation */
    protected MultipleGradientPaint.ColorSpaceEnum colorSpace;

    /** Elements of the inverse transform matrix. */
    protected float a00, a01, a10, a11, a02, a12;

    /** This boolean specifies wether we are in simple lookup mode, where an
     * input value between 0 and 1 may be used to directly index into a single
     * array of gradient colors.  If this boolean value is false, then we have
     * to use a 2-step process where we have to determine which gradient array
     * we fall into, then determine the index into that array.
     */
    protected boolean isSimpleLookup = true;

    /** This boolean indicates if the gradient appears to have sudden
     *  discontinuities in it, this may be because of multiple stops
     *  at the same location or use of the REPEATE mode.  
     */
    protected boolean hasDiscontinuity = false;

    /** Size of gradients array for scaling the 0-1 index when looking up
     *  colors the fast way.  */
    protected int fastGradientArraySize;

    /**
     * Array which contains the interpolated color values for each interval,
     * used by calculateSingleArrayGradient().  It is protected for possible
     * direct access by subclasses.
     */
    protected int[] gradient;

    /** Array of gradient arrays, one array for each interval.  Used by
     *  calculateMultipleArrayGradient().
     */
    protected int[][] gradients;

    /** This holds the blend of all colors in the gradient.
     *  we use this at extreamly low resolutions to ensure we
     *  get a decent blend of the colors.
     */
    protected int gradientAverage;

    /** This holds the color to use when we are off the bottom of the
     * gradient */
    protected int gradientUnderflow;

    /** This holds the color to use when we are off the top of the
     * gradient */
    protected int gradientOverflow;

    /** Length of the 2D slow lookup gradients array. */
    protected int gradientsLength;

    /** Normalized intervals array */
    protected float[] normalizedIntervals;

    /** fractions array */
    protected float[] fractions;

    /** Used to determine if gradient colors are all opaque */
    private int transparencyTest;

    /** Colorspace conversion lookup tables */
    private static final int SRGBtoLinearRGB[] = new int[256];
    private static final int LinearRGBtoSRGB[] = new int[256];

    //build the tables
    static{
        for (int k = 0; k < 256; k++) {
            SRGBtoLinearRGB[k] = convertSRGBtoLinearRGB(k);
            LinearRGBtoSRGB[k] = convertLinearRGBtoSRGB(k);
        }
    }

    /** Constant number of max colors between any 2 arbitrary colors.
     * Used for creating and indexing gradients arrays.
     */
    protected static final int GRADIENT_SIZE = 256;
    protected static final int GRADIENT_SIZE_INDEX = GRADIENT_SIZE -1;

    /** Maximum length of the fast single-array.  If the estimated array size
     * is greater than this, switch over to the slow lookup method.
     * No particular reason for choosing this number, but it seems to provide
     * satisfactory performance for the common case (fast lookup).
     */
    private static final int MAX_GRADIENT_ARRAY_SIZE = 5000;

   /** Constructor for superclass. Does some initialization, but leaves most
    * of the heavy-duty math for calculateGradient(), so the subclass may do
    * some other manipulation beforehand if necessary.  This is not possible
    * if this computation is done in the superclass constructor which always
    * gets called first.
    **/
    public MultipleGradientPaintContext(ColorModel cm,
                                        Rectangle deviceBounds,
                                        Rectangle2D userBounds,
                                        AffineTransform t,
                                        RenderingHints hints,
                                        float[] fractions,
                                        Color[] colors,
                                        MultipleGradientPaint.CycleMethodEnum
                                        cycleMethod,
                                        MultipleGradientPaint.ColorSpaceEnum
                                        colorSpace)
        throws NoninvertibleTransformException
    {
        //We have to deal with the cases where the 1st gradient stop is not
        //equal to 0 and/or the last gradient stop is not equal to 1.
        //In both cases, create a new point and replicate the previous
        //extreme point's color.

        boolean fixFirst = false;
        boolean fixLast = false;
        int len = fractions.length;

        //if the first gradient stop is not equal to zero, fix this condition
        if (fractions[0] != 0f) {
            fixFirst = true;
            len++;
        }

        //if the last gradient stop is not equal to one, fix this condition
        if (fractions[fractions.length - 1] != 1f) {
            fixLast = true;
            len++;
        }
        
        for (int i=0; i<fractions.length-1; i++)
            if (fractions[i] == fractions[i+1])
                len--;

        this.fractions      = new float[len];
        Color [] loColors   = new Color[len-1];
        Color [] hiColors   = new Color[len-1];
        normalizedIntervals = new float[len-1];

        gradientUnderflow = colors[0].getRGB();
        gradientOverflow  = colors[colors.length-1].getRGB();

        int idx = 0;
        if (fixFirst) {
            this.fractions[0] = 0;
            loColors[0] = colors[0];
            hiColors[0] = colors[0];
            normalizedIntervals[0] = fractions[0];
            idx++;
        }

        for (int i=0; i<fractions.length-1; i++) {
            if (fractions[i] == fractions[i+1]) {
                // System.out.println(""EQ Fracts"");
                if (!colors[i].equals(colors[i+1])) {
                    hasDiscontinuity = true;
                }
                continue;
            }
            this.fractions[idx] = fractions[i];
            loColors[idx] = colors[i];
            hiColors[idx] = colors[i+1];
            normalizedIntervals[idx] = fractions[i+1]-fractions[i];
            idx++;
        }
            
        this.fractions[idx] = fractions[fractions.length-1];

        if (fixLast) {
            loColors[idx] = hiColors[idx] = colors[colors.length-1];
            normalizedIntervals[idx] = 1-fractions[fractions.length-1];
            idx++;
            this.fractions[idx] = 1;
        }

        // The inverse transform is needed to from device to user space.
        // Get all the components of the inverse transform matrix.
        AffineTransform tInv = t.createInverse();

        double m[] = new double[6];
        tInv.getMatrix(m);
        a00 = (float)m[0];
        a10 = (float)m[1];
        a01 = (float)m[2];
        a11 = (float)m[3];
        a02 = (float)m[4];
        a12 = (float)m[5];

        //copy some flags
        this.cycleMethod = cycleMethod;
        this.colorSpace = colorSpace;

        // Setup an example Model, we may refine it later.
        if (cm.getColorSpace() == lrgbmodel_A.getColorSpace())
            dataModel = lrgbmodel_A;
        else if (cm.getColorSpace() == srgbmodel_A.getColorSpace())
            dataModel = srgbmodel_A;
        else
            throw new IllegalArgumentException
                (""Unsupported ColorSpace for interpolation"");

        calculateGradientFractions(loColors, hiColors);

        model = GraphicsUtil.coerceColorModel(dataModel,
                                              cm.isAlphaPremultiplied());
    }


    /** This function is the meat of this class.  It calculates an array of
     * gradient colors based on an array of fractions and color values at those
     * fractions.
     */
    protected final void calculateGradientFractions
        (Color []loColors, Color []hiColors) {

        //if interpolation should occur in Linear RGB space, convert the
        //colors using the lookup table
        if (colorSpace == LinearGradientPaint.LINEAR_RGB) {
            for (int i = 0; i < loColors.length; i++) {
                loColors[i] = 
                    new Color(SRGBtoLinearRGB[loColors[i].getRed()],
                              SRGBtoLinearRGB[loColors[i].getGreen()],
                              SRGBtoLinearRGB[loColors[i].getBlue()],
                              loColors[i].getAlpha());
                
                hiColors[i] = 
                    new Color(SRGBtoLinearRGB[hiColors[i].getRed()],
                              SRGBtoLinearRGB[hiColors[i].getGreen()],
                              SRGBtoLinearRGB[hiColors[i].getBlue()],
                              hiColors[i].getAlpha());
            }
        }

        //initialize to be fully opaque for ANDing with colors
        transparencyTest = 0xff000000;

        //array of interpolation arrays
        gradients = new int[fractions.length - 1][];
        gradientsLength = gradients.length;

        // Find smallest interval
        int n = normalizedIntervals.length;

        float Imin = 1;

        for(int i = 0; i < n; i++) {
            Imin = (Imin > normalizedIntervals[i]) ?
                normalizedIntervals[i] : Imin;
        }

        //estimate the size of the entire gradients array.
        //This is to prevent a tiny interval from causing the size of array to
        //explode.  If the estimated size is too large, break to using
        //seperate arrays for each interval, and using an indexing scheme at
        //look-up time.
        int estimatedSize = 0;

        if (Imin == 0) {
            estimatedSize = Integer.MAX_VALUE;
            hasDiscontinuity = true;
        } else {
            for (int i = 0; i < normalizedIntervals.length; i++) {
                estimatedSize += (normalizedIntervals[i]/Imin) * GRADIENT_SIZE;
            }
        }


        if (estimatedSize > MAX_GRADIENT_ARRAY_SIZE) {
            //slow method
            calculateMultipleArrayGradient(loColors, hiColors);
            if ((cycleMethod == MultipleGradientPaint.REPEAT) &&
                (gradients[0][0] != 
                 gradients[gradients.length-1][GRADIENT_SIZE_INDEX]))
                hasDiscontinuity = true;
        } else {
            //fast method
            calculateSingleArrayGradient(loColors, hiColors, Imin);
            if ((cycleMethod == MultipleGradientPaint.REPEAT) &&
                (gradient[0] != gradient[fastGradientArraySize]))
                hasDiscontinuity = true;
        }

        // Use the most 'economical' model (no alpha).
        if((transparencyTest >>> 24) == 0xff) {
            if (dataModel.getColorSpace() == lrgbmodel_NA.getColorSpace())
                dataModel = lrgbmodel_NA;
            else if (dataModel.getColorSpace() == srgbmodel_NA.getColorSpace())
                dataModel = srgbmodel_NA;
            model = dataModel;
        }
    }


    /**
     * FAST LOOKUP METHOD
     *
     * This method calculates the gradient color values and places them in a
     * single int array, gradient[].  It does this by allocating space for
     * each interval based on its size relative to the smallest interval in
     * the array.  The smallest interval is allocated 255 interpolated values
     * (the maximum number of unique in-between colors in a 24 bit color
     * system), and all other intervals are allocated
     * size = (255 * the ratio of their size to the smallest interval).
     *
     * This scheme expedites a speedy retrieval because the colors are
     * distributed along the array according to their user-specified
     * distribution.  All that is needed is a relative index from 0 to 1.
     *
     * The only problem with this method is that the possibility exists for
     * the array size to balloon in the case where there is a
     * disproportionately small gradient interval.  In this case the other
     * intervals will be allocated huge space, but much of that data is
     * redundant.  We thus need to use the space conserving scheme below.
     *
     * @param Imin the size of the smallest interval
     *
     */
    private void calculateSingleArrayGradient
        (Color [] loColors, Color [] hiColors, float Imin) {

        //set the flag so we know later it is a non-simple lookup
        isSimpleLookup = true;

        int rgb1; //2 colors to interpolate
        int rgb2;

        int gradientsTot = 1; //the eventual size of the single array

        // These are fixed point 8.16 (start with 0.5)
        int aveA = 0x008000;
        int aveR = 0x008000;
        int aveG = 0x008000;
        int aveB = 0x008000;

        //for every interval (transition between 2 colors)
        for(int i=0; i < gradients.length; i++){

            //create an array whose size is based on the ratio to the
            //smallest interval.
            int nGradients = (int)((normalizedIntervals[i]/Imin)*255f);
            gradientsTot += nGradients;
            gradients[i] = new int[nGradients];

            //the the 2 colors (keyframes) to interpolate between
            rgb1 = loColors[i].getRGB();
            rgb2 = hiColors[i].getRGB();

            //fill this array with the colors in between rgb1 and rgb2
            interpolate(rgb1, rgb2, gradients[i]);

            // Calculate Average of two colors...
            int argb = gradients[i][GRADIENT_SIZE/2];
            float norm = normalizedIntervals[i];
            aveA += (int)(((argb>> 8)&0xFF0000)*norm);
            aveR += (int)(((argb    )&0xFF0000)*norm);
            aveG += (int)(((argb<< 8)&0xFF0000)*norm);
            aveB += (int)(((argb<<16)&0xFF0000)*norm);

            //if the colors are opaque, transparency should still be 0xff000000
            transparencyTest &= rgb1;
            transparencyTest &= rgb2;
        }

        gradientAverage = (((aveA & 0xFF0000)<< 8) |
                           ((aveR & 0xFF0000)    ) |
                           ((aveG & 0xFF0000)>> 8) |
                           ((aveB & 0xFF0000)>>16));

        // Put all gradients in a single array
        gradient = new int[gradientsTot];
        int curOffset = 0;
        for(int i = 0; i < gradients.length; i++){
            System.arraycopy(gradients[i], 0, gradient,
                             curOffset, gradients[i].length);
            curOffset += gradients[i].length;
        }
        gradient[gradient.length-1] = hiColors[hiColors.length-1].getRGB();

        //if interpolation occurred in Linear RGB space, convert the
        //gradients back to SRGB using the lookup table
        if (colorSpace == LinearGradientPaint.LINEAR_RGB) {
            if (dataModel.getColorSpace() ==
                ColorSpace.getInstance(ColorSpace.CS_sRGB)) {
                for (int i = 0; i < gradient.length; i++) {
                    gradient[i] =
                        convertEntireColorLinearRGBtoSRGB(gradient[i]);
                }
                gradientAverage = 
                    convertEntireColorLinearRGBtoSRGB(gradientAverage);
            }
        } else {
            if (dataModel.getColorSpace() ==
                ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB)) {
                for (int i = 0; i < gradient.length; i++) {
                    gradient[i] =
                        convertEntireColorSRGBtoLinearRGB(gradient[i]);
                }
                gradientAverage = 
                    convertEntireColorSRGBtoLinearRGB(gradientAverage);
            }
        }

        fastGradientArraySize = gradient.length - 1;
    }


    /**
     * SLOW LOOKUP METHOD
     *
     * This method calculates the gradient color values for each interval and
     * places each into its own 255 size array.  The arrays are stored in
     * gradients[][].  (255 is used because this is the maximum number of
     * unique colors between 2 arbitrary colors in a 24 bit color system)
     *
     * This method uses the minimum amount of space (only 255 * number of
     * intervals), but it aggravates the lookup procedure, because now we
     * have to find out which interval to select, then calculate the index
     * within that interval.  This causes a significant performance hit,
     * because it requires this calculation be done for every point in
     * the rendering loop.
     *
     * For those of you who are interested, this is a classic example of the
     * time-space tradeoff.
     *
     */
    private void calculateMultipleArrayGradient
        (Color [] loColors, Color [] hiColors) {

        //set the flag so we know later it is a non-simple lookup
        isSimpleLookup = false;

        int rgb1; //2 colors to interpolate
        int rgb2;

        // These are fixed point 8.16 (start with 0.5)
        int aveA = 0x008000;
        int aveR = 0x008000;
        int aveG = 0x008000;
        int aveB = 0x008000;

        //for every interval (transition between 2 colors)
        for(int i=0; i < gradients.length; i++){

            // This interval will never actually be used (zero size)
            if (normalizedIntervals[i] == 0)
                continue;

            //create an array of the maximum theoretical size for each interval
            gradients[i] = new int[GRADIENT_SIZE];

            //get the the 2 colors
            rgb1 = loColors[i].getRGB();
            rgb2 = hiColors[i].getRGB();

            //fill this array with the colors in between rgb1 and rgb2
            interpolate(rgb1, rgb2, gradients[i]);

            // Calculate Average of two colors...
            int argb = gradients[i][GRADIENT_SIZE/2];
            float norm = normalizedIntervals[i];
            aveA += (int)(((argb>> 8)&0xFF0000)*norm);
            aveR += (int)(((argb    )&0xFF0000)*norm);
            aveG += (int)(((argb<< 8)&0xFF0000)*norm);
            aveB += (int)(((argb<<16)&0xFF0000)*norm);

            //if the colors are opaque, transparency should still be 0xff000000
            transparencyTest &= rgb1;
            transparencyTest &= rgb2;
        }

        gradientAverage = (((aveA & 0xFF0000)<< 8) |
                           ((aveR & 0xFF0000)    ) |
                           ((aveG & 0xFF0000)>> 8) |
                           ((aveB & 0xFF0000)>>16));

        //if interpolation occurred in Linear RGB space, convert the
        //gradients back to SRGB using the lookup table
        if (colorSpace == LinearGradientPaint.LINEAR_RGB) {
            if (dataModel.getColorSpace() ==
                ColorSpace.getInstance(ColorSpace.CS_sRGB)) {
                for (int j = 0; j < gradients.length; j++) {
                    for (int i = 0; i < gradients[j].length; i++) {
                        gradients[j][i] =
                            convertEntireColorLinearRGBtoSRGB(gradients[j][i]);
                    }
                }
                gradientAverage = 
                    convertEntireColorLinearRGBtoSRGB(gradientAverage);
            }
        } else {
            if (dataModel.getColorSpace() ==
                ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB)) {
                for (int j = 0; j < gradients.length; j++) {
                    for (int i = 0; i < gradients[j].length; i++) {
                        gradients[j][i] =
                            convertEntireColorSRGBtoLinearRGB(gradients[j][i]);
                    }
                }
                gradientAverage = 
                    convertEntireColorSRGBtoLinearRGB(gradientAverage);
            }
        }
    }

    /** Yet another helper function.  This one linearly interpolates between
     * 2 colors, filling up the output array.
     *
     * @param rgb1 the start color
     * @param rgb2 the end color
     * @param output the output array of colors... assuming this is not null.
     *
     */
    private void interpolate(int rgb1, int rgb2, int[] output) {

        int a1, r1, g1, b1, da, dr, dg, db; //color components

        //step between interpolated values.
        float stepSize = 1/(float)output.length;

        //extract color components from packed integer
        a1 = (rgb1 >> 24) & 0xff;
        r1 = (rgb1 >> 16) & 0xff;
        g1 = (rgb1 >>  8) & 0xff;
        b1 = (rgb1      ) & 0xff;
        //calculate the total change in alpha, red, green, blue
        da = ((rgb2 >> 24) & 0xff) - a1;
        dr = ((rgb2 >> 16) & 0xff) - r1;
        dg = ((rgb2 >>  8) & 0xff) - g1;
        db = ((rgb2      ) & 0xff) - b1;

        //for each step in the interval calculate the in-between color by
        //multiplying the normalized current position by the total color change
        //(.5 is added to prevent truncation round-off error)
        for (int i = 0; i < output.length; i++) {
            output[i] =
                (((int) ((a1 + i * da * stepSize) + .5) << 24)) |
                (((int) ((r1 + i * dr * stepSize) + .5) << 16)) |
                (((int) ((g1 + i * dg * stepSize) + .5) <<  8)) |
                (((int) ((b1 + i * db * stepSize) + .5)      ));
        }
    }


    /** Yet another helper function.  This one extracts the color components
     * of an integer RGB triple, converts them from LinearRGB to SRGB, then
     * recompacts them into an int.
     */
    private int convertEntireColorLinearRGBtoSRGB(int rgb) {

        int a1, r1, g1, b1; //color components

        //extract red, green, blue components
        a1 = (rgb >> 24) & 0xff;
        r1 = (rgb >> 16) & 0xff;
        g1 = (rgb >> 8) & 0xff;
        b1 = rgb & 0xff;

        //use the lookup table
        r1 =  LinearRGBtoSRGB[r1];
        g1 =  LinearRGBtoSRGB[g1];
        b1 =  LinearRGBtoSRGB[b1];

        //re-compact the components
        return ((a1 << 24) |
                (r1 << 16) |
                (g1 << 8) |
                b1);
    }

    /** Yet another helper function.  This one extracts the color components
     * of an integer RGB triple, converts them from LinearRGB to SRGB, then
     * recompacts them into an int.
     */
    private int convertEntireColorSRGBtoLinearRGB(int rgb) {

        int a1, r1, g1, b1; //color components

        //extract red, green, blue components
        a1 = (rgb >> 24) & 0xff;
        r1 = (rgb >> 16) & 0xff;
        g1 = (rgb >> 8) & 0xff;
        b1 = rgb & 0xff;

        //use the lookup table
        r1 =  SRGBtoLinearRGB[r1];
        g1 =  SRGBtoLinearRGB[g1];
        b1 =  SRGBtoLinearRGB[b1];

        //re-compact the components
        return ((a1 << 24) |
                (r1 << 16) |
                (g1 << 8) |
                b1);
    }


    /** Helper function to index into the gradients array.  This is necessary
     * because each interval has an array of colors with uniform size 255.
     * However, the color intervals are not necessarily of uniform length, so
     * a conversion is required.
     *
     * @param position the unmanipulated position.  want to map this into the
     * range 0 to 1
     *
     * @returns integer color to display
     *
     */
    protected final int indexIntoGradientsArrays(float position) {

        //first, manipulate position value depending on the cycle method.

        if (cycleMethod == MultipleGradientPaint.NO_CYCLE) {

            if (position >= 1) { //upper bound is 1
                return gradientOverflow;
            }

            else if (position <= 0) { //lower bound is 0
                return gradientUnderflow;
            }
        }

        else if (cycleMethod == MultipleGradientPaint.REPEAT) {
            //get the fractional part
            //(modulo behavior discards integer component)
            position = position - (int)position;

            //position now be between -1 and 1

            if (position < 0) {
                position = position + 1; //force it to be in the range 0-1
            }

            int w=0, c1=0, c2=0;
            if (isSimpleLookup) {
              position *= gradient.length;
              int idx1 = (int)(position);
              if (idx1+1 < gradient.length)
                return gradient[idx1];

              w = (int)((position-idx1)*(1<<16));
              c1 = gradient[idx1];
              c2 = gradient[0];
            } else {
              //for all the gradient interval arrays
              for (int i = 0; i < gradientsLength; i++) {

                if (position < fractions[i+1]) { //this is the array we want

                  float delta = position - fractions[i];
                  
                  delta = ((delta / normalizedIntervals[i]) * GRADIENT_SIZE);
                  //this is the interval we want.
                  int index = (int)delta;
                  if ((index+1<gradients[i].length) ||
                      (i+1 < gradientsLength))
                    return gradients[i][index];

                  w  = (int)((delta-index)*(1<<16));
                  c1 = gradients[i][index];
                  c2 = gradients[0][0];
                  break;
                }
              }
            }

            return 
              ((((  (  (c1>>  8)           &0xFF0000)+
                    ((((c2>>>24)     )-((c1>>>24)     ))*w))&0xFF0000)<< 8) |
               
               (((  (  (c1     )           &0xFF0000)+
                    ((((c2>> 16)&0xFF)-((c1>> 16)&0xFF))*w))&0xFF0000)    ) |
                    
               (((  (  (c1<<  8)           &0xFF0000)+
                    ((((c2>>  8)&0xFF)-((c1>>  8)&0xFF))*w))&0xFF0000)>> 8) |
               
               (((  (  (c1<< 16)           &0xFF0000)+
                    ((((c2     )&0xFF)-((c1     )&0xFF))*w))&0xFF0000)>>16));

            // return c1 +
            //   ((( ((((c2>>>24)     )-((c1>>>24)     ))*w)&0xFF0000)<< 8) |
            //    (( ((((c2>> 16)&0xFF)-((c1>> 16)&0xFF))*w)&0xFF0000)    ) |
            //    (( ((((c2>>  8)&0xFF)-((c1>>  8)&0xFF))*w)&0xFF0000)>> 8) |
            //    (( ((((c2     )&0xFF)-((c1     )&0xFF))*w)&0xFF0000)>>16));
        }

        else {  //cycleMethod == MultipleGradientPaint.REFLECT

            if (position < 0) {
                position = -position; //take absolute value
            }

            int part = (int)position; //take the integer part

            position = position - part; //get the fractional part

            if ((part & 0x00000001) == 1) { //if integer part is odd
                position = 1 - position; //want the reflected color instead
            }
        }

        //now, get the color based on this 0-1 position:

        if (isSimpleLookup) { //easy to compute: just scale index by array size
            return gradient[(int)(position * fastGradientArraySize)];
        }

        else { //more complicated computation, to save space

            //for all the gradient interval arrays
            for (int i = 0; i < gradientsLength; i++) {

                if (position < fractions[i+1]) { //this is the array we want

                    float delta = position - fractions[i];

                    //this is the interval we want.
                    int index = (int)((delta / normalizedIntervals[i])
                                      * (GRADIENT_SIZE_INDEX));

                    return gradients[i][index];
                }
            }

        }

        return gradientOverflow;
    }


    /** Helper function to index into the gradients array.  This is necessary
     * because each interval has an array of colors with uniform size 255.
     * However, the color intervals are not necessarily of uniform length, so
     * a conversion is required.  This version also does anti-aliasing by
     * averaging the gradient over position+/-(sz/2).
     *
     * @param position the unmanipulated position.  want to map this into the
     * range 0 to 1
     * @param sz the size in gradient space to average.
     *
     * @returns ARGB integer color to display
     */
    protected final int indexGradientAntiAlias(float position, float sz) {
        //first, manipulate position value depending on the cycle method.
        if (cycleMethod == MultipleGradientPaint.NO_CYCLE) {
            if (DEBUG) System.out.println(""NO_CYCLE"");
            float p1 = position-(sz/2);
            float p2 = position+(sz/2);

            if (p1 >= 1) 
                return gradientOverflow;

            if (p2 <= 0) 
                return gradientUnderflow;

            int interior;
            float top_weight=0, bottom_weight=0, frac;
            if (p2 >= 1) {
                top_weight = (p2-1)/sz;
                if (p1 <= 0) {
                    bottom_weight = -p1/sz;
                    frac=1;
                    interior = gradientAverage;
                } else {
                    frac=1-p1;
                    interior = getAntiAlias(p1, true, 1, false, 1-p1, 1);
                }
            } else if (p1 <= 0) {
                bottom_weight = -p1/sz;
                frac = p2;
                interior = getAntiAlias(0, true, p2, false, p2, 1);
            } else
                return getAntiAlias(p1, true, p2, false, sz, 1);
            
            int norm = (int)((1<<16)*frac/sz);
            int pA = (((interior>>>20)&0xFF0)*norm)>>16;
            int pR = (((interior>> 12)&0xFF0)*norm)>>16;
            int pG = (((interior>>  4)&0xFF0)*norm)>>16;
            int pB = (((interior<<  4)&0xFF0)*norm)>>16;

            if (bottom_weight != 0) {
                int bPix = gradientUnderflow;
                // System.out.println(""ave: "" + gradientAverage);
                norm = (int)((1<<16)*bottom_weight);
                pA += (((bPix>>>20) & 0xFF0)*norm)>>16;
                pR += (((bPix>> 12) & 0xFF0)*norm)>>16;
                pG += (((bPix>>  4) & 0xFF0)*norm)>>16;
                pB += (((bPix<<  4) & 0xFF0)*norm)>>16;
            }

            if (top_weight != 0) {
                int tPix = gradientOverflow;

                norm = (int)((1<<16)*top_weight);
                pA += (((tPix>>>20) & 0xFF0)*norm)>>16;
                pR += (((tPix>> 12) & 0xFF0)*norm)>>16;
                pG += (((tPix>>  4) & 0xFF0)*norm)>>16;
                pB += (((tPix<<  4) & 0xFF0)*norm)>>16;
            }

            return (((pA&0xFF0)<<20)  |
                    ((pR&0xFF0)<<12)  |
                    ((pG&0xFF0)<< 4)  |
                    ((pB&0xFF0)>> 4));
        }

        // See how many times we are going to ""wrap around"" the gradient,
        // array.
        int intSz = (int)sz;
        
        float weight = 1f;
        if (intSz != 0) {
            // We need to make sure that sz is < 1.0 otherwise 
            // p1 and p2 my pass each other which will cause no end of
            // trouble.
            sz -= intSz;
            weight = sz/(intSz+sz);
            if (weight < 0.1)
                // The part of the color from the location will be swamped
                // by the averaged part of the gradient so just use the
                // average color for the gradient.
                return gradientAverage;
        }
            
        // So close to full gradient just use the average value...
        if (sz > 0.99)
            return gradientAverage;
            
            // Go up and down from position by 1/2 sz.
        float p1 = position-(sz/2);
        float p2 = position+(sz/2);
        if (DEBUG) System.out.println(""P1: "" + p1 + "" P2: "" + p2);

        // These indicate the direction to go from p1 and p2 when
        // averaging...
        boolean p1_up=true;
        boolean p2_up=false;

        if (cycleMethod == MultipleGradientPaint.REPEAT) {
            if (DEBUG) System.out.println(""REPEAT"");

            // Get positions between -1 and 1
            p1=p1-(int)p1;
            p2=p2-(int)p2;

            // force to be in rage 0-1.
            if (p1 <0) p1 += 1;
            if (p2 <0) p2 += 1;
        }

        else {  //cycleMethod == MultipleGradientPaint.REFLECT
            if (DEBUG) System.out.println(""REFLECT"");

            //take absolute values
            // Note when we reflect we change sense of p1/2_up.
            if (p2 < 0) {
                p1 = -p1; p1_up = !p1_up;
                p2 = -p2; p2_up = !p2_up;
            } else if (p1 < 0) { 
                p1 = -p1; p1_up = !p1_up; 
            }

            int part1, part2;
            part1 = (int)p1;   // take the integer part
            p1   = p1 - part1; // get the fractional part

            part2 = (int)p2;   // take the integer part
            p2   = p2 - part2; // get the fractional part

            // if integer part is odd we want the reflected color instead.
            // Note when we reflect we change sense of p1/2_up.
            if ((part1 & 0x01) == 1) {
                p1 = 1-p1;
                p1_up = !p1_up;
            }

            if ((part2 & 0x01) == 1) {
                p2 = 1-p2;
                p2_up = !p2_up;
            }

            // Check if in the end they just got switched around.
            // this commonly happens if they both end up negative.
            if ((p1 > p2) && !p1_up && p2_up) {
                float t = p1;
                p1 = p2; 
                p2 = t;
                p1_up = true;
                p2_up = false;
            }
        }

        return getAntiAlias(p1, p1_up, p2, p2_up, sz, weight);
    }


    private final int getAntiAlias(float p1, boolean p1_up,
                                   float p2, boolean p2_up,
                                   float sz, float weight) {

        // Until the last set of ops these are 28.4 fixed point values.
        int ach=0, rch=0, gch=0, bch=0;
        if (isSimpleLookup) {
            p1 *= fastGradientArraySize;
            p2 *= fastGradientArraySize;

            int idx1 = (int)p1;
            int idx2 = (int)p2;

            int i, pix;

            if (p1_up && !p2_up && (idx1 <= idx2)) {

                if (idx1 == idx2)
                    return gradient[idx1];

                // Sum between idx1 and idx2.
                for (i=idx1+1; i<idx2; i++) {
                    pix  = gradient[i];
                    ach += ((pix>>>20)&0xFF0);
                    rch += ((pix>>>12)&0xFF0);
                    gch += ((pix>>> 4)&0xFF0);
                    bch += ((pix<<  4)&0xFF0);
                }
            } else {
                // Do the bulk of the work, all the whole gradient entries
                // for idx1 and idx2.
                if (p1_up) {
                    for (i=idx1+1; i<fastGradientArraySize; i++) {
                        pix  = gradient[i];
                        ach += ((pix>>>20)&0xFF0);
                        rch += ((pix>>>12)&0xFF0);
                        gch += ((pix>>> 4)&0xFF0);
                        bch += ((pix<<  4)&0xFF0);
                    }
                } else {
                    for (i=0; i<idx1; i++) {
                        pix  = gradient[i];
                        ach += ((pix>>>20)&0xFF0);
                        rch += ((pix>>>12)&0xFF0);
                        gch += ((pix>>> 4)&0xFF0);
                        bch += ((pix<<  4)&0xFF0);
                    }
                }

                if (p2_up) {
                    for (i=idx2+1; i<fastGradientArraySize; i++) {
                        pix  = gradient[i];
                        ach += ((pix>>>20)&0xFF0);
                        rch += ((pix>>>12)&0xFF0);
                        gch += ((pix>>> 4)&0xFF0);
                        bch += ((pix<<  4)&0xFF0);
                    }
                } else {
                    for (i=0; i<idx2; i++) {
                        pix  = gradient[i];
                        ach += ((pix>>>20)&0xFF0);
                        rch += ((pix>>>12)&0xFF0);
                        gch += ((pix>>> 4)&0xFF0);
                        bch += ((pix<<  4)&0xFF0);
                    }
                }
            }

            int norm, isz;

            // Normalize the summation so far...
            isz = (int)((1<<16)/(sz*fastGradientArraySize));
            ach = (ach*isz)>>16;
            rch = (rch*isz)>>16;
            gch = (gch*isz)>>16;
            bch = (bch*isz)>>16;

            // Clean up with the partial buckets at each end.
            if (p1_up) norm = (int)((1-(p1-idx1))*isz);
            else       norm = (int)(   (p1-idx1) *isz);
            pix = gradient[idx1];
            ach += (((pix>>>20)&0xFF0) *norm)>>16;
            rch += (((pix>>>12)&0xFF0) *norm)>>16;
            gch += (((pix>>> 4)&0xFF0) *norm)>>16;
            bch += (((pix<<  4)&0xFF0) *norm)>>16;

            if (p2_up) norm = (int)((1-(p2-idx2))*isz);
            else       norm = (int)(   (p2-idx2) *isz);
            pix = gradient[idx2];
            ach += (((pix>>>20)&0xFF0) *norm)>>16;
            rch += (((pix>>>12)&0xFF0) *norm)>>16;
            gch += (((pix>>> 4)&0xFF0) *norm)>>16;
            bch += (((pix<<  4)&0xFF0) *norm)>>16;

            // Round and drop the 4bits frac.
            ach = (ach+0x08)>>4;
            rch = (rch+0x08)>>4;
            gch = (gch+0x08)>>4;
            bch = (bch+0x08)>>4;

        } else {
            int idx1=0, idx2=0;
            int i1=-1, i2=-1;
            float f1=0, f2=0;
            // Find which gradient interval our points fall into.
            for (int i = 0; i < gradientsLength; i++) {
                if ((p1 < fractions[i+1]) && (i1 == -1)) { 
                    //this is the array we want
                    i1 = i;
                    f1 = p1 - fractions[i];

                    f1 = ((f1/normalizedIntervals[i])
                             *GRADIENT_SIZE_INDEX);
                    //this is the  interval we want.
                    idx1 = (int)f1;
                    if (i2 != -1) break;
                }
                if ((p2 < fractions[i+1]) && (i2 == -1)) { 
                    //this is the array we want
                    i2 = i;
                    f2 = p2 - fractions[i];
                    
                    f2 = ((f2/normalizedIntervals[i])
                             *GRADIENT_SIZE_INDEX);
                    //this is the interval we want.
                    idx2 = (int)f2;
                    if (i1 != -1) break;
                }
            }

            if (i1 == -1) {
                i1 = gradients.length - 1;
                f1 = idx1 = GRADIENT_SIZE_INDEX;
            }

            if (i2 == -1) {
                i2 = gradients.length - 1;
                f2 = idx2 = GRADIENT_SIZE_INDEX;
            }

            if (DEBUG) System.out.println(""I1: "" + i1 + "" Idx1: "" + idx1 +
                                          "" I2: "" + i2 + "" Idx2: "" + idx2); 

            // Simple case within one gradient array (so the average
            // of the two idx gives us the true average of colors).
            if ((i1 == i2) && (idx1 <= idx2) && p1_up && !p2_up)
                return gradients[i1][(idx1+idx2+1)>>1];

            // i1 != i2

            int pix, norm;
            int base = (int)((1<<16)/sz);
            if ((i1 < i2) && p1_up && !p2_up) {
                norm = (int)((base
                              *normalizedIntervals[i1]
                              *(GRADIENT_SIZE_INDEX-f1))
                             /GRADIENT_SIZE_INDEX);
                pix  = gradients[i1][(idx1+GRADIENT_SIZE)>>1];
                ach += (((pix>>>20)&0xFF0) *norm)>>16;
                rch += (((pix>>>12)&0xFF0) *norm)>>16;
                gch += (((pix>>> 4)&0xFF0) *norm)>>16;
                bch += (((pix<<  4)&0xFF0) *norm)>>16;

                for (int i=i1+1; i<i2; i++) {
                    norm = (int)(base*normalizedIntervals[i]);
                    pix  = gradients[i][GRADIENT_SIZE>>1];
                  
                    ach += (((pix>>>20)&0xFF0) *norm)>>16;
                    rch += (((pix>>>12)&0xFF0) *norm)>>16;
                    gch += (((pix>>> 4)&0xFF0) *norm)>>16;
                    bch += (((pix<<  4)&0xFF0) *norm)>>16;
                }

                norm = (int)((base*normalizedIntervals[i2]*f2)
                             /GRADIENT_SIZE_INDEX);
                pix  = gradients[i2][(idx2+1)>>1];
                ach += (((pix>>>20)&0xFF0) *norm)>>16;
                rch += (((pix>>>12)&0xFF0) *norm)>>16;
                gch += (((pix>>> 4)&0xFF0) *norm)>>16;
                bch += (((pix<<  4)&0xFF0) *norm)>>16;
            } else {
                if (p1_up) {
                    norm = (int)((base
                                  *normalizedIntervals[i1]
                                  *(GRADIENT_SIZE_INDEX-f1))
                                 /GRADIENT_SIZE_INDEX);
                    pix  = gradients[i1][(idx1+GRADIENT_SIZE)>>1];
                } else {
                    norm = (int)((base*normalizedIntervals[i1]*f1)
                                 /GRADIENT_SIZE_INDEX);
                    pix  = gradients[i1][(idx1+1)>>1];
                }
                ach += (((pix>>>20)&0xFF0) *norm)>>16;
                rch += (((pix>>>12)&0xFF0) *norm)>>16;
                gch += (((pix>>> 4)&0xFF0) *norm)>>16;
                bch += (((pix<<  4)&0xFF0) *norm)>>16;

                if (p2_up) {
                    norm = (int)((base
                                  *normalizedIntervals[i2]
                                  *(GRADIENT_SIZE_INDEX-f2))
                                 /GRADIENT_SIZE_INDEX);
                    pix  =  gradients[i2][(idx2+GRADIENT_SIZE)>>1];
                } else {
                    norm = (int)((base*normalizedIntervals[i2]*f2)
                                 /GRADIENT_SIZE_INDEX);
                    pix  = gradients[i2][(idx2+1)>>1];
                }
                ach += (((pix>>>20)&0xFF0) *norm)>>16;
                rch += (((pix>>>12)&0xFF0) *norm)>>16;
                gch += (((pix>>> 4)&0xFF0) *norm)>>16;
                bch += (((pix<<  4)&0xFF0) *norm)>>16;

                if (p1_up) {
                    for (int i=i1+1; i<gradientsLength; i++) {
                        norm = (int)(base*normalizedIntervals[i]);
                        pix  = gradients[i][GRADIENT_SIZE>>1];

                        ach += (((pix>>>20)&0xFF0) *norm)>>16;
                        rch += (((pix>>>12)&0xFF0) *norm)>>16;
                        gch += (((pix>>> 4)&0xFF0) *norm)>>16;
                        bch += (((pix<<  4)&0xFF0) *norm)>>16;
                    }
                } else {
                    for (int i=0; i<i1; i++) {
                        norm = (int)(base*normalizedIntervals[i]);
                        pix  = gradients[i][GRADIENT_SIZE>>1];
                  
                        ach += (((pix>>>20)&0xFF0) *norm)>>16;
                        rch += (((pix>>>12)&0xFF0) *norm)>>16;
                        gch += (((pix>>> 4)&0xFF0) *norm)>>16;
                        bch += (((pix<<  4)&0xFF0) *norm)>>16;
                    }
                }

                if (p2_up) {
                    for (int i=i2+1; i<gradientsLength; i++) {
                        norm = (int)(base*normalizedIntervals[i]);
                        pix  = gradients[i][GRADIENT_SIZE>>1];

                        ach += (((pix>>>20)&0xFF0) *norm)>>16;
                        rch += (((pix>>>12)&0xFF0) *norm)>>16;
                        gch += (((pix>>> 4)&0xFF0) *norm)>>16;
                        bch += (((pix<<  4)&0xFF0) *norm)>>16;
                    }
                } else {
                    for (int i=0; i<i2; i++) {
                        norm = (int)(base*normalizedIntervals[i]);
                        pix  = gradients[i][GRADIENT_SIZE>>1];

                        ach += (((pix>>>20)&0xFF0) *norm)>>16;
                        rch += (((pix>>>12)&0xFF0) *norm)>>16;
                        gch += (((pix>>> 4)&0xFF0) *norm)>>16;
                        bch += (((pix<<  4)&0xFF0) *norm)>>16;
                    }
                }

            }
            ach = (ach+0x08)>>4;
            rch = (rch+0x08)>>4;
            gch = (gch+0x08)>>4;
            bch = (bch+0x08)>>4;
            if (DEBUG) System.out.println(""Pix: ["" + ach + "", "" + rch + 
                                          "", "" + gch + "", "" + bch + ""]"");
        }

        if (weight != 1) {
            // System.out.println(""ave: "" + gradientAverage);
            int aveW = (int)((1<<16)*(1-weight));
            int aveA = ((gradientAverage>>>24) & 0xFF)*aveW;
            int aveR = ((gradientAverage>> 16) & 0xFF)*aveW;
            int aveG = ((gradientAverage>>  8) & 0xFF)*aveW;
            int aveB = ((gradientAverage     ) & 0xFF)*aveW;

            int iw = (int)(weight*(1<<16));
            ach = ((ach*iw)+aveA)>>16;
            rch = ((rch*iw)+aveR)>>16;
            gch = ((gch*iw)+aveG)>>16;
            bch = ((bch*iw)+aveB)>>16;
        }
              
        return ((ach<<24) | (rch<<16) | (gch<<8) | bch);
    }


    /** Helper function to convert a color component in sRGB space to linear
     * RGB space.  Used to build a static lookup table.
     */
    private static int convertSRGBtoLinearRGB(int color) {

        float input, output;

        input = ((float) color) / 255.0f;
        if (input <= 0.04045f) {
            output = input / 12.92f;
        }
        else {
            output = (float) Math.pow((input + 0.055) / 1.055, 2.4);
        }
        int o = Math.round(output * 255.0f);

        return o;
    }

     /** Helper function to convert a color component in linear RGB space to
      *  SRGB space. Used to build a static lookup table.
      */
    private static int convertLinearRGBtoSRGB(int color) {

        float input, output;

        input = ((float) color) / 255.0f;

        if (input <= 0.0031308) {
            output = input * 12.92f;
        }
        else {
            output = (1.055f *
                ((float) Math.pow(input, (1.0 / 2.4)))) - 0.055f;
        }

        int o = Math.round(output * 255.0f);

        return o;
    }


    /** Superclass getRaster... */
    public final Raster getRaster(int x, int y, int w, int h) {
        if (w == 0 || h == 0) {
            return null;
        }

        //
        // If working raster is big enough, reuse it. Otherwise,
        // build a large enough new one.
        //
        WritableRaster raster = saved;
        if (raster == null || raster.getWidth() < w || raster.getHeight() < h)
            {
                raster = getCachedRaster(dataModel, w, h);
                saved = raster;
            }

        // Access raster internal int array. Because we use a DirectColorModel,
        // we know the DataBuffer is of type DataBufferInt and the SampleModel
        // is SinglePixelPackedSampleModel.
        // Adjust for initial offset in DataBuffer and also for the scanline
        // stride.
        //
        DataBufferInt rasterDB = (DataBufferInt)raster.getDataBuffer();
        int[] pixels = rasterDB.getBankData()[0];
        int off = rasterDB.getOffset();
        int scanlineStride = ((SinglePixelPackedSampleModel)
                              raster.getSampleModel()).getScanlineStride();
        int adjust = scanlineStride - w;

        fillRaster(pixels, off, adjust, x, y, w, h); //delegate to subclass.

        GraphicsUtil.coerceData(raster, dataModel,
                                model.isAlphaPremultiplied());


        return raster;
    }

    /** Subclasses should implement this. */
    protected abstract void fillRaster(int pixels[], int off, int adjust,
                                       int x, int y, int w, int h);


    /** Took this cacheRaster code from GradientPaint. It appears to recycle
     * rasters for use by any other instance, as long as they are sufficiently
     * large.
     */
    protected final
    static synchronized WritableRaster getCachedRaster
        (ColorModel cm, int w, int h) {
        if (cm == cachedModel) {
            if (cached != null) {
                WritableRaster ras = (WritableRaster) cached.get();
                if (ras != null &&
                    ras.getWidth() >= w &&
                    ras.getHeight() >= h)
                    {
                        cached = null;
                        return ras;
                    }
            }
        }
        // Don't create rediculously small rasters...
        if (w<32) w=32;
        if (h<32) h=32;
        return cm.createCompatibleWritableRaster(w, h);
    }

    /** Took this cacheRaster code from GradientPaint. It appears to recycle
     * rasters for use by any other instance, as long as they are sufficiently
     * large.
     */
    protected final
    static synchronized void putCachedRaster(ColorModel cm,
                                             WritableRaster ras) {
        if (cached != null) {
            WritableRaster cras = (WritableRaster) cached.get();
            if (cras != null) {
                int cw = cras.getWidth();
                int ch = cras.getHeight();
                int iw = ras.getWidth();
                int ih = ras.getHeight();
                if (cw >= iw && ch >= ih) {
                    return;
                }
                if (cw * ch >= iw * ih) {
                    return;
                }
            }
        }
        cachedModel = cm;
        cached = new WeakReference(ras);
    }

    /**
     * Release the resources allocated for the operation.
     */
    public final void dispose() {
        if (saved != null) {
            putCachedRaster(model, saved);
            saved = null;
        }
    }

    /**
     * Return the ColorModel of the output.
     */
    public final ColorModel getColorModel() {
        return model;
    }
}

"
RadialGradientPaint.java,kitfox-6.9.6,"/*****************************************************************************
 * Copyright (C) The Apache Software Foundation. All rights reserved.        *
 * ------------------------------------------------------------------------- *
 * This software is published under the terms of the Apache Software License *
 * version 1.1, a copy of which has been included with this distribution in  *
 * the LICENSE file.                                                         *
 *****************************************************************************/

package com.kitfox.svg.batik;

import java.awt.Color;
import java.awt.PaintContext;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.ColorModel;

/**
 * <p>
 * This class provides a way to fill a shape with a circular radial color 
 * gradient pattern. The user may specify 2 or more gradient colors, and this 
 * paint will provide an interpolation between each color.
 * <p>
 *
 * The user must provide an array of floats specifying how to distribute the 
 * colors along the gradient.  These values should range from 0.0 to 1.0 and 
 * act like keyframes along the gradient (they mark where the gradient should 
 * be exactly a particular color).
 *
 * <p>
 * This paint will map the first color of the gradient to a focus point within
 * the circle, and the last color to the perimeter of the circle, interpolating
 * smoothly for any inbetween colors specified by the user.  Any line drawn 
 * from the focus point to the circumference will span the all the gradient 
 * colors.  By default the focus is set to be the center of the circle.
 *
 * <p>
 * Specifying a focus point outside of the circle's radius will result in the 
 * focus being set to the intersection point of the focus-center line and the 
 * perimenter of the circle.
 * <p>
 *
 * Specifying a cycle method allows the user to control the painting behavior 
 * outside of the bounds of the circle's radius.  See LinearGradientPaint for 
 * more details.
 *
 * <p>
 * The following code demonstrates typical usage of RadialGradientPaint:
 * <p>
 * <code>
 * Point2D center = new Point2D.Float(0, 0);<br>
 * float radius = 20;
 * float[] dist = {0.0, 0.2, 1.0};<br>
 * Color[] colors = {Color.red, Color.white, Color.blue};<br>
 * RadialGradientPaint p = new RadialGradientPaint(center, radius, 
 * dist, colors);
 * </code>
 *
 * <p> In the event that the user does not set the first keyframe value equal
 * to 0 and the last keyframe value equal to 1, keyframes will be created at
 * these positions and the first and last colors will be replicated there.
 * So, if a user specifies the following arrays to construct a gradient:<br>
 * {Color.blue, Color.red}, {.3, .7}<br>
 * this will be converted to a gradient with the following keyframes:
 * {Color.blue, Color.blue, Color.red, Color.red}, {0, .3, .7, 1}
 *
 *
 * <p>
 * <img src = ""radial.jpg"">
 * <p>
 * This image demonstrates a radial gradient with NO_CYCLE and default focus.
 * <p>
 *
 * <img src = ""radial2.jpg"">
 * <p>
 * This image demonstrates a radial gradient with NO_CYCLE and non-centered 
 * focus.
 * <p>
 * 
 * <img src = ""radial3.jpg"">
 * <p>
 * This image demonstrates a radial gradient with REFLECT and non-centered 
 * focus.
 *
 * @author  Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans
 * @author <a href=""mailto:vincent.hardy@eng.sun.com"">Vincent Hardy</a>
 * @version $Id: RadialGradientPaint.java,v 1.1 2004/09/06 19:35:39 kitfox Exp $
 *
 */

public final class RadialGradientPaint extends MultipleGradientPaint {

    /** Focus point which defines the 0% gradient stop x coordinate. */
    private Point2D focus;

    /** Center of the circle defining the 100% gradient stop x coordinate. */
    private Point2D center;

    /** Radius of the outermost circle defining the 100% gradient stop. */
    private float radius;

    /**
     * <p>
     *
     * Constructs a <code>RadialGradientPaint</code>, using the center as the 
     * focus point.
     *
     * @param cx the x coordinate in user space of the center point of the 
     * circle defining the gradient.  The last color of the gradient is mapped
     * to the perimeter of this circle
     *
     * @param cy the y coordinate in user space of the center point of the 
     * circle defining the gradient.  The last color of the gradient is mapped
     * to the perimeter of this circle
     *
     * @param radius the radius of the circle defining the extents of the 
     * color gradient   
     *
     * @param fractions numbers ranging from 0.0 to 1.0 specifying the 
     * distribution of colors along the gradient
     *
     * @param colors array of colors to use in the gradient. The first color 
     * is used at the focus point, the last color around the perimeter of the 
     * circle.
     *        
     *
     * @throws IllegalArgumentException  
     *         if fractions.length != colors.length, or if colors is less 
     *         than 2 in size, or if radius < 0
     *
     *
     */
    public RadialGradientPaint(float cx, float cy, float radius,
                               float[] fractions, Color[] colors) {
        this(cx, cy,
             radius,
             cx, cy,
             fractions,
             colors);
    }    
    
    /**
     * <p>
     *
     * Constructs a <code>RadialGradientPaint</code>, using the center as the 
     * focus point.
     *
     * @param center the center point, in user space, of the circle defining 
     * the gradient
     *
     * @param radius the radius of the circle defining the extents of the 
     * color gradient
     *
     * @param fractions numbers ranging from 0.0 to 1.0 specifying the 
     * distribution of colors along the gradient
     *
     * @param colors array of colors to use in the gradient. The first color 
     * is used at the focus point, the last color around the perimeter of the 
     * circle.
     *   
     * @throws NullPointerException if center point is null
     *
     * @throws IllegalArgumentException  
     *         if fractions.length != colors.length, or if colors is less 
     *         than 2 in size, or if radius < 0
     *
     *
     */
    public RadialGradientPaint(Point2D center, float radius,
                               float[] fractions, Color[] colors) {
        this(center,
             radius,
             center,	    
             fractions,
             colors);
    }

    /**
     * <p>
     *
     * Constructs a <code>RadialGradientPaint</code>.
     *
     * @param cx the x coordinate in user space of the center point of the 
     * circle defining the gradient.  The last color of the gradient is mapped
     * to the perimeter of this circle
     *
     * @param cy the y coordinate in user space of the center point of the 
     * circle defining the gradient.  The last color of the gradient is mapped
     * to the perimeter of this circle
     *
     * @param radius the radius of the circle defining the extents of the 
     * color gradient
     *
     * @param fx the x coordinate of the point in user space to which the 
     * first color is mapped
     *
     * @param fy the y coordinate of the point in user space to which the 
     * first color is mapped
     *
     * @param fractions numbers ranging from 0.0 to 1.0 specifying the 
     * distribution of colors along the gradient
     *
     * @param colors array of colors to use in the gradient. The first color 
     * is used at the focus point, the last color around the perimeter of the 
     * circle.
     *  
     * @throws IllegalArgumentException  
     *         if fractions.length != colors.length, or if colors is less 
     *         than 2 in size, or if radius < 0
     *
     *
     */
    public RadialGradientPaint(float cx, float cy, float radius,
                               float fx, float fy,
                               float[] fractions, Color[] colors) {
        this(new Point2D.Float(cx, cy),
             radius,
             new Point2D.Float(fx, fy),
             fractions,
             colors,
             NO_CYCLE,
             SRGB);
    }
    
    /**
     * <p>
     *
     * Constructs a <code>RadialGradientPaint</code>.
     *
     * @param center the center point, in user space, of the circle defining 
     * the gradient. The last color of the gradient is mapped to the perimeter
     * of this circle
     *
     * @param radius the radius of the circle defining the extents of the color
     * gradient
     *
     * @param focus the point, in user space, to which the first color is 
     * mapped    
     *
     * @param fractions numbers ranging from 0.0 to 1.0 specifying the 
     * distribution of colors along the gradient
     *
     * @param colors array of colors to use in the gradient. The first color 
     * is used at the focus point, the last color around the perimeter of the
     * circle.
     *   
     * @throws NullPointerException if one of the points is null
     *
     * @throws IllegalArgumentException  
     *         if fractions.length != colors.length, or if colors is less 
     *         than 2 in size, or if radius < 0
     *
     */
    public RadialGradientPaint(Point2D center, float radius,
                               Point2D focus,
                               float[] fractions, Color[] colors) {
        this(center,
             radius,
             focus,
             fractions,
             colors,
             NO_CYCLE,
             SRGB);	
    }
    
    /**
     * <p>
     *
     * Constructs a <code>RadialGradientPaint</code>.
     *
     * @param center the center point in user space of the circle defining the
     * gradient. The last color of the gradient is mapped to the perimeter of 
     * this circle
     *
     * @param radius the radius of the circle defining the extents of the color
     * gradient
     *
     * @param focus the point in user space to which the first color is mapped
     *   
     * @param fractions numbers ranging from 0.0 to 1.0 specifying the 
     * distribution of colors along the gradient
     *
     * @param colors array of colors to use in the gradient. The first color is
     * used at the focus point, the last color around the perimeter of the 
     * circle.
     *
     * @param cycleMethod either NO_CYCLE, REFLECT, or REPEAT
     *
     * @param colorSpace which colorspace to use for interpolation, 
     * either SRGB or LINEAR_RGB
     *   
     * @throws NullPointerException if one of the points is null
     *
     * @throws IllegalArgumentException 
     *         if fractions.length != colors.length, or if colors is less 
     *         than 2 in size, or if radius < 0
     *
     */
    public RadialGradientPaint(Point2D center, float radius,
                               Point2D focus,
                               float[] fractions, Color[] colors,
                               CycleMethodEnum cycleMethod, 
                               ColorSpaceEnum colorSpace) {
        this(center,
             radius,
             focus,
             fractions,
             colors,
             cycleMethod,
             colorSpace,
             new AffineTransform());
    }

    /**
     * <p>
     *
     * Constructs a <code>RadialGradientPaint</code>.
     *
     * @param center the center point in user space of the circle defining the
     * gradient.  The last color of the gradient is mapped to the perimeter of
     * this circle
     *
     * @param radius the radius of the circle defining the extents of the color
     * gradient. 
     *
     * @param focus the point in user space to which the first color is mapped
     *
     * @param fractions numbers ranging from 0.0 to 1.0 specifying the 
     * distribution of colors along the gradient
     *
     * @param colors array of colors to use in the gradient. The first color is
     * used at the focus point, the last color around the perimeter of the 
     * circle.
     *
     * @param cycleMethod either NO_CYCLE, REFLECT, or REPEAT
     *
     * @param colorSpace which colorspace to use for interpolation, 
     * either SRGB or LINEAR_RGB          
     *
     * @param gradientTransform transform to apply to the gradient
     *
     * @throws NullPointerException if one of the points is null, 
     * or gradientTransform is null
     *
     * @throws IllegalArgumentException 
     *         if fractions.length != colors.length, or if colors is less 
     *         than 2 in size, or if radius < 0
     *
     */
    public RadialGradientPaint(Point2D center,
                               float radius,
                               Point2D focus,
                               float[] fractions,  Color[] colors,
                               CycleMethodEnum cycleMethod, 
                               ColorSpaceEnum colorSpace,
                               AffineTransform gradientTransform){
        super(fractions, colors, cycleMethod, colorSpace, gradientTransform);

        // Check input arguments
        if (center == null) {
            throw new NullPointerException(""Center point should not be null."");
        }
	
        if (focus == null) {
            throw new NullPointerException(""Focus point should not be null."");
        }

        if (radius <= 0) {
            throw new IllegalArgumentException(""radius should be greater than zero"");
        }

        //copy parameters
        this.center = (Point2D)center.clone();
        this.focus = (Point2D)focus.clone();
        this.radius = radius;
    }
    
    /**
     * <p>
     *
     * Constructs a <code>RadialGradientPaint</code>, the gradient circle is 
     * defined by a bounding box.
     *    
     * @param gradientBounds the bounding box, in user space, of the circle 
     * defining outermost extent of the gradient.
     *
     * @param fractions numbers ranging from 0.0 to 1.0 specifying the 
     * distribution of colors along the gradient
     *
     * @param colors array of colors to use in the gradient. The first color 
     * is used at the focus point, the last color around the perimeter of the 
     * circle.
     *
     * @throws NullPointerException if the gradientBounds is null
     *
     * @throws IllegalArgumentException 
     *         if fractions.length != colors.length, or if colors is less 
     *         than 2 in size, or if radius < 0
     *
     */    
    public RadialGradientPaint(Rectangle2D gradientBounds,
                               float[] fractions,  Color[] colors) {

        //calculate center point and radius based on bounding box coordinates.
        this((float)gradientBounds.getX() +
             ( (float)gradientBounds.getWidth() / 2),
	     
             (float)gradientBounds.getY() +
             ( (float)gradientBounds.getWidth() / 2),
	     
             (float)gradientBounds.getWidth() / 2, 
             fractions, colors);
    }


    /** <p>
     * Creates and returns a PaintContext used to generate the color pattern,
     * for use by the internal rendering engine.
     *
     * @param cm {@link ColorModel} that receives
     * the <code>Paint</code> data. This is used only as a hint.
     *
     * @param deviceBounds the device space bounding box of the 
     * graphics primitive being rendered
     *
     * @param userBounds the user space bounding box of the 
     * graphics primitive being rendered
     *
     * @param transform the {@link AffineTransform} from user
     * space into device space
     *
     * @param hints the hints that the context object uses to choose
     * between rendering alternatives
     *
     * @return the {@link PaintContext} that generates color patterns.
     *
     * @throws IllegalArgumentException if the transform is not invertible
     *
     * @see PaintContext
     */
    public PaintContext createContext(ColorModel cm,
                                      Rectangle deviceBounds,
                                      Rectangle2D userBounds,
                                      AffineTransform transform,
                                      RenderingHints hints) {
        // Can't modify the transform passed in...
        transform = new AffineTransform(transform);
        // incorporate the gradient transform
        transform.concatenate(gradientTransform);

        try{
            return new RadialGradientPaintContext
                (cm, deviceBounds, userBounds, transform, hints,
                 (float)center.getX(), (float)center.getY(), radius,
                 (float)focus.getX(), (float)focus.getY(),
                 fractions, colors, cycleMethod, colorSpace);       	    
        }
	
        catch(NoninvertibleTransformException e){
            throw new IllegalArgumentException(""transform should be "" +
                                               ""invertible"");
        }
    }

    /**
     * Returns a copy of the center point of the radial gradient.
     * @return a {@link Point2D} object that is a copy of the center point     
     */
    public Point2D getCenterPoint() {
        return new Point2D.Double(center.getX(), center.getY());
    }
    
    /** Returns a copy of the end point of the gradient axis.
     * @return a {@link Point2D} object that is a copy of the focus point     
     */
    public Point2D getFocusPoint() {
        return new Point2D.Double(focus.getX(), focus.getY());
    }

    /** Returns the radius of the circle defining the radial gradient.
     * @return the radius of the circle defining the radial gradient
     */
    public float getRadius() {
        return radius;
    }
    
}

"
RadialGradientPaintContext.java,kitfox-6.9.6,"/*****************************************************************************
 * Copyright (C) The Apache Software Foundation. All rights reserved.        *
 * ------------------------------------------------------------------------- *
 * This software is published under the terms of the Apache Software License *
 * version 1.1, a copy of which has been included with this distribution in  *
 * the LICENSE file.                                                         *
 *****************************************************************************/

package com.kitfox.svg.batik;

import java.awt.Color;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Rectangle2D;
import java.awt.image.ColorModel;

/**
 * Provides the actual implementation for the RadialGradientPaint.
 * This is where the pixel processing is done.  A RadialGradienPaint
 * only supports circular gradients, but it should be possible to scale
 * the circle to look approximately elliptical, by means of a
 * gradient transform passed into the RadialGradientPaint constructor.
 *
 * @author Nicholas Talian, Vincent Hardy, Jim Graham, Jerry Evans
 * @author <a href=""mailto:vincent.hardy@eng.sun.com"">Vincent Hardy</a>
 * @version $Id: RadialGradientPaintContext.java,v 1.2 2005/10/12 20:36:55 kitfox Exp $
 *
 */
final class RadialGradientPaintContext extends MultipleGradientPaintContext {  
    
    /** True when (focus == center)  */
    private boolean isSimpleFocus = false;

    /** True when (cycleMethod == NO_CYCLE) */
    private boolean isNonCyclic = false;
       
    /** Radius of the outermost circle defining the 100% gradient stop. */
    private float radius;   
    
    /** Variables representing center and focus points. */
    private float centerX, centerY, focusX, focusY;     

    /** Radius of the gradient circle squared. */
    private float radiusSq; 
        
    /** Constant part of X, Y user space coordinates. */
    private float constA, constB;
       
    /** This value represents the solution when focusX == X.  It is called
     * trivial because it is easier to calculate than the general case.
     */
    private float trivial;       

    private static final int FIXED_POINT_IMPL = 1;
    private static final int DEFAULT_IMPL     = 2;
    private static final int ANTI_ALIAS_IMPL  = 3;

    private int fillMethod;
    
    /** Amount for offset when clamping focus. */
    private static final float SCALEBACK = .97f;
    
    /** 
     * Constructor for RadialGradientPaintContext.
     *
     *  @param cm {@link ColorModel} that receives
     *  the <code>Paint</code> data. This is used only as a hint.
     *
     *  @param deviceBounds the device space bounding box of the 
     *  graphics primitive being rendered
     *
     *  @param userBounds the user space bounding box of the 
     *  graphics primitive being rendered
     * 
     *  @param t the {@link AffineTransform} from user
     *  space into device space (gradientTransform should be 
     *  concatenated with this)    
     *
     *  @param hints the hints that the context object uses to choose
     *  between rendering alternatives
     *       
     *  @param cx the center point in user space of the circle defining 
     *  the gradient.  The last color of the gradient is mapped to the 
     *  perimeter of this circle X coordinate
     *
     *  @param cy the center point in user space of the circle defining 
     *  the gradient.  The last color of the gradient is mapped to the 
     *  perimeter of this circle Y coordinate
     *     
     *  @param r the radius of the circle defining the extents of the 
     *  color gradient
     *
     *  @param fx the point in user space to which the first color is mapped
     *  X coordinate
     *
     *  @param fy the point in user space to which the first color is mapped
     *  Y coordinate
     *
     *  @param fractions the fractions specifying the gradient distribution
     *
     *  @param colors the gradient colors
     *
     *  @param cycleMethod either NO_CYCLE, REFLECT, or REPEAT
     *
     *  @param colorSpace which colorspace to use for interpolation, 
     *  either SRGB or LINEAR_RGB
     *
     */
    public RadialGradientPaintContext(ColorModel cm,
                                      Rectangle deviceBounds,
                                      Rectangle2D userBounds,
                                      AffineTransform t,
                                      RenderingHints hints,
                                      float cx, float cy,
                                      float r,
                                      float fx, float fy,
                                      float[] fractions,
                                      Color[] colors,
                                      MultipleGradientPaint.CycleMethodEnum 
                                      cycleMethod,
                                      MultipleGradientPaint.ColorSpaceEnum 
                                      colorSpace)
        throws NoninvertibleTransformException
    {       	
        super(cm, deviceBounds, userBounds, t, hints, fractions, colors, 
              cycleMethod, colorSpace);

        //copy some parameters.
        centerX = cx;
        centerY = cy;	
        focusX = fx;
        focusY = fy;
        radius = r;

        this.isSimpleFocus = (focusX == centerX) && (focusY == centerY);
        this.isNonCyclic = (cycleMethod == RadialGradientPaint.NO_CYCLE);
	
        //for use in the quadractic equation
        radiusSq = radius * radius;

        float dX = focusX - centerX;
        float dY = focusY - centerY;

        double dist = Math.sqrt((dX * dX) + (dY * dY));

        //test if distance from focus to center is greater than the radius
        if (dist > radius* SCALEBACK) { //clamp focus to radius
          double angle = Math.atan2(dY, dX);
			
          //x = r cos theta, y = r sin theta
          focusX = (float)(SCALEBACK * radius * Math.cos(angle)) + centerX;
          
          focusY = (float)(SCALEBACK * radius * Math.sin(angle)) + centerY;
        }

        //calculate the solution to be used in the case where X == focusX
        //in cyclicCircularGradientFillRaster
        dX = focusX - centerX;
        trivial = (float)Math.sqrt(radiusSq - (dX * dX));

        // constant parts of X, Y user space coordinates 
        constA = a02 - centerX;
        constB = a12 - centerY;

        Object colorRend;
        Object rend;
        //hints can be null on Mac OSX
        if (hints == null)
        {
            colorRend = RenderingHints.VALUE_COLOR_RENDER_DEFAULT;
            rend = RenderingHints.VALUE_RENDER_DEFAULT;
        }
        else
        {
            colorRend = hints.get(RenderingHints.KEY_COLOR_RENDERING);
            rend      = hints.get(RenderingHints.KEY_RENDERING);
        }

        fillMethod = 0;

        if ((rend      == RenderingHints.VALUE_RENDER_QUALITY) ||
            (colorRend == RenderingHints.VALUE_COLOR_RENDER_QUALITY)) {
            // System.out.println(""AAHints set: "" + rend + "", "" + colorRend);
            fillMethod = ANTI_ALIAS_IMPL;
        }

        if ((rend      == RenderingHints.VALUE_RENDER_SPEED) ||
            (colorRend == RenderingHints.VALUE_COLOR_RENDER_SPEED)) {
            // System.out.println(""SPHints set: "" + rend + "", "" + colorRend);
            fillMethod = DEFAULT_IMPL;
        }

        // We are in the 'default' case, no hint or hint set to
        // DEFAULT values...
        if (fillMethod == 0) {
            // For now we will always use the 'default' impl if 
            // one is not specified.
            fillMethod = DEFAULT_IMPL;

            if (false) {
                // This could be used for a 'smart' choice in
                // the default case, if the gradient has obvious
                // discontinuites use AA, otherwise default
                if (hasDiscontinuity) {
                    fillMethod = ANTI_ALIAS_IMPL;
                } else {
                    fillMethod = DEFAULT_IMPL;
                }
            }
        }

        if ((fillMethod == DEFAULT_IMPL) &&
            (isSimpleFocus && isNonCyclic && isSimpleLookup)) {
            this.calculateFixedPointSqrtLookupTable();
            fillMethod = FIXED_POINT_IMPL;
        }
    }
    
    /**
     * Return a Raster containing the colors generated for the graphics
     * operation.
     * @param x,y,w,h The area in device space for which colors are
     * generated.
     */
    protected void fillRaster(int pixels[], int off, int adjust,
                              int x, int y, int w, int h) {
        switch(fillMethod) {
        case FIXED_POINT_IMPL:
            // System.out.println(""Calling FP"");
            fixedPointSimplestCaseNonCyclicFillRaster(pixels, off, adjust, x, 
                                                      y, w, h);
            break;
        case ANTI_ALIAS_IMPL:
            // System.out.println(""Calling AA"");
            antiAliasFillRaster(pixels, off, adjust, x, y, w, h);
            break;
        case DEFAULT_IMPL:
        default:
            // System.out.println(""Calling Default"");
            cyclicCircularGradientFillRaster(pixels, off, adjust, x, y, w, h);
        }
    }    
    
    /**
     * This code works in the simplest of cases, where the focus == center 
     * point, the gradient is noncyclic, and the gradient lookup method is 
     * fast (single array index, no conversion necessary).
     *
     */         
    private void fixedPointSimplestCaseNonCyclicFillRaster(int pixels[], 
                                                           int off,
                                                           int adjust, 
                                                           int x, int y, 
                                                           int w, int h) {
        float iSq=0;  // Square distance index
        final float indexFactor = fastGradientArraySize / radius;      

        //constant part of X and Y coordinates for the entire raster
        final float constX = (a00*x) + (a01*y) + constA;
        final float constY = (a10*x) + (a11*y) + constB;
        final float deltaX = indexFactor * a00; //incremental change in dX
        final float deltaY = indexFactor * a10; //incremental change in dY
        float dX, dY; //the current distance from center
        final int fixedArraySizeSq=
            (fastGradientArraySize * fastGradientArraySize);
        float g, gDelta, gDeltaDelta, temp; //gradient square value
        int gIndex; // integer number used to index gradient array
        int iSqInt; // Square distance index       		   
	
        int end, j; //indexing variables
        int indexer = off;//used to index pixels array

        temp        = ((deltaX * deltaX) + (deltaY * deltaY));
        gDeltaDelta = ((temp * 2));

        if (temp > fixedArraySizeSq) {
            // This combination of scale and circle radius means
            // essentially no pixels will be anything but the end
            // stop color.  This also avoids math problems.
            final int val = gradientOverflow;
            for(j = 0; j < h; j++){ //for every row
                //for every column (inner loop begins here)
                for (end = indexer+w; indexer < end; indexer++) 
                    pixels[indexer] = val;
                indexer += adjust;
            }
            return;
        }

        // For every point in the raster, calculate the color at that point
        for(j = 0; j < h; j++){ //for every row
            //x and y (in user space) of the first pixel of this row
            dX = indexFactor * ((a01*j) + constX);
            dY = indexFactor * ((a11*j) + constY);	   	   

            // these values below here allow for an incremental calculation
            // of dX^2 + dY^2 

            //initialize to be equal to distance squared
            g = (((dY * dY) + (dX * dX)) );
            gDelta =  (((((deltaY * dY) + (deltaX * dX))* 2) + 
                        temp));	 
	    
            //for every column (inner loop begins here)
            for (end = indexer+w; indexer < end; indexer++) {	       
                //determine the distance to the center
		
                //since this is a non cyclic fill raster, crop at ""1"" and 0
                if (g >= fixedArraySizeSq) {
                    pixels[indexer] = gradientOverflow;
                }
		
                // This should not happen as gIndex is a square
                // quantity. Code commented out on purpose, can't underflow.
                // else if (g < 0) {
                //    gIndex = 0;		    
                // }
		
                else {
                    iSq = (g * invSqStepFloat);
                    
                    iSqInt = (int)iSq; //chop off fractional part
                    iSq -= iSqInt;		    
                    gIndex = sqrtLutFixed[iSqInt];
                    gIndex += (int)(iSq * (sqrtLutFixed[iSqInt + 1]-gIndex));
                    pixels[indexer] = gradient[gIndex]; 
                }
		
				
                //incremental calculation
                g += gDelta;
                gDelta += gDeltaDelta;		
            }	  
            indexer += adjust;
        }
    }

    /** Length of a square distance intervale in the lookup table */
    private float invSqStepFloat; 
    
    /** Used to limit the size of the square root lookup table */
    private int MAX_PRECISION = 256;
    
    /** Square root lookup table */
    private int sqrtLutFixed[] = new int[MAX_PRECISION];
    
    /**
     * Build square root lookup table
     */       
    private void calculateFixedPointSqrtLookupTable() {	      
        float sqStepFloat;
        sqStepFloat = ((fastGradientArraySize  * fastGradientArraySize) 
                       / (MAX_PRECISION - 2));
	
        // The last two values are the same so that linear square root 
        // interpolation can happen on the maximum reachable element in the 
        // lookup table (precision-2)
        int i;
        for (i = 0; i < MAX_PRECISION - 1; i++) {
            sqrtLutFixed[i] = (int)(Math.sqrt(i*sqStepFloat));
        }
        sqrtLutFixed[i] = sqrtLutFixed[i-1];	
        invSqStepFloat = 1/sqStepFloat;
    }
    
    /** Fill the raster, cycling the gradient colors when a point falls outside
     *  of the perimeter of the 100% stop circle.          
     * 
     *  This calculation first computes the intersection point of the line
     *  from the focus through the current point in the raster, and the
     *  perimeter of the gradient circle.
     * 
     *  Then it determines the percentage distance of the current point along
     *  that line (focus is 0%, perimeter is 100%). 
     *
     *  Equation of a circle centered at (a,b) with radius r:
     *  (x-a)^2 + (y-b)^2 = r^2
     *  Equation of a line with slope m and y-intercept b
     *  y = mx + b
     *  replacing y in the cirlce equation and solving using the quadratic
     *  formula produces the following set of equations.  Constant factors have
     *  been extracted out of the inner loop.
     *
     */   
    private void cyclicCircularGradientFillRaster(int pixels[], int off, 
                                                  int adjust, 
                                                  int x, int y, 
                                                  int w, int h) {
        // Constant part of the C factor of the quadratic equation
        final double constC = 
            -(radiusSq) + (centerX * centerX) + (centerY * centerY);
        double A; //coefficient of the quadratic equation (Ax^2 + Bx + C = 0)
        double B; //coefficient of the quadratic equation
        double C; //coefficient of the quadratic equation
        double slope; //slope of the focus-perimeter line
        double yintcpt; //y-intercept of the focus-perimeter line
        double solutionX;//intersection with circle X coordinate
        double solutionY;//intersection with circle Y coordinate       
       	final float constX = (a00*x) + (a01*y) + a02;//const part of X coord
        final float constY = (a10*x) + (a11*y) + a12; //const part of Y coord
       	final float precalc2 = 2 * centerY;//const in inner loop quad. formula
        final float precalc3 =-2 * centerX;//const in inner loop quad. formula
        float X; // User space point X coordinate 
        float Y; // User space point Y coordinate
        float g;//value between 0 and 1 specifying position in the gradient
        float det; //determinant of quadratic formula (should always be >0)
        float currentToFocusSq;//sq distance from the current pt. to focus
        float intersectToFocusSq;//sq distance from the intersect pt. to focus
        float deltaXSq; //temp variable for a change in X squared.
        float deltaYSq; //temp variable for a change in Y squared.
        int indexer = off; //index variable for pixels array
        int i, j; //indexing variables for FOR loops
        int pixInc = w+adjust;//incremental index change for pixels array

        for (j = 0; j < h; j++) { //for every row
	    
            X = (a01*j) + constX; //constants from column to column
            Y = (a11*j) + constY;
	    
            //for every column (inner loop begins here)
            for (i = 0; i < w; i++) {	       			
	
                // special case to avoid divide by zero or very near zero
                if (((X-focusX)>-0.000001) &&
                    ((X-focusX)< 0.000001)) {		   
                    solutionX = focusX;
		    
                    solutionY = centerY;
		    
                    solutionY += (Y > focusY)?trivial:-trivial;
                }
		
                else {    
		    
                    //slope of the focus-current line
                    slope =   (Y - focusY) / (X - focusX);
		    
                    yintcpt = Y - (slope * X); //y-intercept of that same line
		    
                    //use the quadratic formula to calculate the intersection
                    //point		  
                    A = (slope * slope) + 1; 
		    
                    B =  precalc3 + (-2 * slope * (centerY - yintcpt));
		    
                    C =  constC + (yintcpt* (yintcpt - precalc2));
		    
                    det = (float)Math.sqrt((B * B) - ( 4 * A * C));
		    
                    solutionX = -B;
		    
                    //choose the positive or negative root depending
                    //on where the X coord lies with respect to the focus.
                    solutionX += (X < focusX)?-det:det;
		    
                    solutionX = solutionX / (2 * A);//divisor
		    
                    solutionY = (slope * solutionX) + yintcpt;
                }	                    	

                //calculate the square of the distance from the current point 
                //to the focus and the square of the distance from the 
                //intersection point to the focus. Want the squares so we can
                //do 1 square root after division instead of 2 before.

                deltaXSq = (float)solutionX - focusX;
                deltaXSq = deltaXSq * deltaXSq;

                deltaYSq = (float)solutionY - focusY;
                deltaYSq = deltaYSq * deltaYSq;

                intersectToFocusSq = deltaXSq + deltaYSq;

                deltaXSq = X - focusX;
                deltaXSq = deltaXSq * deltaXSq;

                deltaYSq = Y - focusY;
                deltaYSq = deltaYSq * deltaYSq;

                currentToFocusSq = deltaXSq + deltaYSq;

                //want the percentage (0-1) of the current point along the 
                //focus-circumference line
                g = (float)Math.sqrt(currentToFocusSq / intersectToFocusSq);

                //Get the color at this point
                pixels[indexer + i] = indexIntoGradientsArrays(g);
		
                X += a00; //incremental change in X, Y
                Y += a10;	
            } //end inner loop
            indexer += pixInc;
        } //end outer loop
    }


    /** Fill the raster, cycling the gradient colors when a point
     *  falls outside of the perimeter of the 100% stop circle. Use
     *  the anti-aliased gradient lookup.
     *
     *  This calculation first computes the intersection point of the line
     *  from the focus through the current point in the raster, and the
     *  perimeter of the gradient circle.
     * 
     *  Then it determines the percentage distance of the current point along
     *  that line (focus is 0%, perimeter is 100%). 
     *
     *  Equation of a circle centered at (a,b) with radius r:
     *  (x-a)^2 + (y-b)^2 = r^2
     *  Equation of a line with slope m and y-intercept b
     *  y = mx + b
     *  replacing y in the cirlce equation and solving using the quadratic
     *  formula produces the following set of equations.  Constant factors have
     *  been extracted out of the inner loop.
     * */
    private void antiAliasFillRaster(int pixels[], int off, 
                                     int adjust, 
                                     int x, int y, 
                                     int w, int h) {
        // Constant part of the C factor of the quadratic equation
        final double constC = 
            -(radiusSq) + (centerX * centerX) + (centerY * centerY);
        //coefficients of the quadratic equation (Ax^2 + Bx + C = 0)
       	final float precalc2 = 2 * centerY;//const in inner loop quad. formula
        final float precalc3 =-2 * centerX;//const in inner loop quad. formula

        //const part of X,Y coord (shifted to bottom left corner of pixel.
       	final float constX = (a00*(x-.5f)) + (a01*(y+.5f)) + a02;
        final float constY = (a10*(x-.5f)) + (a11*(y+.5f)) + a12;
        float X; // User space point X coordinate 
        float Y; // User space point Y coordinate
        int i, j; //indexing variables for FOR loops
        int indexer = off-1; //index variable for pixels array

        // Size of a pixel in user space.
        double pixSzSq = (float)(a00*a00+a01*a01+a10*a10+a11*a11);
        double [] prevGs = new double[w+1];
        double deltaXSq, deltaYSq;
        double solutionX, solutionY;
        double slope, yintcpt, A, B, C, det;
        double intersectToFocusSq, currentToFocusSq;
        double g00, g01, g10, g11;

        // Set X,Y to top left corner of first pixel of first row.
        X = constX - a01;
        Y = constY - a11;

        // Calc top row of g's.
        for (i=0; i <= w; i++) {
            // special case to avoid divide by zero or very near zero
            if (((X-focusX)>-0.000001) &&
                ((X-focusX)< 0.000001)) {		   
                solutionX = focusX;
                solutionY = centerY;
                solutionY += (Y > focusY)?trivial:-trivial;
            }
            else { 
                // Formula for Circle: (X-Xc)^2 + (Y-Yc)^2 - R^2 = 0
                // Formula line:        Y = Slope*x + Y0;
                // 
                // So you substitue line into Circle and apply
                // Quadradic formula.


                //slope of the focus-current line
                slope =   (Y - focusY) / (X - focusX);
		    
                yintcpt = Y - (slope * X); //y-intercept of that same line
		    
                //use the quadratic formula to calculate the intersection
                //point		  
                A = (slope * slope) + 1; 
		    
                B =  precalc3 + (-2 * slope * (centerY - yintcpt));
		    
                C =  constC + (yintcpt* (yintcpt - precalc2));
		    
                det = Math.sqrt((B * B) - ( 4 * A * C));
		    
                solutionX = -B;
		    
                //choose the positive or negative root depending
                //on where the X coord lies with respect to the focus.
                solutionX += (X < focusX)?-det:det;
		    
                solutionX = solutionX / (2 * A);//divisor
		    
                solutionY = (slope * solutionX) + yintcpt;
            }	                    	

            //calculate the square of the distance from the current point 
            //to the focus and the square of the distance from the 
            //intersection point to the focus. Want the squares so we can
            //do 1 square root after division instead of 2 before.
            deltaXSq = solutionX - focusX;
            deltaXSq = deltaXSq * deltaXSq;
        
            deltaYSq = solutionY - focusY;
            deltaYSq = deltaYSq * deltaYSq;
        
            intersectToFocusSq = deltaXSq + deltaYSq;
        
            deltaXSq = X - focusX;
            deltaXSq = deltaXSq * deltaXSq;
        
            deltaYSq = Y - focusY;
            deltaYSq = deltaYSq * deltaYSq;
        
            currentToFocusSq = deltaXSq + deltaYSq;
        
            //want the percentage (0-1) of the current point along the 
            //focus-circumference line
            prevGs[i] = Math.sqrt(currentToFocusSq / intersectToFocusSq);

            X += a00; //incremental change in X, Y
            Y += a10;	
        }

        for (j = 0; j < h; j++) { //for every row
	    
            // Set X,Y to bottom edge of pixel row.
            X = (a01*j) + constX; //constants from row to row
            Y = (a11*j) + constY;

            g10 = prevGs[0];
            // special case to avoid divide by zero or very near zero
            if (((X-focusX)>-0.000001) &&
                ((X-focusX)< 0.000001)) {		   
                solutionX = focusX;
                solutionY = centerY;
                solutionY += (Y > focusY)?trivial:-trivial;
            }
            else { 
                // Formula for Circle: (X-Xc)^2 + (Y-Yc)^2 - R^2 = 0
                // Formula line:        Y = Slope*x + Y0;
                // 
                // So you substitue line into Circle and apply
                // Quadradic formula.


                //slope of the focus-current line
                slope =   (Y - focusY) / (X - focusX);
		    
                yintcpt = Y - (slope * X); //y-intercept of that same line
		    
                //use the quadratic formula to calculate the intersection
                //point		  
                A = (slope * slope) + 1; 
		    
                B =  precalc3 + (-2 * slope * (centerY - yintcpt));
		    
                C =  constC + (yintcpt* (yintcpt - precalc2));
		    
                det = Math.sqrt((B * B) - ( 4 * A * C));
		    
                solutionX = -B;
		    
                //choose the positive or negative root depending
                //on where the X coord lies with respect to the focus.
                solutionX += (X < focusX)?-det:det;
		    
                solutionX = solutionX / (2 * A);//divisor
		    
                solutionY = (slope * solutionX) + yintcpt;
            }	                    	

            //calculate the square of the distance from the current point 
            //to the focus and the square of the distance from the 
            //intersection point to the focus. Want the squares so we can
            //do 1 square root after division instead of 2 before.
            deltaXSq = solutionX - focusX;
            deltaXSq = deltaXSq * deltaXSq;
        
            deltaYSq = solutionY - focusY;
            deltaYSq = deltaYSq * deltaYSq;
        
            intersectToFocusSq = deltaXSq + deltaYSq;
        
            deltaXSq = X - focusX;
            deltaXSq = deltaXSq * deltaXSq;
        
            deltaYSq = Y - focusY;
            deltaYSq = deltaYSq * deltaYSq;
                
            currentToFocusSq = deltaXSq + deltaYSq;
            g11 = Math.sqrt(currentToFocusSq / intersectToFocusSq);
            prevGs[0] = g11;
            
            X += a00; //incremental change in X, Y
            Y += a10;	

            //for every column (inner loop begins here)
            for (i=1; i <= w; i++) {
                g00 = g10;
                g01 = g11;
                g10 = prevGs[i];

                // special case to avoid divide by zero or very near zero
                if (((X-focusX)>-0.000001) &&
                    ((X-focusX)< 0.000001)) {		   
                    solutionX = focusX;
                    solutionY = centerY;
                    solutionY += (Y > focusY)?trivial:-trivial;
                }
                else { 
                    // Formula for Circle: (X-Xc)^2 + (Y-Yc)^2 - R^2 = 0
                    // Formula line:        Y = Slope*x + Y0;
                    // 
                    // So you substitue line into Circle and apply
                    // Quadradic formula.


                    //slope of the focus-current line
                    slope =   (Y - focusY) / (X - focusX);
		    
                    yintcpt = Y - (slope * X); //y-intercept of that same line
		    
                    //use the quadratic formula to calculate the intersection
                    //point		  
                    A = (slope * slope) + 1; 
		    
                    B =  precalc3 + (-2 * slope * (centerY - yintcpt));
		    
                    C =  constC + (yintcpt* (yintcpt - precalc2));
		    
                    det = Math.sqrt((B * B) - ( 4 * A * C));
		    
                    solutionX = -B;
		    
                    //choose the positive or negative root depending
                    //on where the X coord lies with respect to the focus.
                    solutionX += (X < focusX)?-det:det;
		    
                    solutionX = solutionX / (2 * A);//divisor
		    
                    solutionY = (slope * solutionX) + yintcpt;
                }	                    	

                //calculate the square of the distance from the current point 
                //to the focus and the square of the distance from the 
                //intersection point to the focus. Want the squares so we can
                //do 1 square root after division instead of 2 before.
                deltaXSq = solutionX - focusX;
                deltaXSq = deltaXSq * deltaXSq;
        
                deltaYSq = solutionY - focusY;
                deltaYSq = deltaYSq * deltaYSq;
        
                intersectToFocusSq = deltaXSq + deltaYSq;
        
                deltaXSq = X - focusX;
                deltaXSq = deltaXSq * deltaXSq;
        
                deltaYSq = Y - focusY;
                deltaYSq = deltaYSq * deltaYSq;
        
                currentToFocusSq = deltaXSq + deltaYSq;
                g11 = Math.sqrt(currentToFocusSq / intersectToFocusSq);
                prevGs[i] = g11;

                //Get the color at this point
                pixels[indexer+i] = indexGradientAntiAlias
                    ((float)((g00+g01+g10+g11)/4), 
                     (float)Math.max(Math.abs(g11-g00),
                                     Math.abs(g10-g01)));

                X += a00; //incremental change in X, Y
                Y += a10;	
            } //end inner loop
            indexer += (w+adjust);
        } //end outer loop
    }
}
"
Circle.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 5:25 PM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Circle extends ShapeElement
{

    public static final String TAG_NAME = ""circle"";
    float cx = 0f;
    float cy = 0f;
    float r = 0f;
    Ellipse2D.Float circle = new Ellipse2D.Float();

    /**
     * Creates a new instance of Rect
     */
    public Circle()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""cx"")))
        {
            cx = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""cy"")))
        {
            cy = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""r"")))
        {
            r = sty.getFloatValueWithUnits();
        }

        circle.setFrame(cx - r, cy - r, r * 2f, r * 2f);
    }

    public void render(Graphics2D g) throws SVGException
    {
        beginLayer(g);
        renderShape(g, circle);
        finishLayer(g);
    }

    public Shape getShape()
    {
        return shapeToParent(circle);
    }

    public Rectangle2D getBoundingBox() throws SVGException
    {
        return boundsToParent(includeStrokeInBounds(circle.getBounds2D()));
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;
        boolean changeState = super.updateTime(curTime);

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;

        if (getPres(sty.setName(""cx"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != cx)
            {
                cx = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""cy"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != cy)
            {
                cy = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""r"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != r)
            {
                r = newVal;
                shapeChange = true;
            }
        }

        if (shapeChange)
        {
            build();
//            circle.setFrame(cx - r, cy - r, r * 2f, r * 2f);
//            return true;
        }

        return changeState || shapeChange;
    }
}
"
ClipPath.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 1:56 AM
 */
package com.kitfox.svg;

import java.awt.Shape;
import java.awt.geom.Area;

import com.kitfox.svg.xml.StyleAttribute;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class ClipPath extends SVGElement
{

    public static final String TAG_NAME = ""clippath"";
    public static final int CP_USER_SPACE_ON_USE = 0;
    public static final int CP_OBJECT_BOUNDING_BOX = 1;
    int clipPathUnits = CP_USER_SPACE_ON_USE;

    /**
     * Creates a new instance of Stop
     */
    public ClipPath()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    /**
     * Called after the start element but before the end element to indicate
     * each child tag that has been processed
     */
    public void loaderAddChild(SVGLoaderHelper helper, SVGElement child) throws SVGElementException
    {
        super.loaderAddChild(helper, child);
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        clipPathUnits = (getPres(sty.setName(""clipPathUnits""))
            && sty.getStringValue().equals(""objectBoundingBox""))
            ? CP_OBJECT_BOUNDING_BOX
            : CP_USER_SPACE_ON_USE;
    }

    public int getClipPathUnits()
    {
        return clipPathUnits;
    }

    public Shape getClipPathShape()
    {
        if (!hasChildren())
        {
            return null;
        }
        if (getNumChildren() == 1)
        {
            return ((ShapeElement) getChild(0)).getShape();
        }

        Area clipArea = null;
        for (SVGElement child : getChildren())
        {
            ShapeElement se = (ShapeElement) child;

            if (clipArea == null)
            {
                Shape shape = se.getShape();
                if (shape != null)
                {
                    clipArea = new Area(se.getShape());
                }
                continue;
            }

            Shape shape = se.getShape();
            if (shape != null)
            {
                clipArea.intersect(new Area(shape));
            }
        }

        return clipArea;
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;


        if (getPres(sty.setName(""clipPathUnits"")))
        {
            String newUnitsStrn = sty.getStringValue();
            int newUnits = newUnitsStrn.equals(""objectBoundingBox"")
                ? CP_OBJECT_BOUNDING_BOX
                : CP_USER_SPACE_ON_USE;

            if (newUnits != clipPathUnits)
            {
                clipPathUnits = newUnits;
                shapeChange = true;
            }
        }

        if (shapeChange)
        {
            build();
        }

        return shapeChange;
    }
}
"
AdobeComposite.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on April 1, 2004, 6:40 AM
 */

package com.kitfox.svg.composite;

import com.kitfox.svg.SVGConst;
import java.awt.*;
import java.awt.image.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class AdobeComposite implements Composite
{
    public static final int CT_NORMAL = 0;
    public static final int CT_MULTIPLY = 1;
    public static final int CT_LAST = 2;

    final int compositeType;
    final float extraAlpha;

    /** Creates a new instance of AdobeComposite */
    public AdobeComposite(int compositeType, float extraAlpha)
    {
        this.compositeType = compositeType;
        this.extraAlpha = extraAlpha;

        if (compositeType < 0 || compositeType >= CT_LAST)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, ""Invalid composite type"");
        }

        if (extraAlpha < 0f || extraAlpha > 1f)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, ""Invalid alpha"");
        }
    }

    public int getCompositeType() { return compositeType; }

    public CompositeContext createContext(ColorModel srcColorModel, ColorModel dstColorModel, RenderingHints hints)
    {
        return new AdobeCompositeContext(compositeType, extraAlpha);
    }

}
"
AdobeCompositeContext.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on April 1, 2004, 6:41 AM
 */

package com.kitfox.svg.composite;

import java.awt.*;
import java.awt.image.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class AdobeCompositeContext implements CompositeContext
{
    final int compositeType;
    final float extraAlpha;

    float[] rgba_src = new float[4];
    float[] rgba_dstIn = new float[4];
    float[] rgba_dstOut = new float[4];

    /** Creates a new instance of AdobeCompositeContext */
    public AdobeCompositeContext(int compositeType, float extraAlpha)
    {
        this.compositeType = compositeType;
        this.extraAlpha = extraAlpha;

        rgba_dstOut[3] = 1f;
    }

    public void compose(Raster src, Raster dstIn, WritableRaster dstOut)
    {
        int width = src.getWidth();
        int height = src.getHeight();

        for (int j = 0; j < height; j++)
        {
            for (int i = 0; i < width; i++)
            {
                src.getPixel(i, j, rgba_src);
                dstIn.getPixel(i, j, rgba_dstIn);

                //Ignore transparent pixels
                if (rgba_src[3] == 0)
                {
//                    dstOut.setPixel(i, j, rgba_dstIn);
                    continue;
                }

                float alpha = rgba_src[3];

                switch (compositeType)
                {
                    default:
                    case AdobeComposite.CT_NORMAL:
                        rgba_dstOut[0] = rgba_src[0] * alpha + rgba_dstIn[0] * (1f - alpha);
                        rgba_dstOut[1] = rgba_src[1] * alpha + rgba_dstIn[1] * (1f - alpha);
                        rgba_dstOut[2] = rgba_src[2] * alpha + rgba_dstIn[2] * (1f - alpha);
                        break;
                    case AdobeComposite.CT_MULTIPLY:
                        rgba_dstOut[0] = rgba_src[0] * rgba_dstIn[0] * alpha + rgba_dstIn[0] * (1f - alpha);
                        rgba_dstOut[1] = rgba_src[1] * rgba_dstIn[1] * alpha + rgba_dstIn[1] * (1f - alpha);
                        rgba_dstOut[2] = rgba_src[2] * rgba_dstIn[2] * alpha + rgba_dstIn[2] * (1f - alpha);
                        break;
                }
            }
        }
    }

    public void dispose() {
    }

}
"
Defs.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 1:56 AM
 */
package com.kitfox.svg;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Defs extends TransformableElement
{

    public static final String TAG_NAME = ""defs"";

    /**
     * Creates a new instance of Stop
     */
    public Defs()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    /**
     * Called after the start element but before the end element to indicate
     * each child tag that has been processed
     */
    public void loaderAddChild(SVGLoaderHelper helper, SVGElement child) throws SVGElementException
    {
        super.loaderAddChild(helper, child);

//        members.add(child);
    }

    public boolean updateTime(double curTime) throws SVGException
    {
        boolean stateChange = false;
        for (SVGElement ele : getChildren())
        {
            stateChange = stateChange || ele.updateTime(curTime);
        }

        return super.updateTime(curTime) || stateChange;
    }
}
"
Desc.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 19, 2004, 1:56 AM
 */
package com.kitfox.svg;

/**
 * Holds title textual information within tree
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Desc extends SVGElement
{

    public static final String TAG_NAME = ""desc"";
    StringBuffer text = new StringBuffer();

    /**
     * Creates a new instance of Stop
     */
    public Desc()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    /**
     * Called during load process to add text scanned within a tag
     */
    public void loaderAddText(SVGLoaderHelper helper, String text)
    {
        this.text.append(text);
    }

    public String getText()
    {
        return text.toString();
    }

    public boolean updateTime(double curTime)
    {
        return false;
    }
}
"
Ellipse.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 5:25 PM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Ellipse extends ShapeElement
{

    public static final String TAG_NAME = ""ellipse"";
    float cx = 0.0f;
    float cy = 0.0f;
    float rx = 0.0f;
    float ry = 0.0f;
    Ellipse2D.Float ellipse = new Ellipse2D.Float();

    /**
     * Creates a new instance of Rect
     */
    public Ellipse()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""cx"")))
        {
            cx = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""cy"")))
        {
            cy = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""rx"")))
        {
            rx = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""ry"")))
        {
            ry = sty.getFloatValueWithUnits();
        }

        ellipse.setFrame(cx - rx, cy - ry, rx * 2f, ry * 2f);
    }

    public void render(Graphics2D g) throws SVGException
    {
        beginLayer(g);
        renderShape(g, ellipse);
        finishLayer(g);
    }

    public Shape getShape()
    {
        return shapeToParent(ellipse);
    }

    public Rectangle2D getBoundingBox() throws SVGException
    {
        return boundsToParent(includeStrokeInBounds(ellipse.getBounds2D()));
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;
        boolean changeState = super.updateTime(curTime);

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;

        if (getPres(sty.setName(""cx"")))
        {
            float newCx = sty.getFloatValueWithUnits();
            if (newCx != cx)
            {
                cx = newCx;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""cy"")))
        {
            float newCy = sty.getFloatValueWithUnits();
            if (newCy != cy)
            {
                cy = newCy;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""rx"")))
        {
            float newRx = sty.getFloatValueWithUnits();
            if (newRx != rx)
            {
                rx = newRx;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""ry"")))
        {
            float newRy = sty.getFloatValueWithUnits();
            if (newRy != ry)
            {
                ry = newRy;
                shapeChange = true;
            }
        }

        if (shapeChange)
        {
            build();
//            ellipse.setFrame(cx - rx, cy - ry, rx * 2f, ry * 2f);
//            return true;
        }

        return changeState || shapeChange;
    }
}
"
FeDistantLight.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on March 18, 2004, 6:52 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class FeDistantLight extends FeLight
{

    public static final String TAG_NAME = ""fedistantlight"";
    float azimuth = 0f;
    float elevation = 0f;

    /**
     * Creates a new instance of FillElement
     */
    public FeDistantLight()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();
        String strn;

        if (getPres(sty.setName(""azimuth"")))
        {
            azimuth = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""elevation"")))
        {
            elevation = sty.getFloatValueWithUnits();
        }
    }

    public float getAzimuth()
    {
        return azimuth;
    }

    public float getElevation()
    {
        return elevation;
    }

    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean stateChange = false;

        if (getPres(sty.setName(""azimuth"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != azimuth)
            {
                azimuth = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""elevation"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != elevation)
            {
                elevation = newVal;
                stateChange = true;
            }
        }

        return stateChange;
    }
}
"
FeLight.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on March 18, 2004, 6:52 AM
 */
package com.kitfox.svg;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
abstract public class FeLight extends FilterEffects
{

    public static final String TAG_NAME = ""feLight"";

    /**
     * Creates a new instance of FillElement
     */
    public FeLight()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }
}
"
FePointLight.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on March 18, 2004, 6:52 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class FePointLight extends FeLight
{

    public static final String TAG_NAME = ""fepointlight"";
    float x = 0f;
    float y = 0f;
    float z = 0f;

    /**
     * Creates a new instance of FillElement
     */
    public FePointLight()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();
        String strn;

        if (getPres(sty.setName(""x"")))
        {
            x = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""y"")))
        {
            y = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""z"")))
        {
            z = sty.getFloatValueWithUnits();
        }
    }

    public float getX()
    {
        return x;
    }

    public float getY()
    {
        return y;
    }

    public float getZ()
    {
        return z;
    }

    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean stateChange = false;

        if (getPres(sty.setName(""x"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != x)
            {
                x = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""y"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != y)
            {
                y = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""z"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != z)
            {
                z = newVal;
                stateChange = true;
            }
        }

        return stateChange;
    }
}
"
FeSpotLight.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on March 18, 2004, 6:52 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class FeSpotLight extends FeLight
{

    public static final String TAG_NAME = ""fespotlight"";
    float x = 0f;
    float y = 0f;
    float z = 0f;
    float pointsAtX = 0f;
    float pointsAtY = 0f;
    float pointsAtZ = 0f;
    float specularComponent = 0f;
    float limitingConeAngle = 0f;

    /**
     * Creates a new instance of FillElement
     */
    public FeSpotLight()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();
        String strn;

        if (getPres(sty.setName(""x"")))
        {
            x = sty.getFloatValueWithUnits();
        }
        if (getPres(sty.setName(""y"")))
        {
            y = sty.getFloatValueWithUnits();
        }
        if (getPres(sty.setName(""z"")))
        {
            z = sty.getFloatValueWithUnits();
        }
        if (getPres(sty.setName(""pointsAtX"")))
        {
            pointsAtX = sty.getFloatValueWithUnits();
        }
        if (getPres(sty.setName(""pointsAtY"")))
        {
            pointsAtY = sty.getFloatValueWithUnits();
        }
        if (getPres(sty.setName(""pointsAtZ"")))
        {
            pointsAtZ = sty.getFloatValueWithUnits();
        }
        if (getPres(sty.setName(""specularComponent"")))
        {
            specularComponent = sty.getFloatValueWithUnits();
        }
        if (getPres(sty.setName(""limitingConeAngle"")))
        {
            limitingConeAngle = sty.getFloatValueWithUnits();
        }
    }

    public float getX()
    {
        return x;
    }

    public float getY()
    {
        return y;
    }

    public float getZ()
    {
        return z;
    }

    public float getPointsAtX()
    {
        return pointsAtX;
    }

    public float getPointsAtY()
    {
        return pointsAtY;
    }

    public float getPointsAtZ()
    {
        return pointsAtZ;
    }

    public float getSpecularComponent()
    {
        return specularComponent;
    }

    public float getLimitingConeAngle()
    {
        return limitingConeAngle;
    }

    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean stateChange = false;

        if (getPres(sty.setName(""x"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != x)
            {
                x = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""y"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != y)
            {
                y = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""z"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != z)
            {
                z = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""pointsAtX"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != pointsAtX)
            {
                pointsAtX = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""pointsAtY"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != pointsAtY)
            {
                pointsAtY = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""pointsAtZ"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != pointsAtZ)
            {
                pointsAtZ = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""specularComponent"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != specularComponent)
            {
                specularComponent = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""limitingConeAngle"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != limitingConeAngle)
            {
                limitingConeAngle = newVal;
                stateChange = true;
            }
        }

        return stateChange;
    }
}
"
FillElement.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on March 18, 2004, 6:52 AM
 */
package com.kitfox.svg;

import java.awt.*;
import java.awt.geom.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
abstract public class FillElement extends SVGElement
{
    /**
     * Creates a new instance of FillElement
     */
    public FillElement()
    {
    }

    /**
     * Requests the paint defined by this element. Passes in information to
     * allow paint to be customized
     *
     * @param bounds - bounding box of shape being rendered
     * @param xform - The current transformation that the shape is being
     * rendered under.
     */
    abstract public Paint getPaint(Rectangle2D bounds, AffineTransform xform);
}
"
Filter.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on March 18, 2004, 6:52 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.geom.Point2D;
import java.net.URI;
import java.net.URL;
import java.util.ArrayList;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Filter extends SVGElement
{

    public static final String TAG_NAME = ""filter"";
    public static final int FU_OBJECT_BOUNDING_BOX = 0;
    public static final int FU_USER_SPACE_ON_USE = 1;
    protected int filterUnits = FU_OBJECT_BOUNDING_BOX;
    public static final int PU_OBJECT_BOUNDING_BOX = 0;
    public static final int PU_USER_SPACE_ON_USE = 1;
    protected int primitiveUnits = PU_OBJECT_BOUNDING_BOX;
    float x = 0f;
    float y = 0f;
    float width = 1f;
    float height = 1f;
    Point2D filterRes = new Point2D.Double();
    URL href = null;
    final ArrayList filterEffects = new ArrayList();

    /**
     * Creates a new instance of FillElement
     */
    public Filter()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    /**
     * Called after the start element but before the end element to indicate
     * each child tag that has been processed
     */
    public void loaderAddChild(SVGLoaderHelper helper, SVGElement child) throws SVGElementException
    {
        super.loaderAddChild(helper, child);

        if (child instanceof FilterEffects)
        {
            filterEffects.add(child);
        }
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();
        String strn;

        if (getPres(sty.setName(""filterUnits"")))
        {
            strn = sty.getStringValue().toLowerCase();
            if (strn.equals(""userspaceonuse""))
            {
                filterUnits = FU_USER_SPACE_ON_USE;
            } else
            {
                filterUnits = FU_OBJECT_BOUNDING_BOX;
            }
        }

        if (getPres(sty.setName(""primitiveUnits"")))
        {
            strn = sty.getStringValue().toLowerCase();
            if (strn.equals(""userspaceonuse""))
            {
                primitiveUnits = PU_USER_SPACE_ON_USE;
            } else
            {
                primitiveUnits = PU_OBJECT_BOUNDING_BOX;
            }
        }

        if (getPres(sty.setName(""x"")))
        {
            x = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""y"")))
        {
            y = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""width"")))
        {
            width = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""height"")))
        {
            height = sty.getFloatValueWithUnits();
        }

        try
        {
            if (getPres(sty.setName(""xlink:href"")))
            {
                URI src = sty.getURIValue(getXMLBase());
                href = src.toURL();
            }
        } catch (Exception e)
        {
            throw new SVGException(e);
        }

    }

    public float getX()
    {
        return x;
    }

    public float getY()
    {
        return y;
    }

    public float getWidth()
    {
        return width;
    }

    public float getHeight()
    {
        return height;
    }

    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean stateChange = false;

        if (getPres(sty.setName(""x"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != x)
            {
                x = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""y"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != y)
            {
                y = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""width"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != width)
            {
                width = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""height"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != height)
            {
                height = newVal;
                stateChange = true;
            }
        }

        try
        {
            if (getPres(sty.setName(""xlink:href"")))
            {
                URI src = sty.getURIValue(getXMLBase());
                URL newVal = src.toURL();

                if (!newVal.equals(href))
                {
                    href = newVal;
                    stateChange = true;
                }
            }
        } catch (Exception e)
        {
            throw new SVGException(e);
        }

        if (getPres(sty.setName(""filterUnits"")))
        {
            int newVal;
            String strn = sty.getStringValue().toLowerCase();
            if (strn.equals(""userspaceonuse""))
            {
                newVal = FU_USER_SPACE_ON_USE;
            } else
            {
                newVal = FU_OBJECT_BOUNDING_BOX;
            }
            if (newVal != filterUnits)
            {
                filterUnits = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""primitiveUnits"")))
        {
            int newVal;
            String strn = sty.getStringValue().toLowerCase();
            if (strn.equals(""userspaceonuse""))
            {
                newVal = PU_USER_SPACE_ON_USE;
            } else
            {
                newVal = PU_OBJECT_BOUNDING_BOX;
            }
            if (newVal != filterUnits)
            {
                primitiveUnits = newVal;
                stateChange = true;
            }
        }



        return stateChange;
    }
}
"
FilterEffects.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on March 18, 2004, 6:52 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.net.URI;
import java.net.URL;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class FilterEffects extends SVGElement
{
    public static final String TAG_NAME = ""filtereffects"";
    
    public static final int FP_SOURCE_GRAPHIC = 0;
    public static final int FP_SOURCE_ALPHA = 1;
    public static final int FP_BACKGROUND_IMAGE = 2;
    public static final int FP_BACKGROUND_ALPHA = 3;
    public static final int FP_FILL_PAINT = 4;
    public static final int FP_STROKE_PAINT = 5;
    public static final int FP_CUSTOM = 5;
    private int filterPrimitiveTypeIn;
    private String filterPrimitiveRefIn;
    float x = 0f;
    float y = 0f;
    float width = 1f;
    float height = 1f;
    String result = ""defaultFilterName"";
    URL href = null;

    /**
     * Creates a new instance of FillElement
     */
    public FilterEffects()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    /**
     * Called after the start element but before the end element to indicate
     * each child tag that has been processed
     */
    public void loaderAddChild(SVGLoaderHelper helper, SVGElement child) throws SVGElementException
    {
        super.loaderAddChild(helper, child);

        if (child instanceof FilterEffects)
        {
//            filterEffects.add(child);
        }
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();
        String strn;
        /*
         if (getPres(sty.setName(""filterUnits"")))
         {
         strn = sty.getStringValue().toLowerCase();
         if (strn.equals(""userspaceonuse"")) filterUnits = FU_USER_SPACE_ON_USE;
         else filterUnits = FU_OBJECT_BOUNDING_BOX;
         }

         if (getPres(sty.setName(""primitiveUnits"")))
         {
         strn = sty.getStringValue().toLowerCase();
         if (strn.equals(""userspaceonuse"")) primitiveUnits = PU_USER_SPACE_ON_USE;
         else primitiveUnits = PU_OBJECT_BOUNDING_BOX;
         }

         if (getPres(sty.setName(""x""))) x = sty.getFloatValue();

         if (getPres(sty.setName(""y""))) y = sty.getFloatValue();

         if (getPres(sty.setName(""width""))) width = sty.getFloatValue();

         if (getPres(sty.setName(""height""))) height = sty.getFloatValue();

         try {
         if (getPres(sty.setName(""xlink:href"")))
         {
         URI src = sty.getURIValue(getXMLBase());
         href = src.toURL();
         }
         }
         catch (Exception e)
         {
         throw new SVGException(e);
         }
         */
    }

    public float getX()
    {
        return x;
    }

    public float getY()
    {
        return y;
    }

    public float getWidth()
    {
        return width;
    }

    public float getHeight()
    {
        return height;
    }

    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean stateChange = false;

        if (getPres(sty.setName(""x"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != x)
            {
                x = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""y"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != y)
            {
                y = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""width"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != width)
            {
                width = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""height"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != height)
            {
                height = newVal;
                stateChange = true;
            }
        }

        try
        {
            if (getPres(sty.setName(""xlink:href"")))
            {
                URI src = sty.getURIValue(getXMLBase());
                URL newVal = src.toURL();

                if (!newVal.equals(href))
                {
                    href = newVal;
                    stateChange = true;
                }
            }
        } catch (Exception e)
        {
            throw new SVGException(e);
        }

        /*
         if (getPres(sty.setName(""filterUnits"")))
         {
         int newVal;
         String strn = sty.getStringValue().toLowerCase();
         if (strn.equals(""userspaceonuse"")) newVal = FU_USER_SPACE_ON_USE;
         else newVal = FU_OBJECT_BOUNDING_BOX;
         if (newVal != filterUnits)
         {
         filterUnits = newVal;
         stateChange = true;
         }
         }

         if (getPres(sty.setName(""primitiveUnits"")))
         {
         int newVal;
         String strn = sty.getStringValue().toLowerCase();
         if (strn.equals(""userspaceonuse"")) newVal = PU_USER_SPACE_ON_USE;
         else newVal = PU_OBJECT_BOUNDING_BOX;
         if (newVal != filterUnits)
         {
         primitiveUnits = newVal;
         stateChange = true;
         }
         }

         */

        return stateChange;
    }
}
"
Font.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 20, 2004, 10:00 PM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.util.HashMap;

/**
 * Implements an embedded font.
 *
 * SVG specification: http://www.w3.org/TR/SVG/fonts.html
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Font extends SVGElement
{

    public static final String TAG_NAME = ""font"";
    int horizOriginX = 0;
    int horizOriginY = 0;
    int horizAdvX = -1;  //Must be specified
    int vertOriginX = -1;  //Defaults to horizAdvX / 2
    int vertOriginY = -1;  //Defaults to font's ascent
    int vertAdvY = -1;  //Defaults to one 'em'.  See font-face
    FontFace fontFace = null;
    MissingGlyph missingGlyph = null;
    final HashMap glyphs = new HashMap();

    /**
     * Creates a new instance of Font
     */
    public Font()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    /**
     * Called after the start element but before the end element to indicate
     * each child tag that has been processed
     */
    public void loaderAddChild(SVGLoaderHelper helper, SVGElement child) throws SVGElementException
    {
        super.loaderAddChild(helper, child);

        if (child instanceof Glyph)
        {
            glyphs.put(((Glyph) child).getUnicode(), child);
        } else if (child instanceof MissingGlyph)
        {
            missingGlyph = (MissingGlyph) child;
        } else if (child instanceof FontFace)
        {
            fontFace = (FontFace) child;
        }
    }

    public void loaderEndElement(SVGLoaderHelper helper) throws SVGParseException
    {
        super.loaderEndElement(helper);

        //build();

        helper.universe.registerFont(this);
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""horiz-origin-x"")))
        {
            horizOriginX = sty.getIntValue();
        }

        if (getPres(sty.setName(""horiz-origin-y"")))
        {
            horizOriginY = sty.getIntValue();
        }

        if (getPres(sty.setName(""horiz-adv-x"")))
        {
            horizAdvX = sty.getIntValue();
        }

        if (getPres(sty.setName(""vert-origin-x"")))
        {
            vertOriginX = sty.getIntValue();
        }

        if (getPres(sty.setName(""vert-origin-y"")))
        {
            vertOriginY = sty.getIntValue();
        }

        if (getPres(sty.setName(""vert-adv-y"")))
        {
            vertAdvY = sty.getIntValue();
        }
    }

    public FontFace getFontFace()
    {
        return fontFace;
    }

    public MissingGlyph getGlyph(String unicode)
    {
        Glyph retVal = (Glyph) glyphs.get(unicode);
        if (retVal == null)
        {
            return missingGlyph;
        }
        return retVal;
    }

    public int getHorizOriginX()
    {
        return horizOriginX;
    }

    public int getHorizOriginY()
    {
        return horizOriginY;
    }

    public int getHorizAdvX()
    {
        return horizAdvX;
    }

    public int getVertOriginX()
    {
        if (vertOriginX != -1)
        {
            return vertOriginX;
        }
        vertOriginX = getHorizAdvX() / 2;
        return vertOriginX;
    }

    public int getVertOriginY()
    {
        if (vertOriginY != -1)
        {
            return vertOriginY;
        }
        vertOriginY = fontFace.getAscent();
        return vertOriginY;
    }

    public int getVertAdvY()
    {
        if (vertAdvY != -1)
        {
            return vertAdvY;
        }
        vertAdvY = fontFace.getUnitsPerEm();
        return vertAdvY;
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
        //Fonts can't change
        return false;
        /*
         if (trackManager.getNumTracks() == 0) return false;
        
         //Get current values for parameters
         StyleAttribute sty = new StyleAttribute();
         boolean stateChange = false;
        
         if (getPres(sty.setName(""horiz-origin-x"")))
         {
         int newVal = sty.getIntValue();
         if (newVal != horizOriginX)
         {
         horizOriginX = newVal;
         stateChange = true;
         }
         }
        
         if (getPres(sty.setName(""horiz-origin-y"")))
         {
         int newVal = sty.getIntValue();
         if (newVal != horizOriginY)
         {
         horizOriginY = newVal;
         stateChange = true;
         }
         }
        
         if (getPres(sty.setName(""horiz-adv-x"")))
         {
         int newVal = sty.getIntValue();
         if (newVal != horizAdvX)
         {
         horizAdvX = newVal;
         stateChange = true;
         }
         }
        
         if (getPres(sty.setName(""vert-origin-x"")))
         {
         int newVal = sty.getIntValue();
         if (newVal != vertOriginX)
         {
         vertOriginX = newVal;
         stateChange = true;
         }
         }
        
         if (getPres(sty.setName(""vert-origin-y"")))
         {
         int newVal = sty.getIntValue();
         if (newVal != vertOriginY)
         {
         vertOriginY = newVal;
         stateChange = true;
         }
         }
        
         if (getPres(sty.setName(""vert-adv-y"")))
         {
         int newVal = sty.getIntValue();
         if (newVal != vertAdvY)
         {
         vertAdvY = newVal;
         stateChange = true;
         }
         }
        
         return shapeChange;
         */
    }
}
"
FontFace.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 20, 2004, 10:00 PM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;

/**
 * Implements an embedded font.
 *
 * SVG specification: http://www.w3.org/TR/SVG/fonts.html
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class FontFace extends SVGElement
{

    public static final String TAG_NAME = ""fontface"";
    String fontFamily;
    /**
     * Em size of coordinate system font is defined in
     */
    int unitsPerEm = 1000;
    int ascent = -1;
    int descent = -1;
    int accentHeight = -1;
    int underlinePosition = -1;
    int underlineThickness = -1;
    int strikethroughPosition = -1;
    int strikethroughThickness = -1;
    int overlinePosition = -1;
    int overlineThickness = -1;

    /**
     * Creates a new instance of Font
     */
    public FontFace()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""font-family"")))
        {
            fontFamily = sty.getStringValue();
        }

        if (getPres(sty.setName(""units-per-em"")))
        {
            unitsPerEm = sty.getIntValue();
        }
        if (getPres(sty.setName(""ascent"")))
        {
            ascent = sty.getIntValue();
        }
        if (getPres(sty.setName(""descent"")))
        {
            descent = sty.getIntValue();
        }
        if (getPres(sty.setName(""accent-height"")))
        {
            accentHeight = sty.getIntValue();
        }

        if (getPres(sty.setName(""underline-position"")))
        {
            underlinePosition = sty.getIntValue();
        }
        if (getPres(sty.setName(""underline-thickness"")))
        {
            underlineThickness = sty.getIntValue();
        }
        if (getPres(sty.setName(""strikethrough-position"")))
        {
            strikethroughPosition = sty.getIntValue();
        }
        if (getPres(sty.setName(""strikethrough-thickenss"")))
        {
            strikethroughThickness = sty.getIntValue();
        }
        if (getPres(sty.setName(""overline-position"")))
        {
            overlinePosition = sty.getIntValue();
        }
        if (getPres(sty.setName(""overline-thickness"")))
        {
            overlineThickness = sty.getIntValue();
        }
    }

    public String getFontFamily()
    {
        return fontFamily;
    }

    public int getUnitsPerEm()
    {
        return unitsPerEm;
    }

    public int getAscent()
    {
        if (ascent == -1)
        {
            ascent = unitsPerEm - ((Font) parent).getVertOriginY();
        }
        return ascent;
    }

    public int getDescent()
    {
        if (descent == -1)
        {
            descent = ((Font) parent).getVertOriginY();
        }
        return descent;
    }

    public int getAccentHeight()
    {
        if (accentHeight == -1)
        {
            accentHeight = getAscent();
        }
        return accentHeight;
    }

    public int getUnderlinePosition()
    {
        if (underlinePosition == -1)
        {
            underlinePosition = unitsPerEm * 5 / 6;
        }
        return underlinePosition;
    }

    public int getUnderlineThickness()
    {
        if (underlineThickness == -1)
        {
            underlineThickness = unitsPerEm / 20;
        }
        return underlineThickness;
    }

    public int getStrikethroughPosition()
    {
        if (strikethroughPosition == -1)
        {
            strikethroughPosition = unitsPerEm * 3 / 6;
        }
        return strikethroughPosition;
    }

    public int getStrikethroughThickness()
    {
        if (strikethroughThickness == -1)
        {
            strikethroughThickness = unitsPerEm / 20;
        }
        return strikethroughThickness;
    }

    public int getOverlinePosition()
    {
        if (overlinePosition == -1)
        {
            overlinePosition = unitsPerEm * 5 / 6;
        }
        return overlinePosition;
    }

    public int getOverlineThickness()
    {
        if (overlineThickness == -1)
        {
            overlineThickness = unitsPerEm / 20;
        }
        return overlineThickness;
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime)
    {
        //Fonts can't change
        return false;
    }
}
"
Glyph.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 20, 2004, 10:00 PM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;

/**
 * Implements an embedded font.
 *
 * SVG specification: http://www.w3.org/TR/SVG/fonts.html
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Glyph extends MissingGlyph
{

    public static final String TAG_NAME = ""missingglyph"";
    /**
     * One or more characters indicating the unicode sequence that denotes this
     * glyph.
     */
    String unicode;

    /**
     * Creates a new instance of Font
     */
    public Glyph()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""unicode"")))
        {
            unicode = sty.getStringValue();
        }
    }

    public String getUnicode()
    {
        return unicode;
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
        //Fonts can't change
        return false;
    }
}
"
Gradient.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 3:25 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Color;
import java.awt.geom.AffineTransform;
import java.net.URI;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
abstract public class Gradient extends FillElement
{
    public static final String TAG_NAME = ""gradient"";
    
    public static final int SM_PAD = 0;
    public static final int SM_REPEAT = 1;
    public static final int SM_REFLECT = 2;
    int spreadMethod = SM_PAD;
    public static final int GU_OBJECT_BOUNDING_BOX = 0;
    public static final int GU_USER_SPACE_ON_USE = 1;
    protected int gradientUnits = GU_OBJECT_BOUNDING_BOX;
    //Either this gradient contains a list of stops, or it will take it's
    // stops from the referenced gradient
    ArrayList stops = new ArrayList();
    URI stopRef = null;
    protected AffineTransform gradientTransform = null;
    
    //Cache arrays of stop values here
    float[] stopFractions;
    Color[] stopColors;

    /**
     * Creates a new instance of Gradient
     */
    public Gradient()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    /**
     * Called after the start element but before the end element to indicate
     * each child tag that has been processed
     */
    public void loaderAddChild(SVGLoaderHelper helper, SVGElement child) throws SVGElementException
    {
        super.loaderAddChild(helper, child);

        if (!(child instanceof Stop))
        {
            return;
        }
        appendStop((Stop) child);
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();
        String strn;

        if (getPres(sty.setName(""spreadMethod"")))
        {
            strn = sty.getStringValue().toLowerCase();
            if (strn.equals(""repeat""))
            {
                spreadMethod = SM_REPEAT;
            } else if (strn.equals(""reflect""))
            {
                spreadMethod = SM_REFLECT;
            } else
            {
                spreadMethod = SM_PAD;
            }
        }

        if (getPres(sty.setName(""gradientUnits"")))
        {
            strn = sty.getStringValue().toLowerCase();
            if (strn.equals(""userspaceonuse""))
            {
                gradientUnits = GU_USER_SPACE_ON_USE;
            } else
            {
                gradientUnits = GU_OBJECT_BOUNDING_BOX;
            }
        }

        if (getPres(sty.setName(""gradientTransform"")))
        {
            gradientTransform = parseTransform(sty.getStringValue());
        }
        //If we still don't have one, set it to identity
        if (gradientTransform == null)
        {
            gradientTransform = new AffineTransform();
        }


        //Check to see if we're using our own stops or referencing someone else's
        if (getPres(sty.setName(""xlink:href"")))
        {
            try
            {
                stopRef = sty.getURIValue(getXMLBase());
//System.err.println(""Gradient: "" + sty.getStringValue() + "", "" + getXMLBase() + "", "" + src);
//                URI src = getXMLBase().resolve(href);
//                stopRef = (Gradient)diagram.getUniverse().getElement(src);
            } catch (Exception e)
            {
                throw new SVGException(""Could not resolve relative URL in Gradient: "" + sty.getStringValue() + "", "" + getXMLBase(), e);
            }
        }
    }

    public float[] getStopFractions()
    {
        if (stopRef != null)
        {
            Gradient grad = (Gradient) diagram.getUniverse().getElement(stopRef);
            return grad.getStopFractions();
        }

        if (stopFractions != null)
        {
            return stopFractions;
        }

        stopFractions = new float[stops.size()];
        int idx = 0;
        for (Iterator it = stops.iterator(); it.hasNext();)
        {
            Stop stop = (Stop) it.next();
            float val = stop.offset;
            if (idx != 0 && val < stopFractions[idx - 1])
            {
                val = stopFractions[idx - 1];
            }
            stopFractions[idx++] = val;
        }

        return stopFractions;
    }

    public Color[] getStopColors()
    {
        if (stopRef != null)
        {
            Gradient grad = (Gradient) diagram.getUniverse().getElement(stopRef);
            return grad.getStopColors();
        }

        if (stopColors != null)
        {
            return stopColors;
        }

        stopColors = new Color[stops.size()];
        int idx = 0;
        for (Iterator it = stops.iterator(); it.hasNext();)
        {
            Stop stop = (Stop) it.next();
            int stopColorVal = stop.color.getRGB();
            Color stopColor = new Color((stopColorVal >> 16) & 0xff, (stopColorVal >> 8) & 0xff, stopColorVal & 0xff, clamp((int) (stop.opacity * 255), 0, 255));
            stopColors[idx++] = stopColor;
        }

        return stopColors;
    }

    public void setStops(Color[] colors, float[] fractions)
    {
        if (colors.length != fractions.length)
        {
            throw new IllegalArgumentException();
        }

        this.stopColors = colors;
        this.stopFractions = fractions;
        stopRef = null;
    }

    private int clamp(int val, int min, int max)
    {
        if (val < min)
        {
            return min;
        }
        if (val > max)
        {
            return max;
        }
        return val;
    }

    public void setStopRef(URI grad)
    {
        stopRef = grad;
    }

    public void appendStop(Stop stop)
    {
        stops.add(stop);
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;
        boolean stateChange = false;

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;
        String strn;


        if (getPres(sty.setName(""spreadMethod"")))
        {
            int newVal;
            strn = sty.getStringValue().toLowerCase();
            if (strn.equals(""repeat""))
            {
                newVal = SM_REPEAT;
            } else if (strn.equals(""reflect""))
            {
                newVal = SM_REFLECT;
            } else
            {
                newVal = SM_PAD;
            }
            if (spreadMethod != newVal)
            {
                spreadMethod = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""gradientUnits"")))
        {
            int newVal;
            strn = sty.getStringValue().toLowerCase();
            if (strn.equals(""userspaceonuse""))
            {
                newVal = GU_USER_SPACE_ON_USE;
            } else
            {
                newVal = GU_OBJECT_BOUNDING_BOX;
            }
            if (newVal != gradientUnits)
            {
                gradientUnits = newVal;
                stateChange = true;
            }
        }

        if (getPres(sty.setName(""gradientTransform"")))
        {
            AffineTransform newVal = parseTransform(sty.getStringValue());
            if (newVal != null && newVal.equals(gradientTransform))
            {
                gradientTransform = newVal;
                stateChange = true;
            }
        }


        //Check to see if we're using our own stops or referencing someone else's
        if (getPres(sty.setName(""xlink:href"")))
        {
            try
            {
                URI newVal = sty.getURIValue(getXMLBase());
                if ((newVal == null && stopRef != null) || !newVal.equals(stopRef))
                {
                    stopRef = newVal;
                    stateChange = true;
                }
            } catch (Exception e)
            {
                Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                    ""Could not parse xlink:href"", e);
            }
        }

        //Check stops, if any
        for (Iterator it = stops.iterator(); it.hasNext();)
        {
            Stop stop = (Stop) it.next();
            if (stop.updateTime(curTime))
            {
                stateChange = true;
                stopFractions = null;
                stopColors = null;
            }
        }

        return stateChange;
    }
}
"
Group.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 1:56 AM
 */
package com.kitfox.svg;

import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.List;

import com.kitfox.svg.xml.StyleAttribute;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Group extends ShapeElement
{
    public static final String TAG_NAME = ""group"";
    
    //Cache bounding box for faster clip testing
    Rectangle2D boundingBox;
    Shape cachedShape;

    /**
     * Creates a new instance of Stop
     */
    public Group()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    /**
     * Called after the start element but before the end element to indicate
     * each child tag that has been processed
     */
    public void loaderAddChild(SVGLoaderHelper helper, SVGElement child) throws SVGElementException
    {
        super.loaderAddChild(helper, child);
    }

    protected boolean outsideClip(Graphics2D g) throws SVGException
    {
        Shape clip = g.getClip();
        if (clip == null)
        {
            return false;
        }
        //g.getClipBounds(clipBounds);
        Rectangle2D rect = getBoundingBox();

        if (clip.intersects(rect))
        {
            return false;
        }

        return true;
    }

    void pick(Point2D point, boolean boundingBox, List retVec) throws SVGException
    {
        Point2D xPoint = new Point2D.Double(point.getX(), point.getY());
        if (xform != null)
        {
            try
            {
                xform.inverseTransform(point, xPoint);
            } catch (NoninvertibleTransformException ex)
            {
                throw new SVGException(ex);
            }
        }


		for (SVGElement ele : getChildren())
        {
            if (ele instanceof RenderableElement)
            {
                RenderableElement rendEle = (RenderableElement) ele;

                rendEle.pick(xPoint, boundingBox, retVec);
            }
        }
    }

    void pick(Rectangle2D pickArea, AffineTransform ltw, boolean boundingBox, List retVec) throws SVGException
    {
        if (xform != null)
        {
            ltw = new AffineTransform(ltw);
            ltw.concatenate(xform);
        }


        for (SVGElement ele : getChildren())
        {
            if (ele instanceof RenderableElement)
            {
                RenderableElement rendEle = (RenderableElement) ele;

                rendEle.pick(pickArea, ltw, boundingBox, retVec);
            }
        }
    }

    public void render(Graphics2D g) throws SVGException
    {
        //Don't process if not visible
        StyleAttribute styleAttrib = new StyleAttribute();
        if (getStyle(styleAttrib.setName(""visibility"")))
        {
            if (!styleAttrib.getStringValue().equals(""visible""))
            {
                return;
            }
        }

        //Do not process offscreen groups
        boolean ignoreClip = diagram.ignoringClipHeuristic();
        if (!ignoreClip && outsideClip(g))
        {
            return;
        }

        beginLayer(g);

//        try
//        {
//            g.getClipBounds(clipBounds);
//        }
//        catch (Exception e)
//        {
//            //For some reason, getClipBounds can throw a null pointer exception for
//            // some types of Graphics2D
//            ignoreClip = true;
//        }

        Shape clip = g.getClip();
        for (SVGElement ele : getChildren())
        {
            if (ele instanceof RenderableElement)
            {
                RenderableElement rendEle = (RenderableElement) ele;

//                if (shapeEle == null) continue;

                if (!(ele instanceof Group))
                {
                    //Skip if clipping area is outside our bounds
                    if (!ignoreClip && clip != null
                        && !clip.intersects(rendEle.getBoundingBox()))
                    {
                        continue;
                    }
                }

                rendEle.render(g);
            }
        }

        finishLayer(g);
    }

    /**
     * Retrieves the cached bounding box of this group
     */
    public Shape getShape()
    {
        if (cachedShape == null)
        {
            calcShape();
        }
        return cachedShape;
    }

    public void calcShape()
    {
        Area retShape = new Area();

        for (SVGElement ele : getChildren())
        {

            if (ele instanceof ShapeElement)
            {
                ShapeElement shpEle = (ShapeElement) ele;
                Shape shape = shpEle.getShape();
                if (shape != null)
                {
                    retShape.add(new Area(shape));
                }
            }
        }

        cachedShape = shapeToParent(retShape);
    }

    /**
     * Retrieves the cached bounding box of this group
     */
    public Rectangle2D getBoundingBox() throws SVGException
    {
        if (boundingBox == null)
        {
            calcBoundingBox();
        }
//        calcBoundingBox();
        return boundingBox;
    }

    /**
     * Recalculates the bounding box by taking the union of the bounding boxes
     * of all children. Caches the result.
     */
    public void calcBoundingBox() throws SVGException
    {
//        Rectangle2D retRect = new Rectangle2D.Float();
        Rectangle2D retRect = null;

        for (SVGElement ele : getChildren())
        {

            if (ele instanceof RenderableElement)
            {
                RenderableElement rendEle = (RenderableElement) ele;
                Rectangle2D bounds = rendEle.getBoundingBox();
                if (bounds != null)
                {
                    if (retRect == null)
                    {
                        retRect = bounds;
                    } else
                    {
                        retRect = retRect.createUnion(bounds);
                    }
                }
            }
        }

//        if (xform != null)
//        {
//            retRect = xform.createTransformedShape(retRect).getBounds2D();
//        }

        //If no contents, use degenerate rectangle
        if (retRect == null)
        {
            retRect = new Rectangle2D.Float();
        }

        boundingBox = boundsToParent(retRect);
    }

    public boolean updateTime(double curTime) throws SVGException
    {
        boolean changeState = super.updateTime(curTime);

        //Distribute message to all members of this group
        for (SVGElement ele : getChildren())
        {
            boolean updateVal = ele.updateTime(curTime);

            changeState = changeState || updateVal;

            //Update our shape if shape aware children change
            if (ele instanceof ShapeElement)
            {
                cachedShape = null;
            }
            if (ele instanceof RenderableElement)
            {
                boundingBox = null;
            }
        }

        return changeState;
    }
}
"
Hkern.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 20, 2004, 10:00 PM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;

/**
 *
 * @author kitfox
 */
public class Hkern extends SVGElement
{

    public static final String TAG_NAME = ""hkern"";
    String u1;
    String u2;
    int k;

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();


        //Read glyph spacing info
        if (getPres(sty.setName(""u1"")))
        {
            u1 = sty.getStringValue();
        }

        if (getPres(sty.setName(""u2"")))
        {
            u2 = sty.getStringValue();
        }

        if (getPres(sty.setName(""k"")))
        {
            k = sty.getIntValue();
        }
    }

    public boolean updateTime(double curTime) throws SVGException
    {
        //Fonts can't change
        return false;
    }
}
"
ImageSVG.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 20, 2004, 10:00 PM
 */
package com.kitfox.svg;

import java.awt.AlphaComposite;
import java.awt.Composite;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.kitfox.svg.app.data.Handler;
import com.kitfox.svg.xml.StyleAttribute;

/**
 * Implements an image.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class ImageSVG extends RenderableElement
{
    public static final String TAG_NAME = ""image"";
    
    float x = 0f;
    float y = 0f;
    float width = 0f;
    float height = 0f;
//    BufferedImage href = null;
    URL imageSrc = null;
    AffineTransform xform;
    Rectangle2D bounds;

    /**
     * Creates a new instance of Font
     */
    public ImageSVG()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""x"")))
        {
            x = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""y"")))
        {
            y = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""width"")))
        {
            width = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""height"")))
        {
            height = sty.getFloatValueWithUnits();
        }

        try
        {
            if (getPres(sty.setName(""xlink:href"")))
            {
                URI src = sty.getURIValue(getXMLBase());
                if (""data"".equals(src.getScheme()))
                {
                    imageSrc = new URL(null, src.toASCIIString(), new Handler());
                } else
                {
                    try
                    {
                    	try {
                    		imageSrc = src.toURL();
                    	} catch (MalformedURLException e) {
                    		// FM, workaround for URI's provided without schema, i.e., as absolute paths pointing to a local file.
                    		// Those are, e.g., returned by GraphViz when embedding SVG images via the 'image' attribute.
                    		// Try to add a 'file' scheme for those.
                    		imageSrc = new URI(""file:///""+ sty.getStringValue()).toURL();
                    	}
                    } catch (Exception e) {
                        Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                            ""Could not parse xlink:href "" + src, e);
//                        e.printStackTrace();
                        imageSrc = null;
                    }
                }
            }
        } catch (Exception e)
        {
            throw new SVGException(e);
        }

        diagram.getUniverse().registerImage(imageSrc);

        //Set widths if not set
        BufferedImage img = diagram.getUniverse().getImage(imageSrc);
        if (img == null)
        {
            xform = new AffineTransform();
            bounds = new Rectangle2D.Float();
            return;
        }

        if (width == 0)
        {
            width = img.getWidth();
        }
        if (height == 0)
        {
            height = img.getHeight();
        }

        //Determine image xform
        xform = new AffineTransform();
//        xform.setToScale(this.width / img.getWidth(), this.height / img.getHeight());
//        xform.translate(this.x, this.y);
        xform.translate(this.x, this.y);
        xform.scale(this.width / img.getWidth(), this.height / img.getHeight());

        bounds = new Rectangle2D.Float(this.x, this.y, this.width, this.height);
    }

    public float getX()
    {
        return x;
    }

    public float getY()
    {
        return y;
    }

    public float getWidth()
    {
        return width;
    }

    public float getHeight()
    {
        return height;
    }

    void pick(Point2D point, boolean boundingBox, List retVec) throws SVGException
    {
        if (getBoundingBox().contains(point))
        {
            retVec.add(getPath(null));
        }
    }

    void pick(Rectangle2D pickArea, AffineTransform ltw, boolean boundingBox, List retVec) throws SVGException
    {
        if (ltw.createTransformedShape(getBoundingBox()).intersects(pickArea))
        {
            retVec.add(getPath(null));
        }
    }

    public void render(Graphics2D g) throws SVGException
    {
        StyleAttribute styleAttrib = new StyleAttribute();
        if (getStyle(styleAttrib.setName(""visibility"")))
        {
            if (!styleAttrib.getStringValue().equals(""visible""))
            {
                return;
            }
        }

        beginLayer(g);

        float opacity = 1f;
        if (getStyle(styleAttrib.setName(""opacity"")))
        {
            opacity = styleAttrib.getRatioValue();
        }

        if (opacity <= 0)
        {
            return;
        }

        Composite oldComp = null;

        if (opacity < 1)
        {
            oldComp = g.getComposite();
            Composite comp = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, opacity);
            g.setComposite(comp);
        }

        BufferedImage img = diagram.getUniverse().getImage(imageSrc);
        if (img == null)
        {
            return;
        }

        AffineTransform curXform = g.getTransform();
        g.transform(xform);

        g.drawImage(img, 0, 0, null);

        g.setTransform(curXform);
        if (oldComp != null)
        {
            g.setComposite(oldComp);
        }

        finishLayer(g);
    }

    public Rectangle2D getBoundingBox()
    {
        return boundsToParent(bounds);
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;
        boolean changeState = super.updateTime(curTime);

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;

        if (getPres(sty.setName(""x"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != x)
            {
                x = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""y"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != y)
            {
                y = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""width"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != width)
            {
                width = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""height"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != height)
            {
                height = newVal;
                shapeChange = true;
            }
        }

        try
        {
            if (getPres(sty.setName(""xlink:href"")))
            {
                URI src = sty.getURIValue(getXMLBase());

                URL newVal;
                if (""data"".equals(src.getScheme()))
                {
                    newVal = new URL(null, src.toASCIIString(), new Handler());
                } else
                {
                	try {
                		newVal = src.toURL();
                	} catch (MalformedURLException e) {
                		// FM, workaround for URI's provided without schema, i.e., as absolute paths pointing to a local file.
                		// Those are, e.g., returned by GraphViz when embedding SVG images via the 'image' attribute.
                		// Try to add a 'file' scheme for those.
                		newVal = new URI(""file:///""+ sty.getStringValue()).toURL();
                	}
                }

                if (!newVal.equals(imageSrc))
                {
                    imageSrc = newVal;
                    shapeChange = true;
                }
            }
        } catch (IllegalArgumentException ie)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Image provided with illegal value for href: \""""
                + sty.getStringValue() + '""', ie);
        } catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Could not parse xlink:href"", e);
        }


        if (shapeChange)
        {
            build();
//            diagram.getUniverse().registerImage(imageSrc);
//
//            //Set widths if not set
//            BufferedImage img = diagram.getUniverse().getImage(imageSrc);
//            if (img == null)
//            {
//                xform = new AffineTransform();
//                bounds = new Rectangle2D.Float();
//            }
//            else
//            {
//                if (width == 0) width = img.getWidth();
//                if (height == 0) height = img.getHeight();
//
//                //Determine image xform
//                xform = new AffineTransform();
////                xform.setToScale(this.width / img.getWidth(), this.height / img.getHeight());
////                xform.translate(this.x, this.y);
//                xform.translate(this.x, this.y);
//                xform.scale(this.width / img.getWidth(), this.height / img.getHeight());
//
//                bounds = new Rectangle2D.Float(this.x, this.y, this.width, this.height);
//            }
//
//            return true;
        }

        return changeState || shapeChange;
    }
}
"
Line.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 5:25 PM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Line extends ShapeElement
{
    public static final String TAG_NAME = ""line"";
    
    float x1 = 0f;
    float y1 = 0f;
    float x2 = 0f;
    float y2 = 0f;
    Line2D.Float line;

    /**
     * Creates a new instance of Rect
     */
    public Line()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""x1"")))
        {
            x1 = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""y1"")))
        {
            y1 = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""x2"")))
        {
            x2 = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""y2"")))
        {
            y2 = sty.getFloatValueWithUnits();
        }

        line = new Line2D.Float(x1, y1, x2, y2);
    }

    public void render(Graphics2D g) throws SVGException
    {
        beginLayer(g);
        renderShape(g, line);
        finishLayer(g);
    }

    public Shape getShape()
    {
        return shapeToParent(line);
    }

    public Rectangle2D getBoundingBox() throws SVGException
    {
        return boundsToParent(includeStrokeInBounds(line.getBounds2D()));
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;
        boolean changeState = super.updateTime(curTime);

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;

        if (getPres(sty.setName(""x1"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != x1)
            {
                x1 = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""y1"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != y1)
            {
                y1 = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""x2"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != x2)
            {
                x2 = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""y2"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != y2)
            {
                y2 = newVal;
                shapeChange = true;
            }
        }

        if (shapeChange)
        {
            build();
        }

        return changeState || shapeChange;
    }
}
"
LinearGradient.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 1:54 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Color;
import java.awt.Paint;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class LinearGradient extends Gradient
{
    public static final String TAG_NAME = ""lineargradient"";
    
    float x1 = 0f;
    float y1 = 0f;
    float x2 = 1f;
    float y2 = 0f;

    /**
     * Creates a new instance of LinearGradient
     */
    public LinearGradient()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""x1"")))
        {
            x1 = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""y1"")))
        {
            y1 = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""x2"")))
        {
            x2 = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""y2"")))
        {
            y2 = sty.getFloatValueWithUnits();
        }
    }

    public Paint getPaint(Rectangle2D bounds, AffineTransform xform)
    {
        com.kitfox.svg.batik.MultipleGradientPaint.CycleMethodEnum method;
        switch (spreadMethod)
        {
            default:
            case SM_PAD:
                method = com.kitfox.svg.batik.MultipleGradientPaint.NO_CYCLE;
                break;
            case SM_REPEAT:
                method = com.kitfox.svg.batik.MultipleGradientPaint.REPEAT;
                break;
            case SM_REFLECT:
                method = com.kitfox.svg.batik.MultipleGradientPaint.REFLECT;
                break;
        }

        Paint paint;
        Point2D.Float pt1 = new Point2D.Float(x1, y1);
        Point2D.Float pt2 = new Point2D.Float(x2, y2);
        if (pt1.equals(pt2))
        {
            Color[] colors = getStopColors();
            paint = colors.length > 0 ? colors[0] : Color.black;
        } else if (gradientUnits == GU_USER_SPACE_ON_USE)
        {
            paint = new com.kitfox.svg.batik.LinearGradientPaint(
                pt1,
                pt2,
                getStopFractions(),
                getStopColors(),
                method,
                com.kitfox.svg.batik.MultipleGradientPaint.SRGB,
                gradientTransform == null
                ? new AffineTransform()
                : gradientTransform);
        } else
        {
            AffineTransform viewXform = new AffineTransform();
            viewXform.translate(bounds.getX(), bounds.getY());

            //This is a hack to get around shapes that have a width or height of 0.  Should be close enough to the true answer.
            double width = Math.max(1, bounds.getWidth());
            double height = Math.max(1, bounds.getHeight());
            viewXform.scale(width, height);

            if (gradientTransform != null)
            {
                viewXform.concatenate(gradientTransform);
            }

            paint = new com.kitfox.svg.batik.LinearGradientPaint(
                pt1,
                pt2,
                getStopFractions(),
                getStopColors(),
                method,
                com.kitfox.svg.batik.MultipleGradientPaint.SRGB,
                viewXform);
        }

        return paint;
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return stopChange;
        boolean changeState = super.updateTime(curTime);

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;

        if (getPres(sty.setName(""x1"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != x1)
            {
                x1 = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""y1"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != y1)
            {
                y1 = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""x2"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != x2)
            {
                x2 = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""y2"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != y2)
            {
                y2 = newVal;
                shapeChange = true;
            }
        }

        return changeState || shapeChange;
    }
}
"
Marker.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;

/**
 *
 * @author kitfox
 */
public class Marker extends Group
{
    public static final String TAG_NAME = ""marker"";
    
    AffineTransform viewXform;
    AffineTransform markerXform;
    Rectangle2D viewBox;
    float refX;
    float refY;
    float markerWidth = 3;
    float markerHeight = 3;
    float orient = Float.NaN;
    boolean markerUnitsStrokeWidth = true; //if set to false 'userSpaceOnUse' is assumed

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""refX"")))
        {
            refX = sty.getFloatValueWithUnits();
        }
        if (getPres(sty.setName(""refY"")))
        {
            refY = sty.getFloatValueWithUnits();
        }
        if (getPres(sty.setName(""markerWidth"")))
        {
            markerWidth = sty.getFloatValueWithUnits();
        }
        if (getPres(sty.setName(""markerHeight"")))
        {
            markerHeight = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""orient"")))
        {
            if (""auto"".equals(sty.getStringValue()))
            {
                orient = Float.NaN;
            } else
            {
                orient = sty.getFloatValue();
            }
        }

        if (getPres(sty.setName(""viewBox"")))
        {
            float[] dim = sty.getFloatList();
            viewBox = new Rectangle2D.Float(dim[0], dim[1], dim[2], dim[3]);
        }

        if (viewBox == null)
        {
            viewBox = new Rectangle(0, 0, 1, 1);
        }

        if (getPres(sty.setName(""markerUnits"")))
        {
            String markerUnits = sty.getStringValue();
            if (markerUnits != null && markerUnits.equals(""userSpaceOnUse""))
            {
                markerUnitsStrokeWidth = false;
            }
        }

        //Transform pattern onto unit square
        viewXform = new AffineTransform();
        viewXform.scale(1.0 / viewBox.getWidth(), 1.0 / viewBox.getHeight());
        viewXform.translate(-viewBox.getX(), -viewBox.getY());

        markerXform = new AffineTransform();
        markerXform.scale(markerWidth, markerHeight);
        markerXform.concatenate(viewXform);
        markerXform.translate(-refX, -refY);
    }

    protected boolean outsideClip(Graphics2D g) throws SVGException
    {
        Shape clip = g.getClip();
        Rectangle2D rect = super.getBoundingBox();
        if (clip == null || clip.intersects(rect))
        {
            return false;
        }

        return true;

    }

    public void render(Graphics2D g) throws SVGException
    {
        AffineTransform oldXform = g.getTransform();
        g.transform(markerXform);

        super.render(g);

        g.setTransform(oldXform);
    }

    public void render(Graphics2D g, MarkerPos pos, float strokeWidth) throws SVGException
    {
        AffineTransform cacheXform = g.getTransform();

        g.translate(pos.x, pos.y);
        if (markerUnitsStrokeWidth)
        {
            g.scale(strokeWidth, strokeWidth);
        }

        g.rotate(Math.atan2(pos.dy, pos.dx));

        g.transform(markerXform);

        super.render(g);

        g.setTransform(cacheXform);
    }

    public Shape getShape()
    {
        Shape shape = super.getShape();
        return markerXform.createTransformedShape(shape);
    }

    public Rectangle2D getBoundingBox() throws SVGException
    {
        Rectangle2D rect = super.getBoundingBox();
        return markerXform.createTransformedShape(rect).getBounds2D();
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
        boolean changeState = super.updateTime(curTime);

        //Marker properties do not change
        return changeState;
    }
    
    //--------------------------------
    public static final int MARKER_START = 0;
    public static final int MARKER_MID = 1;
    public static final int MARKER_END = 2;

    public static class MarkerPos
    {

        int type;
        double x;
        double y;
        double dx;
        double dy;

        public MarkerPos(int type, double x, double y, double dx, double dy)
        {
            this.type = type;
            this.x = x;
            this.y = y;
            this.dx = dx;
            this.dy = dy;
        }
    }

    public static class MarkerLayout
    {

        private ArrayList markerList = new ArrayList();
        boolean started = false;

        public void layout(Shape shape)
        {
            double px = 0;
            double py = 0;
            double[] coords = new double[6];
            for (PathIterator it = shape.getPathIterator(null);
                !it.isDone(); it.next())
            {
                switch (it.currentSegment(coords))
                {
                    case PathIterator.SEG_MOVETO:
                        px = coords[0];
                        py = coords[1];
                        started = false;
                        break;
                    case PathIterator.SEG_CLOSE:
                        started = false;
                        break;
                    case PathIterator.SEG_LINETO:
                    {
                        double x = coords[0];
                        double y = coords[1];
                        markerIn(px, py, x - px, y - py);
                        markerOut(x, y, x - px, y - py);
                        px = x;
                        py = y;
                        break;
                    }
                    case PathIterator.SEG_QUADTO:
                    {
                        double k0x = coords[0];
                        double k0y = coords[1];
                        double x = coords[2];
                        double y = coords[3];


                        //Best in tangent
                        if (px != k0x || py != k0y)
                        {
                            markerIn(px, py, k0x - px, k0y - py);
                        } else
                        {
                            markerIn(px, py, x - px, y - py);
                        }

                        //Best out tangent
                        if (x != k0x || y != k0y)
                        {
                            markerOut(x, y, x - k0x, y - k0y);
                        } else
                        {
                            markerOut(x, y, x - px, y - py);
                        }

                        markerIn(px, py, k0x - px, k0y - py);
                        markerOut(x, y, x - k0x, y - k0y);
                        px = x;
                        py = y;
                        break;
                    }
                    case PathIterator.SEG_CUBICTO:
                    {
                        double k0x = coords[0];
                        double k0y = coords[1];
                        double k1x = coords[2];
                        double k1y = coords[3];
                        double x = coords[4];
                        double y = coords[5];

                        //Best in tangent
                        if (px != k0x || py != k0y)
                        {
                            markerIn(px, py, k0x - px, k0y - py);
                        } else if (px != k1x || py != k1y)
                        {
                            markerIn(px, py, k1x - px, k1y - py);
                        } else
                        {
                            markerIn(px, py, x - px, y - py);
                        }

                        //Best out tangent
                        if (x != k1x || y != k1y)
                        {
                            markerOut(x, y, x - k1x, y - k1y);
                        } else if (x != k0x || y != k0y)
                        {
                            markerOut(x, y, x - k0x, y - k0y);
                        } else
                        {
                            markerOut(x, y, x - px, y - py);
                        }
                        px = x;
                        py = y;
                        break;
                    }
                }
            }

            for (int i = 1; i < markerList.size(); ++i)
            {
                MarkerPos prev = (MarkerPos) markerList.get(i - 1);
                MarkerPos cur = (MarkerPos) markerList.get(i);

                if (cur.type == MARKER_START)
                {
                    prev.type = MARKER_END;
                }
            }
            MarkerPos last = (MarkerPos) markerList.get(markerList.size() - 1);
            last.type = MARKER_END;
        }

        private void markerIn(double x, double y, double dx, double dy)
        {
            if (started == false)
            {
                started = true;
                markerList.add(new MarkerPos(MARKER_START, x, y, dx, dy));
            }
        }

        private void markerOut(double x, double y, double dx, double dy)
        {
            markerList.add(new MarkerPos(MARKER_MID, x, y, dx, dy));
        }

        /**
         * @return the markerList
         */
        public ArrayList getMarkerList()
        {
            return markerList;
        }
    }
}
"
Metadata.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 19, 2004, 1:56 AM
 */
package com.kitfox.svg;

/**
 * Does not hold any information. Included to allow metadata tag to be parsed.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Metadata extends SVGElement
{
    public static final String TAG_NAME = ""metadata"";

    /**
     * Creates a new instance of Stop
     */
    public Metadata()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    public boolean updateTime(double curTime)
    {
        return false;
    }
}
"
MissingGlyph.java,kitfox-6.9.6,"/*
 * SVG Salamander Copyright (c) 2004, Mark McKay All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. - Redistributions in binary
 * form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided
 * with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Mark McKay can be contacted at mark@kitfox.com. Salamander and other projects
 * can be found at http://www.kitfox.com
 *
 * Created on February 20, 2004, 10:00 PM
 */
package com.kitfox.svg;

import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;

import com.kitfox.svg.pathcmd.BuildHistory;
import com.kitfox.svg.pathcmd.PathCommand;
import com.kitfox.svg.xml.StyleAttribute;

/**
 * Implements an embedded font.
 *
 * SVG specification: http://www.w3.org/TR/SVG/fonts.html
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class MissingGlyph extends ShapeElement {
	public static final String TAG_NAME = ""missingglyph"";

	//We may define a path
	Shape path = null;
	//Alternately, we may have child graphical elements
	int horizAdvX = -1; //Inherits font's value if not set
	int vertOriginX = -1; //Inherits font's value if not set
	int vertOriginY = -1; //Inherits font's value if not set
	int vertAdvY = -1; //Inherits font's value if not set

	/**
	 * Creates a new instance of Font
	 */
	public MissingGlyph() {
	}

	public String getTagName() {
		return TAG_NAME;
	}

	/**
	 * Called after the start element but before the end element to indicate
	 * each child tag that has been processed
	 */
	public void loaderAddChild(SVGLoaderHelper helper, SVGElement child) throws SVGElementException {
		super.loaderAddChild(helper, child);
	}

	protected void build() throws SVGException {
		super.build();

		StyleAttribute sty = new StyleAttribute();

		String commandList = """";
		if (getPres(sty.setName(""d""))) {
			commandList = sty.getStringValue();
		}

		//If glyph path was specified, calculate it
		if (commandList != null) {
			String fillRule = getStyle(sty.setName(""fill-rule"")) ? sty.getStringValue() : ""nonzero"";

			PathCommand[] commands = parsePathList(commandList);

			GeneralPath buildPath = new GeneralPath(
					fillRule.equals(""evenodd"") ? GeneralPath.WIND_EVEN_ODD : GeneralPath.WIND_NON_ZERO,
					commands.length);

			BuildHistory hist = new BuildHistory();

			for (int i = 0; i < commands.length; i++) {
				PathCommand cmd = commands[i];
				cmd.appendPath(buildPath, hist);
			}

			//Reflect glyph path to put it in user coordinate system
			AffineTransform at = new AffineTransform();
			at.scale(1, -1);
			path = at.createTransformedShape(buildPath);
		}

		//Read glyph spacing info
		if (getPres(sty.setName(""horiz-adv-x""))) {
			horizAdvX = sty.getIntValue();
		}

		if (getPres(sty.setName(""vert-origin-x""))) {
			vertOriginX = sty.getIntValue();
		}

		if (getPres(sty.setName(""vert-origin-y""))) {
			vertOriginY = sty.getIntValue();
		}

		if (getPres(sty.setName(""vert-adv-y""))) {
			vertAdvY = sty.getIntValue();
		}
	}

	public Shape getPath() {
		return path;
	}

	public void render(Graphics2D g) throws SVGException {
		//Do not push or pop stack

		if (path != null) {
			renderShape(g, path);
		}

		for (SVGElement ele : getChildren()) {
			if (ele instanceof RenderableElement) {
				((RenderableElement) ele).render(g);
			}
		}

		//Do not push or pop stack
	}

	public int getHorizAdvX() {
		if (horizAdvX == -1) {
			horizAdvX = ((Font) parent).getHorizAdvX();
		}
		return horizAdvX;
	}

	public int getVertOriginX() {
		if (vertOriginX == -1) {
			vertOriginX = getHorizAdvX() / 2;
		}
		return vertOriginX;
	}

	public int getVertOriginY() {
		if (vertOriginY == -1) {
			vertOriginY = ((Font) parent).getFontFace().getAscent();
		}
		return vertOriginY;
	}

	public int getVertAdvY() {
		if (vertAdvY == -1) {
			vertAdvY = ((Font) parent).getFontFace().getUnitsPerEm();
		}
		return vertAdvY;

	}

	public Shape getShape() {
		if (path != null) {
			return shapeToParent(path);
		}
		return null;
	}

	public Rectangle2D getBoundingBox() throws SVGException {
		if (path != null) {
			return boundsToParent(includeStrokeInBounds(path.getBounds2D()));
		}
		return null;
	}

	/**
	 * Updates all attributes in this diagram associated with a time event. Ie,
	 * all attributes with track information.
	 *
	 * @return - true if this node has changed state as a result of the time
	 *         update
	 */
	public boolean updateTime(double curTime) throws SVGException {
		//Fonts can't change
		return false;
	}
}
"
package-info.java,kitfox-6.9.6,"/**
 * Provides the nodes of an SVG scene graph.  This graph can be queried, updated
 * and picked against at runtime.  See the online docs for instructions on
 * how to use SVGSalamander
 *
 * @author <a href=""mailto:kitfox@kitfox.com"">Mark McKay</a> (C) 2005
 */

package com.kitfox.svg;"
Path.java,kitfox-6.9.6,"/*
 * SVG Salamander Copyright (c) 2004, Mark McKay All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. - Redistributions in binary
 * form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided
 * with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Mark McKay can be contacted at mark@kitfox.com. Salamander and other projects
 * can be found at http://www.kitfox.com
 * 
 * Created on January 26, 2004, 5:25 PM
 */
package com.kitfox.svg;

import java.awt.BasicStroke;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.kitfox.svg.xml.StyleAttribute;

// import org.apache.batik.ext.awt.geom.ExtendedGeneralPath;
/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Path extends ShapeElement {

	public static final String TAG_NAME = ""path"";
	//    PathCommand[] commands = null;
	int fillRule = GeneralPath.WIND_NON_ZERO;
	String d = """";
	//    ExtendedGeneralPath path;
	GeneralPath path;

	/**
	 * Creates a new instance of Rect
	 */
	public Path() {
	}

	public String getTagName() {
		return TAG_NAME;
	}

	protected void build() throws SVGException {
		super.build();

		StyleAttribute sty = new StyleAttribute();

		String fillRuleStrn = (getStyle(sty.setName(""fill-rule""))) ? sty.getStringValue() : ""nonzero"";
		fillRule = fillRuleStrn.equals(""evenodd"") ? GeneralPath.WIND_EVEN_ODD : GeneralPath.WIND_NON_ZERO;

		if (getPres(sty.setName(""d""))) {
			d = sty.getStringValue();
		}

		path = buildPath(d, fillRule);
	}

	//inserted by Sander Leemans
	@Override
	void pick(Point2D point, boolean boundingBox, List retVec) throws SVGException {
		if (boundingBox) {
			//do nothing special, just call the super function
			super.pick(point, true, retVec);
			return;
		} else {
			//check whether we are on the stroke
			Shape strokeShape = getStrokeShape(new StyleAttribute(), getShape(), null);
			if (strokeShape.contains(point)) {
				//we are on the stroke; call super function to add stuff
				super.pick(point, true, retVec);
				return;
			}

			//check whether we are in the path
			GeneralPath closedPath = buildPath(closePath(d), fillRule);
			if (closedPath.contains(point)) {
				//delegate to super function to add stuff
				super.pick(point, true, retVec);
				return;
			}
		}
		return;
	}

	//inserted by Sander Leemans
	public Shape getStrokeShape(StyleAttribute styleAttrib, Shape shape, AffineTransform cacheXform)
			throws SVGException {

		float[] strokeDashArray = null;
		if (getStyle(styleAttrib.setName(""stroke-dasharray""))) {
			strokeDashArray = styleAttrib.getFloatList();
			if (strokeDashArray.length == 0)
				strokeDashArray = null;
		}

		float strokeDashOffset = 0f;
		if (getStyle(styleAttrib.setName(""stroke-dashoffset""))) {
			strokeDashOffset = styleAttrib.getFloatValueWithUnits();
		}

		int strokeLinecap = BasicStroke.CAP_BUTT;
		if (getStyle(styleAttrib.setName(""stroke-linecap""))) {
			String val = styleAttrib.getStringValue();
			if (val.equals(""round"")) {
				strokeLinecap = BasicStroke.CAP_ROUND;
			} else if (val.equals(""square"")) {
				strokeLinecap = BasicStroke.CAP_SQUARE;
			}
		}

		int strokeLinejoin = BasicStroke.JOIN_MITER;
		if (getStyle(styleAttrib.setName(""stroke-linejoin""))) {
			String val = styleAttrib.getStringValue();
			if (val.equals(""round"")) {
				strokeLinejoin = BasicStroke.JOIN_ROUND;
			} else if (val.equals(""bevel"")) {
				strokeLinejoin = BasicStroke.JOIN_BEVEL;
			}
		}

		float strokeMiterLimit = 4f;
		if (getStyle(styleAttrib.setName(""stroke-miterlimit""))) {
			strokeMiterLimit = Math.max(styleAttrib.getFloatValueWithUnits(), 1);
		}

		float strokeOpacity = 1;
		if (getStyle(styleAttrib.setName(""stroke-opacity""))) {
			strokeOpacity *= styleAttrib.getRatioValue();
		}

		if (strokeOpacity == 0f) {
			return null;
		}

		float strokeWidth = 1f;
		if (getStyle(styleAttrib.setName(""stroke-width""))) {
			strokeWidth = styleAttrib.getFloatValueWithUnits();
		}
		//        if (strokeWidthScalar != 1f)
		//        {
		strokeWidth *= strokeWidthScalar;
		//        }

		BasicStroke stroke;
		if (strokeDashArray == null) {
			StrokeCacheIndex index = new StrokeCacheIndex();
			index.strokeWidth = strokeWidth;
			index.strokeLinecap = strokeLinecap;
			index.strokeLinejoin = strokeLinejoin;
			index.strokeMiterLimit = strokeMiterLimit;
			index.strokeDashArray = null;
			index.strokeDashOffset = Float.MIN_VALUE;
			stroke = strokeCache.get(index);
			if (stroke == null) {
				stroke = new BasicStroke(strokeWidth, strokeLinecap, strokeLinejoin, strokeMiterLimit);
				strokeCache.put(index, stroke);
			}
		} else {
			StrokeCacheIndex index = new StrokeCacheIndex();
			index.strokeWidth = strokeWidth;
			index.strokeLinecap = strokeLinecap;
			index.strokeLinejoin = strokeLinejoin;
			index.strokeMiterLimit = strokeMiterLimit;
			index.strokeDashArray = strokeDashArray;
			index.strokeDashOffset = strokeDashOffset;
			stroke = strokeCache.get(index);
			if (stroke == null) {
				stroke = new BasicStroke(strokeWidth, strokeLinecap, strokeLinejoin, strokeMiterLimit, strokeDashArray,
						strokeDashOffset);
				strokeCache.put(index, stroke);
			}
		}

		Shape strokeShape;
		if (vectorEffect == VECTOR_EFFECT_NON_SCALING_STROKE) {
			strokeShape = cacheXform.createTransformedShape(shape);
			strokeShape = stroke.createStrokedShape(strokeShape);
		} else {
			strokeShape = stroke.createStrokedShape(shape);
		}

		return strokeShape;
	}

	private static final Pattern pattern = Pattern.compile(""-?(\\d*\\.)?\\d+,-?(\\d*\\.)?\\d+"");

	public static String closePath(String path) {

		//get the points from the path
		Matcher matcher = pattern.matcher(path);

		List<String> points = new ArrayList<String>();
		while (matcher.find()) {
			points.add(matcher.group());
		}

		if (path.toLowerCase().endsWith(""z"")) {
			//the path is already closed; return the original path
			return path;
		} else if (points.get(0).equals(points.get(points.size() - 1))) {
			//the path begins and ends at the same points; it is already closed; return the original path
			return path;
		}

		//reverse the list of points
		Collections.reverse(points);

		//output as a new path
		StringBuilder result = new StringBuilder();
		Iterator<String> it = points.iterator();

		result.append(""L"");
		result.append(it.next());

		try {
			while (it.hasNext()) {
				result.append(""C"");
				result.append(it.next());
				result.append("" "");
				result.append(it.next());
				result.append("" "");
				result.append(it.next());
			}
		} catch (NoSuchElementException e) {
			return path;
		}

		return path + result.toString();
	}

	public void render(Graphics2D g) throws SVGException {
		beginLayer(g);
		renderShape(g, path);
		finishLayer(g);
	}

	public Shape getShape() {
		return shapeToParent(path);
	}

	public Rectangle2D getBoundingBox() throws SVGException {
		return boundsToParent(includeStrokeInBounds(path.getBounds2D()));
	}

	/**
	 * Updates all attributes in this diagram associated with a time event. Ie,
	 * all attributes with track information.
	 *
	 * @return - true if this node has changed state as a result of the time
	 *         update
	 */
	public boolean updateTime(double curTime) throws SVGException {
		//        if (trackManager.getNumTracks() == 0) return false;
		boolean changeState = super.updateTime(curTime);

		//Get current values for parameters
		StyleAttribute sty = new StyleAttribute();
		boolean shapeChange = false;

		if (getStyle(sty.setName(""fill-rule""))) {
			int newVal = sty.getStringValue().equals(""evenodd"") ? GeneralPath.WIND_EVEN_ODD : GeneralPath.WIND_NON_ZERO;
			if (newVal != fillRule) {
				fillRule = newVal;
				changeState = true;
			}
		}

		if (getPres(sty.setName(""d""))) {
			String newVal = sty.getStringValue();
			if (!newVal.equals(d)) {
				d = newVal;
				shapeChange = true;
			}
		}

		if (shapeChange) {
			build();
			//            path = buildPath(d, fillRule);
			//            return true;
		}

		return changeState || shapeChange;
	}
}
"
Arc.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 8:40 PM
 */

package com.kitfox.svg.pathcmd;

//import org.apache.batik.ext.awt.geom.ExtendedGeneralPath;
import java.awt.*;
import java.awt.geom.*;

/**
 * This is a little used SVG function, as most editors will save curves as 
 * Beziers.  To reduce the need to rely on the Batik library, this functionallity
 * is being bypassed for the time being.  In the future, it would be nice to
 * extend the GeneralPath command to include the arcTo ability provided by Batik.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Arc extends PathCommand 
{

    public float rx = 0f;
    public float ry = 0f;
    public float xAxisRot = 0f;
    public boolean largeArc = false;
    public boolean sweep = false;
    public float x = 0f;
    public float y = 0f;

    /** Creates a new instance of MoveTo */
    public Arc() {
    }

    public Arc(boolean isRelative, float rx, float ry, float xAxisRot, boolean largeArc, boolean sweep, float x, float y) {
        super(isRelative);
        this.rx = rx;
        this.ry = ry;
        this.xAxisRot = xAxisRot;
        this.largeArc = largeArc;
        this.sweep = sweep;
        this.x = x;
        this.y = y;
    }

//    public void appendPath(ExtendedGeneralPath path, BuildHistory hist)
    public void appendPath(GeneralPath path, BuildHistory hist)
    {
        float offx = isRelative ? hist.lastPoint.x : 0f;
        float offy = isRelative ? hist.lastPoint.y : 0f;

        arcTo(path, rx, ry, xAxisRot, largeArc, sweep,
            x + offx, y + offy,
            hist.lastPoint.x, hist.lastPoint.y);
//        path.lineTo(x + offx, y + offy);
//        hist.setPoint(x + offx, y + offy);
        hist.setLastPoint(x + offx, y + offy);
        hist.setLastKnot(x + offx, y + offy);
    }

    public int getNumKnotsAdded()
    {
        return 6;
    }

    /**
     * Adds an elliptical arc, defined by two radii, an angle from the
     * x-axis, a flag to choose the large arc or not, a flag to
     * indicate if we increase or decrease the angles and the final
     * point of the arc.
     *
     * @param rx the x radius of the ellipse
     * @param ry the y radius of the ellipse
     *
     * @param angle the angle from the x-axis of the current
     * coordinate system to the x-axis of the ellipse in degrees.
     *
     * @param largeArcFlag the large arc flag. If true the arc
     * spanning less than or equal to 180 degrees is chosen, otherwise
     * the arc spanning greater than 180 degrees is chosen
     *
     * @param sweepFlag the sweep flag. If true the line joining
     * center to arc sweeps through decreasing angles otherwise it
     * sweeps through increasing angles
     *
     * @param x the absolute x coordinate of the final point of the arc.
     * @param y the absolute y coordinate of the final point of the arc.
     * @param x0 - The absolute x coordinate of the initial point of the arc.
     * @param y0 - The absolute y coordinate of the initial point of the arc.
     */
    public void arcTo(GeneralPath path, float rx, float ry,
                                   float angle,
                                   boolean largeArcFlag,
                                   boolean sweepFlag,
                                   float x, float y, float x0, float y0) 
    {

        // Ensure radii are valid
        if (rx == 0 || ry == 0) {
            path.lineTo((float) x, (float) y);
            return;
        }

        if (x0 == x && y0 == y) {
            // If the endpoints (x, y) and (x0, y0) are identical, then this
            // is equivalent to omitting the elliptical arc segment entirely.
            return;
        }

        Arc2D arc = computeArc(x0, y0, rx, ry, angle, 
                               largeArcFlag, sweepFlag, x, y);
        if (arc == null) return;

        AffineTransform t = AffineTransform.getRotateInstance
            (Math.toRadians(angle), arc.getCenterX(), arc.getCenterY());
        Shape s = t.createTransformedShape(arc);
        path.append(s, true);
    }


    /** 
     * This constructs an unrotated Arc2D from the SVG specification of an 
     * Elliptical arc.  To get the final arc you need to apply a rotation
     * transform such as:
     * 
     * AffineTransform.getRotateInstance
     *     (angle, arc.getX()+arc.getWidth()/2, arc.getY()+arc.getHeight()/2);
     */
    public static Arc2D computeArc(double x0, double y0,
                                   double rx, double ry,
                                   double angle,
                                   boolean largeArcFlag,
                                   boolean sweepFlag,
                                   double x, double y) {
        //
        // Elliptical arc implementation based on the SVG specification notes
        //

        // Compute the half distance between the current and the final point
        double dx2 = (x0 - x) / 2.0;
        double dy2 = (y0 - y) / 2.0;
        // Convert angle from degrees to radians
        angle = Math.toRadians(angle % 360.0);
        double cosAngle = Math.cos(angle);
        double sinAngle = Math.sin(angle);

        //
        // Step 1 : Compute (x1, y1)
        //
        double x1 = (cosAngle * dx2 + sinAngle * dy2);
        double y1 = (-sinAngle * dx2 + cosAngle * dy2);
        // Ensure radii are large enough
        rx = Math.abs(rx);
        ry = Math.abs(ry);
        double Prx = rx * rx;
        double Pry = ry * ry;
        double Px1 = x1 * x1;
        double Py1 = y1 * y1;
        // check that radii are large enough
        double radiiCheck = Px1/Prx + Py1/Pry;
        if (radiiCheck > 1) {
            rx = Math.sqrt(radiiCheck) * rx;
            ry = Math.sqrt(radiiCheck) * ry;
            Prx = rx * rx;
            Pry = ry * ry;
        }

        //
        // Step 2 : Compute (cx1, cy1)
        //
        double sign = (largeArcFlag == sweepFlag) ? -1 : 1;
        double sq = ((Prx*Pry)-(Prx*Py1)-(Pry*Px1)) / ((Prx*Py1)+(Pry*Px1));
        sq = (sq < 0) ? 0 : sq;
        double coef = (sign * Math.sqrt(sq));
        double cx1 = coef * ((rx * y1) / ry);
        double cy1 = coef * -((ry * x1) / rx);

        //
        // Step 3 : Compute (cx, cy) from (cx1, cy1)
        //
        double sx2 = (x0 + x) / 2.0;
        double sy2 = (y0 + y) / 2.0;
        double cx = sx2 + (cosAngle * cx1 - sinAngle * cy1);
        double cy = sy2 + (sinAngle * cx1 + cosAngle * cy1);

        //
        // Step 4 : Compute the angleStart (angle1) and the angleExtent (dangle)
        //
        double ux = (x1 - cx1) / rx;
        double uy = (y1 - cy1) / ry;
        double vx = (-x1 - cx1) / rx;
        double vy = (-y1 - cy1) / ry;
        double p, n;
        // Compute the angle start
        n = Math.sqrt((ux * ux) + (uy * uy));
        p = ux; // (1 * ux) + (0 * uy)
        sign = (uy < 0) ? -1d : 1d;
        double angleStart = Math.toDegrees(sign * Math.acos(p / n));

        // Compute the angle extent
        n = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));
        p = ux * vx + uy * vy;
        sign = (ux * vy - uy * vx < 0) ? -1d : 1d;
        double angleExtent = Math.toDegrees(sign * Math.acos(p / n));
        if(!sweepFlag && angleExtent > 0) {
            angleExtent -= 360f;
        } else if (sweepFlag && angleExtent < 0) {
            angleExtent += 360f;
        }
        angleExtent %= 360f;
        angleStart %= 360f;

        //
        // We can now build the resulting Arc2D in double precision
        //
        Arc2D.Double arc = new Arc2D.Double();
        arc.x = cx - rx;
        arc.y = cy - ry;
        arc.width = rx * 2.0;
        arc.height = ry * 2.0;
        arc.start = -angleStart;
        arc.extent = -angleExtent;

        return arc;
    }

    public String toString()
    {
        return ""A "" + rx + "" "" + ry
             + "" "" + xAxisRot + "" "" + largeArc
             + "" "" + sweep
             + "" "" + x + "" "" + y;
    }
}
"
BuildHistory.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 9:18 PM
 */
package com.kitfox.svg.pathcmd;

import java.awt.geom.Point2D;

/**
 * When building a path from command segments, most need to cache information
 * (such as the point finished at) for future commands. This structure allows
 * that
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class BuildHistory
{

//    Point2D.Float[] history = new Point2D.Float[2];
//    Point2D.Float[] history = {new Point2D.Float(), new Point2D.Float()};
//    Point2D.Float start = new Point2D.Float();
    Point2D.Float startPoint = new Point2D.Float();
    Point2D.Float lastPoint = new Point2D.Float();
    Point2D.Float lastKnot = new Point2D.Float();
    boolean init;
    //int length = 0;

    /**
     * Creates a new instance of BuildHistory
     */
    public BuildHistory()
    {
    }
    
    public void setStartPoint(float x, float y)
    {
        startPoint.setLocation(x, y);
    }
    
    public void setLastPoint(float x, float y)
    {
        lastPoint.setLocation(x, y);
    }
    
    public void setLastKnot(float x, float y)
    {
        lastKnot.setLocation(x, y);
    }
//    public void setPoint(float x, float y)
//    {
//        history[0].setLocation(x, y);
//        length = 1;
//    }
//    public void setStart(float x, float y)
//    {
//        start.setLocation(x, y);
//    }
//    public void setPointAndKnot(float x, float y, float kx, float ky)
//    {
//        history[0].setLocation(x, y);
//        history[1].setLocation(kx, ky);
//        length = 2;
//    }
}
"
Cubic.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 8:40 PM
 */

package com.kitfox.svg.pathcmd;

//import org.apache.batik.ext.awt.geom.ExtendedGeneralPath;
import java.awt.geom.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Cubic extends PathCommand {

    public float k1x = 0f;
    public float k1y = 0f;
    public float k2x = 0f;
    public float k2y = 0f;
    public float x = 0f;
    public float y = 0f;

    /** Creates a new instance of MoveTo */
    public Cubic() {
    }

    public String toString()
    {
        return ""C "" + k1x + "" "" + k1y
             + "" "" + k2x + "" "" + k2y
             + "" "" + x + "" "" + y;
    }

    public Cubic(boolean isRelative, float k1x, float k1y, float k2x, float k2y, float x, float y) {
        super(isRelative);
        this.k1x = k1x;
        this.k1y = k1y;
        this.k2x = k2x;
        this.k2y = k2y;
        this.x = x;
        this.y = y;
    }

//    public void appendPath(ExtendedGeneralPath path, BuildHistory hist)
    public void appendPath(GeneralPath path, BuildHistory hist)
    {
        float offx = isRelative ? hist.lastPoint.x : 0f;
        float offy = isRelative ? hist.lastPoint.y : 0f;

        path.curveTo(k1x + offx, k1y + offy,
            k2x + offx, k2y + offy, 
            x + offx, y + offy);
//        hist.setPointAndKnot(x + offx, y + offy, k2x + offx, k2y + offy);
        hist.setLastPoint(x + offx, y + offy);
        hist.setLastKnot(k2x + offx, k2y + offy);
    }

    public int getNumKnotsAdded()
    {
        return 6;
    }
}
"
CubicSmooth.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 8:40 PM
 */

package com.kitfox.svg.pathcmd;

//import org.apache.batik.ext.awt.geom.ExtendedGeneralPath;
import java.awt.geom.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class CubicSmooth extends PathCommand {

    public float x = 0f;
    public float y = 0f;
    public float k2x = 0f;
    public float k2y = 0f;

    /** Creates a new instance of MoveTo */
    public CubicSmooth() {
    }

    public CubicSmooth(boolean isRelative, float k2x, float k2y, float x, float y) {
        super(isRelative);
        this.k2x = k2x;
        this.k2y = k2y;
        this.x = x;
        this.y = y;
    }

//    public void appendPath(ExtendedGeneralPath path, BuildHistory hist)
    public void appendPath(GeneralPath path, BuildHistory hist)
    {
        float offx = isRelative ? hist.lastPoint.x : 0f;
        float offy = isRelative ? hist.lastPoint.y : 0f;

        float oldKx = hist.lastKnot.x;
        float oldKy = hist.lastKnot.y;
        float oldX = hist.lastPoint.x;
        float oldY = hist.lastPoint.y;
        //Calc knot as reflection of old knot
        float k1x = oldX * 2f - oldKx;
        float k1y = oldY * 2f - oldKy;

        path.curveTo(k1x, k1y, k2x + offx, k2y + offy, x + offx, y + offy);
        hist.setLastPoint(x + offx, y + offy);
        hist.setLastKnot(k2x + offx, k2y + offy);
    }
    
    public int getNumKnotsAdded()
    {
        return 6;
    }

    public String toString()
    {
        return ""S "" + k2x + "" "" + k2y
             + "" "" + x + "" "" + y;
    }
}
"
Horizontal.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 8:40 PM
 */

package com.kitfox.svg.pathcmd;

//import org.apache.batik.ext.awt.geom.ExtendedGeneralPath;
import java.awt.geom.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Horizontal extends PathCommand {

    public float x = 0f;

    /** Creates a new instance of MoveTo */
    public Horizontal() {
    }

    public String toString()
    {
        return ""H "" + x;
    }

    public Horizontal(boolean isRelative, float x) {
        super(isRelative);
        this.x = x;
    }


//    public void appendPath(ExtendedGeneralPath path, BuildHistory hist)
    public void appendPath(GeneralPath path, BuildHistory hist)
    {
        float offx = isRelative ? hist.lastPoint.x : 0f;
        float offy = hist.lastPoint.y;

        path.lineTo(x + offx, offy);
        hist.setLastPoint(x + offx, offy);
        hist.setLastKnot(x + offx, offy);
    }
    
    public int getNumKnotsAdded()
    {
        return 2;
    }
}
"
LineTo.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 8:40 PM
 */

package com.kitfox.svg.pathcmd;

//import org.apache.batik.ext.awt.geom.ExtendedGeneralPath;
import java.awt.geom.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class LineTo extends PathCommand {

    public float x = 0f;
    public float y = 0f;

    /** Creates a new instance of MoveTo */
    public LineTo() {
    }

    public LineTo(boolean isRelative, float x, float y) {
        super(isRelative);
        this.x = x;
        this.y = y;
    }


//    public void appendPath(ExtendedGeneralPath path, BuildHistory hist)
    public void appendPath(GeneralPath path, BuildHistory hist)
    {
        float offx = isRelative ? hist.lastPoint.x : 0f;
        float offy = isRelative ? hist.lastPoint.y : 0f;

        path.lineTo(x + offx, y + offy);
        hist.setLastPoint(x + offx, y + offy);
        hist.setLastKnot(x + offx, y + offy);
    }
    
    public int getNumKnotsAdded()
    {
        return 2;
    }

    public String toString()
    {
        return ""L "" + x + "" "" + y;
    }
}
"
MoveTo.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 8:40 PM
 */

package com.kitfox.svg.pathcmd;

//import org.apache.batik.ext.awt.geom.ExtendedGeneralPath;
import java.awt.geom.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class MoveTo extends PathCommand {

    public float x = 0f;
    public float y = 0f;

    /** Creates a new instance of MoveTo */
    public MoveTo() {
    }

    public MoveTo(boolean isRelative, float x, float y) {
        super(isRelative);
        this.x = x;
        this.y = y;
    }

//    public void appendPath(ExtendedGeneralPath path, BuildHistory hist)
    public void appendPath(GeneralPath path, BuildHistory hist)
    {
        float offx = isRelative ? hist.lastPoint.x : 0f;
        float offy = isRelative ? hist.lastPoint.y : 0f;

        path.moveTo(x + offx, y + offy);
        hist.setStartPoint(x + offx, y + offy);
        hist.setLastPoint(x + offx, y + offy);
        hist.setLastKnot(x + offx, y + offy);
    }

    public int getNumKnotsAdded()
    {
        return 2;
    }

    public String toString()
    {
        return ""M "" + x + "" "" + y;
    }
    
    
}
"
PathCommand.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 8:39 PM
 */

package com.kitfox.svg.pathcmd;

//import org.apache.batik.ext.awt.geom.ExtendedGeneralPath;
import java.awt.geom.*;

/**
 * This is the element of a path and contains instructions for rendering a
 * portion of the path
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
abstract public class PathCommand {

    public boolean isRelative = false;

    /** Creates a new instance of PathCommand */
    public PathCommand() {
    }

    public PathCommand(boolean isRelative) {
        this.isRelative = isRelative;
    }

//    abstract public void appendPath(ExtendedGeneralPath path, BuildHistory hist);
    abstract public void appendPath(GeneralPath path, BuildHistory hist);

    abstract public int getNumKnotsAdded();
}
"
PathUtil.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on May 10, 2005, 5:56 AM
 */

package com.kitfox.svg.pathcmd;

import java.awt.geom.*;

/**
 *
 * @author kitfox
 */
public class PathUtil
{
    
    /** Creates a new instance of PathUtil */
    public PathUtil()
    {
    }
    
    /**
     * Converts a GeneralPath into an SVG representation
     */
    public static String buildPathString(GeneralPath path)
    {
        float[] coords = new float[6];
        
        StringBuffer sb = new StringBuffer();
        
        for (PathIterator pathIt = path.getPathIterator(new AffineTransform()); !pathIt.isDone(); pathIt.next())
        {
            int segId = pathIt.currentSegment(coords);
            
            switch (segId)
            {
                case PathIterator.SEG_CLOSE:
                {
                    sb.append("" Z"");
                    break;
                }
                case PathIterator.SEG_CUBICTO:
                {
                    sb.append("" C "" + coords[0] + "" "" + coords[1] + "" "" + coords[2] + "" "" + coords[3] + "" "" + coords[4] + "" "" + coords[5]);
                    break;
                }
                case PathIterator.SEG_LINETO:
                {
                    sb.append("" L "" + coords[0] + "" "" + coords[1]);
                    break;
                }
                case PathIterator.SEG_MOVETO:
                {
                    sb.append("" M "" + coords[0] + "" "" + coords[1]);
                    break;
                }
                case PathIterator.SEG_QUADTO:
                {
                    sb.append("" Q "" + coords[0] + "" "" + coords[1] + "" "" + coords[2] + "" "" + coords[3]);
                    break;
                }
            }
        }
        
        return sb.toString();
    }
}
"
Quadratic.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 8:40 PM
 */

package com.kitfox.svg.pathcmd;

//import org.apache.batik.ext.awt.geom.ExtendedGeneralPath;
import java.awt.geom.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Quadratic extends PathCommand {

    public float kx = 0f;
    public float ky = 0f;
    public float x = 0f;
    public float y = 0f;

    /** Creates a new instance of MoveTo */
    public Quadratic() {
    }

    public String toString()
    {
        return ""Q "" + kx + "" "" + ky
             + "" "" + x + "" "" + y;
    }

    public Quadratic(boolean isRelative, float kx, float ky, float x, float y) {
        super(isRelative);
        this.kx = kx;
        this.ky = ky;
        this.x = x;
        this.y = y;
    }

//    public void appendPath(ExtendedGeneralPath path, BuildHistory hist)
    public void appendPath(GeneralPath path, BuildHistory hist)
    {
        float offx = isRelative ? hist.lastPoint.x : 0f;
        float offy = isRelative ? hist.lastPoint.y : 0f;

        path.quadTo(kx + offx, ky + offy, x + offx, y + offy);
        hist.setLastPoint(x + offx, y + offy);
        hist.setLastKnot(kx + offx, ky + offy);
    }

    public int getNumKnotsAdded()
    {
        return 4;
    }
}
"
QuadraticSmooth.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 8:40 PM
 */

package com.kitfox.svg.pathcmd;

//import org.apache.batik.ext.awt.geom.ExtendedGeneralPath;
import java.awt.geom.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class QuadraticSmooth extends PathCommand {

    public float x = 0f;
    public float y = 0f;

    /** Creates a new instance of MoveTo */
    public QuadraticSmooth() {
    }

    public String toString()
    {
        return ""T "" + x + "" "" + y;
    }

    public QuadraticSmooth(boolean isRelative, float x, float y) {
        super(isRelative);
        this.x = x;
        this.y = y;
    }

//    public void appendPath(ExtendedGeneralPath path, BuildHistory hist)
    public void appendPath(GeneralPath path, BuildHistory hist)
    {
        float offx = isRelative ? hist.lastPoint.x : 0f;
        float offy = isRelative ? hist.lastPoint.y : 0f;

        float oldKx = hist.lastKnot.x;
        float oldKy = hist.lastKnot.y;
        float oldX = hist.lastPoint.x;
        float oldY = hist.lastPoint.y;
        //Calc knot as reflection of old knot
        float kx = oldX * 2f - oldKx;
        float ky = oldY * 2f - oldKy;

        path.quadTo(kx, ky, x + offx, y + offy);
        hist.setLastPoint(x + offx, y + offy);
        hist.setLastKnot(kx, ky);
    }

    public int getNumKnotsAdded()
    {
        return 4;
    }
}
"
Terminal.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 8:40 PM
 */

package com.kitfox.svg.pathcmd;

//import org.apache.batik.ext.awt.geom.ExtendedGeneralPath;
import java.awt.geom.*;

/**
 * Finishes a path
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Terminal extends PathCommand {

    /** Creates a new instance of MoveTo */
    public Terminal() {
    }

    public String toString()
    {
        return ""Z"";
    }


//    public void appendPath(ExtendedGeneralPath path, BuildHistory hist)
    public void appendPath(GeneralPath path, BuildHistory hist)
    {
        path.closePath();
        hist.setLastPoint(hist.startPoint.x, hist.startPoint.y);
        hist.setLastKnot(hist.startPoint.x, hist.startPoint.y);
    }
    
    public int getNumKnotsAdded()
    {
        return 0;
    }
}
"
Vertical.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 8:40 PM
 */

package com.kitfox.svg.pathcmd;

//import org.apache.batik.ext.awt.geom.ExtendedGeneralPath;
import java.awt.geom.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Vertical extends PathCommand {

    public float y = 0f;

    /** Creates a new instance of MoveTo */
    public Vertical() {
    }

    public String toString()
    {
        return ""V "" + y;
    }

    public Vertical(boolean isRelative, float y) {
        super(isRelative);
        this.y = y;
    }

//    public void appendPath(ExtendedGeneralPath path, BuildHistory hist)
    public void appendPath(GeneralPath path, BuildHistory hist)
    {
        float offx = hist.lastPoint.x;
        float offy = isRelative ? hist.lastPoint.y : 0f;

        path.lineTo(offx, y + offy);
        hist.setLastPoint(offx, y + offy);
        hist.setLastKnot(offx, y + offy);
    }

    public int getNumKnotsAdded()
    {
        return 2;
    }
}
"
PatternPaint.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on April 1, 2004, 3:37 AM
 */

package com.kitfox.svg.pattern;

import java.awt.*;
import java.awt.geom.*;
import java.awt.image.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class PatternPaint implements Paint
{
    BufferedImage source;  //Image we're rendering from
    AffineTransform xform;

    /** Creates a new instance of PatternPaint */
    public PatternPaint(BufferedImage source, AffineTransform xform)
    {
        this.source = source;
        this.xform = xform;
    }

    public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)
    {
        return new PatternPaintContext(source, deviceBounds, xform, this.xform);
    }

    public int getTransparency()
    {
        return source.getColorModel().getTransparency();
    }

}
"
PatternPaintContext.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on April 1, 2004, 3:37 AM
 */

package com.kitfox.svg.pattern;

import com.kitfox.svg.SVGConst;
import java.awt.*;
import java.awt.geom.*;
import java.awt.image.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class PatternPaintContext implements PaintContext
{
    BufferedImage source;  //Image we're rendering from
    Rectangle deviceBounds;  //int size of rectangle we're rendering to
//    AffineTransform userXform;  //xform from user space to device space
//    AffineTransform distortXform;  //distortion applied to this pattern

    AffineTransform xform;  //distortion applied to this pattern

    int sourceWidth;
    int sourceHeight;

    //Raster we use to build tile
    BufferedImage buf;

    /** Creates a new instance of PatternPaintContext */
    public PatternPaintContext(BufferedImage source, Rectangle deviceBounds, AffineTransform userXform, AffineTransform distortXform)
    {
//System.err.println(""Bounds "" + deviceBounds);
        this.source = source;
        this.deviceBounds = deviceBounds;
        try {
//            this.distortXform = distortXform.createInverse();
//            this.userXform = userXform.createInverse();

//            xform = userXform.createInverse();
//            xform.concatenate(distortXform.createInverse());
            xform = distortXform.createInverse();
            xform.concatenate(userXform.createInverse());
        }
        catch (Exception e) 
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
        }

        sourceWidth = source.getWidth();
        sourceHeight = source.getHeight();
    }

    public void dispose() {
    }

    public ColorModel getColorModel() {
        return source.getColorModel();
    }

    public Raster getRaster(int x, int y, int w, int h)
    {
//System.err.println("""" + x + "", "" + y + "", "" + w + "", "" + h);
        if (buf == null || buf.getWidth() != w || buf.getHeight() != buf.getHeight())
        {
            buf = new BufferedImage(w, h, source.getType());
        }

//        Point2D.Float srcPt = new Point2D.Float(), srcPt2 = new Point2D.Float(), destPt = new Point2D.Float();
        Point2D.Float srcPt = new Point2D.Float(), destPt = new Point2D.Float();
        for (int j = 0; j < h; j++)
        {
            for (int i = 0; i < w; i++)
            {
                destPt.setLocation(i + x, j + y);

                xform.transform(destPt, srcPt);

//                userXform.transform(destPt, srcPt2);
//                distortXform.transform(srcPt2, srcPt);

                int ii = ((int)srcPt.x) % sourceWidth;
                if (ii < 0) ii += sourceWidth;
                int jj = ((int)srcPt.y) % sourceHeight;
                if (jj < 0) jj += sourceHeight;

                buf.setRGB(i, j, source.getRGB(ii, jj));
            }
        }

        return buf.getData();
    }

    public static void main(String[] argv)
    {
        int i = -4;
        System.err.println(""Hello "" + (i % 4));
    }

}
"
PatternSVG.java,kitfox-6.9.6,"/*
 * SVG Salamander Copyright (c) 2004, Mark McKay All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. - Redistributions in binary
 * form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided
 * with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Mark McKay can be contacted at mark@kitfox.com. Salamander and other projects
 * can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 3:25 AM
 */
package com.kitfox.svg;

import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.RenderingHints;
import java.awt.TexturePaint;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.net.URI;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.kitfox.svg.pattern.PatternPaint;
import com.kitfox.svg.xml.StyleAttribute;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class PatternSVG extends FillElement {
	public static final String TAG_NAME = ""pattern"";

	public static final int GU_OBJECT_BOUNDING_BOX = 0;
	public static final int GU_USER_SPACE_ON_USE = 1;
	int gradientUnits = GU_OBJECT_BOUNDING_BOX;
	float x;
	float y;
	float width;
	float height;
	AffineTransform patternXform = new AffineTransform();
	Rectangle2D.Float viewBox;
	Paint texPaint;

	/**
	 * Creates a new instance of Gradient
	 */
	public PatternSVG() {
	}

	public String getTagName() {
		return TAG_NAME;
	}

	/**
	 * Called after the start element but before the end element to indicate
	 * each child tag that has been processed
	 */
	public void loaderAddChild(SVGLoaderHelper helper, SVGElement child) throws SVGElementException {
		super.loaderAddChild(helper, child);
	}

	protected void build() throws SVGException {
		super.build();

		StyleAttribute sty = new StyleAttribute();

		//Load style string
		String href = null;
		if (getPres(sty.setName(""xlink:href""))) {
			href = sty.getStringValue();
		}
		//String href = attrs.getValue(""xlink:href"");
		//If we have a link to another pattern, initialize ourselves with it's values
		if (href != null) {
			//System.err.println(""Gradient.loaderStartElement() href '"" + href + ""'"");
			try {
				URI src = getXMLBase().resolve(href);
				PatternSVG patSrc = (PatternSVG) diagram.getUniverse().getElement(src);

				gradientUnits = patSrc.gradientUnits;
				x = patSrc.x;
				y = patSrc.y;
				width = patSrc.width;
				height = patSrc.height;
				viewBox = patSrc.viewBox;
				patternXform.setTransform(patSrc.patternXform);
				addChildren(patSrc.getChildren());
			} catch (Exception e) {
				Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, ""Could not parse xlink:href"", e);
			}
		}

		String gradientUnits = """";
		if (getPres(sty.setName(""gradientUnits""))) {
			gradientUnits = sty.getStringValue().toLowerCase();
		}
		if (gradientUnits.equals(""userspaceonuse"")) {
			this.gradientUnits = GU_USER_SPACE_ON_USE;
		} else {
			this.gradientUnits = GU_OBJECT_BOUNDING_BOX;
		}

		String patternTransform = """";
		if (getPres(sty.setName(""patternTransform""))) {
			patternTransform = sty.getStringValue();
		}
		patternXform = parseTransform(patternTransform);

		if (getPres(sty.setName(""x""))) {
			x = sty.getFloatValueWithUnits();
		}

		if (getPres(sty.setName(""y""))) {
			y = sty.getFloatValueWithUnits();
		}

		if (getPres(sty.setName(""width""))) {
			width = sty.getFloatValueWithUnits();
		}

		if (getPres(sty.setName(""height""))) {
			height = sty.getFloatValueWithUnits();
		}

		if (getPres(sty.setName(""viewBox""))) {
			float[] dim = sty.getFloatList();
			viewBox = new Rectangle2D.Float(dim[0], dim[1], dim[2], dim[3]);
		}

		preparePattern();
	}

	/*
	 * public void loaderEndElement(SVGLoaderHelper helper) { build(); }
	 */
	protected void preparePattern() throws SVGException {
		//For now, treat all fills as UserSpaceOnUse.  Otherwise, we'll need
		// a different paint for every object.
		int tileWidth = (int) width;
		int tileHeight = (int) height;

		float stretchX = 1f, stretchY = 1f;
		if (!patternXform.isIdentity()) {
			//Scale our source tile so that we can have nice sampling from it.
			float xlateX = (float) patternXform.getTranslateX();
			float xlateY = (float) patternXform.getTranslateY();

			Point2D.Float pt = new Point2D.Float(), pt2 = new Point2D.Float();

			pt.setLocation(width, 0);
			patternXform.transform(pt, pt2);
			pt2.x -= xlateX;
			pt2.y -= xlateY;
			stretchX = (float) Math.sqrt(pt2.x * pt2.x + pt2.y * pt2.y) * 1.5f / width;

			pt.setLocation(height, 0);
			patternXform.transform(pt, pt2);
			pt2.x -= xlateX;
			pt2.y -= xlateY;
			stretchY = (float) Math.sqrt(pt2.x * pt2.x + pt2.y * pt2.y) * 1.5f / height;

			tileWidth *= stretchX;
			tileHeight *= stretchY;
		}

		if (tileWidth == 0 || tileHeight == 0) {
			//Use defaults if tile has degenerate size
			return;
		}

		BufferedImage buf = new BufferedImage(tileWidth, tileHeight, BufferedImage.TYPE_INT_ARGB);
		Graphics2D g = buf.createGraphics();
		g.setClip(0, 0, tileWidth, tileHeight);
		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

		for (SVGElement ele : getChildren()) {
			if (ele instanceof RenderableElement) {
				AffineTransform xform = new AffineTransform();

				if (viewBox == null) {
					xform.translate(-x, -y);
				} else {
					xform.scale(tileWidth / viewBox.width, tileHeight / viewBox.height);
					xform.translate(-viewBox.x, -viewBox.y);
				}

				g.setTransform(xform);
				((RenderableElement) ele).render(g);
			}
		}

		g.dispose();

		//try {
		//javax.imageio.ImageIO.write(buf, ""png"", new java.io.File(""c:\\tmp\\texPaint.png""));
		//} catch (Exception e ) {}

		if (patternXform.isIdentity()) {
			texPaint = new TexturePaint(buf, new Rectangle2D.Float(x, y, width, height));
		} else {
			patternXform.scale(1 / stretchX, 1 / stretchY);
			texPaint = new PatternPaint(buf, patternXform);
		}
	}

	public Paint getPaint(Rectangle2D bounds, AffineTransform xform) {
		return texPaint;
	}

	/**
	 * Updates all attributes in this diagram associated with a time event. Ie,
	 * all attributes with track information.
	 *
	 * @return - true if this node has changed state as a result of the time
	 *         update
	 */
	public boolean updateTime(double curTime) throws SVGException {
		//Patterns don't change state
		return false;
	}
}
"
Polygon.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 5:25 PM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import com.kitfox.svg.xml.XMLParseUtil;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Polygon extends ShapeElement
{
    public static final String TAG_NAME = ""polygon"";

    int fillRule = GeneralPath.WIND_NON_ZERO;
    String pointsStrn = """";
    GeneralPath path;

    /**
     * Creates a new instance of Rect
     */
    public Polygon()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""points"")))
        {
            pointsStrn = sty.getStringValue();
        }

        String fillRuleStrn = getStyle(sty.setName(""fill-rule"")) ? sty.getStringValue() : ""nonzero"";
        fillRule = fillRuleStrn.equals(""evenodd"") ? GeneralPath.WIND_EVEN_ODD : GeneralPath.WIND_NON_ZERO;

        buildPath();
    }

    protected void buildPath()
    {
        float[] points = XMLParseUtil.parseFloatList(pointsStrn);
        path = new GeneralPath(fillRule, points.length / 2);

        path.moveTo(points[0], points[1]);
        for (int i = 2; i < points.length; i += 2)
        {
            path.lineTo(points[i], points[i + 1]);
        }
        path.closePath();
    }

    public void render(Graphics2D g) throws SVGException
    {
        beginLayer(g);
        renderShape(g, path);
        finishLayer(g);
    }

    public Shape getShape()
    {
        return shapeToParent(path);
    }

    public Rectangle2D getBoundingBox() throws SVGException
    {
        return boundsToParent(includeStrokeInBounds(path.getBounds2D()));
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;
        boolean changeState = super.updateTime(curTime);

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;

        if (getStyle(sty.setName(""fill-rule"")))
        {
            int newVal = sty.getStringValue().equals(""evenodd"")
                ? GeneralPath.WIND_EVEN_ODD
                : GeneralPath.WIND_NON_ZERO;
            if (newVal != fillRule)
            {
                fillRule = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""points"")))
        {
            String newVal = sty.getStringValue();
            if (!newVal.equals(pointsStrn))
            {
                pointsStrn = newVal;
                shapeChange = true;
            }
        }


        if (shapeChange)
        {
            build();
//            buildPath();
//            return true;
        }

        return changeState || shapeChange;
    }
}
"
Polyline.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 5:25 PM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import com.kitfox.svg.xml.XMLParseUtil;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Polyline extends ShapeElement
{
    public static final String TAG_NAME = ""polyline"";
    
    int fillRule = GeneralPath.WIND_NON_ZERO;
    String pointsStrn = """";
    GeneralPath path;

    /**
     * Creates a new instance of Rect
     */
    public Polyline()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    public void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""points"")))
        {
            pointsStrn = sty.getStringValue();
        }

        String fillRuleStrn = getStyle(sty.setName(""fill-rule"")) ? sty.getStringValue() : ""nonzero"";
        fillRule = fillRuleStrn.equals(""evenodd"") ? GeneralPath.WIND_EVEN_ODD : GeneralPath.WIND_NON_ZERO;

        buildPath();
    }

    protected void buildPath()
    {
        float[] points = XMLParseUtil.parseFloatList(pointsStrn);
        path = new GeneralPath(fillRule, points.length / 2);

        path.moveTo(points[0], points[1]);
        for (int i = 2; i < points.length; i += 2)
        {
            path.lineTo(points[i], points[i + 1]);
        }
    }

    public void render(Graphics2D g) throws SVGException
    {
        beginLayer(g);
        renderShape(g, path);
        finishLayer(g);
    }

    public Shape getShape()
    {
        return shapeToParent(path);
    }

    public Rectangle2D getBoundingBox() throws SVGException
    {
        return boundsToParent(includeStrokeInBounds(path.getBounds2D()));
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;
        boolean changeState = super.updateTime(curTime);

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;

        if (getStyle(sty.setName(""fill-rule"")))
        {
            int newVal = sty.getStringValue().equals(""evenodd"")
                ? GeneralPath.WIND_EVEN_ODD
                : GeneralPath.WIND_NON_ZERO;
            if (newVal != fillRule)
            {
                fillRule = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""points"")))
        {
            String newVal = sty.getStringValue();
            if (!newVal.equals(pointsStrn))
            {
                pointsStrn = newVal;
                shapeChange = true;
            }
        }


        if (shapeChange)
        {
            build();
//            buildPath();
//            return true;
        }

        return changeState || shapeChange;
    }
}
"
RadialGradient.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 1:55 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Color;
import java.awt.Paint;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class RadialGradient extends Gradient
{
    public static final String TAG_NAME = ""radialgradient"";

    float cx = 0.5f;
    float cy = 0.5f;
    float fx = 0.5f;
    float fy = 0.5f;
    float r = 0.5f;

    /**
     * Creates a new instance of RadialGradient
     */
    public RadialGradient()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""cx"")))
        {
            cx = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""cy"")))
        {
            cy = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""fx"")))
        {
            fx = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""fy"")))
        {
            fy = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""r"")))
        {
            r = sty.getFloatValueWithUnits();
        }
    }

    public Paint getPaint(Rectangle2D bounds, AffineTransform xform)
    {
        com.kitfox.svg.batik.MultipleGradientPaint.CycleMethodEnum method;
        switch (spreadMethod)
        {
            default:
            case SM_PAD:
                method = com.kitfox.svg.batik.MultipleGradientPaint.NO_CYCLE;
                break;
            case SM_REPEAT:
                method = com.kitfox.svg.batik.MultipleGradientPaint.REPEAT;
                break;
            case SM_REFLECT:
                method = com.kitfox.svg.batik.MultipleGradientPaint.REFLECT;
                break;
        }

        Paint paint;
        Point2D.Float pt1 = new Point2D.Float(cx, cy);
        Point2D.Float pt2 = new Point2D.Float(fx, fy);
        if (gradientUnits == GU_USER_SPACE_ON_USE)
        {
            paint = new com.kitfox.svg.batik.RadialGradientPaint(
                pt1,
                r,
                pt2,
                getStopFractions(),
                getStopColors(),
                method,
                com.kitfox.svg.batik.MultipleGradientPaint.SRGB,
                gradientTransform);
        } else
        {
            AffineTransform viewXform = new AffineTransform();
            viewXform.translate(bounds.getX(), bounds.getY());
            viewXform.scale(bounds.getWidth(), bounds.getHeight());

            viewXform.concatenate(gradientTransform);

            paint = new com.kitfox.svg.batik.RadialGradientPaint(
                pt1,
                r,
                pt2,
                getStopFractions(),
                getStopColors(),
                method,
                com.kitfox.svg.batik.MultipleGradientPaint.SRGB,
                viewXform);
        }

        return paint;
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;
        boolean changeState = super.updateTime(curTime);

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;

        if (getPres(sty.setName(""cx"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != cx)
            {
                cx = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""cy"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != cy)
            {
                cy = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""fx"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != fx)
            {
                fx = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""fy"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != fy)
            {
                fy = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""r"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != r)
            {
                r = newVal;
                shapeChange = true;
            }
        }

        return changeState;
    }
}
"
Rect.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 5:25 PM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RectangularShape;
import java.awt.geom.RoundRectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Rect extends ShapeElement
{
    public static final String TAG_NAME = ""rect"";

    float x = 0f;
    float y = 0f;
    float width = 0f;
    float height = 0f;
    float rx = 0f;
    float ry = 0f;
    RectangularShape rect;

    /**
     * Creates a new instance of Rect
     */
    public Rect()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    private void writeObject(ObjectOutputStream out) throws IOException
    {
        out.writeFloat(x);
        out.writeFloat(y);
        out.writeFloat(width);
        out.writeFloat(height);
        out.writeFloat(rx);
        out.writeFloat(ry);
    }

    private void readObject(ObjectInputStream in) throws IOException
    {
        x = in.readFloat();
        y = in.readFloat();
        width = in.readFloat();
        height = in.readFloat();
        rx = in.readFloat();
        ry = in.readFloat();

        if (rx == 0f && ry == 0f)
        {
            rect = new Rectangle2D.Float(x, y, width, height);
        } else
        {
            rect = new RoundRectangle2D.Float(x, y, width, height, rx * 2, ry * 2);
        }
    }

    /*
     public void loaderStartElement(SVGLoaderHelper helper, Attributes attrs, SVGElement parent)
     {
     //Load style string
     super.loaderStartElement(helper, attrs, parent);

     String x = attrs.getValue(""x"");
     String y = attrs.getValue(""y"");
     String width = attrs.getValue(""width"");
     String height = attrs.getValue(""height"");
     String rx = attrs.getValue(""rx"");
     String ry = attrs.getValue(""ry"");

     if (rx == null) rx = ry;
     if (ry == null) ry = rx;

     this.x = XMLParseUtil.parseFloat(x);
     this.y = XMLParseUtil.parseFloat(y);
     this.width = XMLParseUtil.parseFloat(width);
     this.height = XMLParseUtil.parseFloat(height);
     if (rx != null)
     {
     this.rx = XMLParseUtil.parseFloat(rx);
     this.ry = XMLParseUtil.parseFloat(ry);
     }

     build();
     //        setBounds(this.x, this.y, this.width, this.height);
     }
     */
    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

//        SVGElement parent = this.getParent();
//        if (parent instanceof RenderableElement)
//        {
//            RenderableElement re = (RenderableElement)parent;
//            Rectangle2D bounds = re.getBoundingBox();
//            bounds = null;
//        }


        if (getPres(sty.setName(""x"")))
        {
            x = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""y"")))
        {
            y = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""width"")))
        {
            width = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""height"")))
        {
            height = sty.getFloatValueWithUnits();
        }

        boolean rxSet = false;
        if (getPres(sty.setName(""rx"")))
        {
            rx = sty.getFloatValueWithUnits();
            rxSet = true;
        }

        boolean rySet = false;
        if (getPres(sty.setName(""ry"")))
        {
            ry = sty.getFloatValueWithUnits();
            rySet = true;
        }

        if (!rxSet)
        {
            rx = ry;
        }
        if (!rySet)
        {
            ry = rx;
        }


        if (rx == 0f && ry == 0f)
        {
            rect = new Rectangle2D.Float(x, y, width, height);
        } else
        {
            rect = new RoundRectangle2D.Float(x, y, width, height, rx * 2, ry * 2);
        }
    }

    public void render(Graphics2D g) throws SVGException
    {
        beginLayer(g);
        renderShape(g, rect);
        finishLayer(g);
    }

    public Shape getShape()
    {
        return shapeToParent(rect);
    }

    public Rectangle2D getBoundingBox() throws SVGException
    {
        return boundsToParent(includeStrokeInBounds(rect.getBounds2D()));
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;
        boolean changeState = super.updateTime(curTime);

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;

        if (getPres(sty.setName(""x"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != x)
            {
                x = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""y"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != y)
            {
                y = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""width"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != width)
            {
                width = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""height"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != height)
            {
                height = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""rx"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != rx)
            {
                rx = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""ry"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != ry)
            {
                ry = newVal;
                shapeChange = true;
            }
        }

        if (shapeChange)
        {
            build();
//            if (rx == 0f && ry == 0f)
//            {
//                rect = new Rectangle2D.Float(x, y, width, height);
//            }
//            else
//            {
//                rect = new RoundRectangle2D.Float(x, y, width, height, rx * 2, ry * 2);
//            }
//            return true;
        }

        return changeState || shapeChange;
    }
}
"
RenderableElement.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 9:00 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.net.URI;
import java.util.List;

/**
 * Maintains bounding box for this element
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
abstract public class RenderableElement extends TransformableElement
{
    AffineTransform cachedXform = null;
    
    Shape cachedClip = null;
    public static final int VECTOR_EFFECT_NONE = 0;
    public static final int VECTOR_EFFECT_NON_SCALING_STROKE = 1;
    int vectorEffect;

    /**
     * Creates a new instance of BoundedElement
     */
    public RenderableElement()
    {
    }

    public RenderableElement(String id, SVGElement parent)
    {
        super(id, parent);
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""vector-effect"")))
        {
            if (""non-scaling-stroke"".equals(sty.getStringValue()))
            {
                vectorEffect = VECTOR_EFFECT_NON_SCALING_STROKE;
            } else
            {
                vectorEffect = VECTOR_EFFECT_NONE;
            }
        } else
        {
            vectorEffect = VECTOR_EFFECT_NONE;
        }
    }

    abstract public void render(Graphics2D g) throws SVGException;

    abstract void pick(Point2D point, boolean boundingBox, List retVec) throws SVGException;

    abstract void pick(Rectangle2D pickArea, AffineTransform ltw, boolean boundingBox, List retVec) throws SVGException;

    abstract public Rectangle2D getBoundingBox() throws SVGException;
    /*
     public void loaderStartElement(SVGLoaderHelper helper, Attributes attrs, SVGElement parent)
     {
     super.loaderStartElement(helper, attrs, parent);
     }
     */

    /**
     * Pushes transform stack, transforms to local coordinates and sets up
     * clipping mask.
     */
    protected void beginLayer(Graphics2D g) throws SVGException
    {
        if (xform != null)
        {
            cachedXform = g.getTransform();
            g.transform(xform);
        }

        StyleAttribute styleAttrib = new StyleAttribute();

        //Get clipping path
//        StyleAttribute styleAttrib = getStyle(""clip-path"", false);
        Shape clipPath = null;
        int clipPathUnits = ClipPath.CP_USER_SPACE_ON_USE;
        if (getStyle(styleAttrib.setName(""clip-path""), false)
             && !""none"".equals(styleAttrib.getStringValue()))
        {
            URI uri = styleAttrib.getURIValue(getXMLBase());
            if (uri != null)
            {
                ClipPath ele = (ClipPath) diagram.getUniverse().getElement(uri);
                clipPath = ele.getClipPathShape();
                clipPathUnits = ele.getClipPathUnits();
            }
        }

        //Return if we're out of clipping range
        if (clipPath != null)
        {
            if (clipPathUnits == ClipPath.CP_OBJECT_BOUNDING_BOX && (this instanceof ShapeElement))
            {
                Rectangle2D rect = ((ShapeElement) this).getBoundingBox();
                AffineTransform at = new AffineTransform();
                at.scale(rect.getWidth(), rect.getHeight());
                clipPath = at.createTransformedShape(clipPath);
            }

            cachedClip = g.getClip();
            if (cachedClip == null)
            {
                g.setClip(clipPath);
            } else
            {
                Area newClip = new Area(cachedClip);
                newClip.intersect(new Area(clipPath));
                g.setClip(newClip);
            }
        }
    }

    /**
     * Restores transform and clipping values to the way they were before this
     * layer was drawn.
     */
    protected void finishLayer(Graphics2D g)
    {
        if (cachedClip != null)
        {
            g.setClip(cachedClip);
        }

        if (cachedXform != null)
        {
            g.setTransform(cachedXform);
        }
    }
}
"
ShapeElement.java,kitfox-6.9.6,"/*
 * SVG Salamander Copyright (c) 2004, Mark McKay All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. - Redistributions in binary
 * form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided
 * with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Mark McKay can be contacted at mark@kitfox.com. Salamander and other projects
 * can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 5:21 PM
 */

package com.kitfox.svg;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import com.kitfox.svg.Marker.MarkerLayout;
import com.kitfox.svg.Marker.MarkerPos;
import com.kitfox.svg.xml.StyleAttribute;

/**
 * Parent of shape objects
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
abstract public class ShapeElement extends RenderableElement {

	/**
	 * This is necessary to get text elements to render the stroke the correct
	 * width. It is an alternative to producing new font glyph sets at different
	 * sizes.
	 */
	protected float strokeWidthScalar = 1f;

	protected static Map<StrokeCacheIndex, BasicStroke> strokeCache = new ConcurrentHashMap<>();

	protected static class StrokeCacheIndex {
		float strokeWidth;
		int strokeLinecap;
		int strokeLinejoin;
		float strokeMiterLimit;
		float[] strokeDashArray;
		float strokeDashOffset;

		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + Arrays.hashCode(strokeDashArray);
			result = prime * result + Float.floatToIntBits(strokeDashOffset);
			result = prime * result + strokeLinecap;
			result = prime * result + strokeLinejoin;
			result = prime * result + Float.floatToIntBits(strokeMiterLimit);
			result = prime * result + Float.floatToIntBits(strokeWidth);
			return result;
		}

		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			StrokeCacheIndex other = (StrokeCacheIndex) obj;
			if (!Arrays.equals(strokeDashArray, other.strokeDashArray))
				return false;
			if (Float.floatToIntBits(strokeDashOffset) != Float.floatToIntBits(other.strokeDashOffset))
				return false;
			if (strokeLinecap != other.strokeLinecap)
				return false;
			if (strokeLinejoin != other.strokeLinejoin)
				return false;
			if (Float.floatToIntBits(strokeMiterLimit) != Float.floatToIntBits(other.strokeMiterLimit))
				return false;
			if (Float.floatToIntBits(strokeWidth) != Float.floatToIntBits(other.strokeWidth))
				return false;
			return true;
		}
	}

	/** Creates a new instance of ShapeElement */
	public ShapeElement() {
	}

	abstract public void render(java.awt.Graphics2D g) throws SVGException;

	/*
	 * protected void setStrokeWidthScalar(float strokeWidthScalar) {
	 * this.strokeWidthScalar = strokeWidthScalar; }
	 */

	void pick(Point2D point, boolean boundingBox, List retVec) throws SVGException {
		//        StyleAttribute styleAttrib = new StyleAttribute();
		//        if (getStyle(styleAttrib.setName(""fill"")) && getShape().contains(point))
		if ((boundingBox ? getBoundingBox() : getShape()).contains(point)) {
			retVec.add(getPath(null));
		}
	}

	void pick(Rectangle2D pickArea, AffineTransform ltw, boolean boundingBox, List retVec) throws SVGException {
		StyleAttribute styleAttrib = new StyleAttribute();
		//        if (getStyle(styleAttrib.setName(""fill"")) && getShape().contains(point))
		if (ltw.createTransformedShape((boundingBox ? getBoundingBox() : getShape())).intersects(pickArea)) {
			retVec.add(getPath(null));
		}
	}

	private Paint handleCurrentColor(StyleAttribute styleAttrib) throws SVGException {
		if (styleAttrib.getStringValue().equals(""currentColor"")) {
			StyleAttribute currentColorAttrib = new StyleAttribute();
			if (getStyle(currentColorAttrib.setName(""color""))) {
				if (!currentColorAttrib.getStringValue().equals(""none"")) {
					return currentColorAttrib.getColorValue();
				}
			}
			return null;
		} else {
			return styleAttrib.getColorValue();
		}
	}

	protected void renderShape(Graphics2D g, Shape shape) throws SVGException {
		//g.setColor(Color.green);

		StyleAttribute styleAttrib = new StyleAttribute();

		//Don't process if not visible
		if (getStyle(styleAttrib.setName(""visibility""))) {
			if (!styleAttrib.getStringValue().equals(""visible""))
				return;
		}

		if (getStyle(styleAttrib.setName(""display""))) {
			if (styleAttrib.getStringValue().equals(""none""))
				return;
		}

		//None, solid color, gradient, pattern
		Paint fillPaint = Color.black; //Default to black.  Must be explicitly set to none for no fill.
		if (getStyle(styleAttrib.setName(""fill""))) {
			if (styleAttrib.getStringValue().equals(""none""))
				fillPaint = null;
			else {
				fillPaint = handleCurrentColor(styleAttrib);
				if (fillPaint == null) {
					URI uri = styleAttrib.getURIValue(getXMLBase());
					if (uri != null) {
						Rectangle2D bounds = shape.getBounds2D();
						AffineTransform xform = g.getTransform();

						SVGElement ele = diagram.getUniverse().getElement(uri);
						if (ele != null) {
							fillPaint = ((FillElement) ele).getPaint(bounds, xform);
						}
					}
				}
			}
		}

		//Default opacity
		float opacity = 1f;
		if (getStyle(styleAttrib.setName(""opacity""))) {
			opacity = styleAttrib.getRatioValue();
		}

		float fillOpacity = opacity;
		if (getStyle(styleAttrib.setName(""fill-opacity""))) {
			fillOpacity *= styleAttrib.getRatioValue();
		}

		Paint strokePaint = null; //Default is to stroke with none
		if (getStyle(styleAttrib.setName(""stroke""))) {
			if (styleAttrib.getStringValue().equals(""none""))
				strokePaint = null;
			else {
				strokePaint = handleCurrentColor(styleAttrib);
				if (strokePaint == null) {
					URI uri = styleAttrib.getURIValue(getXMLBase());
					if (uri != null) {
						Rectangle2D bounds = shape.getBounds2D();
						AffineTransform xform = g.getTransform();

						SVGElement ele = diagram.getUniverse().getElement(uri);
						if (ele != null) {
							strokePaint = ((FillElement) ele).getPaint(bounds, xform);
						}
					}
				}
			}
		}

		float[] strokeDashArray = null;
		if (getStyle(styleAttrib.setName(""stroke-dasharray""))) {
			strokeDashArray = styleAttrib.getFloatList();
			if (strokeDashArray.length == 0)
				strokeDashArray = null;
		}

		float strokeDashOffset = 0f;
		if (getStyle(styleAttrib.setName(""stroke-dashoffset""))) {
			strokeDashOffset = styleAttrib.getFloatValueWithUnits();
		}

		int strokeLinecap = BasicStroke.CAP_BUTT;
		if (getStyle(styleAttrib.setName(""stroke-linecap""))) {
			String val = styleAttrib.getStringValue();
			if (val.equals(""round"")) {
				strokeLinecap = BasicStroke.CAP_ROUND;
			} else if (val.equals(""square"")) {
				strokeLinecap = BasicStroke.CAP_SQUARE;
			}
		}

		int strokeLinejoin = BasicStroke.JOIN_MITER;
		if (getStyle(styleAttrib.setName(""stroke-linejoin""))) {
			String val = styleAttrib.getStringValue();
			if (val.equals(""round"")) {
				strokeLinejoin = BasicStroke.JOIN_ROUND;
			} else if (val.equals(""bevel"")) {
				strokeLinejoin = BasicStroke.JOIN_BEVEL;
			}
		}

		float strokeMiterLimit = 4f;
		if (getStyle(styleAttrib.setName(""stroke-miterlimit""))) {
			strokeMiterLimit = Math.max(styleAttrib.getFloatValueWithUnits(), 1);
		}

		float strokeOpacity = opacity;
		if (getStyle(styleAttrib.setName(""stroke-opacity""))) {
			strokeOpacity *= styleAttrib.getRatioValue();
		}

		float strokeWidth = 1f;
		if (getStyle(styleAttrib.setName(""stroke-width""))) {
			strokeWidth = styleAttrib.getFloatValueWithUnits();
		}
		//        if (strokeWidthScalar != 1f)
		//        {
		strokeWidth *= strokeWidthScalar;
		//        }

		Marker markerStart = null;
		if (getStyle(styleAttrib.setName(""marker-start""))) {
			if (!styleAttrib.getStringValue().equals(""none"")) {
				URI uri = styleAttrib.getURIValue(getXMLBase());
				markerStart = (Marker) diagram.getUniverse().getElement(uri);
			}
		}

		Marker markerMid = null;
		if (getStyle(styleAttrib.setName(""marker-mid""))) {
			if (!styleAttrib.getStringValue().equals(""none"")) {
				URI uri = styleAttrib.getURIValue(getXMLBase());
				markerMid = (Marker) diagram.getUniverse().getElement(uri);
			}
		}

		Marker markerEnd = null;
		if (getStyle(styleAttrib.setName(""marker-end""))) {
			if (!styleAttrib.getStringValue().equals(""none"")) {
				URI uri = styleAttrib.getURIValue(getXMLBase());
				markerEnd = (Marker) diagram.getUniverse().getElement(uri);
			}
		}

		//Draw the shape
		if (fillPaint != null && fillOpacity != 0f) {
			if (fillOpacity <= 0) {
				//Do nothing
			} else if (fillOpacity < 1f) {
				Composite cachedComposite = g.getComposite();
				g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, fillOpacity));

				g.setPaint(fillPaint);
				g.fill(shape);

				g.setComposite(cachedComposite);
			} else {
				g.setPaint(fillPaint);
				g.fill(shape);
			}
		}

		if (strokePaint != null && strokeOpacity != 0f) {
			BasicStroke stroke;
			if (strokeDashArray == null) {
				StrokeCacheIndex index = new StrokeCacheIndex();
				index.strokeWidth = strokeWidth;
				index.strokeLinecap = strokeLinecap;
				index.strokeLinejoin = strokeLinejoin;
				index.strokeMiterLimit = strokeMiterLimit;
				index.strokeDashArray = null;
				index.strokeDashOffset = Float.MIN_VALUE;
				stroke = strokeCache.get(index);
				if (stroke == null) {
					stroke = new BasicStroke(strokeWidth, strokeLinecap, strokeLinejoin, strokeMiterLimit);
					strokeCache.put(index, stroke);
				}
			} else {
				StrokeCacheIndex index = new StrokeCacheIndex();
				index.strokeWidth = strokeWidth;
				index.strokeLinecap = strokeLinecap;
				index.strokeLinejoin = strokeLinejoin;
				index.strokeMiterLimit = strokeMiterLimit;
				index.strokeDashArray = strokeDashArray;
				index.strokeDashOffset = strokeDashOffset;
				stroke = strokeCache.get(index);
				if (stroke == null) {
					stroke = new BasicStroke(strokeWidth, strokeLinecap, strokeLinejoin, strokeMiterLimit,
							strokeDashArray, strokeDashOffset);
					strokeCache.put(index, stroke);
				}
			}

			Shape strokeShape;
			AffineTransform cacheXform = g.getTransform();
			if (vectorEffect == VECTOR_EFFECT_NON_SCALING_STROKE) {
				strokeShape = cacheXform.createTransformedShape(shape);
				strokeShape = stroke.createStrokedShape(strokeShape);
			} else {
				strokeShape = stroke.createStrokedShape(shape);
			}

			if (strokeOpacity <= 0) {
				//Do nothing
			} else {
				Composite cachedComposite = g.getComposite();

				if (strokeOpacity < 1f) {
					g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, strokeOpacity));
				}

				if (vectorEffect == VECTOR_EFFECT_NON_SCALING_STROKE) {
					//Set to identity
					g.setTransform(new AffineTransform());
				}

				g.setPaint(strokePaint);
				g.fill(strokeShape);

				if (vectorEffect == VECTOR_EFFECT_NON_SCALING_STROKE) {
					//Set to identity
					g.setTransform(cacheXform);
				}

				if (strokeOpacity < 1f) {
					g.setComposite(cachedComposite);
				}
			}
		}

		if (markerStart != null || markerMid != null || markerEnd != null) {
			MarkerLayout layout = new MarkerLayout();
			layout.layout(shape);

			ArrayList list = layout.getMarkerList();
			for (int i = 0; i < list.size(); ++i) {
				MarkerPos pos = (MarkerPos) list.get(i);

				switch (pos.type) {
					case Marker.MARKER_START :
						if (markerStart != null) {
							markerStart.render(g, pos, strokeWidth);
						}
						break;
					case Marker.MARKER_MID :
						if (markerMid != null) {
							markerMid.render(g, pos, strokeWidth);
						}
						break;
					case Marker.MARKER_END :
						if (markerEnd != null) {
							markerEnd.render(g, pos, strokeWidth);
						}
						break;
				}
			}
		}
	}

	abstract public Shape getShape();

	protected Rectangle2D includeStrokeInBounds(Rectangle2D rect) throws SVGException {
		StyleAttribute styleAttrib = new StyleAttribute();
		if (!getStyle(styleAttrib.setName(""stroke"")))
			return rect;

		double strokeWidth = 1;
		if (getStyle(styleAttrib.setName(""stroke-width"")))
			strokeWidth = styleAttrib.getDoubleValue();

		rect.setRect(rect.getX() - strokeWidth / 2, rect.getY() - strokeWidth / 2, rect.getWidth() + strokeWidth,
				rect.getHeight() + strokeWidth);

		return rect;
	}

}
"
Stop.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 1:56 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Color;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Stop extends SVGElement
{

    public static final String TAG_NAME = ""stop"";
    float offset = 0f;
    float opacity = 1f;
    Color color = Color.black;

    /**
     * Creates a new instance of Stop
     */
    public Stop()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""offset"")))
        {
            offset = sty.getFloatValue();
            String units = sty.getUnits();
            if (units != null && units.equals(""%""))
            {
                offset /= 100f;
            }
            if (offset > 1)
            {
                offset = 1;
            }
            if (offset < 0)
            {
                offset = 0;
            }
        }

        if (getStyle(sty.setName(""stop-color"")))
        {
            color = sty.getColorValue();
        }

        if (getStyle(sty.setName(""stop-opacity"")))
        {
            opacity = sty.getRatioValue();
        }
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;

        if (getPres(sty.setName(""offset"")))
        {
            float newVal = sty.getFloatValue();
            if (newVal != offset)
            {
                offset = newVal;
                shapeChange = true;
            }
        }

        if (getStyle(sty.setName(""stop-color"")))
        {
            Color newVal = sty.getColorValue();
            if (newVal != color)
            {
                color = newVal;
                shapeChange = true;
            }
        }

        if (getStyle(sty.setName(""stop-opacity"")))
        {
            float newVal = sty.getFloatValue();
            if (newVal != opacity)
            {
                opacity = newVal;
                shapeChange = true;
            }
        }

        return shapeChange;
    }
}
"
Style.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 19, 2004, 1:56 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import com.kitfox.svg.xml.StyleSheet;

/**
 * Holds title textual information within tree
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Style extends SVGElement
{

    public static final String TAG_NAME = ""style"";
    //Should be set to ""text/css""
    String type;
    StringBuffer text = new StringBuffer();

    StyleSheet styleSheet;
    
    /**
     * Creates a new instance of Stop
     */
    public Style()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    /**
     * Called during load process to add text scanned within a tag
     */
    public void loaderAddText(SVGLoaderHelper helper, String text)
    {
        this.text.append(text);
        
        //Invalidate style sheet
        styleSheet = null;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""type"")))
        {
            type = sty.getStringValue();
        }
    }

    public boolean updateTime(double curTime) throws SVGException
    {
        //Style sheet doesn't change
        return false;
    }

    public StyleSheet getStyleSheet()
    {
        if (styleSheet == null && text.length() > 0)
        {
            styleSheet = StyleSheet.parseSheet(text.toString());
        }
        return styleSheet;
    }
}
"
SVGCache.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on April 2, 2005, 1:54 AM
 */

package com.kitfox.svg;

/**
 * A convienience singleton for allowing all classes to access a common SVG universe.
 *
 * @author kitfox
 */
public class SVGCache
{
    private static final SVGUniverse svgUniverse = new SVGUniverse();
    
    /** Creates a new instance of SVGUniverseSingleton */
    private SVGCache()
    {
    }

    public static SVGUniverse getSVGUniverse()
    {
        return svgUniverse;
    }
    
}
"
SVGConst.java,kitfox-6.9.6,"/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.kitfox.svg;

/**
 *
 * @author kitfox
 */
public interface SVGConst
{
    public static final String SVG_LOGGER = ""svgSalamandeLogger"";
}
"
SVGDiagram.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 18, 2004, 5:04 PM
 */

package com.kitfox.svg;

import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;
import java.net.URI;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;


/**
 * Top level structure in an SVG tree.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class SVGDiagram implements Serializable
{
    public static final long serialVersionUID = 0;
    
    //Indexes elements within this SVG diagram
    final HashMap idMap = new HashMap();

    SVGRoot root;
    final SVGUniverse universe;

    /**
     * This is used by the SVGRoot to determine the width of the 
     */
    private Rectangle deviceViewport = new Rectangle(100, 100);

    /**
     * If true, no attempt will be made to discard geometry based on it being
     * out of bounds.  This trades potentially drawing many out of bounds
     * shapes with having to recalculate bounding boxes every animation iteration.
     */
    protected boolean ignoreClipHeuristic = false;

    /**
     * URL which uniquely identifies this document
     */
//    final URI docRoot;

    /**
     * URI that uniquely identifies this document.  Also used to resolve
     * relative urls.  Default base for document.
     */
    final URI xmlBase;

    /** Creates a new instance of SVGDiagram */
    public SVGDiagram(URI xmlBase, SVGUniverse universe)
    {
        this.universe = universe;
//        this.docRoot = docRoot;
        this.xmlBase = xmlBase;
    }

    /**
     * Draws this diagram to the passed graphics context
     */
    public void render(Graphics2D g) throws SVGException
    {
        root.render(g);
    }
    
    /**
     * Searches thorough the scene graph for all RenderableElements that have
     * shapes that contain the passed point.
     * 
     * For every shape which contains the pick point, a List containing the
     * path to the node is added to the return list.  That is, the result of
     * SVGElement.getPath() is added for each entry.
     *
     * @return the passed in list
     */
    public List pick(Point2D point, List retVec) throws SVGException
    {
        return pick(point, false, retVec);
    }
    
    public List pick(Point2D point, boolean boundingBox, List retVec) throws SVGException
    {
        if (retVec == null)
        {
            retVec = new ArrayList();
        }
        
        root.pick(point, boundingBox, retVec);
        
        return retVec;
    }

    public List pick(Rectangle2D pickArea, List retVec) throws SVGException
    {
        return pick(pickArea, false, retVec);
    }
    
    public List pick(Rectangle2D pickArea, boolean boundingBox, List retVec) throws SVGException
    {
        if (retVec == null)
        {
            retVec = new ArrayList();
        }
        
        root.pick(pickArea, new AffineTransform(), boundingBox, retVec);
        
        return retVec;
    }

    public SVGUniverse getUniverse()
    {
        return universe;
    }

    public URI getXMLBase()
    {
        return xmlBase;
    }

//    public URL getDocRoot()
//    {
//        return docRoot;
//    }

    public float getWidth()
    {
        if (root == null) return 1;
        return Math.max(1, root.getDeviceWidth());
    }
    
    public float getHeight()
    {
        if (root == null) return 1;
        return Math.max(1, root.getDeviceHeight());
    }
    
    /**
     * Returns the viewing rectangle of this diagram in device coordinates.
     */
    public Rectangle2D getViewRect(Rectangle2D rect)
    {
        if (root != null) return root.getDeviceRect(rect);
        return rect;
    }

    public Rectangle2D getViewRect()
    {
        return getViewRect(new Rectangle2D.Double());
    }

    public SVGElement getElement(String name)
    {
        return (SVGElement)idMap.get(name);
    }

    public void setElement(String name, SVGElement node)
    {
        idMap.put(name, node);
    }

    public void removeElement(String name)
    {
        idMap.remove(name);
    }

    public SVGRoot getRoot()
    {
        return root;
    }

    public void setRoot(SVGRoot root)
    {
        this.root = root;
        root.setDiagram(this);
    }

    public boolean ignoringClipHeuristic() { return ignoreClipHeuristic; }

    public void setIgnoringClipHeuristic(boolean ignoreClipHeuristic) { this.ignoreClipHeuristic = ignoreClipHeuristic; }

    /**
     * Updates all attributes in this diagram associated with a time event.
     * Ie, all attributes with track information.
     */
    public void updateTime(double curTime) throws SVGException
    {
        if (root == null) return;
        root.updateTime(curTime);
    }

    public Rectangle getDeviceViewport()
    {
        return deviceViewport;
    }

    /**
     * Sets the dimensions of the device being rendered into.  This is used by
     * SVGRoot when its x, y, width or height parameters are specified as
     * percentages.
     */
    public void setDeviceViewport(Rectangle deviceViewport)
    {
        this.deviceViewport.setBounds(deviceViewport);
        if (root != null)
        {
            try
            {
                root.build();
            } catch (SVGException ex)
            {
                Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, 
                    ""Could not build document"", ex);
            }
        }
    }
}
"
SVGDisplayPanel.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 20, 2004, 12:29 PM
 */

package com.kitfox.svg;

import javax.swing.*;
import java.awt.*;
import java.awt.geom.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class SVGDisplayPanel extends javax.swing.JPanel implements Scrollable
{
    public static final long serialVersionUID = 1;
    
    SVGDiagram diagram = null;
    float scale = 1f;
    Color bgColor = null;

    /** Creates new form SVGDisplayPanel */
    public SVGDisplayPanel()
    {
        initComponents();
    }

    public SVGDiagram getDiagram()
    {
        return diagram;
    }
    
    public void setDiagram(SVGDiagram diagram)
    {
        this.diagram = diagram;
        diagram.setDeviceViewport(getBounds());
        
        setDimension();
    }

    public void setScale(float scale)
    {
        this.scale = scale;
        setDimension();
    }

    public void setBgColor(Color col)
    {
        bgColor = col;
    }

    private void setDimension()
    {
        if (diagram == null)
        {
            setPreferredSize(new Dimension(1, 1));
            revalidate();
            return;
        }

        final Rectangle2D.Float rect = new Rectangle2D.Float();
        diagram.getViewRect(rect);

        int w = (int)(rect.width * scale);
        int h = (int)(rect.height * scale);

        setPreferredSize(new Dimension(w, h));
        revalidate();
    }

    /**
     * Update this image to reflect the passed time
     */
    public void updateTime(double curTime) throws SVGException
    {
        if (diagram == null) return;
        
        diagram.updateTime(curTime);
    }
    
    public void paintComponent(Graphics gg)
    {
        Graphics2D g = (Graphics2D)gg;

        if (bgColor != null)
        {
            Dimension dim = getSize();
            g.setColor(bgColor);
            g.fillRect(0, 0, dim.width, dim.height);
        }

        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        if (diagram != null) 
        {
            try
            {
                diagram.render(g);
            }
            catch (SVGException e)
            {
                Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, 
                    ""Could not render diagram"", e);
            }
        }
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate=""collapsed"" desc="" Generated Code "">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        setLayout(new java.awt.BorderLayout());

        addComponentListener(new java.awt.event.ComponentAdapter()
        {
            public void componentResized(java.awt.event.ComponentEvent evt)
            {
                formComponentResized(evt);
            }
        });

    }// </editor-fold>//GEN-END:initComponents

    private void formComponentResized(java.awt.event.ComponentEvent evt)//GEN-FIRST:event_formComponentResized
    {//GEN-HEADEREND:event_formComponentResized
        if (diagram != null)
        {
            diagram.setDeviceViewport(getBounds());
            setDimension();
        }

    }//GEN-LAST:event_formComponentResized

    public Dimension getPreferredScrollableViewportSize()
    {
        return getPreferredSize();
    }

    public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction)
    {
        if (orientation == SwingConstants.HORIZONTAL)
        {
            return visibleRect.width;
        }
        else return visibleRect.height;
    }

    public boolean getScrollableTracksViewportHeight()
    {
        return false;
    }

    public boolean getScrollableTracksViewportWidth()
    {
        return false;
    }

    public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction)
    {
        return getScrollableBlockIncrement(visibleRect, orientation, direction) / 16;
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

}
"
SVGElement.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 1:59 AM
 */
package com.kitfox.svg;

import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.io.Serializable;
import java.net.URI;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;

import com.kitfox.svg.animation.AnimationElement;
import com.kitfox.svg.animation.TrackBase;
import com.kitfox.svg.animation.TrackManager;
import com.kitfox.svg.pathcmd.Arc;
import com.kitfox.svg.pathcmd.BuildHistory;
import com.kitfox.svg.pathcmd.Cubic;
import com.kitfox.svg.pathcmd.CubicSmooth;
import com.kitfox.svg.pathcmd.Horizontal;
import com.kitfox.svg.pathcmd.LineTo;
import com.kitfox.svg.pathcmd.MoveTo;
import com.kitfox.svg.pathcmd.PathCommand;
import com.kitfox.svg.pathcmd.Quadratic;
import com.kitfox.svg.pathcmd.QuadraticSmooth;
import com.kitfox.svg.pathcmd.Terminal;
import com.kitfox.svg.pathcmd.Vertical;
import com.kitfox.svg.xml.StyleAttribute;
import com.kitfox.svg.xml.StyleSheet;
import com.kitfox.svg.xml.XMLParseUtil;


/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
abstract public class SVGElement implements Serializable
{

    public static final long serialVersionUID = 0;
    public static final String SVG_NS = ""http://www.w3.org/2000/svg"";
    protected SVGElement parent = null;
    private final ArrayList<SVGElement> children = new ArrayList();
    protected long childrenChangeCounter = 0;
    protected String id = null;
    /**
     * CSS class. Used for applying style sheet information.
     */
    protected String cssClass = null;
    /**
     * Styles defined for this elemnt via the <b>style</b> attribute.
     */
    protected final HashMap inlineStyles = new HashMap();
    /**
     * Presentation attributes set for this element. Ie, any attribute other
     * than the <b>style</b> attribute.
     */
    protected final HashMap presAttribs = new HashMap();
    /**
     * A list of presentation attributes to not include in the presentation
     * attribute set.
     */
    protected static final Set ignorePresAttrib;

    static
    {
        HashSet set = new HashSet();
//        set.add(""id"");
//        set.add(""class"");
//        set.add(""style"");
//        set.add(""xml:base"");

        ignorePresAttrib = Collections.unmodifiableSet(set);
    }
    /**
     * This element may override the URI we resolve against with an xml:base
     * attribute. If so, a copy is placed here. Otherwise, we defer to our
     * parent for the reolution base
     */
    protected URI xmlBase = null;
    /**
     * The diagram this element belongs to
     */
    protected SVGDiagram diagram;
    /**
     * Link to the universe we reside in
     */
    protected final TrackManager trackManager = new TrackManager();
    boolean dirty = true;

    /**
     * Creates a new instance of SVGElement
     */
    public SVGElement()
    {
        this(null, null, null);
    }

    public SVGElement(String id, SVGElement parent)
    {
        this(id, null, parent);
    }

    public SVGElement(String id, String cssClass, SVGElement parent)
    {
        this.id = id;
        this.cssClass = cssClass;
        this.parent = parent;
    }

    abstract public String getTagName();

    public SVGElement getParent()
    {
        return parent;
    }

    void setParent(SVGElement parent)
    {
        this.parent = parent;
    }

    /**
     * @return an ordered list of nodes from the root of the tree to this node
     */
    public List getPath(List retVec)
    {
        if (retVec == null)
        {
            retVec = new ArrayList();
        }

        if (parent != null)
        {
            parent.getPath(retVec);
        }
        retVec.add(this);

        return retVec;
    }

    /**
     * @param retVec - A list to add all children to. If null, a new list is
     * created and children of this group are added.
     *
     * @return The list containing the children of this group
     */
    public List getChildren(List retVec)
    {
        if (retVec == null)
        {
            retVec = new ArrayList();
        }

        retVec.addAll(children);

        return retVec;
    }

    /**
     * @param id - Id of svg element to return
     * @return the child of the given id, or null if no such child exists.
     */
    public SVGElement getChild(String id)
    {
        for (Iterator it = children.iterator(); it.hasNext();)
        {
            SVGElement ele = (SVGElement) it.next();
            String eleId = ele.getId();
            if (eleId != null && eleId.equals(id))
            {
                return ele;
            }
        }

        return null;
    }

    /**
     * Searches children for given element. If found, returns index of child.
     * Otherwise returns -1.
     */
    public int indexOfChild(SVGElement child)
    {
        return children.indexOf(child);
    }

    /**
     * Swaps 2 elements in children.
     *
     * @i index of first
     * @j index of second
     *
     * @return true if successful, false otherwise
     */
    public void swapChildren(int i, int j) throws SVGException
    {
    	childrenChangeCounter++;
        if ((children == null) || (i < 0) || (i >= children.size()) || (j < 0) || (j >= children.size()))
        {
            return;
        }

        SVGElement temp = children.get(i);
        children.set(i, children.get(j));
        children.set(j, temp);
        build();
    }

    /**
     * Called during SAX load process to notify that this tag has begun the
     * process of being loaded
     *
     * @param attrs - Attributes of this tag
     * @param helper - An object passed to all SVG elements involved in this
     * build process to aid in sharing information.
     */
    public void loaderStartElement(SVGLoaderHelper helper, Attributes attrs, SVGElement parent) throws SAXException
    {
        //Set identification info
        this.parent = parent;
        this.diagram = helper.diagram;

        this.id = attrs.getValue(""id"");
        if (this.id != null && !this.id.equals(""""))
        {
            diagram.setElement(this.id, this);
        }

        String className = attrs.getValue(""class"");
        this.cssClass = (className == null || className.equals("""")) ? null : className;
        //docRoot = helper.docRoot;
        //universe = helper.universe;

        //Parse style string, if any
        String style = attrs.getValue(""style"");
        if (style != null)
        {
            HashMap map = XMLParseUtil.parseStyle(style, inlineStyles);
        }

        String base = attrs.getValue(""xml:base"");
        if (base != null && !base.equals(""""))
        {
            try
            {
                xmlBase = new URI(base);
            } catch (Exception e)
            {
                throw new SAXException(e);
            }
        }

        //Place all other attributes into the presentation attribute list
        int numAttrs = attrs.getLength();
        for (int i = 0; i < numAttrs; i++)
        {
            String name = attrs.getQName(i);
            if (ignorePresAttrib.contains(name))
            {
                continue;
            }
            String value = attrs.getValue(i);

            presAttribs.put(name, new StyleAttribute(name, value));
        }
    }

    public void removeAttribute(String name, int attribType)
    {
        switch (attribType)
        {
            case AnimationElement.AT_CSS:
                inlineStyles.remove(name);
                return;
            case AnimationElement.AT_XML:
                presAttribs.remove(name);
                return;
        }
    }

    public void addAttribute(String name, int attribType, String value) throws SVGElementException
    {
        if (hasAttribute(name, attribType))
        {
            throw new SVGElementException(this, ""Attribute "" + name + ""("" + AnimationElement.animationElementToString(attribType) + "") already exists"");
        }

        //Alter layout for id attribute
        if (""id"".equals(name))
        {
            if (diagram != null)
            {
                diagram.removeElement(id);
                diagram.setElement(value, this);
            }
            this.id = value;
        }

        switch (attribType)
        {
            case AnimationElement.AT_CSS:
                inlineStyles.put(name, new StyleAttribute(name, value));
                return;
            case AnimationElement.AT_XML:
                presAttribs.put(name, new StyleAttribute(name, value));
                return;
        }

        throw new SVGElementException(this, ""Invalid attribute type "" + attribType);
    }

    public boolean hasAttribute(String name, int attribType) throws SVGElementException
    {
        switch (attribType)
        {
            case AnimationElement.AT_CSS:
                return inlineStyles.containsKey(name);
            case AnimationElement.AT_XML:
                return presAttribs.containsKey(name);
            case AnimationElement.AT_AUTO:
                return inlineStyles.containsKey(name) || presAttribs.containsKey(name);
        }

        throw new SVGElementException(this, ""Invalid attribute type "" + attribType);
    }

    /**
     * @return a set of Strings that corespond to CSS attributes on this element
     */
    public Set getInlineAttributes()
    {
        return inlineStyles.keySet();
    }

    /**
     * @return a set of Strings that corespond to XML attributes on this element
     */
    public Set getPresentationAttributes()
    {
        return presAttribs.keySet();
    }

    /**
     * Called after the start element but before the end element to indicate
     * each child tag that has been processed
     */
    public void loaderAddChild(SVGLoaderHelper helper, SVGElement child) throws SVGElementException
    {
    	childrenChangeCounter++;
        children.add(child);
        child.parent = this;
        child.setDiagram(diagram);

        //Add info to track if we've scanned animation element
        if (child instanceof AnimationElement)
        {
            trackManager.addTrackElement((AnimationElement) child);
        }
    }

    protected void setDiagram(SVGDiagram diagram)
    {
        this.diagram = diagram;
        diagram.setElement(id, this);
        for (Iterator it = children.iterator(); it.hasNext();)
        {
            SVGElement ele = (SVGElement) it.next();
            ele.setDiagram(diagram);
        }
    }
    
    protected void addChild(SVGElement child) {
    	childrenChangeCounter++;
    	children.add(child);
    }
    
    protected void addChildren(Collection<SVGElement> children) {
    	childrenChangeCounter++;
    	children.addAll(children);
    }

    public void removeChild(SVGElement child) throws SVGElementException
    {
    	childrenChangeCounter++;
        if (!children.contains(child))
        {
            throw new SVGElementException(this, ""Element does not contain child "" + child);
        }

        children.remove(child);
    }

    /**
     * Called during load process to add text scanned within a tag
     */
    public void loaderAddText(SVGLoaderHelper helper, String text)
    {
    }

    /**
     * Called to indicate that this tag and the tags it contains have been
     * completely processed, and that it should finish any load processes.
     */
    public void loaderEndElement(SVGLoaderHelper helper) throws SVGParseException
    {
//        try
//        {
//            build();
//        }
//        catch (SVGException se)
//        {
//            throw new SVGParseException(se);
//        }
    }

    /**
     * Called by internal processes to rebuild the geometry of this node from
     * it's presentation attributes, style attributes and animated tracks.
     */
    protected void build() throws SVGException
    {
        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""id"")))
        {
            String newId = sty.getStringValue();
            if (!newId.equals(id))
            {
                diagram.removeElement(id);
                id = newId;
                diagram.setElement(this.id, this);
            }
        }
        if (getPres(sty.setName(""class"")))
        {
            cssClass = sty.getStringValue();
        }
        if (getPres(sty.setName(""xml:base"")))
        {
            xmlBase = sty.getURIValue();
        }

        //Build children
        for (int i = 0; i < children.size(); ++i)
        {
            SVGElement ele = (SVGElement) children.get(i);
            ele.build();
        }
    }

    public URI getXMLBase()
    {
        return xmlBase != null ? xmlBase
            : (parent != null ? parent.getXMLBase() : diagram.getXMLBase());
    }

    /**
     * @return the id assigned to this node. Null if no id explicitly set.
     */
    public String getId()
    {
        return id;
    }
    LinkedList contexts = new LinkedList();

    /**
     * Hack to allow nodes to temporarily change their parents. The Use tag will
     * need this so it can alter the attributes that a particular node uses.
     */
    protected void pushParentContext(SVGElement context)
    {
        contexts.addLast(context);
    }

    protected SVGElement popParentContext()
    {
        return (SVGElement) contexts.removeLast();
    }

    protected SVGElement getParentContext()
    {
        return contexts.isEmpty() ? null : (SVGElement) contexts.getLast();
    }

    public SVGRoot getRoot()
    {
        return parent == null ? null : parent.getRoot();
    }

    /*
     * Returns the named style attribute.  Checks for inline styles first, then
     * internal and extranal style sheets, and finally checks for presentation
     * attributes.
     * @param styleName - Name of attribute to return
     * @param recursive - If true and this object does not contain the
     * named style attribute, checks attributes of parents abck to root until
     * one found.
     */
    public boolean getStyle(StyleAttribute attrib) throws SVGException
    {
        return getStyle(attrib, true);
    }

    public void setAttribute(String name, int attribType, String value) throws SVGElementException
    {
        StyleAttribute styAttr;


        switch (attribType)
        {
            case AnimationElement.AT_CSS:
            {
                styAttr = (StyleAttribute) inlineStyles.get(name);
                break;
            }
            case AnimationElement.AT_XML:
            {
                styAttr = (StyleAttribute) presAttribs.get(name);
                break;
            }
            case AnimationElement.AT_AUTO:
            {
                styAttr = (StyleAttribute) inlineStyles.get(name);

                if (styAttr == null)
                {
                    styAttr = (StyleAttribute) presAttribs.get(name);
                }
                break;
            }
            default:
                throw new SVGElementException(this, ""Invalid attribute type "" + attribType);
        }

        if (styAttr == null)
        {
            throw new SVGElementException(this, ""Could not find attribute "" + name + ""("" + AnimationElement.animationElementToString(attribType) + "").  Make sure to create attribute before setting it."");
        }

        //Alter layout for relevant attributes
        if (""id"".equals(styAttr.getName()))
        {
            if (diagram != null)
            {
                diagram.removeElement(this.id);
                diagram.setElement(value, this);
            }
            this.id = value;
        }

        styAttr.setStringValue(value);
    }

    public boolean getStyle(StyleAttribute attrib, boolean recursive) throws SVGException
    {
        return getStyle(attrib, recursive, true);
    }
    
    /**
     * Copies the current style into the passed style attribute. Checks for
     * inline styles first, then internal and extranal style sheets, and finally
     * checks for presentation attributes. Recursively checks parents.
     *
     * @param attrib - Attribute to write style data to. Must have it's name set
     * to the name of the style being queried.
     * @param recursive - If true and this object does not contain the named
     * style attribute, checks attributes of parents back to root until one
     * found.
     */
    public boolean getStyle(StyleAttribute attrib, boolean recursive, boolean evalAnimation)
            throws SVGException
    {
        String styName = attrib.getName();

        //Check for local inline styles
        StyleAttribute styAttr = (StyleAttribute)inlineStyles.get(styName);

        attrib.setStringValue(styAttr == null ? """" : styAttr.getStringValue());

        //Evalutate coresponding track, if one exists
        if (evalAnimation)
        {
            TrackBase track = trackManager.getTrack(styName, AnimationElement.AT_CSS);
            if (track != null)
            {
                track.getValue(attrib, diagram.getUniverse().getCurTime());
                return true;
            }
        }

        //Return if we've found a non animated style
        if (styAttr != null)
        {
            return true;
        }


        //Check for presentation attribute
        StyleAttribute presAttr = (StyleAttribute)presAttribs.get(styName);

        attrib.setStringValue(presAttr == null ? """" : presAttr.getStringValue());

        //Evalutate coresponding track, if one exists
        if (evalAnimation)
        {
            TrackBase track = trackManager.getTrack(styName, AnimationElement.AT_XML);
            if (track != null)
            {
                track.getValue(attrib, diagram.getUniverse().getCurTime());
                return true;
            }
        }

        //Return if we've found a presentation attribute instead
        if (presAttr != null)
        {
            return true;
        }

        //Check for style sheet
        SVGRoot root = getRoot();
        if (root != null)
        {
            StyleSheet ss = root.getStyleSheet();
            if (ss != null)
            {
                return ss.getStyle(attrib, getTagName(), cssClass);
            }
        }

        //If we're recursive, check parents
        if (recursive)
        {
            SVGElement parentContext = getParentContext();
            if (parentContext != null)
            {
                return parentContext.getStyle(attrib, true);
            }
            if (parent != null)
            {
                return parent.getStyle(attrib, true);
            }
        }

        //Unsuccessful reading style attribute
        return false;
    }

    /**
     * @return the raw style value of this attribute. Does not take the
     * presentation value or animation into consideration. Used by animations to
     * determine the base to animate from.
     */
    public StyleAttribute getStyleAbsolute(String styName)
    {
        //Check for local inline styles
        return (StyleAttribute) inlineStyles.get(styName);
    }

    /**
     * Copies the presentation attribute into the passed one.
     *
     * @return - True if attribute was read successfully
     */
    public boolean getPres(StyleAttribute attrib) throws SVGException
    {
        String presName = attrib.getName();

        //Make sure we have a coresponding presentation attribute
        StyleAttribute presAttr = (StyleAttribute) presAttribs.get(presName);

        //Copy presentation value directly
        attrib.setStringValue(presAttr == null ? """" : presAttr.getStringValue());

        //Evalutate coresponding track, if one exists
        TrackBase track = trackManager.getTrack(presName, AnimationElement.AT_XML);
        if (track != null)
        {
            track.getValue(attrib, diagram.getUniverse().getCurTime());
            return true;
        }

        //Return if we found presentation attribute
        if (presAttr != null)
        {
            return true;
        }

        return false;
    }

    /**
     * @return the raw presentation value of this attribute. Ignores any
     * modifications applied by style attributes or animation. Used by
     * animations to determine the starting point to animate from
     */
    public StyleAttribute getPresAbsolute(String styName)
    {
        //Check for local inline styles
        return (StyleAttribute) presAttribs.get(styName);
    }

    static protected AffineTransform parseTransform(String val) throws SVGException
    {
        final Matcher matchExpression = Pattern.compile(""\\w+\\([^)]*\\)"").matcher("""");

        AffineTransform retXform = new AffineTransform();

        matchExpression.reset(val);
        while (matchExpression.find())
        {
            retXform.concatenate(parseSingleTransform(matchExpression.group()));
        }

        return retXform;
    }

    static public AffineTransform parseSingleTransform(String val) throws SVGException
    {
        final Matcher matchWord = Pattern.compile(""[-.\\w]+"").matcher("""");

        AffineTransform retXform = new AffineTransform();

        matchWord.reset(val);
        if (!matchWord.find())
        {
            //Return identity transformation if no data present (eg, empty string)
            return retXform;
        }

        String function = matchWord.group().toLowerCase();

        LinkedList termList = new LinkedList();
        while (matchWord.find())
        {
            termList.add(matchWord.group());
        }


        double[] terms = new double[termList.size()];
        Iterator it = termList.iterator();
        int count = 0;
        while (it.hasNext())
        {
            terms[count++] = XMLParseUtil.parseDouble((String) it.next());
        }

        //Calculate transformation
        if (function.equals(""matrix""))
        {
            retXform.setTransform(terms[0], terms[1], terms[2], terms[3], terms[4], terms[5]);
        } else if (function.equals(""translate""))
        {
            if (terms.length == 1)
            {
                retXform.setToTranslation(terms[0], 0);
            } else
            {
                retXform.setToTranslation(terms[0], terms[1]);
            }
        } else if (function.equals(""scale""))
        {
            if (terms.length > 1)
            {
                retXform.setToScale(terms[0], terms[1]);
            } else
            {
                retXform.setToScale(terms[0], terms[0]);
            }
        } else if (function.equals(""rotate""))
        {
            if (terms.length > 2)
            {
                retXform.setToRotation(Math.toRadians(terms[0]), terms[1], terms[2]);
            } else
            {
                retXform.setToRotation(Math.toRadians(terms[0]));
            }
        } else if (function.equals(""skewx""))
        {
            retXform.setToShear(Math.toRadians(terms[0]), 0.0);
        } else if (function.equals(""skewy""))
        {
            retXform.setToShear(0.0, Math.toRadians(terms[0]));
        } else
        {
            throw new SVGException(""Unknown transform type"");
        }

        return retXform;
    }

    static protected float nextFloat(LinkedList l)
    {
        String s = (String) l.removeFirst();
        return Float.parseFloat(s);
    }

    static public PathCommand[] parsePathList(String list)
    {
        final Matcher matchPathCmd = Pattern.compile(""([MmLlHhVvAaQqTtCcSsZz])|([-+]?((\\d*\\.\\d+)|(\\d+))([eE][-+]?\\d+)?)"").matcher(list);

        //Tokenize
        LinkedList tokens = new LinkedList();
        while (matchPathCmd.find())
        {
            tokens.addLast(matchPathCmd.group());
        }


        boolean defaultRelative = false;
        LinkedList cmdList = new LinkedList();
        char curCmd = 'Z';
        while (tokens.size() != 0)
        {
            String curToken = (String) tokens.removeFirst();
            char initChar = curToken.charAt(0);
            if ((initChar >= 'A' && initChar <= 'Z') || (initChar >= 'a' && initChar <= 'z'))
            {
                curCmd = initChar;
            } else
            {
                tokens.addFirst(curToken);
            }

            PathCommand cmd = null;

            switch (curCmd)
            {
                case 'M':
                    cmd = new MoveTo(false, nextFloat(tokens), nextFloat(tokens));
                    curCmd = 'L';
                    break;
                case 'm':
                    cmd = new MoveTo(true, nextFloat(tokens), nextFloat(tokens));
                    curCmd = 'l';
                    break;
                case 'L':
                    cmd = new LineTo(false, nextFloat(tokens), nextFloat(tokens));
                    break;
                case 'l':
                    cmd = new LineTo(true, nextFloat(tokens), nextFloat(tokens));
                    break;
                case 'H':
                    cmd = new Horizontal(false, nextFloat(tokens));
                    break;
                case 'h':
                    cmd = new Horizontal(true, nextFloat(tokens));
                    break;
                case 'V':
                    cmd = new Vertical(false, nextFloat(tokens));
                    break;
                case 'v':
                    cmd = new Vertical(true, nextFloat(tokens));
                    break;
                case 'A':
                    cmd = new Arc(false, nextFloat(tokens), nextFloat(tokens),
                        nextFloat(tokens),
                        nextFloat(tokens) == 1f, nextFloat(tokens) == 1f,
                        nextFloat(tokens), nextFloat(tokens));
                    break;
                case 'a':
                    cmd = new Arc(true, nextFloat(tokens), nextFloat(tokens),
                        nextFloat(tokens),
                        nextFloat(tokens) == 1f, nextFloat(tokens) == 1f,
                        nextFloat(tokens), nextFloat(tokens));
                    break;
                case 'Q':
                    cmd = new Quadratic(false, nextFloat(tokens), nextFloat(tokens),
                        nextFloat(tokens), nextFloat(tokens));
                    break;
                case 'q':
                    cmd = new Quadratic(true, nextFloat(tokens), nextFloat(tokens),
                        nextFloat(tokens), nextFloat(tokens));
                    break;
                case 'T':
                    cmd = new QuadraticSmooth(false, nextFloat(tokens), nextFloat(tokens));
                    break;
                case 't':
                    cmd = new QuadraticSmooth(true, nextFloat(tokens), nextFloat(tokens));
                    break;
                case 'C':
                    cmd = new Cubic(false, nextFloat(tokens), nextFloat(tokens),
                        nextFloat(tokens), nextFloat(tokens),
                        nextFloat(tokens), nextFloat(tokens));
                    break;
                case 'c':
                    cmd = new Cubic(true, nextFloat(tokens), nextFloat(tokens),
                        nextFloat(tokens), nextFloat(tokens),
                        nextFloat(tokens), nextFloat(tokens));
                    break;
                case 'S':
                    cmd = new CubicSmooth(false, nextFloat(tokens), nextFloat(tokens),
                        nextFloat(tokens), nextFloat(tokens));
                    break;
                case 's':
                    cmd = new CubicSmooth(true, nextFloat(tokens), nextFloat(tokens),
                        nextFloat(tokens), nextFloat(tokens));
                    break;
                case 'Z':
                case 'z':
                    cmd = new Terminal();
                    break;
                default:
                    throw new RuntimeException(""Invalid path element"");
            }

            cmdList.add(cmd);
            defaultRelative = cmd.isRelative;
        }

        PathCommand[] retArr = new PathCommand[cmdList.size()];
        cmdList.toArray(retArr);
        return retArr;
    }

    static public GeneralPath buildPath(String text, int windingRule)
    {
        PathCommand[] commands = parsePathList(text);

        int numKnots = 2;
        for (int i = 0; i < commands.length; i++)
        {
            numKnots += commands[i].getNumKnotsAdded();
        }


        GeneralPath path = new GeneralPath(windingRule, numKnots);

        BuildHistory hist = new BuildHistory();

        for (int i = 0; i < commands.length; i++)
        {
            PathCommand cmd = commands[i];
            cmd.appendPath(path, hist);
        }

        return path;
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    abstract public boolean updateTime(double curTime) throws SVGException;
    
    public boolean hasChildren() {
    	return children.isEmpty();
    }
    
    public List<SVGElement> getChildren() {
    	return Collections.unmodifiableList(children);
    }

    public int getNumChildren()
    {
        return children.size();
    }

    public SVGElement getChild(int i)
    {
        return (SVGElement) children.get(i);
    }

    public double lerp(double t0, double t1, double alpha)
    {
        return (1 - alpha) * t0 + alpha * t1;
    }
}
"
SVGElementException.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on May 12, 2005, 11:32 PM
 */

package com.kitfox.svg;

/**
 *
 * @author kitfox
 */
public class SVGElementException extends SVGException
{
    public static final long serialVersionUID = 0;
    
    private final SVGElement element;
    
    /**
     * Creates a new instance of <code>SVGException</code> without detail message.
     */
    public SVGElementException(SVGElement element)
    {
        this(element, null, null);
    }
    
    
    /**
     * Constructs an instance of <code>SVGException</code> with the specified detail message.
     * @param msg the detail message.
     */
    public SVGElementException(SVGElement element, String msg)
    {
        this(element, msg, null);
    }
    
    public SVGElementException(SVGElement element, String msg, Throwable cause)
    {
        super(msg, cause);
        this.element = element;
    }
    
    public SVGElementException(SVGElement element, Throwable cause)
    {
        this(element, null, cause);
    }

    public SVGElement getElement()
    {
        return element;
    }
}
"
SVGException.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on May 12, 2005, 11:32 PM
 */

package com.kitfox.svg;

/**
 *
 * @author kitfox
 */
public class SVGException extends java.lang.Exception
{
    public static final long serialVersionUID = 0;
    
    /**
     * Creates a new instance of <code>SVGException</code> without detail message.
     */
    public SVGException()
    {
    }
    
    
    /**
     * Constructs an instance of <code>SVGException</code> with the specified detail message.
     * @param msg the detail message.
     */
    public SVGException(String msg)
    {
        super(msg);
    }
    
    public SVGException(String msg, Throwable cause)
    {
        super(msg, cause);
    }
    
    public SVGException(Throwable cause)
    {
        super(cause);
    }
}
"
SVGLoader.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 18, 2004, 5:09 PM
 */

package com.kitfox.svg;


import java.util.*;
import java.net.*;
import org.xml.sax.*;
import org.xml.sax.helpers.DefaultHandler;

import com.kitfox.svg.animation.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class SVGLoader extends DefaultHandler
{
    final HashMap nodeClasses = new HashMap();
    //final HashMap attribClasses = new HashMap();
    final LinkedList buildStack = new LinkedList();

    final HashSet ignoreClasses = new HashSet();

    final SVGLoaderHelper helper;

    /**
     * The diagram that represents the base of this SVG document we're loading.
     * Will be augmented to include node indexing info and other useful stuff.
     */
    final SVGDiagram diagram;

//    SVGElement loadRoot;

    //Used to keep track of document elements that are not part of the SVG namespace
    int skipNonSVGTagDepth = 0;
    int indent = 0;

    final boolean verbose;
    
    /** Creates a new instance of SVGLoader */
    public SVGLoader(URI xmlBase, SVGUniverse universe)
    {
        this(xmlBase, universe, false);
    }
    
    public SVGLoader(URI xmlBase, SVGUniverse universe, boolean verbose)
    {
        this.verbose = verbose;
        
        diagram = new SVGDiagram(xmlBase, universe);

        //Compile a list of important builder classes
        nodeClasses.put(""a"", A.class);
        nodeClasses.put(""animate"", Animate.class);
        nodeClasses.put(""animatecolor"", AnimateColor.class);
        nodeClasses.put(""animatemotion"", AnimateMotion.class);
        nodeClasses.put(""animatetransform"", AnimateTransform.class);
        nodeClasses.put(""circle"", Circle.class);
        nodeClasses.put(""clippath"", ClipPath.class);
        nodeClasses.put(""defs"", Defs.class);
        nodeClasses.put(""desc"", Desc.class);
        nodeClasses.put(""ellipse"", Ellipse.class);
        nodeClasses.put(""filter"", Filter.class);
        nodeClasses.put(""font"", Font.class);
        nodeClasses.put(""font-face"", FontFace.class);
        nodeClasses.put(""g"", Group.class);
        nodeClasses.put(""glyph"", Glyph.class);
        nodeClasses.put(""hkern"", Hkern.class);
        nodeClasses.put(""image"", ImageSVG.class);
        nodeClasses.put(""line"", Line.class);
        nodeClasses.put(""lineargradient"", LinearGradient.class);
        nodeClasses.put(""marker"", Marker.class);
        nodeClasses.put(""metadata"", Metadata.class);
        nodeClasses.put(""missing-glyph"", MissingGlyph.class);
        nodeClasses.put(""path"", Path.class);
        nodeClasses.put(""pattern"", PatternSVG.class);
        nodeClasses.put(""polygon"", Polygon.class);
        nodeClasses.put(""polyline"", Polyline.class);
        nodeClasses.put(""radialgradient"", RadialGradient.class);
        nodeClasses.put(""rect"", Rect.class);
        nodeClasses.put(""set"", SetSmil.class);
        nodeClasses.put(""shape"", ShapeElement.class);
        nodeClasses.put(""stop"", Stop.class);
        nodeClasses.put(""style"", Style.class);
        nodeClasses.put(""svg"", SVGRoot.class);
        nodeClasses.put(""symbol"", Symbol.class);
        nodeClasses.put(""text"", Text.class);
        nodeClasses.put(""title"", Title.class);
        nodeClasses.put(""tspan"", Tspan.class);
        nodeClasses.put(""use"", Use.class);

        ignoreClasses.add(""midpointstop"");

        //attribClasses.put(""clip-path"", StyleUrl.class);
        //attribClasses.put(""color"", StyleColor.class);

        helper = new SVGLoaderHelper(xmlBase, universe, diagram);
    }

    private String printIndent(int indent, String indentStrn)
    {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < indent; i++)
        {
            sb.append(indentStrn);
        }
        return sb.toString();
    }
    
    public void startDocument() throws SAXException
    {
//        System.err.println(""Start doc"");

//        buildStack.clear();
    }

    public void endDocument() throws SAXException
    {
//        System.err.println(""End doc"");
    }

    public void startElement(String namespaceURI, String sName, String qName, Attributes attrs) throws SAXException
    {
        if (verbose)
        {
            System.err.println(printIndent(indent, "" "") + ""Starting parse of tag "" + sName+ "": "" + namespaceURI);
        }
        indent++;
        
        if (skipNonSVGTagDepth != 0 || (!namespaceURI.equals("""") && !namespaceURI.equals(SVGElement.SVG_NS)))
        {
            skipNonSVGTagDepth++;
            return;
        }
        
        sName = sName.toLowerCase();

//javax.swing.JOptionPane.showMessageDialog(null, sName);

        Object obj = nodeClasses.get(sName);
        if (obj == null)
        {
            if (!ignoreClasses.contains(sName))
            {
                if (verbose)
                {
                    System.err.println(""SVGLoader: Could not identify tag '"" + sName + ""'"");
                }
            }
            return;
        }

//Debug info tag depth
//for (int i = 0; i < buildStack.size(); i++) System.err.print("" "");
//System.err.println(""+"" + sName);

        try {
            Class cls = (Class)obj;
            SVGElement svgEle = (SVGElement)cls.newInstance();

            SVGElement parent = null;
            if (buildStack.size() != 0) parent = (SVGElement)buildStack.getLast();
            svgEle.loaderStartElement(helper, attrs, parent);

            buildStack.addLast(svgEle);
        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, 
                ""Could not load"", e);
            throw new SAXException(e);
        }

    }

    public void endElement(String namespaceURI, String sName, String qName)
        throws SAXException
    {
        indent--;
        if (verbose)
        {
            System.err.println(printIndent(indent, "" "") + ""Ending parse of tag "" + sName+ "": "" + namespaceURI);
        }
        
        if (skipNonSVGTagDepth != 0)
        {
            skipNonSVGTagDepth--;
            return;
        }
        
        sName = sName.toLowerCase();

        Object obj = nodeClasses.get(sName);
        if (obj == null) return;

//Debug info tag depth
//for (int i = 0; i < buildStack.size(); i++) System.err.print("" "");
//System.err.println(""-"" + sName);

        try {
            SVGElement svgEle = (SVGElement)buildStack.removeLast();

            svgEle.loaderEndElement(helper);

            SVGElement parent = null;
            if (buildStack.size() != 0)
            {
                parent = (SVGElement)buildStack.getLast();
            }
            //else loadRoot = (SVGElement)svgEle;

            if (parent != null)
            {
                parent.loaderAddChild(helper, svgEle);
            }
            else
            {
                diagram.setRoot((SVGRoot)svgEle);
            }

        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, 
                ""Could not parse"", e);
            throw new SAXException(e);
        }
    }

    public void characters(char buf[], int offset, int len)
        throws SAXException
    {
        if (skipNonSVGTagDepth != 0)
        {
            return;
        }

        if (buildStack.size() != 0)
        {
            SVGElement parent = (SVGElement)buildStack.getLast();
            String s = new String(buf, offset, len);
            parent.loaderAddText(helper, s);
        }
    }

    public void processingInstruction(String target, String data)
        throws SAXException
    {
        //Check for external style sheet
    }
    
//    public SVGElement getLoadRoot() { return loadRoot; }
    public SVGDiagram getLoadedDiagram() { return diagram; }
}
"
SVGLoaderHelper.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 18, 2004, 5:37 PM
 */

package com.kitfox.svg;

import java.net.*;
import java.io.*;

import com.kitfox.svg.animation.parser.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class SVGLoaderHelper
{
    /** This is the URL that this document is being loaded from */
//    public final URL docRoot;
//    public final URI docRoot;

    /** This is the universe of all currently loaded SVG documents */
    public final SVGUniverse universe;

    /** This is the diagram which the load process is currently loading */
    public final SVGDiagram diagram;

    public final URI xmlBase;

    /**
     * Animate nodes use this to parse their time strings
     */
    public final AnimTimeParser animTimeParser = new AnimTimeParser(new StringReader(""""));
    
    /** Creates a new instance of SVGLoaderHelper */
    public SVGLoaderHelper(URI xmlBase, SVGUniverse universe, SVGDiagram diagram)
    {
        this.xmlBase = xmlBase;
        this.universe = universe;
        this.diagram = diagram;
    }

}
"
SVGParseException.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on May 12, 2005, 11:32 PM
 */

package com.kitfox.svg;

/**
 *
 * @author kitfox
 */
public class SVGParseException extends java.lang.Exception
{
    public static final long serialVersionUID = 0;
    
    /**
     * Creates a new instance of <code>SVGException</code> without detail message.
     */
    public SVGParseException()
    {
    }
    
    
    /**
     * Constructs an instance of <code>SVGException</code> with the specified detail message.
     * @param msg the detail message.
     */
    public SVGParseException(String msg)
    {
        super(msg);
    }
    
    public SVGParseException(String msg, Throwable cause)
    {
        super(msg, cause);
    }
    
    public SVGParseException(Throwable cause)
    {
        super(cause);
    }
}
"
SVGRoot.java,kitfox-6.9.6,"/*
 * SVG Salamander Copyright (c) 2004, Mark McKay All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. - Redistributions in binary
 * form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided
 * with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Mark McKay can be contacted at mark@kitfox.com. Salamander and other projects
 * can be found at http://www.kitfox.com
 *
 * Created on February 18, 2004, 5:33 PM
 */

package com.kitfox.svg;

import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.List;

import com.kitfox.svg.xml.NumberWithUnits;
import com.kitfox.svg.xml.StyleAttribute;
import com.kitfox.svg.xml.StyleSheet;

/**
 * The root element of an SVG tree.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class SVGRoot extends Group {
	public static final String TAG_NAME = ""svg"";

	NumberWithUnits x;
	NumberWithUnits y;
	NumberWithUnits width;
	NumberWithUnits height;

	Rectangle2D.Float viewBox = null;

	public static final int PA_X_NONE = 0;
	public static final int PA_X_MIN = 1;
	public static final int PA_X_MID = 2;
	public static final int PA_X_MAX = 3;

	public static final int PA_Y_NONE = 0;
	public static final int PA_Y_MIN = 1;
	public static final int PA_Y_MID = 2;
	public static final int PA_Y_MAX = 3;

	public static final int PS_MEET = 0;
	public static final int PS_SLICE = 1;

	int parSpecifier = PS_MEET;
	int parAlignX = PA_X_MID;
	int parAlignY = PA_Y_MID;

	final AffineTransform viewXform = new AffineTransform();
	final Rectangle2D.Float clipRect = new Rectangle2D.Float();

	private StyleSheet styleSheet;

	private long styleSheetChildrenCounter = -1;

	/** Creates a new instance of SVGRoot */
	public SVGRoot() {
	}

	public String getTagName() {
		return TAG_NAME;
	}

	public void build() throws SVGException {
		super.build();

		StyleAttribute sty = new StyleAttribute();

		if (getPres(sty.setName(""x""))) {
			x = sty.getNumberWithUnits();
		}

		if (getPres(sty.setName(""y""))) {
			y = sty.getNumberWithUnits();
		}

		if (getPres(sty.setName(""width""))) {
			width = sty.getNumberWithUnits();
		}

		if (getPres(sty.setName(""height""))) {
			height = sty.getNumberWithUnits();
		}

		if (getPres(sty.setName(""viewBox""))) {
			float[] coords = sty.getFloatList();
			viewBox = new Rectangle2D.Float(coords[0], coords[1], coords[2], coords[3]);
		}

		if (getPres(sty.setName(""preserveAspectRatio""))) {
			String preserve = sty.getStringValue();

			if (contains(preserve, ""none"")) {
				parAlignX = PA_X_NONE;
				parAlignY = PA_Y_NONE;
			} else if (contains(preserve, ""xMinYMin"")) {
				parAlignX = PA_X_MIN;
				parAlignY = PA_Y_MIN;
			} else if (contains(preserve, ""xMidYMin"")) {
				parAlignX = PA_X_MID;
				parAlignY = PA_Y_MIN;
			} else if (contains(preserve, ""xMaxYMin"")) {
				parAlignX = PA_X_MAX;
				parAlignY = PA_Y_MIN;
			} else if (contains(preserve, ""xMinYMid"")) {
				parAlignX = PA_X_MIN;
				parAlignY = PA_Y_MID;
			} else if (contains(preserve, ""xMidYMid"")) {
				parAlignX = PA_X_MID;
				parAlignY = PA_Y_MID;
			} else if (contains(preserve, ""xMaxYMid"")) {
				parAlignX = PA_X_MAX;
				parAlignY = PA_Y_MID;
			} else if (contains(preserve, ""xMinYMax"")) {
				parAlignX = PA_X_MIN;
				parAlignY = PA_Y_MAX;
			} else if (contains(preserve, ""xMidYMax"")) {
				parAlignX = PA_X_MID;
				parAlignY = PA_Y_MAX;
			} else if (contains(preserve, ""xMaxYMax"")) {
				parAlignX = PA_X_MAX;
				parAlignY = PA_Y_MAX;
			}

			if (contains(preserve, ""meet"")) {
				parSpecifier = PS_MEET;
			} else if (contains(preserve, ""slice"")) {
				parSpecifier = PS_SLICE;
			}
		}

		prepareViewport();
	}

	private boolean contains(String text, String find) {
		return (text.indexOf(find) != -1);
	}

	public SVGRoot getRoot() {
		return this;
	}

	protected void prepareViewport() {
		Rectangle deviceViewport = diagram.getDeviceViewport();

		Rectangle2D defaultBounds;
		try {
			defaultBounds = getBoundingBox();
		} catch (SVGException ex) {
			defaultBounds = new Rectangle2D.Float();
		}

		//Determine destination rectangle
		float xx, yy, ww, hh;
		if (width != null) {
			xx = (x == null) ? 0 : StyleAttribute.convertUnitsToPixels(x.getUnits(), x.getValue());
			if (width.getUnits() == NumberWithUnits.UT_PERCENT) {
				ww = width.getValue() * deviceViewport.width;
			} else {
				ww = StyleAttribute.convertUnitsToPixels(width.getUnits(), width.getValue());
			}
		} else if (viewBox != null) {
			xx = (float) viewBox.x;
			ww = (float) viewBox.width;
			width = new NumberWithUnits(ww, NumberWithUnits.UT_PX);
			x = new NumberWithUnits(xx, NumberWithUnits.UT_PX);
		} else {
			//Estimate size from scene bounding box
			xx = (float) defaultBounds.getX();
			ww = (float) defaultBounds.getWidth();
			width = new NumberWithUnits(ww, NumberWithUnits.UT_PX);
			x = new NumberWithUnits(xx, NumberWithUnits.UT_PX);
		}

		if (height != null) {
			yy = (y == null) ? 0 : StyleAttribute.convertUnitsToPixels(y.getUnits(), y.getValue());
			if (height.getUnits() == NumberWithUnits.UT_PERCENT) {
				hh = height.getValue() * deviceViewport.height;
			} else {
				hh = StyleAttribute.convertUnitsToPixels(height.getUnits(), height.getValue());
			}
		} else if (viewBox != null) {
			yy = (float) viewBox.y;
			hh = (float) viewBox.height;
			height = new NumberWithUnits(hh, NumberWithUnits.UT_PX);
			y = new NumberWithUnits(yy, NumberWithUnits.UT_PX);
		} else {
			//Estimate size from scene bounding box
			yy = (float) defaultBounds.getY();
			hh = (float) defaultBounds.getHeight();
			height = new NumberWithUnits(hh, NumberWithUnits.UT_PX);
			y = new NumberWithUnits(yy, NumberWithUnits.UT_PX);
		}

		clipRect.setRect(xx, yy, ww, hh);

		if (viewBox == null) {
			viewXform.setToIdentity();
		} else {
			viewXform.setToTranslation(clipRect.x, clipRect.y);
			viewXform.scale(clipRect.width, clipRect.height);
			viewXform.scale(1 / viewBox.width, 1 / viewBox.height);
			viewXform.translate(-viewBox.x, -viewBox.y);
		}
	}

	public void render(Graphics2D g) throws SVGException {
		prepareViewport();

		AffineTransform cachedXform = g.getTransform();
		g.transform(viewXform);

		super.render(g);

		g.setTransform(cachedXform);
	}

	public void pick(Rectangle2D pickArea, AffineTransform ltw, boolean boundingBox, List retVec) throws SVGException {
		if (viewXform != null) {
			ltw = new AffineTransform(ltw);
			ltw.concatenate(viewXform);
		}

		super.pick(pickArea, ltw, boundingBox, retVec);
	}

	public void pick(Point2D point, boolean boundingBox, List retVec) throws SVGException {
		Point2D xPoint = new Point2D.Double(point.getX(), point.getY());
		if (viewXform != null) {
			try {
				viewXform.inverseTransform(point, xPoint);
			} catch (NoninvertibleTransformException ex) {
				throw new SVGException(ex);
			}
		}

		super.pick(xPoint, boundingBox, retVec);
	}

	public Shape getShape() {
		Shape shape = super.getShape();
		return viewXform.createTransformedShape(shape);
	}

	public Rectangle2D getBoundingBox() throws SVGException {
		Rectangle2D bbox = super.getBoundingBox();
		return viewXform.createTransformedShape(bbox).getBounds2D();
	}

	public float getDeviceWidth() {
		return clipRect.width;
	}

	public float getDeviceHeight() {
		return clipRect.height;
	}

	public Rectangle2D getDeviceRect(Rectangle2D rect) {
		rect.setRect(clipRect);
		return rect;
	}

	/**
	 * Updates all attributes in this diagram associated with a time event. Ie,
	 * all attributes with track information.
	 * 
	 * @return - true if this node has changed state as a result of the time
	 *         update
	 */
	public boolean updateTime(double curTime) throws SVGException {
		boolean changeState = super.updateTime(curTime);

		StyleAttribute sty = new StyleAttribute();
		boolean shapeChange = false;

		if (getPres(sty.setName(""x""))) {
			NumberWithUnits newVal = sty.getNumberWithUnits();
			if (!newVal.equals(x)) {
				x = newVal;
				shapeChange = true;
			}
		}

		if (getPres(sty.setName(""y""))) {
			NumberWithUnits newVal = sty.getNumberWithUnits();
			if (!newVal.equals(y)) {
				y = newVal;
				shapeChange = true;
			}
		}

		if (getPres(sty.setName(""width""))) {
			NumberWithUnits newVal = sty.getNumberWithUnits();
			if (!newVal.equals(width)) {
				width = newVal;
				shapeChange = true;
			}
		}

		if (getPres(sty.setName(""height""))) {
			NumberWithUnits newVal = sty.getNumberWithUnits();
			if (!newVal.equals(height)) {
				height = newVal;
				shapeChange = true;
			}
		}

		if (getPres(sty.setName(""viewBox""))) {
			float[] coords = sty.getFloatList();
			Rectangle2D.Float newViewBox = new Rectangle2D.Float(coords[0], coords[1], coords[2], coords[3]);
			if (!newViewBox.equals(viewBox)) {
				viewBox = newViewBox;
				shapeChange = true;
			}
		}

		if (shapeChange) {
			build();
		}

		return changeState || shapeChange;
	}

	/**
	 * @return the styleSheet
	 */
	public StyleSheet getStyleSheet() {
		if (styleSheet == null) {
			if (childrenChangeCounter != styleSheetChildrenCounter) {
				for (int i = 0; i < getNumChildren(); ++i) {
					SVGElement ele = getChild(i);
					if (ele instanceof Style) {
						return ((Style) ele).getStyleSheet();
					}
				}
				styleSheetChildrenCounter = childrenChangeCounter;
			}
		}

		return styleSheet;
	}

	/**
	 * @param styleSheet
	 *            the styleSheet to set
	 */
	public void setStyleSheet(StyleSheet styleSheet) {
		this.styleSheet = styleSheet;
	}

	public AffineTransform getViewXform() {
		return new AffineTransform(viewXform);
	}
}
"
SVGUniverse.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 18, 2004, 11:43 PM
 */
package com.kitfox.svg;

import com.kitfox.svg.app.beans.SVGIcon;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Reader;
import java.io.Serializable;
import java.lang.ref.SoftReference;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.GZIPInputStream;
import javax.imageio.ImageIO;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

/**
 * Many SVG files can be loaded at one time. These files will quite likely need
 * to reference one another. The SVG universe provides a container for all these
 * files and the means for them to relate to each other.
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class SVGUniverse implements Serializable
{

    public static final long serialVersionUID = 0;
    transient private PropertyChangeSupport changes = new PropertyChangeSupport(this);
    /**
     * Maps document URIs to their loaded SVG diagrams. Note that URIs for
     * documents loaded from URLs will reflect their URLs and URIs for documents
     * initiated from streams will have the scheme <i>svgSalamander</i>.
     */
    final HashMap loadedDocs = new HashMap();
    final HashMap loadedFonts = new HashMap();
    final HashMap loadedImages = new HashMap();
    public static final String INPUTSTREAM_SCHEME = ""svgSalamander"";
    /**
     * Current time in this universe. Used for resolving attributes that are
     * influenced by track information. Time is in milliseconds. Time 0
     * coresponds to the time of 0 in each member diagram.
     */
    protected double curTime = 0.0;
    private boolean verbose = false;
    //Cache reader for efficiency
    XMLReader cachedReader;

    /**
     * Creates a new instance of SVGUniverse
     */
    public SVGUniverse()
    {
    }

    public void addPropertyChangeListener(PropertyChangeListener l)
    {
        changes.addPropertyChangeListener(l);
    }

    public void removePropertyChangeListener(PropertyChangeListener l)
    {
        changes.removePropertyChangeListener(l);
    }

    /**
     * Release all loaded SVG document from memory
     */
    public void clear()
    {
        loadedDocs.clear();
        loadedFonts.clear();
        loadedImages.clear();
    }

    /**
     * Returns the current animation time in milliseconds.
     */
    public double getCurTime()
    {
        return curTime;
    }

    public void setCurTime(double curTime)
    {
        double oldTime = this.curTime;
        this.curTime = curTime;
        changes.firePropertyChange(""curTime"", new Double(oldTime), new Double(curTime));
    }

    /**
     * Updates all time influenced style and presentation attributes in all SVG
     * documents in this universe.
     */
    public void updateTime() throws SVGException
    {
        for (Iterator it = loadedDocs.values().iterator(); it.hasNext();)
        {
            SVGDiagram dia = (SVGDiagram) it.next();
            dia.updateTime(curTime);
        }
    }

    /**
     * Called by the Font element to let the universe know that a font has been
     * loaded and is available.
     */
    void registerFont(Font font)
    {
        loadedFonts.put(font.getFontFace().getFontFamily(), font);
    }

    public Font getDefaultFont()
    {
        for (Iterator it = loadedFonts.values().iterator(); it.hasNext();)
        {
            return (Font) it.next();
        }
        return null;
    }

    public Font getFont(String fontName)
    {
        return (Font) loadedFonts.get(fontName);
    }

    URL registerImage(URI imageURI)
    {
        String scheme = imageURI.getScheme();
        if (scheme.equals(""data""))
        {
            String path = imageURI.getRawSchemeSpecificPart();
            int idx = path.indexOf(';');
            String mime = path.substring(0, idx);
            String content = path.substring(idx + 1);

            if (content.startsWith(""base64""))
            {
                content = content.substring(6);
                try
                {
                    byte[] buf = new sun.misc.BASE64Decoder().decodeBuffer(content);
                    ByteArrayInputStream bais = new ByteArrayInputStream(buf);
                    BufferedImage img = ImageIO.read(bais);

                    URL url;
                    int urlIdx = 0;
                    while (true)
                    {
                        url = new URL(""inlineImage"", ""localhost"", ""img"" + urlIdx);
                        if (!loadedImages.containsKey(url))
                        {
                            break;
                        }
                        urlIdx++;
                    }

                    SoftReference ref = new SoftReference(img);
                    loadedImages.put(url, ref);

                    return url;
                } catch (IOException ex)
                {
                    Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                        ""Could not decode inline image"", ex);
                }
            }
            return null;
        } else
        {
            try
            {
                URL url = imageURI.toURL();
                registerImage(url);
                return url;
            } catch (MalformedURLException ex)
            {
                Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                    ""Bad url"", ex);
            }
            return null;
        }
    }

    void registerImage(URL imageURL)
    {
        if (loadedImages.containsKey(imageURL))
        {
            return;
        }

        SoftReference ref;
        try
        {
            String fileName = imageURL.getFile();
            if ("".svg"".equals(fileName.substring(fileName.length() - 4).toLowerCase()))
            {
                SVGIcon icon = new SVGIcon();
                icon.setSvgURI(imageURL.toURI());

                BufferedImage img = new BufferedImage(icon.getIconWidth(), icon.getIconHeight(), BufferedImage.TYPE_INT_ARGB);
                Graphics2D g = img.createGraphics();
                icon.paintIcon(null, g, 0, 0);
                g.dispose();
                ref = new SoftReference(img);
            } else
            {
                BufferedImage img = ImageIO.read(imageURL);
                ref = new SoftReference(img);
            }
            loadedImages.put(imageURL, ref);
        } catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Could not load image: "" + imageURL, e);
        }
    }

    BufferedImage getImage(URL imageURL)
    {
        SoftReference ref = (SoftReference) loadedImages.get(imageURL);
        if (ref == null)
        {
            return null;
        }

        BufferedImage img = (BufferedImage) ref.get();
        //If image was cleared from memory, reload it
        if (img == null)
        {
            try
            {
                img = ImageIO.read(imageURL);
            } catch (Exception e)
            {
                Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                    ""Could not load image"", e);
            }
            ref = new SoftReference(img);
            loadedImages.put(imageURL, ref);
        }

        return img;
    }

    /**
     * Returns the element of the document at the given URI. If the document is
     * not already loaded, it will be.
     */
    public SVGElement getElement(URI path)
    {
        return getElement(path, true);
    }

    public SVGElement getElement(URL path)
    {
        try
        {
            URI uri = new URI(path.toString());
            return getElement(uri, true);
        } catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Could not parse url "" + path, e);
        }
        return null;
    }

    /**
     * Looks up a href within our universe. If the href refers to a document
     * that is not loaded, it will be loaded. The URL #target will then be
     * checked against the SVG diagram's index and the coresponding element
     * returned. If there is no coresponding index, null is returned.
     */
    public SVGElement getElement(URI path, boolean loadIfAbsent)
    {
        try
        {
            //Strip fragment from URI
            URI xmlBase = new URI(path.getScheme(), path.getSchemeSpecificPart(), null);

            SVGDiagram dia = (SVGDiagram) loadedDocs.get(xmlBase);
            if (dia == null && loadIfAbsent)
            {
//System.err.println(""SVGUnivserse: "" + xmlBase.toString());
//javax.swing.JOptionPane.showMessageDialog(null, xmlBase.toString());
                URL url = xmlBase.toURL();

                loadSVG(url, false);
                dia = (SVGDiagram) loadedDocs.get(xmlBase);
                if (dia == null)
                {
                    return null;
                }
            }

            String fragment = path.getFragment();
            return fragment == null ? dia.getRoot() : dia.getElement(fragment);
        } catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Could not parse path "" + path, e);
            return null;
        }
    }

    public SVGDiagram getDiagram(URI xmlBase)
    {
        return getDiagram(xmlBase, true);
    }

    /**
     * Returns the diagram that has been loaded from this root. If diagram is
     * not already loaded, returns null.
     */
    public SVGDiagram getDiagram(URI xmlBase, boolean loadIfAbsent)
    {
        if (xmlBase == null)
        {
            return null;
        }

        SVGDiagram dia = (SVGDiagram) loadedDocs.get(xmlBase);
        if (dia != null || !loadIfAbsent)
        {
            return dia;
        }

        //Load missing diagram
        try
        {
            URL url;
            if (""jar"".equals(xmlBase.getScheme()) && xmlBase.getPath() != null && !xmlBase.getPath().contains(""!/""))
            {
                //Workaround for resources stored in jars loaded by Webstart.
                //http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6753651
                url = SVGUniverse.class.getResource(""xmlBase.getPath()"");
            }
            else
            {
                url = xmlBase.toURL();
            }


            loadSVG(url, false);
            dia = (SVGDiagram) loadedDocs.get(xmlBase);
            return dia;
        } catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Could not parse"", e);
        }

        return null;
    }

    /**
     * Wraps input stream in a BufferedInputStream. If it is detected that this
     * input stream is GZIPped, also wraps in a GZIPInputStream for inflation.
     *
     * @param is Raw input stream
     * @return Uncompressed stream of SVG data
     * @throws java.io.IOException
     */
    private InputStream createDocumentInputStream(InputStream is) throws IOException
    {
        BufferedInputStream bin = new BufferedInputStream(is);
        bin.mark(2);
        int b0 = bin.read();
        int b1 = bin.read();
        bin.reset();

        //Check for gzip magic number
        if ((b1 << 8 | b0) == GZIPInputStream.GZIP_MAGIC)
        {
            GZIPInputStream iis = new GZIPInputStream(bin);
            return iis;
        } else
        {
            //Plain text
            return bin;
        }
    }

    public URI loadSVG(URL docRoot)
    {
        return loadSVG(docRoot, false);
    }

    /**
     * Loads an SVG file and all the files it references from the URL provided.
     * If a referenced file already exists in the SVG universe, it is not
     * reloaded.
     *
     * @param docRoot - URL to the location where this SVG file can be found.
     * @param forceLoad - if true, ignore cached diagram and reload
     * @return - The URI that refers to the loaded document
     */
    public URI loadSVG(URL docRoot, boolean forceLoad)
    {
        try
        {
            URI uri = new URI(docRoot.toString());
            if (loadedDocs.containsKey(uri) && !forceLoad)
            {
                return uri;
            }

            InputStream is = docRoot.openStream();
            return loadSVG(uri, new InputSource(createDocumentInputStream(is)));
        } catch (URISyntaxException ex)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Could not parse"", ex);
        } catch (IOException e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Could not parse"", e);
        }

        return null;
    }

    public URI loadSVG(InputStream is, String name) throws IOException
    {
        return loadSVG(is, name, false);
    }

    public URI loadSVG(InputStream is, String name, boolean forceLoad) throws IOException
    {
        URI uri = getStreamBuiltURI(name);
        if (uri == null)
        {
            return null;
        }
        if (loadedDocs.containsKey(uri) && !forceLoad)
        {
            return uri;
        }

        return loadSVG(uri, new InputSource(createDocumentInputStream(is)));
    }

    public URI loadSVG(Reader reader, String name)
    {
        return loadSVG(reader, name, false);
    }

    /**
     * This routine allows you to create SVG documents from data streams that
     * may not necessarily have a URL to load from. Since every SVG document
     * must be identified by a unique URL, Salamander provides a method to fake
     * this for streams by defining it's own protocol - svgSalamander - for SVG
     * documents without a formal URL.
     *
     * @param reader - A stream containing a valid SVG document
     * @param name - <p>A unique name for this document. It will be used to
     * construct a unique URI to refer to this document and perform resolution
     * with relative URIs within this document.</p> <p>For example, a name of
     * ""/myScene"" will produce the URI svgSalamander:/myScene.
     * ""/maps/canada/toronto"" will produce svgSalamander:/maps/canada/toronto.
     * If this second document then contained the href ""../uk/london"", it would
     * resolve by default to svgSalamander:/maps/uk/london. That is, SVG
     * Salamander defines the URI scheme svgSalamander for it's own internal use
     * and uses it for uniquely identfying documents loaded by stream.</p> <p>If
     * you need to link to documents outside of this scheme, you can either
     * supply full hrefs (eg, href=""url(http://www.kitfox.com/index.html)"") or
     * put the xml:base attribute in a tag to change the defaultbase URIs are
     * resolved against</p> <p>If a name does not start with the character '/',
     * it will be automatically prefixed to it.</p>
     * @param forceLoad - if true, ignore cached diagram and reload
     *
     * @return - The URI that refers to the loaded document
     */
    public URI loadSVG(Reader reader, String name, boolean forceLoad)
    {
//System.err.println(url.toString());
        //Synthesize URI for this stream
        URI uri = getStreamBuiltURI(name);
        if (uri == null)
        {
            return null;
        }
        if (loadedDocs.containsKey(uri) && !forceLoad)
        {
            return uri;
        }

        return loadSVG(uri, new InputSource(reader));
    }

    /**
     * Synthesize a URI for an SVGDiagram constructed from a stream.
     *
     * @param name - Name given the document constructed from a stream.
     */
    public URI getStreamBuiltURI(String name)
    {
        if (name == null || name.length() == 0)
        {
            return null;
        }

        if (name.charAt(0) != '/')
        {
            name = '/' + name;
        }

        try
        {
            //Dummy URL for SVG documents built from image streams
            return new URI(INPUTSTREAM_SCHEME, name, null);
        } catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Could not parse"", e);
            return null;
        }
    }

    private XMLReader getXMLReaderCached() throws SAXException
    {
        if (cachedReader == null)
        {
            cachedReader = XMLReaderFactory.createXMLReader();
        }
        return cachedReader;
    }

    protected URI loadSVG(URI xmlBase, InputSource is)
    {
        // Use an instance of ourselves as the SAX event handler
        SVGLoader handler = new SVGLoader(xmlBase, this, verbose);

        //Place this docment in the universe before it is completely loaded
        // so that the load process can refer to references within it's current
        // document
        loadedDocs.put(xmlBase, handler.getLoadedDiagram());

        try
        {
            // Parse the input
            XMLReader reader = getXMLReaderCached();
            reader.setEntityResolver(
                new EntityResolver()
                {
                    public InputSource resolveEntity(String publicId, String systemId)
                    {
                        //Ignore all DTDs
                        return new InputSource(new ByteArrayInputStream(new byte[0]));
                    }
                });
            reader.setContentHandler(handler);
            reader.parse(is);

            handler.getLoadedDiagram().updateTime(curTime);
            return xmlBase;
        } catch (SAXParseException sex)
        {
            System.err.println(""Error processing "" + xmlBase);
            System.err.println(sex.getMessage());

            loadedDocs.remove(xmlBase);
            return null;
        } catch (Throwable e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Could not load SVG "" + xmlBase, e);
        }

        return null;
    }

    /**
     * Get list of uris of all loaded documents and subdocuments.
     * @return 
     */
    public ArrayList getLoadedDocumentURIs()
    {
        return new ArrayList(loadedDocs.keySet());
    }
    
    /**
     * Remove loaded document from cache.
     * @param uri 
     */
    public void removeDocument(URI uri)
    {
        loadedDocs.remove(uri);
    }
    
    public boolean isVerbose()
    {
        return verbose;
    }

    public void setVerbose(boolean verbose)
    {
        this.verbose = verbose;
    }

    /**
     * Uses serialization to duplicate this universe.
     */
    public SVGUniverse duplicate() throws IOException, ClassNotFoundException
    {
        ByteArrayOutputStream bs = new ByteArrayOutputStream();
        ObjectOutputStream os = new ObjectOutputStream(bs);
        os.writeObject(this);
        os.close();

        ByteArrayInputStream bin = new ByteArrayInputStream(bs.toByteArray());
        ObjectInputStream is = new ObjectInputStream(bin);
        SVGUniverse universe = (SVGUniverse) is.readObject();
        is.close();

        return universe;
    }
}
"
Symbol.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 1:56 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Rectangle2D;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Symbol extends Group
{

    public static final String TAG_NAME = ""symbol"";
    AffineTransform viewXform;
    Rectangle2D viewBox;

    /**
     * Creates a new instance of Stop
     */
    public Symbol()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

//        sty = getPres(""unicode"");
//        if (sty != null) unicode = sty.getStringValue();


        if (getPres(sty.setName(""viewBox"")))
        {
            float[] dim = sty.getFloatList();
            viewBox = new Rectangle2D.Float(dim[0], dim[1], dim[2], dim[3]);
        }

        if (viewBox == null)
        {
//            viewBox = super.getBoundingBox();
            viewBox = new Rectangle(0, 0, 1, 1);
        }

        //Transform pattern onto unit square
        viewXform = new AffineTransform();
        viewXform.scale(1.0 / viewBox.getWidth(), 1.0 / viewBox.getHeight());
        viewXform.translate(-viewBox.getX(), -viewBox.getY());
    }

    protected boolean outsideClip(Graphics2D g) throws SVGException
    {
        Shape clip = g.getClip();
//        g.getClipBounds(clipBounds);
        Rectangle2D rect = super.getBoundingBox();
        if (clip == null || clip.intersects(rect))
        {
            return false;
        }

        return true;

    }

    public void render(Graphics2D g) throws SVGException
    {
        AffineTransform oldXform = g.getTransform();
        g.transform(viewXform);

        super.render(g);

        g.setTransform(oldXform);
    }

    public Shape getShape()
    {
        Shape shape = super.getShape();
        return viewXform.createTransformedShape(shape);
    }

    public Rectangle2D getBoundingBox() throws SVGException
    {
        Rectangle2D rect = super.getBoundingBox();
        return viewXform.createTransformedShape(rect).getBounds2D();
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;
        boolean changeState = super.updateTime(curTime);

        //View box properties do not change

        return changeState;
    }
}
"
Text.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 1:56 AM
 */
package com.kitfox.svg;

import java.awt.Graphics2D;
import java.awt.GraphicsEnvironment;
import java.awt.Shape;
import java.awt.font.FontRenderContext;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.kitfox.svg.xml.StyleAttribute;

//import org.apache.batik.ext.awt.geom.ExtendedGeneralPath;
/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Text extends ShapeElement
{
    public static final String TAG_NAME = ""text"";
    
    float x = 0;
    float y = 0;
    AffineTransform transform = null;
    String fontFamily;
    float fontSize;
    //List of strings and tspans containing the content of this node
    LinkedList content = new LinkedList();
    Shape textShape;
    public static final int TXAN_START = 0;
    public static final int TXAN_MIDDLE = 1;
    public static final int TXAN_END = 2;
    int textAnchor = TXAN_START;
    public static final int TXST_NORMAL = 0;
    public static final int TXST_ITALIC = 1;
    public static final int TXST_OBLIQUE = 2;
    int fontStyle;
    public static final int TXWE_NORMAL = 0;
    public static final int TXWE_BOLD = 1;
    public static final int TXWE_BOLDER = 2;
    public static final int TXWE_LIGHTER = 3;
    public static final int TXWE_100 = 4;
    public static final int TXWE_200 = 5;
    public static final int TXWE_300 = 6;
    public static final int TXWE_400 = 7;
    public static final int TXWE_500 = 8;
    public static final int TXWE_600 = 9;
    public static final int TXWE_700 = 10;
    public static final int TXWE_800 = 11;
    public static final int TXWE_900 = 12;
    int fontWeight;

    /**
     * Creates a new instance of Stop
     */
    public Text()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    public void appendText(String text)
    {
        content.addLast(text);
    }

    public void appendTspan(Tspan tspan) throws SVGElementException
    {
        super.loaderAddChild(null, tspan);
        content.addLast(tspan);
    }

    /**
     * Discard cached information
     */
    public void rebuild() throws SVGException
    {
        build();
    }

    public java.util.List getContent()
    {
        return content;
    }

    /**
     * Called after the start element but before the end element to indicate
     * each child tag that has been processed
     */
    public void loaderAddChild(SVGLoaderHelper helper, SVGElement child) throws SVGElementException
    {
        super.loaderAddChild(helper, child);

        content.addLast(child);
    }

    /**
     * Called during load process to add text scanned within a tag
     */
    public void loaderAddText(SVGLoaderHelper helper, String text)
    {
        Matcher matchWs = Pattern.compile(""\\s*"").matcher(text);
        if (!matchWs.matches())
        {
            content.addLast(text);
        }
    }

    public void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""x"")))
        {
            x = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""y"")))
        {
            y = sty.getFloatValueWithUnits();
        }

        if (getStyle(sty.setName(""font-family"")))
        {
            fontFamily = sty.getStringValue();
        } else
        {
            fontFamily = ""Sans Serif"";
        }

        if (getStyle(sty.setName(""font-size"")))
        {
            fontSize = sty.getFloatValueWithUnits();
        } else
        {
            fontSize = 12f;
        }

        if (getStyle(sty.setName(""font-style"")))
        {
            String s = sty.getStringValue();
            if (""normal"".equals(s))
            {
                fontStyle = TXST_NORMAL;
            } else if (""italic"".equals(s))
            {
                fontStyle = TXST_ITALIC;
            } else if (""oblique"".equals(s))
            {
                fontStyle = TXST_OBLIQUE;
            }
        } else
        {
            fontStyle = TXST_NORMAL;
        }

        if (getStyle(sty.setName(""font-weight"")))
        {
            String s = sty.getStringValue();
            if (""normal"".equals(s))
            {
                fontWeight = TXWE_NORMAL;
            } else if (""bold"".equals(s))
            {
                fontWeight = TXWE_BOLD;
            }
        } else
        {
            fontWeight = TXWE_NORMAL;
        }

        if (getStyle(sty.setName(""text-anchor"")))
        {
            String s = sty.getStringValue();
            if (s.equals(""middle""))
            {
                textAnchor = TXAN_MIDDLE;
            } else if (s.equals(""end""))
            {
                textAnchor = TXAN_END;
            } else
            {
                textAnchor = TXAN_START;
            }
        } else
        {
            textAnchor = TXAN_START;
        }

        //text anchor
        //text-decoration
        //text-rendering

        buildFont();
    }

    protected void buildFont() throws SVGException
    {
        int style;
        switch (fontStyle)
        {
            case TXST_ITALIC:
                style = java.awt.Font.ITALIC;
                break;
            default:
                style = java.awt.Font.PLAIN;
                break;
        }

        int weight;
        switch (fontWeight)
        {
            case TXWE_BOLD:
            case TXWE_BOLDER:
                weight = java.awt.Font.BOLD;
                break;
            default:
                weight = java.awt.Font.PLAIN;
                break;
        }

		String[] fontFamilies = fontFamily.split("","");

        //Get font
        Font font = null;        
        for (String currentFamily: fontFamilies) {
		    font = diagram.getUniverse().getFont(currentFamily);
		    if (font != null) {
		    	break;
		    } else if (existsSysFont(currentFamily)) {
		        java.awt.Font sysFont = new java.awt.Font(currentFamily, style | weight, (int) fontSize);
		        buildSysFont(sysFont);
		        return;
		    }
        }
        
        if (font == null) {
        	java.awt.Font sysFont = new java.awt.Font(fontFamily, style | weight, (int) fontSize);
        	buildSysFont(sysFont);
		    return;
        }

//        font = new java.awt.Font(font.getFamily(), style | weight, font.getSize());

//        Area textArea = new Area();
        GeneralPath textPath = new GeneralPath();
        textShape = textPath;

        float cursorX = x, cursorY = y;

        FontFace fontFace = font.getFontFace();
        //int unitsPerEm = fontFace.getUnitsPerEm();
        int ascent = fontFace.getAscent();
        float fontScale = fontSize / (float) ascent;

//        AffineTransform oldXform = g.getTransform();
        AffineTransform xform = new AffineTransform();

        for (Iterator it = content.iterator(); it.hasNext();)
        {
            Object obj = it.next();

            if (obj instanceof String)
            {
                String text = (String) obj;
                if (text != null)
                {
                    text = text.trim();
                }

                strokeWidthScalar = 1f / fontScale;

                for (int i = 0; i < text.length(); i++)
                {
                    xform.setToIdentity();
                    xform.setToTranslation(cursorX, cursorY);
                    xform.scale(fontScale, fontScale);
//                    g.transform(xform);

                    String unicode = text.substring(i, i + 1);
                    MissingGlyph glyph = font.getGlyph(unicode);

                    Shape path = glyph.getPath();
                    if (path != null)
                    {
                        path = xform.createTransformedShape(path);
                        textPath.append(path, false);
                    }
//                    else glyph.render(g);

                    cursorX += fontScale * glyph.getHorizAdvX();

//                    g.setTransform(oldXform);
                }

                strokeWidthScalar = 1f;
            } else if (obj instanceof Tspan)
            {
                Tspan tspan = (Tspan) obj;

                xform.setToIdentity();
                xform.setToTranslation(cursorX, cursorY);
                xform.scale(fontScale, fontScale);
//                tspan.setCursorX(cursorX);
//                tspan.setCursorY(cursorY);

                Shape tspanShape = tspan.getShape();
                tspanShape = xform.createTransformedShape(tspanShape);
                textPath.append(tspanShape, false);
//                tspan.render(g);
//                cursorX = tspan.getCursorX();
//                cursorY = tspan.getCursorY();
            }

        }

        switch (textAnchor)
        {
            case TXAN_MIDDLE:
            {
                AffineTransform at = new AffineTransform();
                at.translate(-textPath.getBounds2D().getWidth() / 2, 0);
                textPath.transform(at);
                break;
            }
            case TXAN_END:
            {
                AffineTransform at = new AffineTransform();
                at.translate(-textPath.getBounds2D().getWidth(), 0);
                textPath.transform(at);
                break;
            }
        }
    }

    private boolean existsSysFont(String currentFamily) {
    	for (String existingFontFamily: GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames()) {
    		if (currentFamily.equals(existingFontFamily)) {
    			return true;
    		}
    	}
		return false;
	}

	private void buildSysFont(java.awt.Font font) throws SVGException
    {
        GeneralPath textPath = new GeneralPath();
        textShape = textPath;

        float cursorX = x, cursorY = y;

//        FontMetrics fm = g.getFontMetrics(font);
        FontRenderContext frc = new FontRenderContext(null, true, true);

//        FontFace fontFace = font.getFontFace();
        //int unitsPerEm = fontFace.getUnitsPerEm();
//        int ascent = fm.getAscent();
//        float fontScale = fontSize / (float)ascent;

//        AffineTransform oldXform = g.getTransform();
        AffineTransform xform = new AffineTransform();

        for (Iterator it = content.iterator(); it.hasNext();)
        {
            Object obj = it.next();

            if (obj instanceof String)
            {
                String text = (String) obj;

                Shape textShape = font.createGlyphVector(frc, text).getOutline(cursorX, cursorY);
                textPath.append(textShape, false);
//                renderShape(g, textShape);
//                g.drawString(text, cursorX, cursorY);

                Rectangle2D rect = font.getStringBounds(text, frc);
                cursorX += (float) rect.getWidth();
            } else if (obj instanceof Tspan)
            {
                /*
                 Tspan tspan = (Tspan)obj;
                 
                 xform.setToIdentity();
                 xform.setToTranslation(cursorX, cursorY);
                 
                 Shape tspanShape = tspan.getShape();
                 tspanShape = xform.createTransformedShape(tspanShape);
                 textArea.add(new Area(tspanShape));
                 
                 cursorX += tspanShape.getBounds2D().getWidth();
                 */


                Tspan tspan = (Tspan) obj;
                tspan.setCursorX(cursorX);
                tspan.setCursorY(cursorY);
                tspan.addShape(textPath);
                cursorX = tspan.getCursorX();
                cursorY = tspan.getCursorY();

            }
        }

        switch (textAnchor)
        {
            case TXAN_MIDDLE:
            {
                AffineTransform at = new AffineTransform();
                at.translate(-textPath.getBounds2D().getWidth() / 2, 0);
                textPath.transform(at);
                break;
            }
            case TXAN_END:
            {
                AffineTransform at = new AffineTransform();
                at.translate(-textPath.getBounds2D().getWidth(), 0);
                textPath.transform(at);
                break;
            }
        }
    }

    public void render(Graphics2D g) throws SVGException
    {
        beginLayer(g);
        renderShape(g, textShape);
        finishLayer(g);
    }

    public Shape getShape()
    {
        return shapeToParent(textShape);
    }

    public Rectangle2D getBoundingBox() throws SVGException
    {
        return boundsToParent(includeStrokeInBounds(textShape.getBounds2D()));
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;
        boolean changeState = super.updateTime(curTime);

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;

        if (getPres(sty.setName(""x"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != x)
            {
                x = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""y"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != y)
            {
                y = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""font-family"")))
        {
            String newVal = sty.getStringValue();
            if (!newVal.equals(fontFamily))
            {
                fontFamily = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""font-size"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != fontSize)
            {
                fontSize = newVal;
                shapeChange = true;
            }
        }


        if (getStyle(sty.setName(""font-style"")))
        {
            String s = sty.getStringValue();
            int newVal = fontStyle;
            if (""normal"".equals(s))
            {
                newVal = TXST_NORMAL;
            } else if (""italic"".equals(s))
            {
                newVal = TXST_ITALIC;
            } else if (""oblique"".equals(s))
            {
                newVal = TXST_OBLIQUE;
            }
            if (newVal != fontStyle)
            {
                fontStyle = newVal;
                shapeChange = true;
            }
        }

        if (getStyle(sty.setName(""font-weight"")))
        {
            String s = sty.getStringValue();
            int newVal = fontWeight;
            if (""normal"".equals(s))
            {
                newVal = TXWE_NORMAL;
            } else if (""bold"".equals(s))
            {
                newVal = TXWE_BOLD;
            }
            if (newVal != fontWeight)
            {
                fontWeight = newVal;
                shapeChange = true;
            }
        }

        if (shapeChange)
        {
            build();
//            buildFont();
//            return true;
        }

        return changeState || shapeChange;
    }
}
"
Title.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 19, 2004, 1:56 AM
 */
package com.kitfox.svg;

/**
 * Holds title textual information within tree
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Title extends SVGElement
{
    public static final String TAG_NAME = ""title"";
    
    StringBuffer text = new StringBuffer();

    /**
     * Creates a new instance of Stop
     */
    public Title()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    /**
     * Called during load process to add text scanned within a tag
     */
    public void loaderAddText(SVGLoaderHelper helper, String text)
    {
        this.text.append(text);
    }

    public String getText()
    {
        return text.toString();
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
        //Title does not change
        return false;
    }
}
"
TransformableElement.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 9:00 AM
 */
package com.kitfox.svg;

import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Rectangle2D;

import com.kitfox.svg.xml.StyleAttribute;

/**
 * Maintains bounding box for this element
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
abstract public class TransformableElement extends SVGElement
{
    AffineTransform xform = null;

    /**
     * Creates a new instance of BoundedElement
     */
    public TransformableElement()
    {
    }

    public TransformableElement(String id, SVGElement parent)
    {
        super(id, parent);
    }

    /**
     * Fetches a copy of the cached AffineTransform. Note that this value will
     * only be valid after the node has been updated.
     *
     * @return
     */
    public AffineTransform getXForm()
    {
        return xform == null ? null : new AffineTransform(xform);
    }
    /*
     public void loaderStartElement(SVGLoaderHelper helper, Attributes attrs, SVGElement parent)
     {
     //Load style string
     super.loaderStartElement(helper, attrs, parent);

     String transform = attrs.getValue(""transform"");
     if (transform != null)
     {
     xform = parseTransform(transform);
     }
     }
     */

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""transform"")))
        {
            xform = parseTransform(sty.getStringValue());
        }
    }
    
    public AffineTransform getTranform() 
    {
    	if (xform != null)
    	{
    		return xform;
    	}
    	return new AffineTransform();
    }

    protected Shape shapeToParent(Shape shape)
    {
        if (xform == null)
        {
            return shape;
        }
        return xform.createTransformedShape(shape);
    }

    protected Rectangle2D boundsToParent(Rectangle2D rect)
    {
        if (xform == null)
        {
            return rect;
        }
        return xform.createTransformedShape(rect).getBounds2D();
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""transform"")))
        {
            AffineTransform newXform = parseTransform(sty.getStringValue());
            if (!newXform.equals(xform))
            {
                xform = newXform;
                return true;
            }
        }

        return false;
    }
}
"
Tspan.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 1:56 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.font.FontRenderContext;
import java.awt.font.GlyphMetrics;
import java.awt.font.GlyphVector;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Tspan extends ShapeElement
{

    public static final String TAG_NAME = ""tspan"";
    float[] x = null;
    float[] y = null;
    float[] dx = null;
    float[] dy = null;
    float[] rotate = null;
    private String text = """";
    float cursorX;
    float cursorY;

//    Shape tspanShape;
    /**
     * Creates a new instance of Stop
     */
    public Tspan()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    public float getCursorX()
    {
        return cursorX;
    }

    public float getCursorY()
    {
        return cursorY;
    }

    public void setCursorX(float cursorX)
    {
        this.cursorX = cursorX;
    }

    public void setCursorY(float cursorY)
    {
        this.cursorY = cursorY;
    }
    /*
     public void loaderStartElement(SVGLoaderHelper helper, Attributes attrs, SVGElement parent)
     {
     //Load style string
     super.loaderStartElement(helper, attrs, parent);

     String x = attrs.getValue(""x"");
     String y = attrs.getValue(""y"");
     String dx = attrs.getValue(""dx"");
     String dy = attrs.getValue(""dy"");
     String rotate = attrs.getValue(""rotate"");

     if (x != null) this.x = XMLParseUtil.parseFloatList(x);
     if (y != null) this.y = XMLParseUtil.parseFloatList(y);
     if (dx != null) this.dx = XMLParseUtil.parseFloatList(dx);
     if (dy != null) this.dy = XMLParseUtil.parseFloatList(dy);
     if (rotate != null)
     {
     this.rotate = XMLParseUtil.parseFloatList(rotate);
     for (int i = 0; i < this.rotate.length; i++)
     this.rotate[i] = (float)Math.toRadians(this.rotate[i]);
     }
     }
     */

    /**
     * Called during load process to add text scanned within a tag
     */
    public void loaderAddText(SVGLoaderHelper helper, String text)
    {
        this.text += text;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""x"")))
        {
            x = sty.getFloatList();
        }

        if (getPres(sty.setName(""y"")))
        {
            y = sty.getFloatList();
        }

        if (getPres(sty.setName(""dx"")))
        {
            dx = sty.getFloatList();
        }

        if (getPres(sty.setName(""dy"")))
        {
            dy = sty.getFloatList();
        }

        if (getPres(sty.setName(""rotate"")))
        {
            rotate = sty.getFloatList();
            for (int i = 0; i < this.rotate.length; i++)
            {
                rotate[i] = (float) Math.toRadians(this.rotate[i]);
            }

        }
    }

    public void addShape(GeneralPath addShape) throws SVGException
    {
        if (x != null)
        {
            cursorX = x[0];
        } else if (dx != null)
        {
            cursorX += dx[0];
        }

        if (y != null)
        {
            cursorY = y[0];
        } else if (dy != null)
        {
            cursorY += dy[0];
        }

        StyleAttribute sty = new StyleAttribute();

        String fontFamily = null;
        if (getStyle(sty.setName(""font-family"")))
        {
            fontFamily = sty.getStringValue();
        }


        float fontSize = 12f;
        if (getStyle(sty.setName(""font-size"")))
        {
            fontSize = sty.getFloatValueWithUnits();
        }

        float letterSpacing = 0;
        if (getStyle(sty.setName(""letter-spacing"")))
        {
            letterSpacing = sty.getFloatValueWithUnits();
        }


        //Get font
        Font font = diagram.getUniverse().getFont(fontFamily);
        if (font == null)
        {
            addShapeSysFont(addShape, font, fontFamily, fontSize, letterSpacing);
            return;
        }

        FontFace fontFace = font.getFontFace();
        int ascent = fontFace.getAscent();
        float fontScale = fontSize / (float) ascent;

        AffineTransform xform = new AffineTransform();

        strokeWidthScalar = 1f / fontScale;

        int posPtr = 1;

        for (int i = 0; i < text.length(); i++)
        {
            xform.setToIdentity();
            xform.setToTranslation(cursorX, cursorY);
            xform.scale(fontScale, fontScale);
            if (rotate != null)
            {
                xform.rotate(rotate[posPtr]);
            }

            String unicode = text.substring(i, i + 1);
            MissingGlyph glyph = font.getGlyph(unicode);

            Shape path = glyph.getPath();
            if (path != null)
            {
                path = xform.createTransformedShape(path);
                addShape.append(path, false);
            }

            if (x != null && posPtr < x.length)
            {
                cursorX = x[posPtr];
                cursorY = y[posPtr++];
            } else if (dx != null && posPtr < dx.length)
            {
                cursorX += dx[posPtr];
                cursorY += dy[posPtr++];
            }

            cursorX += fontScale * glyph.getHorizAdvX() + letterSpacing;
        }

        strokeWidthScalar = 1f;
    }

    private void addShapeSysFont(GeneralPath addShape, Font font,
        String fontFamily, float fontSize, float letterSpacing)
    {
        java.awt.Font sysFont = new java.awt.Font(fontFamily, java.awt.Font.PLAIN, (int) fontSize);

        FontRenderContext frc = new FontRenderContext(null, true, true);
        GlyphVector textVector = sysFont.createGlyphVector(frc, text);

        AffineTransform xform = new AffineTransform();

        int posPtr = 1;
        for (int i = 0; i < text.length(); i++)
        {
            xform.setToIdentity();
            xform.setToTranslation(cursorX + i * letterSpacing, cursorY);
            if (rotate != null)
            {
                xform.rotate(rotate[Math.min(i, rotate.length - 1)]);
            }

            String unicode = text.substring(i, i + 1);
            Shape glyphOutline = textVector.getGlyphOutline(i);
            GlyphMetrics glyphMetrics = textVector.getGlyphMetrics(i);

            glyphOutline = xform.createTransformedShape(glyphOutline);
            addShape.append(glyphOutline, false);

            if (x != null && posPtr < x.length)
            {
                cursorX = x[posPtr];
                cursorY = y[posPtr++];
            } else if (dx != null && posPtr < dx.length)
            {
                cursorX += dx[posPtr];
                cursorY += dy[posPtr++];
            }
        }
    }

    public void render(Graphics2D g) throws SVGException
    {
        if (x != null)
        {
            cursorX = x[0];
            cursorY = y[0];
        } else if (dx != null)
        {
            cursorX += dx[0];
            cursorY += dy[0];
        }

        StyleAttribute sty = new StyleAttribute();

        String fontFamily = null;
        if (getPres(sty.setName(""font-family"")))
        {
            fontFamily = sty.getStringValue();
        }


        float fontSize = 12f;
        if (getPres(sty.setName(""font-size"")))
        {
            fontSize = sty.getFloatValueWithUnits();
        }

        //Get font
        Font font = diagram.getUniverse().getFont(fontFamily);
        if (font == null)
        {
            System.err.println(""Could not load font"");
            java.awt.Font sysFont = new java.awt.Font(fontFamily, java.awt.Font.PLAIN, (int) fontSize);
            renderSysFont(g, sysFont);
            return;
        }


        FontFace fontFace = font.getFontFace();
        int ascent = fontFace.getAscent();
        float fontScale = fontSize / (float) ascent;

        AffineTransform oldXform = g.getTransform();
        AffineTransform xform = new AffineTransform();

        strokeWidthScalar = 1f / fontScale;

        int posPtr = 1;

        for (int i = 0; i < text.length(); i++)
        {
            xform.setToTranslation(cursorX, cursorY);
            xform.scale(fontScale, fontScale);
            g.transform(xform);

            String unicode = text.substring(i, i + 1);
            MissingGlyph glyph = font.getGlyph(unicode);

            Shape path = glyph.getPath();
            if (path != null)
            {
                renderShape(g, path);
            } else
            {
                glyph.render(g);
            }

            if (x != null && posPtr < x.length)
            {
                cursorX = x[posPtr];
                cursorY = y[posPtr++];
            } else if (dx != null && posPtr < dx.length)
            {
                cursorX += dx[posPtr];
                cursorY += dy[posPtr++];
            }

            cursorX += fontScale * glyph.getHorizAdvX();

            g.setTransform(oldXform);
        }

        strokeWidthScalar = 1f;
    }

    protected void renderSysFont(Graphics2D g, java.awt.Font font) throws SVGException
    {
        int posPtr = 1;
        FontRenderContext frc = g.getFontRenderContext();

        Shape textShape = font.createGlyphVector(frc, text).getOutline(cursorX, cursorY);
        renderShape(g, textShape);
        Rectangle2D rect = font.getStringBounds(text, frc);
        cursorX += (float) rect.getWidth();
    }

    public Shape getShape()
    {
        return null;
        //return shapeToParent(tspanShape);
    }

    public Rectangle2D getBoundingBox()
    {
        return null;
        //return boundsToParent(tspanShape.getBounds2D());
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
        //Tspan does not change
        return false;
    }

    public String getText()
    {
        return text;
    }

    public void setText(String text)
    {
        this.text = text;
    }
}
"
Use.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 1:54 AM
 */
package com.kitfox.svg;

import com.kitfox.svg.xml.StyleAttribute;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Rectangle2D;
import java.net.URI;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class Use extends ShapeElement
{
    public static final String TAG_NAME = ""use"";
    
    float x = 0f;
    float y = 0f;
    float width = 1f;
    float height = 1f;
//    SVGElement href = null;
    URI href = null;
    AffineTransform refXform;

    /**
     * Creates a new instance of LinearGradient
     */
    public Use()
    {
    }

    public String getTagName()
    {
        return TAG_NAME;
    }

    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""x"")))
        {
            x = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""y"")))
        {
            y = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""width"")))
        {
            width = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""height"")))
        {
            height = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""xlink:href"")))
        {
            URI src = sty.getURIValue(getXMLBase());
            href = src;
//            href = diagram.getUniverse().getElement(src);
        }

        //Determine use offset/scale
        refXform = new AffineTransform();
        refXform.translate(this.x, this.y);
    }

    public void render(Graphics2D g) throws SVGException
    {
        beginLayer(g);

        //AffineTransform oldXform = g.getTransform();
        AffineTransform oldXform = g.getTransform();
        g.transform(refXform);

        SVGElement ref = diagram.getUniverse().getElement(href);

        if (ref == null || !(ref instanceof RenderableElement))
        {
            return;
        }

        RenderableElement rendEle = (RenderableElement) ref;
        rendEle.pushParentContext(this);
        rendEle.render(g);
        rendEle.popParentContext();

        g.setTransform(oldXform);

        finishLayer(g);
    }

    public Shape getShape()
    {
        SVGElement ref = diagram.getUniverse().getElement(href);
        if (ref instanceof ShapeElement)
        {
            Shape shape = ((ShapeElement) ref).getShape();
            shape = refXform.createTransformedShape(shape);
            shape = shapeToParent(shape);
            return shape;
        }

        return null;
    }

    public Rectangle2D getBoundingBox() throws SVGException
    {
        SVGElement ref = diagram.getUniverse().getElement(href);
        if (ref instanceof ShapeElement)
        {
            ShapeElement shapeEle = (ShapeElement) ref;
            shapeEle.pushParentContext(this);
            Rectangle2D bounds = shapeEle.getBoundingBox();
            shapeEle.popParentContext();

            bounds = refXform.createTransformedShape(bounds).getBounds2D();
            bounds = boundsToParent(bounds);

            return bounds;
        }

        return null;
    }

    /**
     * Updates all attributes in this diagram associated with a time event. Ie,
     * all attributes with track information.
     *
     * @return - true if this node has changed state as a result of the time
     * update
     */
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;
        boolean changeState = super.updateTime(curTime);

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;

        if (getPres(sty.setName(""x"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != x)
            {
                x = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""y"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != y)
            {
                y = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""width"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != width)
            {
                width = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""height"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != height)
            {
                height = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""xlink:href"")))
        {
            URI src = sty.getURIValue(getXMLBase());
//            SVGElement newVal = diagram.getUniverse().getElement(src);
            if (!src.equals(href))
            {
                href = src;
                shapeChange = true;
            }
        }
        /*
         if (getPres(sty.setName(""xlink:href"")))
         {
         URI src = sty.getURIValue(getXMLBase());
         href = diagram.getUniverse().getElement(src);
         }
        
         //Determine use offset/scale
         refXform = new AffineTransform();
         refXform.translate(this.x, this.y);
         refXform.scale(this.width, this.height);
         */
        if (shapeChange)
        {
            build();
            //Determine use offset/scale
//            refXform.setToTranslation(this.x, this.y);
//            refXform.scale(this.width, this.height);
//            return true;
        }

        return changeState || shapeChange;
    }
}
"
Base64InputStream.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 */

package com.kitfox.svg.xml;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 *
 * @author kitfox
 */
public class Base64InputStream extends FilterInputStream
{
    int buf;  //Cached bytes to read
    int bufSize;  //Number of bytes waiting to be read from buffer
    boolean drain = false;  //After set, read no more chunks
    
    public Base64InputStream(InputStream in)
    {
        super(in);
    }

    public int read() throws IOException
    {
        if (drain && bufSize == 0)
        {
            return -1;
        }
        
        if (bufSize == 0)
        {
            //Read next chunk into 4 byte buffer
            int chunk = in.read();
            if (chunk == -1)
            {
                drain = true;
                return -1;
            }
            
            //get remaining 3 bytes
            for (int i = 0; i < 3; ++i)
            {
                int value = in.read();
                if (value == -1)
                {
                    throw new IOException(""Early termination of base64 stream"");
                }
                chunk = (chunk << 8) | (value & 0xff);
            }

            //Check for special termination characters
            if ((chunk & 0xffff) == (((byte)'=' << 8) | (byte)'='))
            {
                bufSize = 1;
                drain = true;
            }
            else if ((chunk & 0xff) == (byte)'=')
            {
                bufSize = 2;
                drain = true;
            }
            else
            {
                bufSize = 3;
            }
            
            //Fill buffer with decoded characters
            for (int i = 0; i < bufSize + 1; ++i)
            {
                buf = (buf << 6) | Base64Util.decodeByte((chunk >> 24) & 0xff);
                chunk <<= 8;
            }
        }
        
        //Return nth remaing bte & decrement counter
        return (buf >> (--bufSize * 8)) & 0xff;
    } 
}
"
Base64OutputStream.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 */

package com.kitfox.svg.xml;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

/**
 *
 * @author kitfox
 */
public class Base64OutputStream extends FilterOutputStream
{
    int buf;
    int numBytes;
    int numChunks;
    
    public Base64OutputStream(OutputStream out)
    {
        super(out);
    }
    
    public void flush() throws IOException
    {
        out.flush();
    }
    
    public void close() throws IOException
    {
        switch (numBytes)
        {
            case 1:
                buf <<= 4;
                out.write(getBase64Byte(1));
                out.write(getBase64Byte(0));
                out.write('=');
                out.write('=');
                break;
            case 2:
                buf <<= 2;
                out.write(getBase64Byte(2));
                out.write(getBase64Byte(1));
                out.write(getBase64Byte(0));
                out.write('=');
                break;
            case 3:
                out.write(getBase64Byte(3));
                out.write(getBase64Byte(2));
                out.write(getBase64Byte(1));
                out.write(getBase64Byte(0));
                break;
            default:
                assert false;
        }
        
        out.close();
    }
    
    public void write(int b) throws IOException
    {
        buf = (buf << 8) | (0xff & b);
        numBytes++;
        
        if (numBytes == 3)
        {
            out.write(getBase64Byte(3));
            out.write(getBase64Byte(2));
            out.write(getBase64Byte(1));
            out.write(getBase64Byte(0));
            
            numBytes = 0;
            numChunks++;
            if (numChunks == 16)
            {
//                out.write('\r');
//                out.write('\n');
                numChunks = 0;
            }
        }
    }
    
    public byte getBase64Byte(int index)
    {
        return Base64Util.encodeByte((buf >> (index * 6)) & 0x3f);
    }
}
"
Base64Util.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 */

package com.kitfox.svg.xml;

/**
 *
 * @author kitfox
 */
public class Base64Util 
{
    static final byte[] valueToBase64 = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"".getBytes();
    static final byte[] base64ToValue = new byte[128];
    static {
        for (int i = 0; i < valueToBase64.length; ++i)
        {
            base64ToValue[valueToBase64[i]] = (byte)i;
        }
    }
    
    static public byte encodeByte(int value)
    {
        return valueToBase64[value];
    }
    
    static public byte decodeByte(int base64Char)
    {
        return base64ToValue[base64Char];
    }
}
"
ColorTable.java,kitfox-6.9.6,"/*
 * SVG Salamander Copyright (c) 2004, Mark McKay All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. - Redistributions in binary
 * form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided
 * with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Mark McKay can be contacted at mark@kitfox.com. Salamander and other projects
 * can be found at http://www.kitfox.com
 *
 * Created on January 26, 2004, 4:34 AM
 */

package com.kitfox.svg.xml;

import java.awt.Color;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class ColorTable {

	static final Map colorTable;
	static {
		HashMap table = new HashMap();

		//We really should be interpreting the currentColor keyword as 
		// a reference to the referring node's color, but this quick hack 
		// will stop the program from crashing.
		table.put(""currentcolor"", new Color(0x0));

		table.put(""aliceblue"", new Color(0xf0f8ff));
		table.put(""antiquewhite"", new Color(0xfaebd7));
		table.put(""aqua"", new Color(0x00ffff));
		table.put(""aquamarine"", new Color(0x7fffd4));
		table.put(""azure"", new Color(0xf0ffff));
		table.put(""beige"", new Color(0xf5f5dc));
		table.put(""bisque"", new Color(0xffe4c4));
		table.put(""black"", new Color(0x000000));
		table.put(""blanchedalmond"", new Color(0xffebcd));
		table.put(""blue"", new Color(0x0000ff));
		table.put(""blueviolet"", new Color(0x8a2be2));
		table.put(""brown"", new Color(0xa52a2a));
		table.put(""burlywood"", new Color(0xdeb887));
		table.put(""cadetblue"", new Color(0x5f9ea0));
		table.put(""chartreuse"", new Color(0x7fff00));
		table.put(""chocolate"", new Color(0xd2691e));
		table.put(""coral"", new Color(0xff7f50));
		table.put(""cornflowerblue"", new Color(0x6495ed));
		table.put(""cornsilk"", new Color(0xfff8dc));
		table.put(""crimson"", new Color(0xdc143c));
		table.put(""cyan"", new Color(0x00ffff));
		table.put(""darkblue"", new Color(0x00008b));
		table.put(""darkcyan"", new Color(0x008b8b));
		table.put(""darkgoldenrod"", new Color(0xb8860b));
		table.put(""darkgray"", new Color(0xa9a9a9));
		table.put(""darkgreen"", new Color(0x006400));
		table.put(""darkkhaki"", new Color(0xbdb76b));
		table.put(""darkmagenta"", new Color(0x8b008b));
		table.put(""darkolivegreen"", new Color(0x556b2f));
		table.put(""darkorange"", new Color(0xff8c00));
		table.put(""darkorchid"", new Color(0x9932cc));
		table.put(""darkred"", new Color(0x8b0000));
		table.put(""darksalmon"", new Color(0xe9967a));
		table.put(""darkseagreen"", new Color(0x8fbc8f));
		table.put(""darkslateblue"", new Color(0x483d8b));
		table.put(""darkslategray"", new Color(0x2f4f4f));
		table.put(""darkturquoise"", new Color(0x00ced1));
		table.put(""darkviolet"", new Color(0x9400d3));
		table.put(""deeppink"", new Color(0xff1493));
		table.put(""deepskyblue"", new Color(0x00bfff));
		table.put(""dimgray"", new Color(0x696969));
		table.put(""dodgerblue"", new Color(0x1e90ff));
		table.put(""feldspar"", new Color(0xd19275));
		table.put(""firebrick"", new Color(0xb22222));
		table.put(""floralwhite"", new Color(0xfffaf0));
		table.put(""forestgreen"", new Color(0x228b22));
		table.put(""fuchsia"", new Color(0xff00ff));
		table.put(""gainsboro"", new Color(0xdcdcdc));
		table.put(""ghostwhite"", new Color(0xf8f8ff));
		table.put(""gold"", new Color(0xffd700));
		table.put(""goldenrod"", new Color(0xdaa520));
		table.put(""gray"", new Color(0x808080));
		table.put(""green"", new Color(0x008000));
		table.put(""greenyellow"", new Color(0xadff2f));
		table.put(""honeydew"", new Color(0xf0fff0));
		table.put(""hotpink"", new Color(0xff69b4));
		table.put(""indianred"", new Color(0xcd5c5c));
		table.put(""indigo"", new Color(0x4b0082));
		table.put(""ivory"", new Color(0xfffff0));
		table.put(""khaki"", new Color(0xf0e68c));
		table.put(""lavender"", new Color(0xe6e6fa));
		table.put(""lavenderblush"", new Color(0xfff0f5));
		table.put(""lawngreen"", new Color(0x7cfc00));
		table.put(""lemonchiffon"", new Color(0xfffacd));
		table.put(""lightblue"", new Color(0xadd8e6));
		table.put(""lightcoral"", new Color(0xf08080));
		table.put(""lightcyan"", new Color(0xe0ffff));
		table.put(""lightgoldenrodyellow"", new Color(0xfafad2));
		table.put(""lightgrey"", new Color(0xd3d3d3));
		table.put(""lightgreen"", new Color(0x90ee90));
		table.put(""lightpink"", new Color(0xffb6c1));
		table.put(""lightsalmon"", new Color(0xffa07a));
		table.put(""lightseagreen"", new Color(0x20b2aa));
		table.put(""lightskyblue"", new Color(0x87cefa));
		table.put(""lightslateblue"", new Color(0x8470ff));
		table.put(""lightslategray"", new Color(0x778899));
		table.put(""lightsteelblue"", new Color(0xb0c4de));
		table.put(""lightyellow"", new Color(0xffffe0));
		table.put(""lime"", new Color(0x00ff00));
		table.put(""limegreen"", new Color(0x32cd32));
		table.put(""linen"", new Color(0xfaf0e6));
		table.put(""magenta"", new Color(0xff00ff));
		table.put(""maroon"", new Color(0x800000));
		table.put(""mediumaquamarine"", new Color(0x66cdaa));
		table.put(""mediumblue"", new Color(0x0000cd));
		table.put(""mediumorchid"", new Color(0xba55d3));
		table.put(""mediumpurple"", new Color(0x9370d8));
		table.put(""mediumseagreen"", new Color(0x3cb371));
		table.put(""mediumslateblue"", new Color(0x7b68ee));
		table.put(""mediumspringgreen"", new Color(0x00fa9a));
		table.put(""mediumturquoise"", new Color(0x48d1cc));
		table.put(""mediumvioletred"", new Color(0xc71585));
		table.put(""midnightblue"", new Color(0x191970));
		table.put(""mintcream"", new Color(0xf5fffa));
		table.put(""mistyrose"", new Color(0xffe4e1));
		table.put(""moccasin"", new Color(0xffe4b5));
		table.put(""navajowhite"", new Color(0xffdead));
		table.put(""navy"", new Color(0x000080));
		table.put(""oldlace"", new Color(0xfdf5e6));
		table.put(""olive"", new Color(0x808000));
		table.put(""olivedrab"", new Color(0x6b8e23));
		table.put(""orange"", new Color(0xffa500));
		table.put(""orangered"", new Color(0xff4500));
		table.put(""orchid"", new Color(0xda70d6));
		table.put(""palegoldenrod"", new Color(0xeee8aa));
		table.put(""palegreen"", new Color(0x98fb98));
		table.put(""paleturquoise"", new Color(0xafeeee));
		table.put(""palevioletred"", new Color(0xd87093));
		table.put(""papayawhip"", new Color(0xffefd5));
		table.put(""peachpuff"", new Color(0xffdab9));
		table.put(""peru"", new Color(0xcd853f));
		table.put(""pink"", new Color(0xffc0cb));
		table.put(""plum"", new Color(0xdda0dd));
		table.put(""powderblue"", new Color(0xb0e0e6));
		table.put(""purple"", new Color(0x800080));
		table.put(""red"", new Color(0xff0000));
		table.put(""rosybrown"", new Color(0xbc8f8f));
		table.put(""royalblue"", new Color(0x4169e1));
		table.put(""saddlebrown"", new Color(0x8b4513));
		table.put(""salmon"", new Color(0xfa8072));
		table.put(""sandybrown"", new Color(0xf4a460));
		table.put(""seagreen"", new Color(0x2e8b57));
		table.put(""seashell"", new Color(0xfff5ee));
		table.put(""sienna"", new Color(0xa0522d));
		table.put(""silver"", new Color(0xc0c0c0));
		table.put(""skyblue"", new Color(0x87ceeb));
		table.put(""slateblue"", new Color(0x6a5acd));
		table.put(""slategray"", new Color(0x708090));
		table.put(""snow"", new Color(0xfffafa));
		table.put(""springgreen"", new Color(0x00ff7f));
		table.put(""steelblue"", new Color(0x4682b4));
		table.put(""tan"", new Color(0xd2b48c));
		table.put(""teal"", new Color(0x008080));
		table.put(""thistle"", new Color(0xd8bfd8));
		table.put(""tomato"", new Color(0xff6347));
		table.put(""turquoise"", new Color(0x40e0d0));
		table.put(""violet"", new Color(0xee82ee));
		table.put(""violetred"", new Color(0xd02090));
		table.put(""wheat"", new Color(0xf5deb3));
		table.put(""white"", new Color(0xffffff));
		table.put(""whitesmoke"", new Color(0xf5f5f5));
		table.put(""yellow"", new Color(0xffff00));
		table.put(""yellowgreen"", new Color(0x9acd32));

		colorTable = Collections.unmodifiableMap(table);
	}

	static ColorTable singleton = new ColorTable();

	/** Creates a new instance of ColorTable */
	protected ColorTable() {
		//        buildColorList();
	}

	static public ColorTable instance() {
		return singleton;
	}

	public Color lookupColor(String name) {
		Object obj = colorTable.get(name.toLowerCase());
		if (obj == null)
			return null;

		return (Color) obj;
	}

	protected static final String number = ""\\s*(((\\d+)(\\.\\d*)?)|(\\.\\d+))(%)?\\s*"";
	protected static final Pattern colourMatcher = Pattern
			.compile(""rgb\\("" + number + "","" + number + "","" + number + ""\\)"", Pattern.CASE_INSENSITIVE);

	public static Color parseColor(String val) {
		Color retVal = null;

		if (val.charAt(0) == '#') {
			String hexStrn = val.substring(1);

			if (hexStrn.length() == 3) {
				hexStrn = """" + hexStrn.charAt(0) + hexStrn.charAt(0) + hexStrn.charAt(1) + hexStrn.charAt(1)
						+ hexStrn.charAt(2) + hexStrn.charAt(2);
			}
			int hexVal = parseHex(hexStrn);

			retVal = new Color(hexVal);
		} else {
			final Matcher rgbMatch = colourMatcher.matcher("""");

			rgbMatch.reset(val);
			if (rgbMatch.matches()) {
				float rr = Float.parseFloat(rgbMatch.group(1));
				float gg = Float.parseFloat(rgbMatch.group(7));
				float bb = Float.parseFloat(rgbMatch.group(13));
				rr /= ""%"".equals(rgbMatch.group(6)) ? 100 : 255;
				gg /= ""%"".equals(rgbMatch.group(12)) ? 100 : 255;
				bb /= ""%"".equals(rgbMatch.group(18)) ? 100 : 255;
				retVal = new Color(rr, gg, bb);
			} else {
				Color lookupCol = ColorTable.instance().lookupColor(val);
				if (lookupCol != null)
					retVal = lookupCol;
			}
		}

		return retVal;
	}

	public static int parseHex(String val) {
		int retVal = 0;

		for (int i = 0; i < val.length(); i++) {
			retVal <<= 4;

			char ch = val.charAt(i);
			if (ch >= '0' && ch <= '9') {
				retVal |= ch - '0';
			} else if (ch >= 'a' && ch <= 'z') {
				retVal |= ch - 'a' + 10;
			} else if (ch >= 'A' && ch <= 'Z') {
				retVal |= ch - 'A' + 10;
			} else
				throw new RuntimeException();
		}

		return retVal;
	}

}
"
CPXConsts.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 12, 2004, 12:51 PM
 */

package com.kitfox.svg.xml.cpx;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public interface CPXConsts {

    static final byte[] MAGIC_NUMBER = {'C', 'P', 'X', 0};

    static final int XL_PLAIN = 0;
    static final int XL_ZIP_CRYPT = 1;
}
"
CPXInputStream.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 12, 2004, 10:34 AM
 */

package com.kitfox.svg.xml.cpx;

import com.kitfox.svg.SVGConst;
import java.io.*;
import java.util.*;
import java.util.zip.*;
import java.security.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.crypto.*;

/**
 * This class reads/decodes the CPX file format.  This format is a simple
 * compression/encryption transformer for XML data.  This stream takes in
 * encrypted XML and outputs decrypted.  It does this by checking for a magic
 * number at the start of the stream.  If absent, it treats the stream as
 * raw XML data and passes it through unaltered.  This is to aid development
 * in debugging versions, where the XML files will not be in CPX format.
 *
 * See http://java.sun.com/developer/technicalArticles/Security/Crypto/
 *
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class CPXInputStream extends FilterInputStream implements CPXConsts {


    SecureRandom sec = new SecureRandom();

    Inflater inflater = new Inflater();

    int xlateMode;

    //Keep header bytes in case this stream turns out to be plain text
    byte[] head = new byte[4];
    int headSize = 0;
    int headPtr = 0;

    boolean reachedEOF = false;
    byte[] inBuffer = new byte[2048];
    byte[] decryptBuffer = new byte[2048];

    /** Creates a new instance of CPXInputStream */
    public CPXInputStream(InputStream in) throws IOException {
        super(in);

        //Determine processing type
        for (int i = 0; i < 4; i++)
        {
            int val = in.read();
            head[i] = (byte)val;
            if (val == -1 || head[i] != MAGIC_NUMBER[i])
            {
                headSize = i + 1;
                xlateMode = XL_PLAIN;
                return;
            }
        }

        xlateMode = XL_ZIP_CRYPT;
    }

    /**
     * We do not allow marking
     */
    public boolean markSupported() { return false; }

    /**
     * Closes this input stream and releases any system resources
     * associated with the stream.
     * This
     * method simply performs <code>in.close()</code>.
     *
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.FilterInputStream#in
     */
    public void close() throws IOException {
        reachedEOF = true;
        in.close();
    }

    /**
     * Reads the next byte of data from this input stream. The value
     * byte is returned as an <code>int</code> in the range
     * <code>0</code> to <code>255</code>. If no byte is available
     * because the end of the stream has been reached, the value
     * <code>-1</code> is returned. This method blocks until input data
     * is available, the end of the stream is detected, or an exception
     * is thrown.
     * <p>
     * This method
     * simply performs <code>in.read()</code> and returns the result.
     *
     * @return     the next byte of data, or <code>-1</code> if the end of the
     *             stream is reached.
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.FilterInputStream#in
     */
    public int read() throws IOException
    {
        final byte[] b = new byte[1];
        int retVal = read(b, 0, 1);
        if (retVal == -1) return -1;
        return b[0];
    }

    /**
     * Reads up to <code>byte.length</code> bytes of data from this
     * input stream into an array of bytes. This method blocks until some
     * input is available.
     * <p>
     * This method simply performs the call
     * <code>read(b, 0, b.length)</code> and returns
     * the  result. It is important that it does
     * <i>not</i> do <code>in.read(b)</code> instead;
     * certain subclasses of  <code>FilterInputStream</code>
     * depend on the implementation strategy actually
     * used.
     *
     * @param      b   the buffer into which the data is read.
     * @return     the total number of bytes read into the buffer, or
     *             <code>-1</code> if there is no more data because the end of
     *             the stream has been reached.
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.FilterInputStream#read(byte[], int, int)
     */
    public int read(byte[] b) throws IOException
    {
        return read(b, 0, b.length);
    }

    /**
     * Reads up to <code>len</code> bytes of data from this input stream
     * into an array of bytes. This method blocks until some input is
     * available.
     * <p>
     * This method simply performs <code>in.read(b, off, len)</code>
     * and returns the result.
     *
     * @param      b     the buffer into which the data is read.
     * @param      off   the start offset of the data.
     * @param      len   the maximum number of bytes read.
     * @return     the total number of bytes read into the buffer, or
     *             <code>-1</code> if there is no more data because the end of
     *             the stream has been reached.
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.FilterInputStream#in
     */
    public int read(byte[] b, int off, int len) throws IOException
    {
        if (reachedEOF) return -1;

        if (xlateMode == XL_PLAIN)
        {
            int count = 0;
            //Write header if appropriate
            while (headPtr < headSize && len > 0)
            {
                b[off++] = head[headPtr++];
                count++;
                len--;
            }

            return (len == 0) ? count : count + in.read(b, off, len);
        }

        //Decrypt and inflate
        if (inflater.needsInput() && !decryptChunk())
        {
            reachedEOF = true;

            //Read remaining bytes
            int numRead;
            try {
                numRead = inflater.inflate(b, off, len);
            }
            catch (Exception e)
            {
                Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
                return -1;
            }

            if (!inflater.finished())
            {
                Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                    ""Inflation imncomplete"");
            }

            return numRead == 0 ? -1 : numRead;
        }

        try
        {
            return inflater.inflate(b, off, len);
        }
        catch (DataFormatException e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
            return -1;
        }
    }


    /**
     * Call when inflater indicates that it needs more bytes.
     * @return - true if we decrypted more bytes to deflate, false if we
     * encountered the end of stream
     */
    protected boolean decryptChunk() throws IOException
    {
        while (inflater.needsInput())
        {
            int numInBytes = in.read(inBuffer);
            if (numInBytes == -1) return false;
//            int numDecryptBytes = cipher.update(inBuffer, 0, numInBytes, decryptBuffer);
//            inflater.setInput(decryptBuffer, 0, numDecryptBytes);
inflater.setInput(inBuffer, 0, numInBytes);
        }

        return true;
    }

    /**
     * This method returns 1 if we've not reached EOF, 0 if we have.  Programs
     * should not rely on this to determine the number of bytes that can be
     * read without blocking.
     */
    public int available() { return reachedEOF ? 0 : 1; }

    /**
     * Skips bytes by reading them into a cached buffer
     */
    public long skip(long n) throws IOException
    {
        int skipSize = (int)n;
        if (skipSize > inBuffer.length) skipSize = inBuffer.length;
        return read(inBuffer, 0, skipSize);
    }

}

/*
 import java.security.KeyPairGenerator;
  import java.security.KeyPair;
  import java.security.KeyPairGenerator;
  import java.security.PrivateKey;
  import java.security.PublicKey;
  import java.security.SecureRandom;
  import java.security.Cipher;

  ....

  java.security.Security.addProvider(new cryptix.provider.Cryptix());

  SecureRandom random = new SecureRandom(SecureRandom.getSeed(30));
  KeyPairGenerator keygen = KeyPairGenerator.getInstance(""RSA"");
  keygen.initialize(1024, random);
  keypair = keygen.generateKeyPair();

  PublicKey  pubkey  = keypair.getPublic();
  PrivateKey privkey = keypair.getPrivate();
 */

/*
 *
 *Generate key pairs
KeyPairGenerator keyGen =
             KeyPairGenerator.getInstance(""DSA"");
KeyGen.initialize(1024, new SecureRandom(userSeed));
KeyPair pair = KeyGen.generateKeyPair();
 */"
CPXOutputStream.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 12, 2004, 12:50 PM
 */

package com.kitfox.svg.xml.cpx;

import java.io.*;
import java.util.zip.*;
import java.security.*;
import javax.crypto.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class CPXOutputStream extends FilterOutputStream implements CPXConsts {

    Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION);

    /** Creates a new instance of CPXOutputStream */
    public CPXOutputStream(OutputStream os) throws IOException {
        super(os);

        //Write magic number
        os.write(MAGIC_NUMBER);
    }

    /**
     * Writes the specified <code>byte</code> to this output stream.
     * <p>
     * The <code>write</code> method of <code>FilterOutputStream</code>
     * calls the <code>write</code> method of its underlying output stream,
     * that is, it performs <tt>out.write(b)</tt>.
     * <p>
     * Implements the abstract <tt>write</tt> method of <tt>OutputStream</tt>.
     *
     * @param      b   the <code>byte</code>.
     * @exception  IOException  if an I/O error occurs.
     */
    public void write(int b) throws IOException {
        final byte[] buf = new byte[1];
        buf[0] = (byte)b;
	write(buf, 0, 1);
    }

    /**
     * Writes <code>b.length</code> bytes to this output stream.
     * <p>
     * The <code>write</code> method of <code>FilterOutputStream</code>
     * calls its <code>write</code> method of three arguments with the
     * arguments <code>b</code>, <code>0</code>, and
     * <code>b.length</code>.
     * <p>
     * Note that this method does not call the one-argument
     * <code>write</code> method of its underlying stream with the single
     * argument <code>b</code>.
     *
     * @param      b   the data to be written.
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.FilterOutputStream#write(byte[], int, int)
     */
    public void write(byte b[]) throws IOException {
	write(b, 0, b.length);
    }

    byte[] deflateBuffer = new byte[2048];

    /**
     * Writes <code>len</code> bytes from the specified
     * <code>byte</code> array starting at offset <code>off</code> to
     * this output stream.
     * <p>
     * The <code>write</code> method of <code>FilterOutputStream</code>
     * calls the <code>write</code> method of one argument on each
     * <code>byte</code> to output.
     * <p>
     * Note that this method does not call the <code>write</code> method
     * of its underlying input stream with the same arguments. Subclasses
     * of <code>FilterOutputStream</code> should provide a more efficient
     * implementation of this method.
     *
     * @param      b     the data.
     * @param      off   the start offset in the data.
     * @param      len   the number of bytes to write.
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.FilterOutputStream#write(int)
     */
    public void write(byte b[], int off, int len) throws IOException
    {
        deflater.setInput(b, off, len);

        processAllData();
        /*
        int numDeflatedBytes;
        while ((numDeflatedBytes = deflater.deflate(deflateBuffer)) != 0)
        {
//            byte[] cipherBuf = cipher.update(deflateBuffer, 0, numDeflatedBytes);
//            out.write(cipherBytes);
out.write(deflateBuffer, 0, numDeflatedBytes);
        }
        */
    }

    protected void processAllData() throws IOException
    {
        int numDeflatedBytes;
        while ((numDeflatedBytes = deflater.deflate(deflateBuffer)) != 0)
        {
//            byte[] cipherBuf = cipher.update(deflateBuffer, 0, numDeflatedBytes);
//            out.write(cipherBytes);
out.write(deflateBuffer, 0, numDeflatedBytes);
        }
    }

    /**
     * Flushes this output stream and forces any buffered output bytes
     * to be written out to the stream.
     * <p>
     * The <code>flush</code> method of <code>FilterOutputStream</code>
     * calls the <code>flush</code> method of its underlying output stream.
     *
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.FilterOutputStream#out
     */
    public void flush() throws IOException {
	out.flush();
    }

    /**
     * Closes this output stream and releases any system resources
     * associated with the stream.
     * <p>
     * The <code>close</code> method of <code>FilterOutputStream</code>
     * calls its <code>flush</code> method, and then calls the
     * <code>close</code> method of its underlying output stream.
     *
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.FilterOutputStream#flush()
     * @see        java.io.FilterOutputStream#out
     */
    public void close() throws IOException {
        deflater.finish();
        processAllData();

	try {
	  flush();
	} catch (IOException ignored) {
	}
	out.close();
    }
}
"
CPXTest.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 12, 2004, 2:45 PM
 */

package com.kitfox.svg.xml.cpx;

import com.kitfox.svg.SVGConst;
import java.io.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class CPXTest {

    /** Creates a new instance of CPXTest */
    public CPXTest() {

//        FileInputStream fin = new FileInputStream();
        writeTest();
        readTest();
    }

    public void writeTest()
    {
        try {

            InputStream is = CPXTest.class.getResourceAsStream(""/data/readme.txt"");
//System.err.println(""Is "" + is);

            FileOutputStream fout = new FileOutputStream(""C:\\tmp\\cpxFile.cpx"");
            CPXOutputStream cout = new CPXOutputStream(fout);

            byte[] buffer = new byte[1024];
            int numBytes;
            while ((numBytes = is.read(buffer)) != -1)
            {
                cout.write(buffer, 0, numBytes);
            }
            cout.close();
        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
        }
    }

    public void readTest()
    {
        try {

//            InputStream is = CPXTest.class.getResourceAsStream(""/rawdata/test/cpx/text.txt"");
//            InputStream is = CPXTest.class.getResourceAsStream(""/rawdata/test/cpx/cpxFile.cpx"");
            FileInputStream is = new FileInputStream(""C:\\tmp\\cpxFile.cpx"");
            CPXInputStream cin = new CPXInputStream(is);

            BufferedReader br = new BufferedReader(new InputStreamReader(cin));
            String line;
            while ((line = br.readLine()) != null)
            {
                System.err.println(line);
            }
        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)
    {
        new CPXTest();
    }

}
"
NumberWithUnits.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on February 18, 2004, 2:43 PM
 */

package com.kitfox.svg.xml;

import java.io.Serializable;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class NumberWithUnits implements Serializable
{
    public static final long serialVersionUID = 0;
    
    public static final int UT_UNITLESS = 0;
    public static final int UT_PX = 1;  //Pixels
    public static final int UT_CM = 2;  //Centimeters
    public static final int UT_MM = 3;  //Millimeters
    public static final int UT_IN = 4;  //Inches
    public static final int UT_EM = 5;  //Default font height
    public static final int UT_EX = 6;  //Height of character 'x' in default font
    public static final int UT_PT = 7;  //Points - 1/72 of an inch
    public static final int UT_PC = 8;  //Picas - 1/6 of an inch
    public static final int UT_PERCENT = 9;  //Percent - relative width

    float value = 0f;
    int unitType = UT_UNITLESS;

    /** Creates a new instance of NumberWithUnits */
    public NumberWithUnits()
    {
    }

    public NumberWithUnits(String value)
    {
        set(value);
    }

    public NumberWithUnits(float value, int unitType)
    {
        this.value = value;
        this.unitType = unitType;
    }

    public float getValue() { return value; }
    public int getUnits() { return unitType; }

    public void set(String value)
    {
        this.value = XMLParseUtil.findFloat(value);
        unitType = UT_UNITLESS;

        if (value.indexOf(""px"") != -1) { unitType = UT_PX; return; }
        if (value.indexOf(""cm"") != -1) { unitType = UT_CM; return; }
        if (value.indexOf(""mm"") != -1) { unitType = UT_MM; return; }
        if (value.indexOf(""in"") != -1) { unitType = UT_IN; return; }
        if (value.indexOf(""em"") != -1) { unitType = UT_EM; return; }
        if (value.indexOf(""ex"") != -1) { unitType = UT_EX; return; }
        if (value.indexOf(""pt"") != -1) { unitType = UT_PT; return; }
        if (value.indexOf(""pc"") != -1) { unitType = UT_PC; return; }
        if (value.indexOf(""%"") != -1) { unitType = UT_PERCENT; return; }
    }

    public static String unitsAsString(int unitIdx)
    {
        switch (unitIdx)
        {
            default:
                return """";
            case UT_PX:
                return ""px"";
            case UT_CM:
                return ""cm"";
            case UT_MM:
                return ""mm"";
            case UT_IN:
                return ""in"";
            case UT_EM:
                return ""em"";
            case UT_EX:
                return ""ex"";
            case UT_PT:
                return ""pt"";
            case UT_PC:
                return ""pc"";
            case UT_PERCENT:
                return ""%"";
        }
    }

    public String toString()
    {
        return """" + value + unitsAsString(unitType);
    }

    public boolean equals(Object obj)
    {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final NumberWithUnits other = (NumberWithUnits) obj;
        if (Float.floatToIntBits(this.value) != Float.floatToIntBits(other.value)) {
            return false;
        }
        if (this.unitType != other.unitType) {
            return false;
        }
        return true;
    }

    public int hashCode()
    {
        int hash = 5;
        hash = 37 * hash + Float.floatToIntBits(this.value);
        hash = 37 * hash + this.unitType;
        return hash;
    }


}
"
ReadableXMLElement.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 1, 2003, 1:46 AM
 */

package com.kitfox.svg.xml;

import org.w3c.dom.*;
import java.net.*;
import java.util.*;
import java.lang.reflect.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public interface ReadableXMLElement {

    /**
     * Initializes this element from the passed DOM tree.
     * @param root - DOM tree to build from
     * @param docRoot - URL of the document this DOM tree was created from
     */
    public void read(Element root, URL docRoot);

}
"
StyleAttribute.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on January 27, 2004, 2:53 PM
 */

package com.kitfox.svg.xml;

import com.kitfox.svg.SVGConst;
import java.awt.*;
import java.io.*;
import java.net.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class StyleAttribute implements Serializable
{
    public static final long serialVersionUID = 0;

    static final Pattern patternUrl = Pattern.compile(""\\s*url\\((.*)\\)\\s*"");
    static final Matcher matchFpNumUnits = Pattern.compile(""\\s*([-+]?((\\d*\\.\\d+)|(\\d+))([-+]?[eE]\\d+)?)\\s*(px|cm|mm|in|pc|pt|em|ex)\\s*"").matcher("""");
    
    String name;
    String stringValue;

    boolean colorCompatable = false;
    boolean urlCompatable = false;

    /** Creates a new instance of StyleAttribute */
    public StyleAttribute()
    {
        this(null, null);
    }
    
    public StyleAttribute(String name) 
    {
        this.name = name;
        stringValue = null;
    }

    public StyleAttribute(String name, String stringValue) 
    {
        this.name = name;
        this.stringValue = stringValue;
    }

    public String getName() {
        return name;
    }
    
    public StyleAttribute setName(String name)
    {
        this.name = name;
        return this;
    }
    
    public String getStringValue()
    {
        return stringValue; 
    }

    public String[] getStringList() 
    { 
        return XMLParseUtil.parseStringList(stringValue);
    }

    public void setStringValue(String value)
    {
        stringValue = value;
    }

    public boolean getBooleanValue() {
        return stringValue.toLowerCase().equals(""true"");
    }

    public int getIntValue() {
        return XMLParseUtil.findInt(stringValue);
    }

    public int[] getIntList() {
        return XMLParseUtil.parseIntList(stringValue);
    }

    public double getDoubleValue() {
        return XMLParseUtil.findDouble(stringValue);
    }

    public double[] getDoubleList() {
        return XMLParseUtil.parseDoubleList(stringValue);
    }

    public float getFloatValue() {
        return XMLParseUtil.findFloat(stringValue);
    }

    public float[] getFloatList() {
        return XMLParseUtil.parseFloatList(stringValue);
    }

    public float getRatioValue() {
        return (float)XMLParseUtil.parseRatio(stringValue);
//        try { return Float.parseFloat(stringValue); }
//        catch (Exception e) {}
//        return 0f;
    }

    public String getUnits() {
        matchFpNumUnits.reset(stringValue);
        if (!matchFpNumUnits.matches()) return null;
        return matchFpNumUnits.group(6);
    }

    public NumberWithUnits getNumberWithUnits() {
        return XMLParseUtil.parseNumberWithUnits(stringValue);
    }

    public float getFloatValueWithUnits()
    {
        NumberWithUnits number = getNumberWithUnits();
        return convertUnitsToPixels(number.getUnits(), number.getValue());
    }
    
    static public float convertUnitsToPixels(int unitType, float value)
    {
        if (unitType == NumberWithUnits.UT_UNITLESS || unitType == NumberWithUnits.UT_PERCENT)
        {
            return value;
        }
        
        float pixPerInch;
        try 
        {
            pixPerInch = (float)Toolkit.getDefaultToolkit().getScreenResolution();
        }
        catch (HeadlessException ex)
        {
            //default to 72 dpi
            pixPerInch = 72;
        }
        final float inchesPerCm = .3936f;

        switch (unitType)
        {
            case NumberWithUnits.UT_IN:
                return value * pixPerInch;
            case NumberWithUnits.UT_CM:
                return value * inchesPerCm * pixPerInch;
            case NumberWithUnits.UT_MM:
                return value * .1f * inchesPerCm * pixPerInch;
            case NumberWithUnits.UT_PT:
                return value * (1f / 72f) * pixPerInch;
            case NumberWithUnits.UT_PC:
                return value *  (1f / 6f) * pixPerInch;
        }

        return value;
    }

    public Color getColorValue()
    {
        return ColorTable.parseColor(stringValue);
    }

    public String parseURLFn()
    {
        Matcher matchUrl = patternUrl.matcher(stringValue);
        if (!matchUrl.matches()) 
        {
            return null;
        }
        return matchUrl.group(1);
    }

    public URL getURLValue(URL docRoot)
    {
        String fragment = parseURLFn();
        if (fragment == null) return null;
        try {
            return new URL(docRoot, fragment);
        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
            return null;
        }
    }

    public URL getURLValue(URI docRoot)
    {
        String fragment = parseURLFn();
        if (fragment == null) return null;
        try {
            URI ref = docRoot.resolve(fragment);
            return ref.toURL();
        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
            return null;
        }
    }

    public URI getURIValue()
    {
        return getURIValue(null);
    }
    
    /**
     * Parse this sytle attribute as a URL and return it in URI form resolved
     * against the passed base.
     *
     * @param base - URI to resolve against.  If null, will return value without
     * attempting to resolve it.
     */
    public URI getURIValue(URI base)
    {
        try {
            String fragment = parseURLFn();
            if (fragment == null) fragment = stringValue.replaceAll(""\\s+"", """");
            if (fragment == null) return null;
            
            //======================
            //This gets around a bug in the 1.5.0 JDK
            if (Pattern.matches(""[a-zA-Z]:!\\\\.*"", fragment))
            {
                File file = new File(fragment);
                return file.toURI();
            }
            //======================

            //[scheme:]scheme-specific-part[#fragment]
            
            URI uriFrag = new URI(fragment);
            if (uriFrag.isAbsolute())
            {
                //Has scheme
                return uriFrag;
            }
        
            if (base == null) return uriFrag;
        
            URI relBase = new URI(null, base.getSchemeSpecificPart(), null);
            URI relUri;
            if (relBase.isOpaque())
            {
                relUri = new URI(null, base.getSchemeSpecificPart(), uriFrag.getFragment());
            }
            else
            {
                relUri = relBase.resolve(uriFrag);
            }
            return new URI(base.getScheme() + "":"" + relUri);
        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
            return null;
        }
    }
    
    public static void main(String[] args)
    {
        try
        {
            URI uri = new URI(""jar:http://www.kitfox.com/jackal/jackal.jar!/res/doc/about.svg"");
            uri = uri.resolve(""#myFragment"");
            
            System.err.println(uri.toString());
            
            uri = new URI(""http://www.kitfox.com/jackal/jackal.html"");
            uri = uri.resolve(""#myFragment"");
            
            System.err.println(uri.toString());
        }
        catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
        }
    }
}
"
StyleSheet.java,kitfox-6.9.6,"/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.kitfox.svg.xml;

import com.kitfox.svg.SVGConst;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author kitfox
 */
public class StyleSheet
{
    HashMap ruleMap = new HashMap();

    public static StyleSheet parseSheet(String src)
    {
        //Implement CS parser later
        Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
            ""CSS parser not implemented yet"");
        return null;
    }
    
    public void addStyleRule(StyleSheetRule rule, String value)
    {
        ruleMap.put(rule, value);
    }
    
    public boolean getStyle(StyleAttribute attrib, String tagName, String cssClass)
    {
        StyleSheetRule rule = new StyleSheetRule(attrib.getName(), tagName, cssClass);
        String value = (String)ruleMap.get(rule);
        
        if (value != null)
        {
            attrib.setStringValue(value);
            return true;
        }
        
        //Try again using just class name
        rule = new StyleSheetRule(attrib.getName(), null, cssClass);
        value = (String)ruleMap.get(rule);
        
        if (value != null)
        {
            attrib.setStringValue(value);
            return true;
        }
        
        //Try again using just tag name
        rule = new StyleSheetRule(attrib.getName(), tagName, null);
        value = (String)ruleMap.get(rule);
        
        if (value != null)
        {
            attrib.setStringValue(value);
            return true;
        }
        
        return false;
    }
    
}
"
StyleSheetRule.java,kitfox-6.9.6,"/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.kitfox.svg.xml;

/**
 *
 * @author kitfox
 */
public class StyleSheetRule
{
    final String styleName;
    final String tag;
    final String className;

    public StyleSheetRule(String styleName, String tag, String className)
    {
        this.styleName = styleName;
        this.tag = tag;
        this.className = className;
    }

    public int hashCode()
    {
        int hash = 7;
        hash = 13 * hash + (this.styleName != null ? this.styleName.hashCode() : 0);
        hash = 13 * hash + (this.tag != null ? this.tag.hashCode() : 0);
        hash = 13 * hash + (this.className != null ? this.className.hashCode() : 0);
        return hash;
    }

    public boolean equals(Object obj)
    {
        if (obj == null)
        {
            return false;
        }
        if (getClass() != obj.getClass())
        {
            return false;
        }
        final StyleSheetRule other = (StyleSheetRule) obj;
        if ((this.styleName == null) ? (other.styleName != null) : !this.styleName.equals(other.styleName))
        {
            return false;
        }
        if ((this.tag == null) ? (other.tag != null) : !this.tag.equals(other.tag))
        {
            return false;
        }
        if ((this.className == null) ? (other.className != null) : !this.className.equals(other.className))
        {
            return false;
        }
        return true;
    }

}
"
WritableXMLElement.java,kitfox-6.9.6,"/*
 * SVG Salamander
 * Copyright (c) 2004, Mark McKay
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 *   - Redistributions of source code must retain the above 
 *     copyright notice, this list of conditions and the following
 *     disclaimer.
 *   - Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials 
 *     provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * Mark McKay can be contacted at mark@kitfox.com.  Salamander and other
 * projects can be found at http://www.kitfox.com
 *
 * Created on September 1, 2003, 1:46 AM
 */

package com.kitfox.svg.xml;

import org.w3c.dom.*;
import java.net.*;
import java.util.*;
import java.lang.reflect.*;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public interface WritableXMLElement {

    /**
     * Initializes this element from the passed DOM tree.
     * @param root - DOM tree to build from
     * @param docRoot - URL of the document this DOM tree was created from
     */
//    public void write(Element root, URL docRoot);

}
"
XMLParseUtil.java,kitfox-6.9.6,"/*
 * SVG Salamander Copyright (c) 2004, Mark McKay All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. - Redistributions in binary
 * form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided
 * with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Mark McKay can be contacted at mark@kitfox.com. Salamander and other projects
 * can be found at http://www.kitfox.com
 * 
 * Created on February 18, 2004, 1:49 PM
 */

package com.kitfox.svg.xml;

import java.awt.Toolkit;
import java.lang.reflect.Array;
import java.net.URL;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

import com.kitfox.svg.SVGConst;

/**
 * @author Mark McKay
 * @author <a href=""mailto:mark@kitfox.com"">Mark McKay</a>
 */
public class XMLParseUtil {
	static final Pattern fpMatch = Pattern.compile(
			""([-+]?((\\d*\\.\\d+)|(\\d+))([eE][+-]?\\d+)?)(\\%|in|cm|mm|pt|pc|px|em|ex)?"");
	static final Pattern intMatch = Pattern.compile(""[-+]?\\d+"");

	/** Creates a new instance of XMLParseUtil */
	private XMLParseUtil() {
	}

	/**
	 * Scans the tag's children and returns the first text element found
	 */
	public static String getTagText(Element ele) {
		NodeList nl = ele.getChildNodes();
		int size = nl.getLength();

		Node node = null;
		int i = 0;
		for (; i < size; i++) {
			node = nl.item(i);
			if (node instanceof Text)
				break;
		}
		if (i == size || node == null)
			return null;

		return ((Text) node).getData();
	}

	/**
	 * Returns the first node that is a direct child of root with the
	 * coresponding name. Does not search children of children.
	 */
	public static Element getFirstChild(Element root, String name) {
		NodeList nl = root.getChildNodes();
		int size = nl.getLength();
		for (int i = 0; i < size; i++) {
			Node node = nl.item(i);
			if (!(node instanceof Element))
				continue;
			Element ele = (Element) node;
			if (ele.getTagName().equals(name))
				return ele;
		}

		return null;
	}

	public static String[] parseStringList(String list) {
		//        final Pattern patWs = Pattern.compile(""\\s+"");
		final Matcher matchWs = Pattern.compile(""[^\\s]+"").matcher("""");
		matchWs.reset(list);

		LinkedList matchList = new LinkedList();
		while (matchWs.find()) {
			matchList.add(matchWs.group());
		}

		String[] retArr = new String[matchList.size()];
		return (String[]) matchList.toArray(retArr);
	}

	public static boolean isDouble(String val) {
		try {
			return fpMatch.matcher(val).matches();
		} catch (StringIndexOutOfBoundsException e) {
			throw e;
		}
	}

	public static double parseDouble(String val) {
		/*
		 * if (val == null) return 0.0;
		 * 
		 * double retVal = 0.0; try { retVal = Double.parseDouble(val); } catch
		 * (Exception e) {} return retVal;
		 */
		return findDouble(val);
	}

	/**
	 * Searches the given string for the first floating point number it
	 * contains, parses and returns it.
	 */
	public synchronized static double findDouble(String val) {
		if (val == null)
			return 0;

		Matcher matcher = fpMatch.matcher(val);
		try {
			if (!matcher.find())
				return 0;
		} catch (StringIndexOutOfBoundsException e) {
			Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
					""XMLParseUtil: regex parse problem: '"" + val + ""'"", e);
		}

		val = matcher.group(1);
		//System.err.println(""Parsing "" + val);

		double retVal = 0;
		try {
			retVal = Double.parseDouble(val);

			float pixPerInch;
			try {
				pixPerInch = (float) Toolkit.getDefaultToolkit().getScreenResolution();
			} catch (NoClassDefFoundError err) {
				//Default value for headless X servers
				pixPerInch = 72;
			}
			final float inchesPerCm = .3936f;
			final String units = matcher.group(6);

			if (""%"".equals(units))
				retVal /= 100;
			else if (""in"".equals(units)) {
				retVal *= pixPerInch;
			} else if (""cm"".equals(units)) {
				retVal *= inchesPerCm * pixPerInch;
			} else if (""mm"".equals(units)) {
				retVal *= inchesPerCm * pixPerInch * .1f;
			} else if (""pt"".equals(units)) {
				retVal *= (1f / 72f) * pixPerInch;
			} else if (""pc"".equals(units)) {
				retVal *= (1f / 6f) * pixPerInch;
			}
		} catch (Exception e) {
		}
		return retVal;
	}

	/**
	 * Scans an input string for double values. For each value found, places in
	 * a list. This method regards any characters not part of a floating point
	 * value to be seperators. Thus this will parse whitespace seperated, comma
	 * seperated, and many other separation schemes correctly.
	 */
	public synchronized static double[] parseDoubleList(String list) {
		if (list == null)
			return null;

		Matcher matcher = fpMatch.matcher(list);

		LinkedList doubList = new LinkedList();
		while (matcher.find()) {
			String val = matcher.group(1);
			doubList.add(Double.valueOf(val));
		}

		double[] retArr = new double[doubList.size()];
		Iterator it = doubList.iterator();
		int idx = 0;
		while (it.hasNext()) {
			retArr[idx++] = ((Double) it.next()).doubleValue();
		}

		return retArr;
	}

	public static float parseFloat(String val) {
		/*
		 * if (val == null) return 0f;
		 * 
		 * float retVal = 0f; try { retVal = Float.parseFloat(val); } catch
		 * (Exception e) {} return retVal;
		 */
		return findFloat(val);
	}

	/**
	 * Searches the given string for the first floating point number it
	 * contains, parses and returns it.
	 */
	public synchronized static float findFloat(String val) {
		if (val == null)
			return 0f;

		Matcher matcher = fpMatch.matcher(val);
		if (!matcher.find())
			return 0f;

		val = matcher.group(1);
		//System.err.println(""Parsing "" + val);

		float retVal = 0f;
		try {
			retVal = Float.parseFloat(val);
			String units = matcher.group(6);
			if (""%"".equals(units))
				retVal /= 100;
		} catch (Exception e) {
		}
		return retVal;
	}

	public synchronized static float[] parseFloatList(String list) {
		if (list == null)
			return null;

		Matcher matcher = fpMatch.matcher(list);

		LinkedList floatList = new LinkedList();
		while (matcher.find()) {
			String val = matcher.group(1);
			floatList.add(Float.valueOf(val));
		}

		float[] retArr = new float[floatList.size()];
		Iterator it = floatList.iterator();
		int idx = 0;
		while (it.hasNext()) {
			retArr[idx++] = ((Float) it.next()).floatValue();
		}

		return retArr;
	}

	public static int parseInt(String val) {
		if (val == null)
			return 0;

		int retVal = 0;
		try {
			retVal = Integer.parseInt(val);
		} catch (Exception e) {
		}
		return retVal;
	}

	/**
	 * Searches the given string for the first integer point number it contains,
	 * parses and returns it.
	 */
	public static int findInt(String val) {
		if (val == null)
			return 0;

		Matcher matcher = intMatch.matcher(val);
		if (!matcher.find())
			return 0;

		val = matcher.group();
		//System.err.println(""Parsing "" + val);

		int retVal = 0;
		try {
			retVal = Integer.parseInt(val);
		} catch (Exception e) {
		}
		return retVal;
	}

	public static int[] parseIntList(String list) {
		if (list == null)
			return null;

		Matcher matcher = intMatch.matcher(list);

		LinkedList intList = new LinkedList();
		while (matcher.find()) {
			String val = matcher.group();
			intList.add(Integer.valueOf(val));
		}

		int[] retArr = new int[intList.size()];
		Iterator it = intList.iterator();
		int idx = 0;
		while (it.hasNext()) {
			retArr[idx++] = ((Integer) it.next()).intValue();
		}

		return retArr;
	}

	/*
	 * public static int parseHex(String val) { int retVal = 0;
	 * 
	 * for (int i = 0; i < val.length(); i++) { retVal <<= 4;
	 * 
	 * char ch = val.charAt(i); if (ch >= '0' && ch <= '9') { retVal |= ch -
	 * '0'; } else if (ch >= 'a' && ch <= 'z') { retVal |= ch - 'a' + 10; } else
	 * if (ch >= 'A' && ch <= 'Z') { retVal |= ch - 'A' + 10; } else throw new
	 * RuntimeException(); }
	 * 
	 * return retVal; }
	 */
	/**
	 * The input string represents a ratio. Can either be specified as a double
	 * number on the range of [0.0 1.0] or as a percentage [0% 100%]
	 */
	public static double parseRatio(String val) {
		if (val == null || val.equals(""""))
			return 0.0;

		if (val.charAt(val.length() - 1) == '%') {
			parseDouble(val.substring(0, val.length() - 1));
		}
		return parseDouble(val);
	}

	public static NumberWithUnits parseNumberWithUnits(String val) {
		if (val == null)
			return null;

		return new NumberWithUnits(val);
	}

	/*
	 * public static Color parseColor(String val) { Color retVal = null;
	 * 
	 * if (val.charAt(0) == '#') { String hexStrn = val.substring(1);
	 * 
	 * if (hexStrn.length() == 3) { hexStrn = """" + hexStrn.charAt(0) +
	 * hexStrn.charAt(0) + hexStrn.charAt(1) + hexStrn.charAt(1) +
	 * hexStrn.charAt(2) + hexStrn.charAt(2); } int hexVal = parseHex(hexStrn);
	 * 
	 * retVal = new Color(hexVal); } else { final Matcher rgbMatch =
	 * Pattern.compile(""rgb\\((\\d+),(\\d+),(\\d+)\\)"",
	 * Pattern.CASE_INSENSITIVE).matcher("""");
	 * 
	 * rgbMatch.reset(val); if (rgbMatch.matches()) { int r =
	 * Integer.parseInt(rgbMatch.group(1)); int g =
	 * Integer.parseInt(rgbMatch.group(2)); int b =
	 * Integer.parseInt(rgbMatch.group(3)); retVal = new Color(r, g, b); } else
	 * { Color lookupCol = ColorTable.instance().lookupColor(val); if (lookupCol
	 * != null) retVal = lookupCol; } }
	 * 
	 * return retVal; }
	 */
	/**
	 * Parses the given attribute of this tag and returns it as a String.
	 */
	public static String getAttribString(Element ele, String name) {
		return ele.getAttribute(name);
	}

	/**
	 * Parses the given attribute of this tag and returns it as an int.
	 */
	public static int getAttribInt(Element ele, String name) {
		String sval = ele.getAttribute(name);
		int val = 0;
		try {
			val = Integer.parseInt(sval);
		} catch (Exception e) {
		}

		return val;
	}

	/**
	 * Parses the given attribute of this tag as a hexadecimal encoded string
	 * and returns it as an int
	 */
	public static int getAttribIntHex(Element ele, String name) {
		String sval = ele.getAttribute(name);
		int val = 0;
		try {
			val = Integer.parseInt(sval, 16);
		} catch (Exception e) {
		}

		return val;
	}

	/**
	 * Parses the given attribute of this tag and returns it as a float
	 */
	public static float getAttribFloat(Element ele, String name) {
		String sval = ele.getAttribute(name);
		float val = 0.0f;
		try {
			val = Float.parseFloat(sval);
		} catch (Exception e) {
		}

		return val;
	}

	/**
	 * Parses the given attribute of this tag and returns it as a double.
	 */
	public static double getAttribDouble(Element ele, String name) {
		String sval = ele.getAttribute(name);
		double val = 0.0;
		try {
			val = Double.parseDouble(sval);
		} catch (Exception e) {
		}

		return val;
	}

	/**
	 * Parses the given attribute of this tag and returns it as a boolean.
	 * Essentially compares the lower case textual value to the string ""true""
	 */
	public static boolean getAttribBoolean(Element ele, String name) {
		String sval = ele.getAttribute(name);

		return sval.toLowerCase().equals(""true"");
	}

	public static URL getAttribURL(Element ele, String name, URL docRoot) {
		String sval = ele.getAttribute(name);

		URL url;
		try {
			return new URL(docRoot, sval);
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Returns the first ReadableXMLElement with the given name
	 */
	public static ReadableXMLElement getElement(Class classType, Element root, String name, URL docRoot) {
		if (root == null)
			return null;

		//Do not process if not a LoadableObject
		if (!ReadableXMLElement.class.isAssignableFrom(classType)) {
			return null;
		}

		NodeList nl = root.getChildNodes();
		int size = nl.getLength();
		for (int i = 0; i < size; i++) {
			Node node = nl.item(i);
			if (!(node instanceof Element))
				continue;
			Element ele = (Element) node;
			if (!ele.getTagName().equals(name))
				continue;

			ReadableXMLElement newObj = null;
			try {
				newObj = (ReadableXMLElement) classType.newInstance();
			} catch (Exception e) {
				Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
				continue;
			}
			newObj.read(ele, docRoot);

			if (newObj == null)
				continue;

			return newObj;
		}

		return null;
	}

	/**
	 * Returns a HashMap of nodes that are children of root. All nodes will be
	 * of class classType and have a tag name of 'name'. 'key' is an attribute
	 * of tag 'name' who's string value will be used as the key in the HashMap
	 */
	public static HashMap getElementHashMap(Class classType, Element root, String name, String key, URL docRoot) {
		if (root == null)
			return null;

		//Do not process if not a LoadableObject
		if (!ReadableXMLElement.class.isAssignableFrom(classType)) {
			return null;
		}

		HashMap retMap = new HashMap();

		NodeList nl = root.getChildNodes();
		int size = nl.getLength();
		for (int i = 0; i < size; i++) {
			Node node = nl.item(i);
			if (!(node instanceof Element))
				continue;
			Element ele = (Element) node;
			if (!ele.getTagName().equals(name))
				continue;

			ReadableXMLElement newObj = null;
			try {
				newObj = (ReadableXMLElement) classType.newInstance();
			} catch (Exception e) {
				Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
				continue;
			}
			newObj.read(ele, docRoot);

			if (newObj == null)
				continue;

			String keyVal = getAttribString(ele, key);
			retMap.put(keyVal, newObj);
		}

		return retMap;
	}

	public static HashSet getElementHashSet(Class classType, Element root, String name, URL docRoot) {
		if (root == null)
			return null;

		//Do not process if not a LoadableObject
		if (!ReadableXMLElement.class.isAssignableFrom(classType)) {
			return null;
		}

		HashSet retSet = new HashSet();

		NodeList nl = root.getChildNodes();
		int size = nl.getLength();
		for (int i = 0; i < size; i++) {
			Node node = nl.item(i);
			if (!(node instanceof Element))
				continue;
			Element ele = (Element) node;
			if (!ele.getTagName().equals(name))
				continue;

			ReadableXMLElement newObj = null;
			try {
				newObj = (ReadableXMLElement) classType.newInstance();
			} catch (Exception e) {
				Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
				continue;
			}
			newObj.read(ele, docRoot);

			if (newObj == null) {
				continue;
			}

			retSet.add(newObj);
		}

		return retSet;
	}

	public static LinkedList getElementLinkedList(Class classType, Element root, String name, URL docRoot) {
		if (root == null)
			return null;

		//Do not process if not a LoadableObject
		if (!ReadableXMLElement.class.isAssignableFrom(classType)) {
			return null;
		}

		NodeList nl = root.getChildNodes();
		LinkedList elementCache = new LinkedList();
		int size = nl.getLength();
		for (int i = 0; i < size; i++) {
			Node node = nl.item(i);
			if (!(node instanceof Element))
				continue;
			Element ele = (Element) node;
			if (!ele.getTagName().equals(name))
				continue;

			ReadableXMLElement newObj = null;
			try {
				newObj = (ReadableXMLElement) classType.newInstance();
			} catch (Exception e) {
				Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING, null, e);
				continue;
			}
			newObj.read(ele, docRoot);

			elementCache.addLast(newObj);
		}

		return elementCache;
	}

	public static Object[] getElementArray(Class classType, Element root, String name, URL docRoot) {
		if (root == null)
			return null;

		//Do not process if not a LoadableObject
		if (!ReadableXMLElement.class.isAssignableFrom(classType)) {
			return null;
		}

		LinkedList elementCache = getElementLinkedList(classType, root, name, docRoot);

		Object[] retArr = (Object[]) Array.newInstance(classType, elementCache.size());
		return elementCache.toArray(retArr);
	}

	/**
	 * Takes a number of tags of name 'name' that are children of 'root', and
	 * looks for attributes of 'attrib' on them. Converts attributes to an int
	 * and returns in an array.
	 */
	public static int[] getElementArrayInt(Element root, String name, String attrib) {
		if (root == null)
			return null;

		NodeList nl = root.getChildNodes();
		LinkedList elementCache = new LinkedList();
		int size = nl.getLength();

		for (int i = 0; i < size; i++) {
			Node node = nl.item(i);
			if (!(node instanceof Element))
				continue;
			Element ele = (Element) node;
			if (!ele.getTagName().equals(name))
				continue;

			String valS = ele.getAttribute(attrib);
			int eleVal = 0;
			try {
				eleVal = Integer.parseInt(valS);
			} catch (Exception e) {
			}

			elementCache.addLast(new Integer(eleVal));
		}

		int[] retArr = new int[elementCache.size()];
		Iterator it = elementCache.iterator();
		int idx = 0;
		while (it.hasNext()) {
			retArr[idx++] = ((Integer) it.next()).intValue();
		}

		return retArr;
	}

	/**
	 * Takes a number of tags of name 'name' that are children of 'root', and
	 * looks for attributes of 'attrib' on them. Converts attributes to an int
	 * and returns in an array.
	 */
	public static String[] getElementArrayString(Element root, String name, String attrib) {
		if (root == null)
			return null;

		NodeList nl = root.getChildNodes();
		LinkedList elementCache = new LinkedList();
		int size = nl.getLength();

		for (int i = 0; i < size; i++) {
			Node node = nl.item(i);
			if (!(node instanceof Element))
				continue;
			Element ele = (Element) node;
			if (!ele.getTagName().equals(name))
				continue;

			String valS = ele.getAttribute(attrib);

			elementCache.addLast(valS);
		}

		String[] retArr = new String[elementCache.size()];
		Iterator it = elementCache.iterator();
		int idx = 0;
		while (it.hasNext()) {
			retArr[idx++] = (String) it.next();
		}

		return retArr;
	}

	/**
	 * Takes a CSS style string and retursn a hash of them.
	 * 
	 * @param styleString
	 *            - A CSS formatted string of styles. Eg,
	 *            ""font-size:12;fill:#d32c27;fill-rule:evenodd;stroke-width:1pt;""
	 */
	public static HashMap parseStyle(String styleString) {
		return parseStyle(styleString, new HashMap());
	}

	/**
	 * Takes a CSS style string and returns a hash of them.
	 * 
	 * @param styleString
	 *            - A CSS formatted string of styles. Eg,
	 *            ""font-size:12;fill:#d32c27;fill-rule:evenodd;stroke-width:1pt;""
	 * @param map
	 *            - A map to which these styles will be added
	 */
	public static HashMap parseStyle(String styleString, HashMap map) {
		final Pattern patSemi = Pattern.compile("";"");

		String[] styles = patSemi.split(styleString);

		for (int i = 0; i < styles.length; i++) {
			if (styles[i].length() == 0) {
				continue;
			}

			int colon = styles[i].indexOf(':');
			if (colon == -1) {
				continue;
			}

			String key = styles[i].substring(0, colon).trim();
			String value = styles[i].substring(colon + 1).trim();

			map.put(key, new StyleAttribute(key, value));
		}

		return map;
	}
}
"
FilterFactory.java,log-6.9.380,"package org.processmining.filtering.filter.factories;

import java.util.List;

import org.processmining.filtering.filter.implementations.FilterStackImpl;
import org.processmining.filtering.filter.implementations.MirrorFilterImpl;
import org.processmining.filtering.filter.interfaces.Filter;
import org.processmining.filtering.filter.interfaces.FilterStack;

public class FilterFactory {

	public static <T> Filter<T> mirrorFilter() {
		return new MirrorFilterImpl<T>();
	}

	public static <T> FilterStack<T> filterStack(List<Filter<T>> filters) {
		return new FilterStackImpl<T>(filters);
	}

}
"
FilterStackImpl.java,log-6.9.380,"package org.processmining.filtering.filter.implementations;

import java.util.ArrayList;
import java.util.List;

import org.processmining.filtering.filter.interfaces.Filter;
import org.processmining.filtering.filter.interfaces.FilterStack;

/**
 * @see FilterStack
 * 
 * @author S.J. van Zelst
 * 
 * @param <T>
 *            generic type on which this filter stack should be applied.
 */
public class FilterStackImpl<T> extends ArrayList<Filter<T>> implements FilterStack<T> {

	private static final long serialVersionUID = 6042187895669094422L;

	public FilterStackImpl(List<Filter<T>> filters) {
		this.addAll(filters);
	}

	@Override
	public T apply(T t) {
		T result = t;
		for (Filter<T> filter : this) {
			result = filter.apply(result);
		}
		return result;
	}
	
	@SuppressWarnings(""unchecked"")
	public FilterStack<T> clone() {
		FilterStackImpl<T> clone = null;
		clone = (FilterStackImpl<T>) super.clone();
		return clone;
	}
	

}
"
MirrorFilterImpl.java,log-6.9.380,"package org.processmining.filtering.filter.implementations;

import org.processmining.filtering.filter.interfaces.Filter;

/**
 * A mirror filter is a standard defined filter that (as the name suggests)
 * mirrors each element. Thus mirror function m : T -> T with m(t) = t.
 * 
 * @param <T>
 *            generic type on which this filter is applied.
 * 
 * @author S.J. van Zelst
 */
public class MirrorFilterImpl<T> implements Filter<T> {

	public T apply(T t) {
		return t;
	}

	@SuppressWarnings(""unchecked"")
	public Filter<T> clone() {
		Filter<T> clone = null;
		try  {
			clone = (MirrorFilterImpl<T>) super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
		return clone;
	}
}
"
Filter.java,log-6.9.380,"package org.processmining.filtering.filter.interfaces;

/**
 * A filter is in essence a ""function"" applied on some input. A filter could be
 * defined as a function f : T -> T. A filter is a cloneable object.
 * 
 * @param <T>
 *            generic type on which this filter is applied.
 */
public interface Filter<T> extends Cloneable {
	
	/**
	 * Apply this filter on some input.
	 * 
	 * @param t
	 *            input object of type T
	 * @return return object of type T
	 */
	public T apply(T t);

	/**
	 * Create this filter's clone.
	 * 
	 * @return clone of filter.
	 */
	public Filter<T> clone();
}
"
FilterStack.java,log-6.9.380,"package org.processmining.filtering.filter.interfaces;

import java.util.List;

/**
 * A Filter stack is (as the name suggests) a ""stack of filters"". It is in
 * essence a list of filters, all of the type f: T -> T. If we have a list of
 * filters L = <f0, f1, ..., fn> and we hand over object t of type T, the result
 * will be fn(fn-1(...f1(f0(t)))).
 * 
 * @param <T>
 *            generic type on which this filter is applied.
 */
public interface FilterStack<T> extends Filter<T>, List<Filter<T>> {
	
	public FilterStack<T> clone();

}"
FilterTestPlugin.java,log-6.9.380,"package org.processmining.filtering;
//
//import org.deckfour.xes.extension.std.XConceptExtension;
//import org.deckfour.xes.model.XAttributeMap;
//import org.deckfour.xes.model.XEvent;
//import org.deckfour.xes.model.XLog;
//import org.deckfour.xes.model.XTrace;
//import org.processmining.contexts.uitopia.UIPluginContext;
//import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
//import org.processmining.filtering.filter.factories.FilterFactory;
//import org.processmining.filtering.filter.interfaces.Filter;
//import org.processmining.filtering.xfilter.factories.XFilterFactory;
//import org.processmining.filtering.xfilter.interfaces.XAttributableFilter;
//import org.processmining.filtering.xfilter.interfaces.XFilter;
//import org.processmining.filtering.xflog.implementations.XFLogImpl;
//import org.processmining.filtering.xflog.interfaces.XFLog;
//import org.processmining.framework.plugin.annotations.Plugin;
//import org.processmining.framework.plugin.annotations.PluginVariant;
//
//@Plugin(name = ""Filter test"", parameterLabels = { ""Event log"" }, returnLabels = { ""Log"" }, returnTypes = { XFLog.class })
//public class FilterTestPlugin {
//
//	@UITopiaVariant(affiliation = ""Eindhoven University of Technology"", author = ""S.J. van Zelst"", email = ""s.j.v.zelst@tue.nl"")
//	@PluginVariant(variantLabel = ""Filter test"", requiredParameterLabels = { 0 })
//	/**
//	 * ProM entry point for filter testing.
//	 *
//	 * @param context
//	 * @param log
//	 * @return
//	 */
//	public XFLog filter(final UIPluginContext context, final XLog log) {
//		XAttributableFilter<XEvent> eventFilter = XFilterFactory.containsKeyValuePairFilter(XConceptExtension.KEY_NAME, ""e"");
//		XFilter<XTrace> traceFilter = XFilterFactory.hideXEvent(eventFilter);
//		Filter<XAttributeMap> attributeMapFilter = FilterFactory.mirrorFilter();
//		
//		XFLog fLog = new XFLogImpl(log, traceFilter, attributeMapFilter);
//
//		return fLog;
//	}
//
//}
"
XFilterFactory.java,log-6.9.380,"package org.processmining.filtering.xfilter.factories;

import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;
import org.processmining.filtering.xfilter.implementations.HideXEventXAttributableFilterImpl;
import org.processmining.filtering.xfilter.implementations.XAttributableContainsKeyWithValueXFilterImpl;
import org.processmining.filtering.xfilter.interfaces.XAttributableFilter;
import org.processmining.filtering.xfilter.interfaces.XFilter;

public class XFilterFactory {

	/**
	 * {@link XAttributableContainsKeyWithValueXFilterImpl}
	 * @param key of pair
	 * @param value of pair
	 * @return filter based on pair <key,value>
	 */
	public static <T extends XAttributable> XAttributableFilter<T> containsKeyValuePairFilter(String key, String value) {
		return new XAttributableContainsKeyWithValueXFilterImpl<>(key, value);
	}
	
	/**
	 * {@link XAttributableContainsKeyWithValueXFilterImpl}
	 * @param key of pair
	 * @param value of pair
	 * @return filter based on pair <key,value>
	 */
	public static <T extends XAttributable> XAttributableFilter<T> containsKeyValuePairFilter(String key, boolean value) {
		return new XAttributableContainsKeyWithValueXFilterImpl<>(key, value);
	}
	
	public static XFilter<XTrace> hideXEvent(XAttributableFilter<XEvent> eventFilter) {
		return new HideXEventXAttributableFilterImpl(eventFilter);
	}
}
"
HideXEventXAttributableFilterImpl.java,log-6.9.380,"package org.processmining.filtering.xfilter.implementations;

import java.util.Arrays;

import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;
import org.processmining.filtering.filter.factories.FilterFactory;
import org.processmining.filtering.filter.interfaces.Filter;
import org.processmining.filtering.xfilter.interfaces.XAttributableFilter;
import org.processmining.filtering.xfilter.interfaces.XFilter;
import org.processmining.filtering.xflog.implementations.XFTraceImpl;

public class HideXEventXAttributableFilterImpl implements XFilter<XTrace> {
	
	protected XAttributableFilter<XEvent> eventFilter;
	
	public HideXEventXAttributableFilterImpl(XAttributableFilter<XEvent> eventFilter) {
		this.eventFilter = eventFilter;
	}	
	
	public XTrace apply(XTrace t) {
		int[] keep = new int[0];		
		for (int i = 0; i < t.size(); i++) {
			if (eventFilter.apply(t.get(i)) == null) {
				keep = Arrays.copyOf(keep, keep.length + 1);
				keep[keep.length - 1] = i;
			}
		}
		Filter<XEvent> eventFilter = FilterFactory.mirrorFilter();
		Filter<XAttributeMap> traceAttributeFilter = FilterFactory.mirrorFilter();
		return new XFTraceImpl(t, keep, eventFilter, traceAttributeFilter);
	}
	

	public XFilter<XTrace> clone() {
		HideXEventXAttributableFilterImpl clone = null;
		try {
			clone = (HideXEventXAttributableFilterImpl) super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
		return clone;
	}

	
	
}
"
XAttributableContainsKeyWithValueXFilterImpl.java,log-6.9.380,"package org.processmining.filtering.xfilter.implementations;

import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeLiteral;
import org.processmining.filtering.xfilter.interfaces.XAttributableFilter;

/**
 * The XAttributableContainsKeyWithValueXFilterImpl class checks whether an
 * XAttributable object contains a given <Key, Value> pair. If the object
 * contains the pair, the apply method will return the object (that is
 * mirrored). If the object does not contain the pair, the apply method will
 * return null.
 * 
 * @author S.J. van Zelst
 * 
 * @param <T> XAttributable object
 */
public class XAttributableContainsKeyWithValueXFilterImpl<T extends XAttributable> implements XAttributableFilter<T> {

	protected String key;

	protected String strVal = null;
	protected Boolean boolVal = null;

	public XAttributableContainsKeyWithValueXFilterImpl(String key, String value) {
		this(key);
		this.strVal = value;
	}

	public XAttributableContainsKeyWithValueXFilterImpl(String key, boolean value) {
		this(key);
		this.boolVal = value;
	}

	private XAttributableContainsKeyWithValueXFilterImpl(String key) {
		this.key = key;
	}

	@SuppressWarnings(""unchecked"")
	public XAttributableFilter<T> clone() {
		XAttributableFilter<T> clone = null;
		try {
			clone = (XAttributableFilter<T>) super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
		return clone;
	}

	/**
	 * Apply method, will return (t) iff <K,V> is contained by the given
	 * XAttributable t. Will return null if t does not contain <K,V>.
	 */
	public T apply(T t) {
		T result = null;
		if (t.getAttributes().containsKey(key)) {
			if (routedCheck(t)) {
				result = t;
			}
		}
		return result;
	}

	private boolean routedCheck(T t) {
		boolean result = false;
		if (strVal != null) {
			result = strEquals(t);
		} else if (boolVal != null) {
			result = boolEquals(t);
		}
		return result;
	}

	private boolean strEquals(T t) {
		boolean result = false;
		XAttributeLiteral literal;
		if (t.getAttributes().get(key) instanceof XAttributeLiteral) {
			literal = (XAttributeLiteral) t.getAttributes().get(key);
			if (literal.getValue().equals(strVal)) {
				result = true;
			}
		}
		return result;
	}

	private boolean boolEquals(T t) {
		boolean result = false;
		XAttributeBoolean bool;
		if (t.getAttributes().get(key) instanceof XAttributeBoolean) {
			bool = (XAttributeBoolean) t.getAttributes().get(key);
			if (bool.getValue() == boolVal) {
				result = true;
			}
		}
		return result;
	}

}
"
XAttributableFilter.java,log-6.9.380,"package org.processmining.filtering.xfilter.interfaces;

import org.deckfour.xes.model.XAttributable;

public interface XAttributableFilter<T extends XAttributable> extends XFilter<T> {
}
"
XFilter.java,log-6.9.380,"package org.processmining.filtering.xfilter.interfaces;

import org.processmining.filtering.filter.interfaces.Filter;

public interface XFilter<T> extends Filter<T> {

}
"
ShuffleInsertionList.java,log-6.9.380,"package org.processmining.filtering.xflog.implementations;

import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * An abstract shuffle insertion list is a list that allows a programmer to
 * hide/add/duplicate elements from the list. It does so by maintaining an array
 * of indices referring either to: 1. the original list 2. a set of ""added""
 * elements.
 * 
 * @author S.J. van Zelst
 * 
 * @param <T>
 *            generic type of elements within the list.
 */
public class ShuffleInsertionList<T> extends AbstractList<T> implements Cloneable {

	protected List<T> source;
	protected int[] positions;

	@SuppressWarnings(""unchecked"")
	protected T[] newElements = (T[]) new Object[0];

	public ShuffleInsertionList(List<T> source) {
		this.source = source;
		positions = new int[source.size()];
		for (int i = 0; i < source.size(); i++) {
			positions[i] = i;
		}
	}

	public ShuffleInsertionList(List<T> source, int[] elementPositions) {
		this.source = source;
		this.positions = elementPositions;
	}

	//TODO: Test addition of (artificial) events
	public ShuffleInsertionList(List<T> source, List<T> modifiedOrder) {
		this.source = source;
		Map<T, Integer> newElementMap = new HashMap<>();
		positions = new int[modifiedOrder.size()];
		for (int i = 0; i < modifiedOrder.size(); i++) {
			T t = modifiedOrder.get(i);
			if (source.contains(t)) {
				positions[i] = source.indexOf(t);
			} else {
				if (!(newElementMap.keySet().contains(t))) {
					newElements = Arrays.copyOf(newElements, newElements.length + 1);
					newElements[newElements.length - 1] = t;
					newElementMap.put(t, newElements.length * -1);
				}
				positions[i] = newElementMap.get(t);
			}
		}
	}

	public int size() {
		return positions.length;
	}

	@SuppressWarnings(""unchecked"")
	@Override
	public Object clone() {
		ShuffleInsertionList<T> clone = null;
		try {
			clone = (ShuffleInsertionList<T>) super.clone();
			clone.source = new ArrayList<T>(source);
			clone.positions = positions.clone();
			clone.newElements = newElements.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
		return clone;
	}

	public T get(int index) {
		T result;
		if (positions[index] >= 0) {
			result = source.get(positions[index]);
		} else {
			result = newElements[(positions[index] * -1) - 1];
		}
		return result;
	}

}
"
XFLogImpl.java,log-6.9.380,"package org.processmining.filtering.xflog.implementations;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.model.XVisitor;
import org.processmining.filtering.filter.interfaces.Filter;
import org.processmining.filtering.xflog.interfaces.XFLog;

public class XFLogImpl extends ShuffleInsertionList<XTrace> implements XFLog {

	/**
	 * Filter related variables
	 */
	protected XLog source;
	protected XAttributeMap attributes;
	protected Set<XExtension> extensions = new HashSet<>();
	protected List<XEventClassifier> classifiers = new ArrayList<>();
	protected List<XAttribute> globalTraceAttributes = new ArrayList<>();
	protected List<XAttribute> globalEventAttributes = new ArrayList<>();
	protected XLogInfo cachedInfo = null;
	protected XEventClassifier cachedClassifier = null;

	Filter<XTrace> traceFilter;
	Filter<XAttributeMap> logAttributeFilter;

	public XFLogImpl(XLog source, Filter<XTrace> traceFilter, Filter<XAttributeMap> logAttributeFilter) {
		super(source);
		init(source, traceFilter, logAttributeFilter);
	}

	public XFLogImpl(XLog source, int[] tracePositions, Filter<XTrace> traceFilter,
			Filter<XAttributeMap> logAttributeFilter) {
		super(source, tracePositions);
		init(source, traceFilter, logAttributeFilter);
	}

	public XFLogImpl(XLog source, List<XTrace> modifiedOrder, Filter<XTrace> traceFilter,
			Filter<XAttributeMap> logAttributeFilter) {
		super(source, modifiedOrder);
		init(source, traceFilter, logAttributeFilter);
	}

	protected void init(XLog source, Filter<XTrace> traceFilter, Filter<XAttributeMap> logAttributeFilter) {
		this.source = source;
		attributes = source.getAttributes();
		this.traceFilter = traceFilter;
		this.logAttributeFilter = logAttributeFilter;
	}

	public Object clone() {
		XFLogImpl clone = null;
		try {
			clone = (XFLogImpl) super.clone();
			clone.attributes = (XAttributeMap) attributes.clone();
			clone.extensions = new HashSet<>(extensions);
			clone.classifiers = new ArrayList<>(classifiers);
			clone.globalTraceAttributes = new ArrayList<>(globalTraceAttributes);
			clone.globalEventAttributes = new ArrayList<>(globalEventAttributes);
			clone.cachedClassifier = null;
			clone.cachedInfo = null;
			clone.source = (XLog) this.source.clone();
			clone.traceFilter = traceFilter;
			clone.logAttributeFilter = logAttributeFilter;

			clone.setSource((XLog) source.clone());
			clone.clear();
			for (XTrace trace : this) {
				clone.add((XTrace) trace.clone());
			}
		} catch (NullPointerException e) {
			e.printStackTrace();
		}
		return clone;
	}

	public XAttributeMap getAttributes() {
		return logAttributeFilter.apply(attributes);
	}

	public void setAttributes(XAttributeMap attributes) {
		this.attributes = attributes;

	}

	public Set<XExtension> getExtensions() {
		return extensions;
	}

	public boolean hasAttributes() {
		return !attributes.isEmpty();
	}

	public XLog getSource() {
		return source;
	}

	public void setSource(XLog log) {
		source = log;
	}

	public XTrace get(int index) {
		return traceFilter.apply(super.get(index));
	}

	@Override
	public void setTraceFilter(Filter<XTrace> filter) {
		traceFilter = filter;
	}

	@Override
	public void setLogAttributeFilter(Filter<XAttributeMap> filter) {
		logAttributeFilter = filter;
	}

	public boolean accept(XVisitor visitor) {
		boolean accept = false;
		if (visitor.precondition()) {
			accept = true;
			visitor.init(this);
			visitor.visitLogPre(this);

			// visit extensions
			for (XExtension extension : extensions) {
				extension.accept(visitor, this);
			}

			// visit classifiers
			for (XEventClassifier classifier : classifiers) {
				classifier.accept(visitor, this);
			}

			// visit attributes
			for (XAttribute attribute : attributes.values()) {
				attribute.accept(visitor, this);
			}

			for (XTrace trace : this) {
				trace.accept(visitor, this);
			}

			visitor.visitLogPost(this);
		}
		return accept;
	}

	//TODO: Check what the impact of filtering is on these functions!
	public List<XEventClassifier> getClassifiers() {
		return classifiers;
	}

	public List<XAttribute> getGlobalEventAttributes() {
		return globalEventAttributes;
	}

	public List<XAttribute> getGlobalTraceAttributes() {
		return globalTraceAttributes;
	}

	public XLogInfo getInfo(XEventClassifier classifier) {
		return classifier.equals(cachedClassifier) ? cachedInfo : null;
	}

	public void setInfo(XEventClassifier classifier, XLogInfo info) {
		cachedClassifier = classifier;
		cachedInfo = info;
	}

}
"
XFTraceImpl.java,log-6.9.380,"package org.processmining.filtering.xflog.implementations;

import java.util.List;
import java.util.Set;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.model.XVisitor;
import org.deckfour.xes.util.XAttributeUtils;
import org.processmining.filtering.filter.interfaces.Filter;
import org.processmining.filtering.xflog.interfaces.XFTrace;

public class XFTraceImpl extends ShuffleInsertionList<XEvent> implements XFTrace {

	protected XAttributeMap attributes;
	protected XTrace source;

	protected Filter<XEvent> eventAttributeFilter;
	protected Filter<XAttributeMap> traceAttributeFilter;

	public XFTraceImpl(XTrace source, Filter<XEvent> eventFilter, Filter<XAttributeMap> traceAttributeFilter) {
		super(source);
		init(source, eventFilter, traceAttributeFilter);
	}

	public XFTraceImpl(XTrace source, int[] eventPositions, Filter<XEvent> eventAttributeFilter,
			Filter<XAttributeMap> traceAttributeFilter) {
		super(source, eventPositions);
		init(source, eventAttributeFilter, traceAttributeFilter);
	}

	public XFTraceImpl(XTrace source, List<XEvent> modifiedOrder, Filter<XEvent> eventAttributeFilter,
			Filter<XAttributeMap> traceAttributeFilter) {
		super(source, modifiedOrder);
		init(source, eventAttributeFilter, traceAttributeFilter);
	}

	protected void init(XTrace source, Filter<XEvent> eventAttributeFilter, Filter<XAttributeMap> traceAttributeFilter) {
		this.source = source;
		attributes = source.getAttributes();
		this.eventAttributeFilter = eventAttributeFilter;
		this.traceAttributeFilter = traceAttributeFilter;
	}

	public XEvent get(int index) {
		return eventAttributeFilter.apply(super.get(index));
	}

	@Override
	public Object clone() {
		XFTrace clone = null;
		clone = (XFTraceImpl) super.clone();
		clone.setSource((XTrace) source.clone());
		clone.setAttributes((XAttributeMap) attributes.clone());
		clone.setEventFilter(eventAttributeFilter);
		clone.setTraceAttributeFilter(traceAttributeFilter);
		clone.clear();
		for (XEvent event : this) {
			clone.add((XEvent) event.clone());
		}
		return clone;
	}

	@Override
	public void accept(XVisitor visitor, XLog log) {
		// first call;
		visitor.visitTracePre(this, log);

		// visit attributes
		for (XAttribute attribute : attributes.values()) {
			attribute.accept(visitor, this);
		}

		// visit events
		for (XEvent event : this) {
			event.accept(visitor, this);
		}

		// final call
		visitor.visitTracePost(this, log);
	}

	@Override
	public XAttributeMap getAttributes() {
		return traceAttributeFilter.apply(attributes);
	}

	@Override
	public void setAttributes(XAttributeMap attributes) {
		this.attributes = attributes;

	}

	@Override
	public Set<XExtension> getExtensions() {
		return XAttributeUtils.extractExtensions(getAttributes());
	}

	@Override
	public boolean hasAttributes() {
		return !(attributes.isEmpty());
	}

	@Override
	public XTrace getSource() {
		return source;
	}

	@Override
	public void setSource(XTrace trace) {
		source = trace;
		attributes = trace.getAttributes();
	}

	@Override
	public void setEventFilter(Filter<XEvent> filter) {
		eventAttributeFilter = filter;
	}

	@Override
	public void setTraceAttributeFilter(Filter<XAttributeMap> filter) {
		traceAttributeFilter = filter;
	}

	/**
	 * The interface describes an ""ordering based on time"". This does no longer
	 * comply with the ""current"" view on Logs.
	 */
	public int insertOrdered(XEvent event) {
		throw new UnsupportedOperationException();
	}

}
"
XFLog.java,log-6.9.380,"package org.processmining.filtering.xflog.interfaces;

import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.filtering.filter.interfaces.Filter;

/**
 * An XFLog is a ""Filtered"" XLog. It behaves like an XLog, though using some
 * source log, it can apply various filtering capabilities. An XFLog can apply a
 * ""trace filter"" on each trace and a ""log attribute filter"" on it's own
 * attributes.
 * 
 * @author M.L. van Eck
 * @author S.J. van Zelst
 */
public interface XFLog extends XLog {

	/**
	 * What log is this filtered log based upon?
	 * 
	 * @return pointer to current source.
	 */
	public XLog getSource();

	/**
	 * Set the source of this filtered log. Setting the source can invoke a
	 * re-evaluation of the internal apply(s).
	 * 
	 * @param log
	 *            pointer to new source.
	 */
	public void setSource(XLog log);

	/**
	 * Set the ""trace filter"" of this log. The trace filter will be applied on
	 * each trace upon trace request (lazy evaluation).
	 * 
	 * @param filter
	 *            to apply on traces in the log.
	 */
	public void setTraceFilter(Filter<XTrace> filter);

	/**
	 * Set the ""log attribute filter"" of this log. The filter will be applied on
	 * the log's attribute upon attribute request (lazy evaluation).
	 * 
	 * @param filter
	 *            to apply on log's attributes.
	 */
	public void setLogAttributeFilter(Filter<XAttributeMap> filter);
}
"
XFTrace.java,log-6.9.380,"package org.processmining.filtering.xflog.interfaces;

import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;
import org.processmining.filtering.filter.interfaces.Filter;

/**
 * An XFTrace is a Filtered XTrace. It behaves like a trace and is based on some
 * data type which adheres to the XTrace interface.
 * 
 * @author M.L. van Eck
 * @author S.J. van Zelst
 */
public interface XFTrace extends XTrace {

	/**
	 * What trace is this filtered trace based upon?
	 * 
	 * @return pointer to current source.
	 */
	public XTrace getSource();

	/**
	 * Set the source of this filtered trace. Setting the source can invoke a
	 * re-evaluation of the internal apply(s).
	 * 
	 * @param trace
	 *            pointer to new source.
	 */
	public void setSource(XTrace trace);

	/**
	 * Set the trace's event attribute filter.
	 * 
	 * @param filter
	 *            on attribute map.
	 */
	public void setEventFilter(Filter<XEvent> filter);

	/**
	 * Set the trace's attribute filter
	 * 
	 * @param filter
	 *            on trace attribute-map
	 */
	public void setTraceAttributeFilter(Filter<XAttributeMap> filter);
}
"
HighFrequencyFilterAlgorithm.java,log-6.9.380,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.HighFrequencyFilterParameters;
import org.processmining.log.parameters.LogFilterParameters;

public class HighFrequencyFilterAlgorithm implements LogFilterAlgorithm {

	private Map<Set<List<String>>, Integer> cache;

	public HighFrequencyFilterAlgorithm() {
		cache = new HashMap<Set<List<String>>, Integer>();
	}
	
	public XLog apply(PluginContext context, XLog log, LogFilterParameters parameters) {
		final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();
		final Map<XTrace, List<String>> traceActivitiesMap = new HashMap<XTrace, List<String>>();
		XLog clonedLog = (XLog) log.clone();

		for (XTrace trace : clonedLog) {
			List<String> activities = new ArrayList<String>();
			for (XEvent event : trace) {
				activities.add(parameters.getClassifier().getClassIdentity(event));
			}
			traceActivitiesMap.put(trace, activities);
			if (traceOccurrenceMap.keySet().contains(activities)) {
				traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
			} else {
				traceOccurrenceMap.put(activities, 1);
			}
		}

		List<Integer> occurrences = new ArrayList<Integer>(traceOccurrenceMap.values());
		Collections.sort(occurrences);

//		SummaryStatistics statistics = new SummaryStatistics();
//		for (int occurrence : occurrences) {
//			for (int i = 0; i < occurrence; i++) {
//				statistics.addValue(occurrence);
//			}
//		}
//		int threshold = (int) Math.round(statistics.getMean() - 1.0 * statistics.getStandardDeviation());
		int threshold = ((100 - ((HighFrequencyFilterParameters) parameters).getFrequencyThreshold()) * clonedLog
				.size()) / 100;
		int sum = 0;
		int index = -1;
		while (sum < threshold) {
			sum += occurrences.get(++index);
		}
		/*
		 * The 'traces' occurrences[index]...occurrences[occurrences.size()-1]
		 * cover more than X% if the log, where X = parameters.getThreshold().
		 */
		threshold = occurrences.get(index);
		/*
		 * If we take all traces that occur at least as many times as threshold
		 * times, we cover at least X% of the log.
		 */
		if (threshold == occurrences.get(occurrences.size() - 1) + 1) {
			/*
			 * We're about to remove all traces. That seems to be undesirable.
			 */
			threshold--;
		}
		System.out.println(""Threshold = "" + threshold);

		Collection<XTrace> tracesToRemove = new HashSet<XTrace>();

		for (XTrace trace : clonedLog) {
			if (traceOccurrenceMap.get(traceActivitiesMap.get(trace)) >= threshold) {
				/*
				 * Trace occurs often enough. Filter it in.
				 */
			} else {
				/*
				 * Trace does not occur often enough by itself. Check whether it
				 * matches one that does.
				 */
				boolean retain = false;
				for (XTrace otherTrace : clonedLog) {
					if (traceOccurrenceMap.get(traceActivitiesMap.get(otherTrace)) >= threshold) {
						if (getTraceDistance(traceActivitiesMap.get(trace), traceActivitiesMap.get(otherTrace)) < ((HighFrequencyFilterParameters) parameters)
								.getDistanceThreshold()) {
							/*
							 * Yes, it matches one that does. Filter this trace
							 * in as well.
							 */
							retain = true;
							continue;
						}
					}
				}
				if (!retain) {
					/*
					 * This trace does not occur frequent enough, an dit does
					 * not match any other traces that does. Filter it out.
					 */
					tracesToRemove.add(trace);
				}
			}
		}

		clonedLog.removeAll(tracesToRemove);
		/*
		 * At least X% of the log is retained.
		 */

		return clonedLog;
	}

	private int getTraceDistance(List<String> activities1, List<String> activities2) {
		return getTraceDistance(activities1, activities2, 0, 0);
	}

	private int getTraceDistance(List<String> activities1, List<String> activities2, int index1, int index2) {
		int distance = 0;
		if (index1 >= activities1.size()) {
			distance = activities2.size() - index2;
		} else if (index2 >= activities2.size()) {
			distance = activities1.size() - index1;
		} else {
			Set<List<String>> activities = new HashSet<List<String>>();
			activities.add(activities1);
			activities.add(activities2);
			if (cache.containsKey(activities)) {
				distance = cache.get(activities);
			} else {
				if (activities1.get(index1).equals(activities2.get(index2))) {
					distance = getTraceDistance(activities1, activities2, index1 + 1, index2 + 1);
				} else {
					int distance1 = 1 + getTraceDistance(activities1, activities2, index1 + 1, index2);
					int distance2 = 1 + getTraceDistance(activities1, activities2, index1, index2 + 1);
					if (distance1 < distance2) {
						distance = distance1;
					} else {
						distance = distance2;
					}
				}
				cache.put(activities, distance);
			}
		}
		return distance;
	}
}
"
LogCentralityAlgorithm.java,log-6.9.380,"package org.processmining.log.algorithms;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityParameters;

public class LogCentralityAlgorithm {

	public LogCentrality apply(PluginContext context, XLog log, LogCentrality centrality, LogCentralityParameters parameters) {
		context.getProgress().setMaximum(log.size());
		centrality.setClassifier(context, parameters);
		return centrality;
	}
}
"
LogCentralityFilterAlgorithm.java,log-6.9.380,"package org.processmining.log.algorithms;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

public class LogCentralityFilterAlgorithm {

	public XLog apply(PluginContext context, LogCentrality centrality, LogCentralityFilterParameters parameters) {
		context.getProgress().setMaximum(centrality.size());
		return centrality.filter(context, parameters);
	}
}
"
LogCentralityVisualizerAlgorithm.java,log-6.9.380,"package org.processmining.log.algorithms;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;

import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

import com.fluxicon.slickerbox.components.DistributionUI;
import com.fluxicon.slickerbox.components.RoundedPanel;

public class LogCentralityVisualizerAlgorithm {

	protected Color colorEnclosureBg = new Color(250, 250, 250, 105);
	protected Color colorTitleFg = new Color(20, 20, 20, 230);
	protected Color colorInfoBg = new Color(60, 60, 60, 160);
	protected Color colorInfoBgMouseOver = new Color(60, 60, 60, 240);
	protected Color colorInfoLabel = new Color(210, 210, 210);
	protected Color colorInfoValue = new Color(255, 255, 255);

	private int factor = 100;

	public JComponent apply(LogCentrality centrality, LogCentralityFilterParameters parameters) {
		double sumCentrality = 0.0;
		int j = ((parameters == null) ? centrality.getCentralities().size() : (parameters.getPercentage() * centrality
				.getCentralities().size()) / 100);
		if (j >= centrality.getCentralities().size()) {
			j = centrality.getCentralities().size() - 1;
		}
		while ((j < centrality.getCentralities().size() - 1)
				&& (centrality.getCentralities().get(j) == centrality.getCentralities().get(j + 1))) {
			j++;
		}
		int left, right;
		if (parameters == null || parameters.isFilterIn()) {
			left = 0;
			right = j;
		} else {
			left = j + 1;
			right = centrality.getCentralities().size() - 1;
			if (left > right) {
				left = right;
			}
		}
		int minCentrality = (int) Math.round(factor * centrality.getCentralities().get(left));
		int maxCentrality = (int) Math.round(factor * centrality.getCentralities().get(right));
		int[] centralityArray = new int[right + 1 - left];
		for (int k = left; k <= right; k++) {
			Double value = centrality.getCentralities().get(k);
			centralityArray[k - left] = (int) Math.round(factor * value);
			sumCentrality += value;
		}
		int meanCentrality = (int) Math.round(factor * sumCentrality / (right + 1 - left));
		JComponent[] components = new JComponent[4];
		JComponent panel = getDistributionPanel(""Trace happiness"", centralityArray, meanCentrality, components);
		((JLabel) components[0]).setText("""" + minCentrality / (double) factor);
		((JLabel) components[1]).setText("""" + meanCentrality / (double) factor);
		((JLabel) components[2]).setText("""" + maxCentrality / (double) factor);
		return panel;
	}

	private RoundedPanel getDistributionPanel(String title, int[] values, int meanValue, JComponent[] result) {

		// create distribution panel
		RoundedPanel instancePanel = new RoundedPanel(15, 0, 0);
		instancePanel.setBackground(colorEnclosureBg);
		instancePanel.setLayout(new BoxLayout(instancePanel, BoxLayout.Y_AXIS));
		instancePanel.add(getLeftAlignedHeader(title));
		instancePanel.add(Box.createVerticalStrut(6));
		if (values.length == 0) {
			return instancePanel;
		}
		RoundedPanel instanceDistPanel = new RoundedPanel(10, 0, 0);
		result[3] = instanceDistPanel;
		instanceDistPanel.setBackground(new Color(20, 20, 20));
		instanceDistPanel.setLayout(new BorderLayout());
		DistributionUI instanceDistUI = new DistributionUI(values);
		instanceDistPanel.add(instanceDistUI, BorderLayout.CENTER);
		JPanel keyPanel = new JPanel();
		keyPanel.setOpaque(false);
		keyPanel.setBorder(BorderFactory.createEmptyBorder());
		keyPanel.setLayout(new BoxLayout(keyPanel, BoxLayout.X_AXIS));
		result[0] = packInfo(keyPanel, ""Min"");
		keyPanel.add(Box.createHorizontalGlue());
		keyPanel.add(Box.createHorizontalGlue());
		keyPanel.add(Box.createHorizontalGlue());
		result[1] = packInfo(keyPanel, ""Mean"");
		keyPanel.add(Box.createHorizontalGlue());
		keyPanel.add(Box.createHorizontalGlue());
		keyPanel.add(Box.createHorizontalGlue());
		result[2] = packInfo(keyPanel, ""Max"");
		instancePanel.add(instanceDistPanel);
		instancePanel.add(Box.createVerticalStrut(4));
		instancePanel.add(keyPanel);
		return instancePanel;
	}

	private JLabel packInfo(JPanel panel, String name) {
		String value = ""Initializing ..."";

		RoundedPanel packed = new RoundedPanel(10, 0, 0);
		packed.setBackground(colorInfoBg);
		final RoundedPanel target = packed;
		packed.addMouseListener(new MouseListener() {
			public void mouseClicked(MouseEvent arg0) { /* ignore */
			}

			public void mouseEntered(MouseEvent arg0) {
				target.setBackground(colorInfoBgMouseOver);
				target.repaint();
			}

			public void mouseExited(MouseEvent arg0) {
				target.setBackground(colorInfoBg);
				target.repaint();
			}

			public void mousePressed(MouseEvent arg0) { /* ignore */
			}

			public void mouseReleased(MouseEvent arg0) { /* ignore */
			}
		});
		packed.setLayout(new BoxLayout(packed, BoxLayout.X_AXIS));
		JLabel nameLabel = new JLabel(name);
		nameLabel.setOpaque(false);
		nameLabel.setForeground(colorInfoLabel);
		nameLabel.setFont(nameLabel.getFont().deriveFont(12f));
		JLabel valueLabel = new JLabel(value);
		valueLabel.setOpaque(false);
		valueLabel.setForeground(colorInfoValue);
		valueLabel.setFont(valueLabel.getFont().deriveFont(14f));
		packed.add(Box.createHorizontalStrut(5));
		packed.add(nameLabel);
		packed.add(Box.createHorizontalGlue());
		packed.add(valueLabel);
		packed.add(Box.createHorizontalStrut(5));
		packed.revalidate();

		panel.add(packed);

		return valueLabel;
	}

	private JPanel getLeftAlignedHeader(String title) {
		JLabel hLabel = new JLabel(title);
		hLabel.setOpaque(false);
		hLabel.setForeground(colorTitleFg);
		hLabel.setFont(hLabel.getFont().deriveFont(15f));
		return alignLeft(hLabel);
	}

	private JPanel alignLeft(JComponent component) {
		JPanel hPanel = new JPanel();
		hPanel.setBorder(BorderFactory.createEmptyBorder());
		hPanel.setOpaque(false);
		hPanel.setLayout(new BoxLayout(hPanel, BoxLayout.X_AXIS));
		hPanel.add(component);
		hPanel.add(Box.createHorizontalGlue());
		return hPanel;
	}

}
"
LogCheckerAlgorithm.java,log-6.9.380,"package org.processmining.log.algorithms;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.logchecks.LogCheckType;
import org.processmining.log.models.LogCheckerReport;
import org.processmining.log.parameters.LogCheckerParameters;

public class LogCheckerAlgorithm {

	public LogCheckerReport apply(PluginContext context, final XLog log, final LogCheckerParameters parameters) {
		LogCheckerReport report = new LogCheckerReport();
		boolean allOk = true;
		for (LogCheckType logCheckType: parameters.getLogChecks()) {
			allOk = logCheckType.getLogCheck().check(context, log, report) && allOk;
		}
		if (allOk) {
			report.add(""<h2>No problems detected, congratulations!</h2>"");
		}
		return report;
	}
}
"
LogFilterAlgorithm.java,log-6.9.380,"package org.processmining.log.algorithms;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.LogFilterParameters;

public interface LogFilterAlgorithm {
	
	public XLog apply(PluginContext context, XLog log, LogFilterParameters parameters);

}
"
LogFrequencyAlgorithm.java,log-6.9.380,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.models.impl.LogFrequencyFactory;
import org.processmining.log.parameters.LogFrequencyParameters;

public class LogFrequencyAlgorithm {

	public LogFrequency apply(PluginContext context, XLog log, LogFrequencyParameters parameters) {
		LogFrequency frequency = LogFrequencyFactory.createLogFrequency(log);
		final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();

		for (XTrace trace : log) {
			List<String> activities = new ArrayList<String>();
			for (XEvent event : trace) {
				activities.add(parameters.getClassifier().getClassIdentity(event));
			}
			if (traceOccurrenceMap.keySet().contains(activities)) {
				traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
			} else {
				traceOccurrenceMap.put(activities, 1);
			}
		}

		for (List<String> activities : traceOccurrenceMap.keySet()) {
			frequency.add(traceOccurrenceMap.get(activities));
		}
		return frequency;
	}
}
"
LogFrequencyArrayAlgorithm.java,log-6.9.380,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.LogFrequencyArray;
import org.processmining.log.models.impl.LogFrequencyFactory;
import org.processmining.log.parameters.LogFrequencyParameters;

public class LogFrequencyArrayAlgorithm {

	public LogFrequencyArray apply(PluginContext context, EventLogArray logs, LogFrequencyParameters parameters) {
		LogFrequencyArray frequencies = LogFrequencyFactory.createLogFrequencyArray(logs);
		for (int i = 0; i < logs.getSize(); i++) {
			frequencies.set(i);
			final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();

			for (XTrace trace : logs.getLog(i)) {
				List<String> activities = new ArrayList<String>();
				for (XEvent event : trace) {
					activities.add(parameters.getClassifier().getClassIdentity(event));
				}
				if (traceOccurrenceMap.keySet().contains(activities)) {
					traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
				} else {
					traceOccurrenceMap.put(activities, 1);
				}
			}

			for (List<String> activities : traceOccurrenceMap.keySet()) {
				frequencies.add(traceOccurrenceMap.get(activities));
			}
		}
		return frequencies;
	}
}
"
LowFrequencyFilterAlgorithm.java,log-6.9.380,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.LogFilterParameters;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

public class LowFrequencyFilterAlgorithm implements LogFilterAlgorithm {

	public XLog apply(PluginContext context, XLog log, LogFilterParameters parameters) {
		final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();
		final Map<XTrace, List<String>> traceActivitiesMap = new HashMap<XTrace, List<String>>();
		
		XLog clonedLog = (XLog) log.clone();
		
		for (XTrace trace : clonedLog) {
			List<String> activities = new ArrayList<String>();
			for (XEvent event : trace) {
				activities.add(parameters.getClassifier().getClassIdentity(event));
			}
			traceActivitiesMap.put(trace,  activities);
			if (traceOccurrenceMap.keySet().contains(activities)) {
				traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
			} else {
				traceOccurrenceMap.put(activities, 1);
			}
		}
		
		List<Integer> occurrences = new ArrayList<Integer>(traceOccurrenceMap.values());
		Collections.sort(occurrences);
		int threshold = (((LowFrequencyFilterParameters) parameters).getThreshold() * clonedLog.size()) / 100;
		int sum = 0;
		int index = -1;
		while (sum < threshold) {
			sum += occurrences.get(++index);
		}
		/*
		 * The low-frequency 'traces' (occurrences[0]...occurrences[index]) counted so far make up for X% of the log, 
		 * where X = parameters.getThreshold().
		 */
		threshold = (index == -1 ? 0 : occurrences.get(index)) + 1;
		/*
		 * If we take all traces that occur fewer than threshold times, we cover at least X% of the log.
		 */
		
		if (threshold == occurrences.get(occurrences.size() - 1) + 1) {
			/*
			 * We're about to remove all traces. That seems to be undesirable.
			 */
			threshold--;
		}
		
		Collection<XTrace> tracesToRemove = new HashSet<XTrace>();

		for (XTrace trace : clonedLog) {
			/*
			 * Trace does not occur often enough. Have it removed.
			 */
			if (traceOccurrenceMap.get(traceActivitiesMap.get(trace)) < threshold) {
				tracesToRemove.add(trace);
			}
		}
		
		/*
		 * tracesToRemove holds at least X% of the log.
		 */
		clonedLog.removeAll(tracesToRemove);
		
		return clonedLog;
	}

}
"
LowOccurrencesFilterAlgorithm.java,log-6.9.380,"package org.processmining.log.algorithms;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.LogFilterParameters;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

public class LowOccurrencesFilterAlgorithm implements LogFilterAlgorithm {

	public XLog apply(PluginContext context, XLog log, LogFilterParameters parameters) {
		final Map<List<String>, Integer> traceOccurrenceMap = new HashMap<List<String>, Integer>();
		final Map<XTrace, List<String>> traceActivitiesMap = new HashMap<XTrace, List<String>>();
		XLog clonedLog = (XLog) log.clone();

		for (XTrace trace : clonedLog) {
			List<String> activities = new ArrayList<String>();
			for (XEvent event : trace) {
				activities.add(parameters.getClassifier().getClassIdentity(event));
			}
			traceActivitiesMap.put(trace, activities);
			if (traceOccurrenceMap.keySet().contains(activities)) {
				traceOccurrenceMap.put(activities, traceOccurrenceMap.get(activities) + 1);
			} else {
				traceOccurrenceMap.put(activities, 1);
			}
		}

		Collection<XTrace> tracesToRemove = new HashSet<XTrace>();

		for (XTrace trace : clonedLog) {
			if (traceOccurrenceMap.get(traceActivitiesMap.get(trace)) < ((LowOccurrencesFilterParameters) parameters).getThreshold()) {
				/*
				 * Trace does not occur often enough. Have it removed.
				 */
				tracesToRemove.add(trace);
			}
		}

		clonedLog.removeAll(tracesToRemove);

		return clonedLog;
	}

}
"
MergeLogsAlgorithm.java,log-6.9.380,"package org.processmining.log.algorithms;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.concurrent.TimeUnit;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.MergeLogsParameters;

public class MergeLogsAlgorithm {

	private final String STOPWORDS = ""a about above above across after afterwards again against ""
			+ ""all almost alone along already also although always am among amongst amoungst ""
			+ ""amount an and another any anyhow anyone anything anyway anywhere are around as at ""
			+ ""back be became because become becomes becoming been before beforehand behind being ""
			+ ""below beside besides between beyond bill both bottom but by call can cannot cant co ""
			+ ""con could couldnt cry de describe detail do done down due during each eg eight either ""
			+ ""eleven else elsewhere empty enough etc even ever every everyone everything everywhere ""
			+ ""except few fifteen fify fill find fire first five for former formerly forty found four ""
			+ ""from front full further get give go had has hasnt have he hence her here hereafter hereby ""
			+ ""herein hereupon hers herself him himself his how however hundred ie if in inc indeed ""
			+ ""interest into is it its itself keep last latter latterly least less ltd made many may me ""
			+ ""meanwhile might mill mine more moreover most mostly move much must my myself name namely ""
			+ ""neither never nevertheless next nine no nobody none noone nor not nothing now nowhere of off ""
			+ ""often on once one only onto or other others otherwise our ours ourselves out over own part ""
			+ ""per perhaps please put rather re same see seem seemed seeming seems serious several she should ""
			+ ""show side since sincere six sixty so some somehow someone something sometime sometimes ""
			+ ""somewhere still such system take ten than that the their them themselves then thence there ""
			+ ""thereafter thereby therefore therein thereupon these they thickv thin third this those though ""
			+ ""three through throughout thru thus to together too top toward towards twelve twenty two un ""
			+ ""under until up upon us very via was we well were what whatever when whence whenever where ""
			+ ""whereafter whereas whereby wherein whereupon wherever whether which while whither who whoever ""
			+ ""whole whom whose why will with within without would yet you your yours yourself yourselves the"";

	public XLog apply(PluginContext context, XLog mainLog, XLog subLog, MergeLogsParameters parameters) {
		XLog log = XFactoryRegistry.instance().currentDefault().createLog();
		DateFormat df = new SimpleDateFormat(parameters.getDateFormat());

		long time = -System.currentTimeMillis();

		for (XTrace mainTrace : mainLog) {
			boolean doApply = true;
			if (doApply && parameters.getTraceId() != null) {
				/*
				 * User has selected specific main trace. Filter in only the
				 * trace that has that id as concept:name.
				 */
				String id = XConceptExtension.instance().extractName(mainTrace);
				doApply = (id != null && id.equals(parameters.getTraceId()));
			}
			if (doApply && parameters.getFromDate() != null && parameters.getToDate() != null) {
				/*
				 * User has selected from date and to date. Filter in only those
				 * traces that occur entirely in that interval.
				 */
				doApply = isBetween(mainTrace, parameters.getFromDate(), parameters.getToDate());
			}
			if (doApply && parameters.getSpecificDate() != null) {
				/*
				 * User has selected a specific date. Only filter in those
				 * traces that have this exact date.
				 */
				doApply = false;
				for (XEvent event : mainTrace) {
					Date date = XTimeExtension.instance().extractTimestamp(event);
					if (date.equals(parameters.getSpecificDate())) {
						doApply = true;
						continue;
					}
				}
			}
			if (doApply && parameters.getRequiredWords() != null) {
				/*
				 * User has selected required words. Filter in those traces that
				 * match one of these words.
				 */
				doApply = false;
				Collection<String> required = new HashSet<String>(
						Arrays.asList(parameters.getRequiredWords().split("","")));
				for (XEvent event : mainTrace) {
					for (XAttribute attribute : event.getAttributes().values()) {
						if (attribute instanceof XAttributeLiteral) {
							String value = ((XAttributeLiteral) attribute).getValue();
							if (required.contains(value)) {
								doApply = true;
								continue;
							}
						} else if (attribute instanceof XAttributeDiscrete) {
							long value = ((XAttributeDiscrete) attribute).getValue();
							if (required.contains(String.valueOf(value))) {
								doApply = true;
								continue;
							}
						} else if (attribute instanceof XAttributeContinuous) {
							double value = ((XAttributeContinuous) attribute).getValue();
							if (required.contains(String.valueOf(value))) {
								doApply = true;
								continue;
							}
						} else if (attribute instanceof XAttributeTimestamp) {
							Date value = ((XAttributeTimestamp) attribute).getValue();
							if (required.contains(df.format(value))) {
								doApply = true;
								continue;
							}
						}
					}
					if (doApply) {
						continue;
					}
				}
			}
			if (doApply && parameters.getForbiddenWords() != null) {
				/*
				 * User has selected forbidden words. Filter out those traces
				 * that match one of these words.
				 */
				doApply = true;
				Collection<String> forbidden = new HashSet<String>(
						Arrays.asList(parameters.getForbiddenWords().split("","")));
				for (XEvent event : mainTrace) {
					for (XAttribute attribute : event.getAttributes().values()) {
						if (attribute instanceof XAttributeLiteral) {
							String value = ((XAttributeLiteral) attribute).getValue();
							if (forbidden.contains(value)) {
								doApply = false;
								continue;
							}
						} else if (attribute instanceof XAttributeDiscrete) {
							long value = ((XAttributeDiscrete) attribute).getValue();
							if (forbidden.contains(String.valueOf(value))) {
								doApply = false;
								continue;
							}
						} else if (attribute instanceof XAttributeContinuous) {
							double value = ((XAttributeContinuous) attribute).getValue();
							if (forbidden.contains(String.valueOf(value))) {
								doApply = false;
								continue;
							}
						} else if (attribute instanceof XAttributeTimestamp) {
							Date value = ((XAttributeTimestamp) attribute).getValue();
							if (forbidden.contains(df.format(value))) {
								doApply = false;
								continue;
							}
						}
					}
					if (!doApply) {
						continue;
					}
				}
			}
			if (doApply) {
				/*
				 * Main trace has passed all filters. Add it with all
				 * corresponding sub traces to the resulting log.
				 */
				apply(context, mainTrace, mainLog, subLog, log, parameters);
			}
		}

		time += System.currentTimeMillis();
		context.log(""Merging time :"" + convet_MS(time));
		return log;
	}

	private void apply(PluginContext context, XTrace mainTrace, XLog mainLog, XLog subLog, XLog log,
			MergeLogsParameters parameters) {
		for (XTrace subTrace : subLog) {
			if (isBetween(mainTrace, subTrace)) {
				boolean doApply = true;
				if (doApply && (checkMatch(mainTrace, subTrace) < parameters.getRelated())) {
					doApply = false;
				}
				if (doApply && (checkWordMatch(mainTrace, subTrace) < parameters.getMinMatches())) {
					doApply = false;
				}
				if (doApply) {
					XTrace trace = XFactoryRegistry.instance().currentDefault().createTrace(mainTrace.getAttributes());
					int mainCtr = 0;
					int subCtr = 0;
					while (mainCtr < mainTrace.size() && subCtr < subTrace.size()) {
						Date mainDate = XTimeExtension.instance().extractTimestamp(mainTrace.get(mainCtr));
						if (mainDate == null) {
							trace.add(mainTrace.get(mainCtr));
							mainCtr++;
						} else {
							Date subDate = XTimeExtension.instance().extractTimestamp(subTrace.get(subCtr));
							if (subDate == null) {
								trace.add(subTrace.get(subCtr));
								subCtr++;
							} else if (subDate.before(mainDate)) {
								trace.add(subTrace.get(subCtr));
								subCtr++;
							} else {
								trace.add(mainTrace.get(mainCtr));
								mainCtr++;
							}
						}
					}
					log.add(trace);
				}
			}
		}
	}

	private XTrace previousMainTrace = null;
	private Collection<String> mainWords = null;
	private Collection<String> stopWords = null;

	private int checkWordMatch(XTrace mainTrace, XTrace subTrace) {
		/*
		 * Build the stop words.
		 */
		if (stopWords == null) {
			stopWords = new HashSet<String>();
			stopWords.addAll(Arrays.asList(STOPWORDS.split("" "")));
		}
		/*
		 * Build (or reuse) the main words.
		 */
		if (mainTrace != previousMainTrace) {
			mainWords = new HashSet<String>();
			for (XEvent event : mainTrace) {
				for (XAttribute attribute : event.getAttributes().values()) {
					/*
					 * Exclude date/time from comparision.
					 */
					if (!(attribute instanceof XAttributeTimestamp)) {
						mainWords.addAll(Arrays.asList(attribute.toString().split("" "")));
					}
				}
			}
			mainWords.removeAll(stopWords);
			previousMainTrace = mainTrace;			
		}
		/*
		 * Build the sub words.
		 */
		Collection<String> subWords = new HashSet<String>();
		for (XEvent event : subTrace) {
			for (XAttribute attribute : event.getAttributes().values()) {
				/*
				 * Exclude date/time from comparision.
				 */
				if (!(attribute instanceof XAttributeTimestamp)) {
					subWords.addAll(Arrays.asList(attribute.toString().split("" "")));
				}
			}
		}
		subWords.removeAll(stopWords);
		/*
		 * Remove all words not in the main words.
		 */
		subWords.retainAll(mainWords);
		/*
		 * Return number of matching words.
		 */
		return subWords.size();
	}

	private int checkMatch(XTrace mainTrace, XTrace subTrace) {
		int match = 0;
		for (XEvent mainEvent : mainTrace) {
			for (XEvent subEvent : mainTrace) {
				match += checkMatch(mainEvent, subEvent);
			}
		}
		return match;
	}

	private int checkMatch(XEvent mainEvent, XEvent subEvent) {
		int match = 0;
		for (XAttribute mainAttribute : mainEvent.getAttributes().values()) {
			if (!(mainAttribute instanceof XAttributeTimestamp)) {
				for (XAttribute subAttribute : subEvent.getAttributes().values()) {
					if (mainAttribute.equals(subAttribute)) {
						match++;
					}
				}
			}
		}
		return match;
	}

	private boolean isBetween(XTrace trace, Date firstDate, Date lastDate) {
		Date firstTraceDate = getFirstDate(trace);
		if (firstTraceDate == null) {
			return false;
		}
		/*
		 * Update on June 6, 2016: the subtrace should start after the main trace
		 * has started, but not after it has started. 
		 * There is no requirement on when the subtrace ends.
		 */
		return (firstTraceDate.after(firstDate) && !firstTraceDate.after(lastDate));
	}

	private boolean isBetween(XTrace mainTrace, XTrace subTrace) {
		Date firstTraceDate = getFirstDate(mainTrace);
		Date lastTraceDate = getLastDate(mainTrace);
		if (firstTraceDate == null || lastTraceDate == null) {
			return false;
		}
		return isBetween(subTrace, firstTraceDate, lastTraceDate);
	}

	private Date getFirstDate(XTrace trace) {
		Date firstDate = null;
		for (XEvent event : trace) {
			Date date = XTimeExtension.instance().extractTimestamp(event);
			if (firstDate == null) {
				firstDate = date;
			} else if (date.before(firstDate)) {
				firstDate = date;
			}
		}
		return firstDate;
	}

	private Date getLastDate(XTrace trace) {
		Date lastDate = null;
		for (XEvent event : trace) {
			Date date = XTimeExtension.instance().extractTimestamp(event);
			if (lastDate == null) {
				lastDate = date;
			} else if (date.after(lastDate)) {
				lastDate = date;
			}
		}
		return lastDate;
	}

	private String convet_MS(long millis) {

		return String.format(""%d min, %d sec %d ms"", TimeUnit.MILLISECONDS.toMinutes(millis),
				TimeUnit.MILLISECONDS.toSeconds(millis)
						- TimeUnit.MINUTES.toSeconds(TimeUnit.MILLISECONDS.toMinutes(millis)),
				millis - TimeUnit.SECONDS.toMillis(TimeUnit.MILLISECONDS.toSeconds(millis)));
	}

}
"
SplitLogAlgorithm.java,log-6.9.380,"package org.processmining.log.algorithms;

import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.SplitLogParameters;

public class SplitLogAlgorithm {

	public XLog apply(PluginContext context, XLog log, SplitLogParameters parameters) {

		XFactory factory = XFactoryRegistry.instance().currentDefault();

		XLog splittedLog = factory.createLog(log.getAttributes());
		splittedLog.getExtensions().addAll(log.getExtensions());
		splittedLog.getGlobalTraceAttributes().addAll(log.getGlobalTraceAttributes());
		splittedLog.getGlobalEventAttributes().addAll(log.getGlobalEventAttributes());
		splittedLog.getClassifiers().addAll(log.getClassifiers());

		for (XTrace trace : log) {
			Set<String> splitValues = new TreeSet<String>();
			for (XEvent event : trace) {
				if (event.getAttributes().containsKey(parameters.getKey())) {
					String value = event.getAttributes().get(parameters.getKey()).toString();
					if (value != null && !value.trim().isEmpty()) {
						splitValues.addAll(Arrays.asList(value.trim().split("" "")));
					}
				}
			}
			int ctr = 1;

			for (String splitValue : splitValues) {
				XTrace splittedTrace = factory.createTrace((XAttributeMap) trace.getAttributes().clone());
				XAttributeLiteral attr = factory.createAttributeLiteral(""oldname"",
						XConceptExtension.instance().extractName(trace), null);
				splittedTrace.getAttributes().put(""oldname"", attr);
				XConceptExtension.instance().assignName(splittedTrace,
						XConceptExtension.instance().extractName(trace) + ""-"" + ctr);
				ctr++;
				for (XEvent event : trace) {
					XAttribute attribute = event.getAttributes().get(parameters.getKey());
					String value = attribute == null ? null : attribute.toString();
					if (value == null || value.trim().isEmpty()
							|| Arrays.asList(value.trim().split("" "")).contains(splitValue)) {
						XEvent splittedEvent = factory.createEvent((XAttributeMap) event.getAttributes().clone());
						attr = factory.createAttributeLiteral(parameters.getKey(), splitValue, null);
						splittedEvent.getAttributes().put(parameters.getKey(), attr);
						splittedTrace.add(splittedEvent);
					}
				}
				splittedLog.add(splittedTrace);
			}
		}
		return splittedLog;
	}

	/*
	 * private CSVReader reader;
	 * 
	 * public ArrayList<ArrayList<String>> read(String file, final int index) {
	 * try {
	 * 
	 * reader = new CSVReader(new FileReader(file));
	 * 
	 * String[] nextLine; ArrayList<String> bucket = new ArrayList<String>();
	 * ArrayList<ArrayList<String>> container = new
	 * ArrayList<ArrayList<String>>(); ArrayList<ArrayList<ArrayList<String>>>
	 * super_container = new ArrayList<ArrayList<ArrayList<String>>>(); int
	 * counter = 0; String CaseID = null; while ((nextLine = reader.readNext())
	 * != null) { if (counter == 0) { CaseID = nextLine[0]; } String[] splitted
	 * = nextLine[index].trim().split("" ""); for (int i = 0; i < splitted.length;
	 * i++) { bucket = new ArrayList<String>(); bucket.add(nextLine[0]); if
	 * (!CaseID.equals(nextLine[0])) { super_container.add(container); container
	 * = new ArrayList<ArrayList<String>>(); counter = 0; } else { counter = 1;
	 * } for (int j = 0; j < index; j++) { bucket.add(nextLine[j]); }
	 * bucket.add(splitted[i]); if (index < nextLine.length - 1) { for (int j =
	 * index + 1; j < nextLine.length; j++) { bucket.add(nextLine[j]); } }
	 * container.add(bucket); }
	 * 
	 * } super_container.add(container); for (int i = 0; i <
	 * super_container.size(); i++) { Collections.sort(super_container.get(i),
	 * new Comparator<ArrayList<String>>() {
	 * 
	 * @Override public int compare(ArrayList<String> a, ArrayList<String> b) {
	 * // TODO Auto-generated method stub return a.get(index +
	 * 1).compareTo(b.get(index + 1)); } }); }
	 * 
	 * container = new ArrayList<ArrayList<String>>(); for (int i = 0; i <
	 * super_container.size(); i++) { int counter2 = 1; for (int j = 0; j <
	 * super_container.get(i).size(); j++) {
	 * 
	 * if (j + 1 < super_container.get(i).size() &&
	 * super_container.get(i).get(j).get(index + 1)
	 * .equals(super_container.get(i).get(j + 1).get(index + 1))) {
	 * super_container.get(i).get(j).set(0, super_container.get(i).get(j).get(0)
	 * + ""-"" + counter2); } else { if (j - 1 >= 0 &&
	 * super_container.get(i).get(j).get(index + 1)
	 * .equals(super_container.get(i).get(j - 1).get(index + 1))) {
	 * super_container.get(i).get(j).set(0, super_container.get(i).get(j).get(0)
	 * + ""-"" + counter2); counter2++; } else {
	 * super_container.get(i).get(j).set(0, super_container.get(i).get(j).get(0)
	 * + ""-"" + counter2); } }
	 * 
	 * }
	 * 
	 * } for (int i = 0; i < super_container.size(); i++) { for (int j = 0; j <
	 * super_container.get(i).size(); j++) {
	 * container.add(super_container.get(i).get(j)); } } return container;
	 * 
	 * } catch (FileNotFoundException e) {
	 * 
	 * } catch (IOException e) {
	 * 
	 * } return null; }
	 * 
	 * public void write(ArrayList<ArrayList<String>> sorted) { try { CSVWriter
	 * writer = new CSVWriter(new FileWriter(""./SplitFile.csv""), ',',
	 * CSVWriter.NO_QUOTE_CHARACTER);
	 * 
	 * for (int i = 0; i < sorted.size(); i++) { String[] entries = new
	 * String[sorted.get(i).size()]; for (int j = 0; j < sorted.get(i).size();
	 * j++) { entries[j] = sorted.get(i).get(j); } writer.writeNext(entries);
	 * 
	 * } System.out.println(""Written to the File Successfully""); writer.close();
	 * } catch (IOException e) { System.out.println(""File Name is Already There""
	 * ); } }
	 */
}
"
HighFrequencyFilterConnection.java,log-6.9.380,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.parameters.HighFrequencyFilterParameters;

public class HighFrequencyFilterConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String FILTEREDLOG = ""Filtered log"";

	private HighFrequencyFilterParameters parameters;

	public HighFrequencyFilterConnection(XLog log, XLog filteredLog,
			HighFrequencyFilterParameters parameters) {
		super(""High Frequency Filter Connection"");
		put(LOG, log);
		put(FILTEREDLOG, filteredLog);
		this.parameters = new HighFrequencyFilterParameters(parameters);
	}

	public HighFrequencyFilterParameters getParameters() {
		return parameters;
	}
}
"
LogCentralityConnection.java,log-6.9.380,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityParameters;

public class LogCentralityConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String LOGCENTRALITY = ""Log Centrality"";

	private LogCentralityParameters parameters;

	public LogCentralityConnection(XLog log, LogCentrality logCentrality,
			LogCentralityParameters parameters) {
		super(""Log Centrality Connection"");
		put(LOG, log);
		put(LOGCENTRALITY, logCentrality);
		this.parameters = new LogCentralityParameters(parameters);
	}

	public LogCentralityParameters getParameters() {
		return parameters;
	}
}"
LogCentralityFilterConnection.java,log-6.9.380,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

public class LogCentralityFilterConnection  extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String LOGCENTRALITY = ""Log Centrality"";

	private LogCentralityFilterParameters parameters;

	public LogCentralityFilterConnection(XLog log, LogCentrality logCentrality,
			LogCentralityFilterParameters parameters) {
		super(""Log Centrality Filter Connection"");
		put(LOG, log);
		put(LOGCENTRALITY, logCentrality);
		this.parameters = new LogCentralityFilterParameters(parameters);
	}

	public LogCentralityFilterParameters getParameters() {
		return parameters;
	}
}"
LogFrequencyConnection.java,log-6.9.380,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.parameters.LogFrequencyParameters;

public class LogFrequencyConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String LOGFREQUENCY = ""Log Frequency"";

	private LogFrequencyParameters parameters;

	public LogFrequencyConnection(XLog log, LogFrequency logFrequency,
			LogFrequencyParameters parameters) {
		super(""Log Frequency Connection"");
		put(LOG, log);
		put(LOGFREQUENCY, logFrequency);
		this.parameters = new LogFrequencyParameters(parameters);
	}

	public LogFrequencyParameters getParameters() {
		return parameters;
	}
}"
LowFrequencyFilterConnection.java,log-6.9.380,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

public class LowFrequencyFilterConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String FILTEREDLOG = ""Filtered log"";

	private LowFrequencyFilterParameters parameters;

	public LowFrequencyFilterConnection(XLog log, XLog filteredLog,
			LowFrequencyFilterParameters parameters) {
		super(""Low Frequency Filter Connection"");
		put(LOG, log);
		put(FILTEREDLOG, filteredLog);
		this.parameters = new LowFrequencyFilterParameters(parameters);
	}

	public LowFrequencyFilterParameters getParameters() {
		return parameters;
	}
}
"
LowOccurrencesFilterConnection.java,log-6.9.380,"package org.processmining.log.connections;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

public class LowOccurrencesFilterConnection extends AbstractConnection {

	public final static String LOG = ""Log"";
	public final static String FILTEREDLOG = ""Filtered log"";

	private LowOccurrencesFilterParameters parameters;

	public LowOccurrencesFilterConnection(XLog log, XLog filteredLog,
			 LowOccurrencesFilterParameters parameters) {
		super(""Low Occurrences Filter Connection"");
		put(LOG, log);
		put(FILTEREDLOG, filteredLog);
		this.parameters = new LowOccurrencesFilterParameters(parameters);
	}

	public  LowOccurrencesFilterParameters getParameters() {
		return parameters;
	}
}
"
AbstractCSVFile.java,log-6.9.380,"package org.processmining.log.csv;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import com.google.common.io.Files;

public abstract class AbstractCSVFile implements CSVFile {

	private final Path file;

	public AbstractCSVFile(Path file) {
		this.file = file;	
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.log.csvimport.ICSVFile#getFile()
	 */
	@Override
	public Path getFile() {
		return file;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.log.csvimport.ICSVFile#getFilename()
	 */
	@Override
	public String getFilename() {
		return file.getFileName().toString();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.log.csv.CSVFile#getInputStream()
	 */
	@Override
	public InputStream getInputStream() throws IOException {
		String ext = Files.getFileExtension(getFile().toFile().getName());
		if (ext.equalsIgnoreCase(""csv"") || ext.equalsIgnoreCase(""txt"")) {
			return new FileInputStream(getFile().toFile());
		} else if (ext.equalsIgnoreCase(""zip"")) {
			ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(getFile().toFile()));
			ZipEntry nextEntry = zipInputStream.getNextEntry();
			if (nextEntry == null) {
				throw new IOException(""ZIP files does not contain any files"");
			}
			return zipInputStream;
		} else if (ext.equalsIgnoreCase(""gz"")) {
			return new GZIPInputStream(new FileInputStream(getFile().toFile()));
		}
		throw new UnsupportedOperationException(""Unsupported file type "" + ext);
	}

}
"
CSVConfig.java,log-6.9.380,"package org.processmining.log.csv.config;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;
import org.mozilla.universalchardet.UniversalDetector;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csvimport.exception.CSVConversionException;

/**
 * Configuration for the import of the CSV
 * 
 * @author F. Mannhardt
 *
 */
public final class CSVConfig {
	
	private static final int SEPARATOR_DETECTION_ROW_LIMIT = 10;
	
	private String charset = Charset.defaultCharset().name();
	private CSVSeperator separator = CSVSeperator.COMMA;
	private CSVQuoteCharacter quoteChar = CSVQuoteCharacter.DOUBLE_QUOTE;
	private CSVEscapeCharacter escapeChar = CSVEscapeCharacter.QUOTE;
	
	public CSVConfig() {
	}
	
	public CSVConfig(final CSVFile csvFile) throws CSVConversionException {
		try {
			charset = autoDetectCharset(csvFile);
			separator = autoDetectSeparator(csvFile, charset);
			quoteChar = autoDetectQuote(csvFile, charset);
		} catch (IOException e) {
			throw new CSVConversionException(""Could not auto-detect CSV import parameters."", e);
		}
	}
	
	private static String autoDetectCharset(final CSVFile csvFile) throws FileNotFoundException, IOException {

		final UniversalDetector detector = new UniversalDetector(null);
		
		try (FileInputStream fis = new FileInputStream(csvFile.getFile().toFile())) {
			byte[] buf = new byte[4096];
			int nread;
			while ((nread = fis.read(buf)) > 0 && !detector.isDone()) {
				detector.handleData(buf, 0, nread);
			}
			detector.dataEnd();
		}
		
		if (detector.getDetectedCharset() != null) {
			return detector.getDetectedCharset();
		} else {
			// Nothing detected, assume OS default
			return Charset.defaultCharset().name();
		}
	}

	private static CSVSeperator autoDetectSeparator(final CSVFile csvFile, String charset) throws FileNotFoundException, IOException {
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(csvFile.getFile().toFile()), Charset.forName(charset)))) {
			Map<CSVSeperator, Integer> counter = new HashMap<>();
			for (int i = 0; i < SEPARATOR_DETECTION_ROW_LIMIT; i++) {
				String line = reader.readLine();
				if (line == null) {
					break;
				}
				updateCounter(counter, CSVSeperator.COMMA, "","", line);
				updateCounter(counter, CSVSeperator.TAB, ""\t"", line);
				updateCounter(counter, CSVSeperator.SEMICOLON, "";"", line);
			}
			// now check which are still fine
			for (CSVSeperator seperator : counter.keySet()) {
				if (counter.get(seperator) > 1) {
					return seperator;
				}
			}
			// if none of them was properly detected go with inconsistent ones
			for (CSVSeperator seperator : counter.keySet()) {
				if (counter.get(seperator) == -1) {
					return seperator;
				}
			}
		}
		
		// Fall back to default
		return CSVSeperator.COMMA;
	}

	private static void updateCounter(Map<CSVSeperator, Integer> counter, CSVSeperator separator, String token,
			String line) {
		// Remove all text in between quotes as it should be ignored for separator detection 
		String lineWithoutQuotes = removeTextInQuotes(line);
		int matchCount = StringUtils.countMatches(lineWithoutQuotes, token);
		if (counter.get(separator) == null) {
			counter.put(separator, matchCount);
		} else if (counter.get(separator) != matchCount) {
			// Inconsistent number of separator characters
			counter.put(separator, -1);
		}
	}

	private static String removeTextInQuotes(String line) {
		String internalLine = line;
		while (internalLine.contains(""\"""")) {
			int startIndex = internalLine.indexOf(""\"""");
			int endIndex = internalLine.substring(startIndex + 1, internalLine.length()).indexOf(""\"""");
			// now remove the in between part of the string and replace it with some placeholder text
			internalLine = internalLine.substring(0, startIndex) + ""placeholder""
					+ internalLine.substring(startIndex + 1 + endIndex + 1, internalLine.length());
		}
		return internalLine;
	}

	private static CSVQuoteCharacter autoDetectQuote(CSVFile csvFile, String charset) {
		//TODO implement
		return CSVQuoteCharacter.DOUBLE_QUOTE;
	}

	public String getCharset() {
		return charset;
	}

	public void setCharset(String charset) {
		this.charset = charset;
	}

	public CSVSeperator getSeparator() {
		return separator;
	}

	public void setSeparator(CSVSeperator separator) {
		this.separator = separator;
	}

	public CSVQuoteCharacter getQuoteChar() {
		return quoteChar;
	}

	public void setQuoteChar(CSVQuoteCharacter quoteChar) {
		this.quoteChar = quoteChar;
	}

	public CSVEscapeCharacter getEscapeChar() {
		return escapeChar;
	}

	public void setEscapeChar(CSVEscapeCharacter escapeChar) {
		this.escapeChar = escapeChar;
	}
	
}"
CSVEscapeCharacter.java,log-6.9.380,"package org.processmining.log.csv.config;

public enum CSVEscapeCharacter {
	
	QUOTE(""QUOTE (\"")"", '""');
	
	private final String description;
	private final char escapeChar;

	private CSVEscapeCharacter(String description, char escapeCharacter) {
		this.description = description;
		this.escapeChar = escapeCharacter;
	}

	public String toString() {
		return description;
	}

	public char getEscapeChar() {
		return escapeChar;
	}

}
"
CSVQuoteCharacter.java,log-6.9.380,"package org.processmining.log.csv.config;


public enum CSVQuoteCharacter {
	
	SINGLE_QUOTE(""QUOTE (')"", '\''),
	DOUBLE_QUOTE(""DOUBLE QUOTE (\"")"", '""'), 
	NONE(""NONE"", '\0');

	private final String description;
	private final char quoteChar;

	private CSVQuoteCharacter(String description, char quoteCharacter) {
		this.description = description;
		this.quoteChar = quoteCharacter;
	}

	public String toString() {
		return description;
	}

	public char getQuoteChar() {
		return quoteChar;
	}

}
"
CSVSeperator.java,log-6.9.380,"package org.processmining.log.csv.config;


public enum CSVSeperator {
	COMMA(""Comma (,)"", ','), 
	SEMICOLON(""Semicolon (;)"",';'),
	TAB(""Tab"", '\t'),
	WHITESPACE(""Whitespace"",' ');

	private final String description;
	private final char seperatorChar;

	private CSVSeperator(String description, char seperatorChar) {
		this.description = description;
		this.seperatorChar = seperatorChar;
	}

	public String toString() {
		return description;
	}

	public char getSeperatorChar() {
		return seperatorChar;
	}

}"
CSVFile.java,log-6.9.380,"package org.processmining.log.csv;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;

import org.processmining.log.csv.config.CSVConfig;

/**
 * Interface for a CSV file managed in the ProM environment. Example usage:
 * 
 * <pre>
 * CSVFile file; // get it from a plug-in
 * 
 * // Prepare config with auto guessing of encoding etc.
 * CSVConfig importConfig = new CSVConfig(csvFile);
 * 
 * // Read header
 * try {
 * 	String[] header = csvFile.readHeader(importConfig);
 * } catch (IOException e) {
 * 	// do someting
 * }
 * 
 * // Read content
 * try (ICSVReader reader = csvFile.createReader(importConfig)) {
 * 	while ((nextLine = reader.readNext()) != null) {
 * 		// do something
 * 	}
 * }
 * </pre>
 * 
 * @author F. Mannhardt
 * 
 */
public interface CSVFile {

	/**
	 * @return the complete path to the CSV file (including the file itself)
	 */
	Path getFile();

	/**
	 * @return the filename with extension
	 */
	String getFilename();

	/**
	 * @return input stream of this CSV file
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	InputStream getInputStream() throws FileNotFoundException, IOException;

	/**
	 * Returns the first row of the CSV file.
	 * 
	 * @param config
	 * @return
	 * @throws IOException
	 */
	String[] readHeader(CSVConfig config) throws IOException;

	/**
	 * Returns a new {@link ICSVReader} that can be used to read through the
	 * input stream. The caller is responsible for calling
	 * {@link ICSVReader#close()} on the reader.
	 * 
	 * @param config
	 * @return
	 * @throws IOException
	 */
	ICSVReader createReader(CSVConfig config) throws IOException;

	/**
	 * @return the CSV reader/writer interface used for this {@link CSVFile}
	 */
	ICSV getCSV();

}"
CSVFileReferenceOpenCSVImpl.java,log-6.9.380,"package org.processmining.log.csv;

import java.io.IOException;
import java.nio.file.Path;

import org.processmining.log.csv.config.CSVConfig;

/**
 * {@link CSVFile} implementation that holds a reference to a CSV file on disk.
 * The {@link CSVFileReferenceUnivocityImpl} is recommended!
 *
 * @author F. Mannhardt
 *
 */
public final class CSVFileReferenceOpenCSVImpl extends AbstractCSVFile {

	private final CSVOpenCSVImpl csv;

	public CSVFileReferenceOpenCSVImpl(Path file) {
		super(file);
		csv = new CSVOpenCSVImpl();
	}

	@Deprecated
	public CSVFileReferenceOpenCSVImpl(Path file, String filename, long fileSizeInBytes) {
		this(file);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#readHeader(org.processmining.log.csvimport
	 * .CSVImportConfig)
	 */
	@Override
	public String[] readHeader(CSVConfig importConfig) throws IOException {
		return createReader(importConfig).readNext();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#createReader(org.processmining.log.
	 * csv.CSVConfig)
	 */
	@Override
	public ICSVReader createReader(CSVConfig config) throws IOException {
		return csv.createReader(getInputStream(), config);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.log.csv.CSVFile#getCSV()
	 */
	@Override
	public ICSV getCSV() {
		return csv;
	}

}
"
CSVFileReferenceUnivocityImpl.java,log-6.9.380,"package org.processmining.log.csv;

import java.io.IOException;
import java.nio.file.Path;

import org.processmining.log.csv.config.CSVConfig;

import com.univocity.parsers.common.TextParsingException;

/**
 * {@link CSVFile} implementation that holds a reference to a CSV file on disk.
 *
 * @author N. Tax
 *
 */
public final class CSVFileReferenceUnivocityImpl extends AbstractCSVFile {
	
	private final CSVUnivocityImpl csv;

	public CSVFileReferenceUnivocityImpl(Path file) {
		super(file);
		csv = new CSVUnivocityImpl();
	}
	
	@Deprecated
	public CSVFileReferenceUnivocityImpl(Path file, String filename, long fileSizeInBytes) {
		this(file);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#readHeader(org.processmining.log.csvimport
	 * .CSVImportConfig)
	 */
	@Override
	public String[] readHeader(CSVConfig importConfig) throws IOException {
		try {
			return createReader(importConfig).readNext();
		} catch (TextParsingException | IllegalStateException e) {
			// Wrap unchecked Univocity exceptions into a IOException for consistency
			throw new IOException(e);
		}
	}

	/* (non-Javadoc)
	 * @see org.processmining.log.csv.CSVFile#createReader(org.processmining.log.csv.CSVConfig)
	 */
	@Override
	public ICSVReader createReader(CSVConfig config) throws IOException {
		return csv.createReader(getInputStream(), config);
	}

	/* (non-Javadoc)
	 * @see org.processmining.log.csv.CSVFile#getCSV()
	 */
	@Override
	public ICSV getCSV() {
		return csv;
	}
	
}
"
CSVOpenCSVImpl.java,log-6.9.380,"package org.processmining.log.csv;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;

import org.processmining.log.csv.config.CSVConfig;

import au.com.bytecode.opencsv.CSVParser;
import au.com.bytecode.opencsv.CSVReader;
import au.com.bytecode.opencsv.CSVWriter;

public class CSVOpenCSVImpl implements ICSV {
	
	private static final int BUFFER_SIZE = 8192 * 4;

	private static CSVReader createCSVReader(InputStream is, CSVConfig importConfig)
			throws UnsupportedEncodingException {
		if (importConfig.getQuoteChar() == null) {
			return new CSVReader(new BufferedReader(new InputStreamReader(is, importConfig.getCharset()), BUFFER_SIZE),
					importConfig.getSeparator().getSeperatorChar(), CSVParser.DEFAULT_QUOTE_CHARACTER,
					CSVParser.DEFAULT_ESCAPE_CHARACTER, 0, false, false, true);
		} else {
			return new CSVReader(new BufferedReader(new InputStreamReader(is, importConfig.getCharset()), BUFFER_SIZE),
					importConfig.getSeparator().getSeperatorChar(), importConfig.getQuoteChar().getQuoteChar());
		}

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#createReader(org.processmining.log.
	 * csvimport.CSVImportConfig)
	 */
	@Override
	public ICSVReader createReader(InputStream is, CSVConfig importConfig) throws IOException {
		final CSVReader csvReader = createCSVReader(is, importConfig);
		return new ICSVReader() {

			/* (non-Javadoc)
			 * @see org.processmining.log.csv.AbstractCSVReader#readNext()
			 */
			public String[] readNext() throws IOException {
				return csvReader.readNext();
			}

			/* (non-Javadoc)
			 * @see org.processmining.log.csv.AbstractCSVReader#close()
			 */
			public void close() throws IOException {
				csvReader.close();
			}
			
		};
	}
	
	private static CSVWriter createCSVWriter(OutputStream os, CSVConfig importConfig)
			throws UnsupportedEncodingException {
		return new CSVWriter(new BufferedWriter(new OutputStreamWriter(os, importConfig.getCharset()), BUFFER_SIZE),
				importConfig.getSeparator().getSeperatorChar(), importConfig.getQuoteChar().getQuoteChar());
	}

	public ICSVWriter createWriter(OutputStream os, CSVConfig importConfig) throws IOException {
		final CSVWriter csvWriter = createCSVWriter(os, importConfig);
		return new ICSVWriter() {

			public void writeNext(String[] value) {
				csvWriter.writeNext(value, false);
			}

			public void close() throws IOException {
				csvWriter.close();
			}

			
		};
	}

}
"
CSVUnivocityImpl.java,log-6.9.380,"package org.processmining.log.csv;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;

import org.apache.commons.io.input.BOMInputStream;
import org.processmining.log.csv.config.CSVConfig;

import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;
import com.univocity.parsers.csv.CsvWriter;
import com.univocity.parsers.csv.CsvWriterSettings;

public class CSVUnivocityImpl implements ICSV {
	
	private static final int MAX_CHARS_PER_COLUMN = 65536;
	
	private static final int BUFFER_SIZE = 8192 * 4;

	private static CsvParser createCSVReader(InputStream is, CSVConfig importConfig) throws UnsupportedEncodingException{
		CsvParserSettings settings = new CsvParserSettings();
		settings.setMaxCharsPerColumn(MAX_CHARS_PER_COLUMN);
		settings.setLineSeparatorDetectionEnabled(true);
		settings.getFormat().setDelimiter(importConfig.getSeparator().getSeperatorChar());
		settings.getFormat().setQuote(importConfig.getQuoteChar().getQuoteChar());
		settings.getFormat().setCharToEscapeQuoteEscaping(importConfig.getEscapeChar().getEscapeChar());
		CsvParser parser = new CsvParser(settings);
		BOMInputStream bomExcludingStream = new BOMInputStream(is); // exclude BOM byte for UTF-BOM encoded files as those mess up with pretty much everything
		parser.beginParsing(new BufferedReader(new InputStreamReader(bomExcludingStream, importConfig.getCharset()), BUFFER_SIZE));
		return parser;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.log.csv.CSVFile#createReader(org.processmining.log.
	 * csvimport.CSVImportConfig)
	 */
	@Override
	public ICSVReader createReader(InputStream is, CSVConfig importConfig) throws IOException {
		final CsvParser csvReader = createCSVReader(is, importConfig);
		return new ICSVReader() {
			
			public String[] readNext() throws IOException {
				return csvReader.parseNext();
			}

			public void close() throws IOException {
				csvReader.stopParsing();
			}
			
		};
	}
	
	private static CsvWriter createCSVWriter(OutputStream os, CSVConfig importConfig) throws UnsupportedEncodingException {
		CsvWriterSettings settings = new CsvWriterSettings();
		settings.getFormat().setDelimiter(importConfig.getSeparator().getSeperatorChar());
		settings.getFormat().setQuote(importConfig.getQuoteChar().getQuoteChar());
		settings.getFormat().setCharToEscapeQuoteEscaping(importConfig.getEscapeChar().getEscapeChar());
		CsvWriter writer = new CsvWriter(new OutputStreamWriter(os, importConfig.getCharset()), settings);
		return writer;
	}

	/* (non-Javadoc)
	 * @see org.processmining.log.csv.CSVFile#createWriter(java.io.OutputStream, org.processmining.log.csvimport.config.CSVImportConfig)
	 */
	@Override
	public ICSVWriter createWriter(OutputStream os, CSVConfig config) throws IOException {
		final CsvWriter writer = createCSVWriter(os, config);
		return new ICSVWriter() {
			
			public void writeNext(String[] value) {
				writer.writeRow((Object[])value);
			}
			
			public void close() throws IOException {				
				writer.close();				
			}
		};
	}

}
"
ICSV.java,log-6.9.380,"package org.processmining.log.csv;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import org.processmining.log.csv.config.CSVConfig;

/**
 * Wrapper around some CSV parsing library.
 * 
 * @author F. Mannhardt
 *
 */
public interface ICSV {

	/**
	 * Returns a new {@link ICSVWriter} that can be used to write data to a new
	 * {@link OutputStream} in CSV format. The caller is responsible for calling
	 * {@link ICSVWriter#close()} on the writer.
	 * 
	 * @param os
	 * @param config
	 * @return
	 * @throws IOException
	 */
	ICSVWriter createWriter(OutputStream os, CSVConfig config) throws IOException;

	/**
	 * Returns a new {@link ICSVReader} that can be used to read data from the
	 * {@link InputStream} in CSV format. The caller is responsible for calling
	 * {@link ICSVReader#close()} on the writer.
	 * 
	 * @param os
	 * @param config
	 * @return
	 * @throws IOException
	 */
	ICSVReader createReader(InputStream is, CSVConfig config) throws IOException;

}
"
ICSVReader.java,log-6.9.380,"package org.processmining.log.csv;

import java.io.IOException;

/**
 * Reader of a CSV file
 * 
 * @author F. Mannhardt
 *
 */
public interface ICSVReader extends AutoCloseable {

	/**
	 * @return the next line or NULL in case of EOF
	 * @throws IOException
	 */
	String[] readNext() throws IOException;

	/* (non-Javadoc)
	 * @see java.lang.AutoCloseable#close()
	 */
	void close() throws IOException;

}
"
ICSVWriter.java,log-6.9.380,"package org.processmining.log.csv;

import java.io.IOException;

public interface ICSVWriter {

	void writeNext(String[] value);
	
	void close() throws IOException;
	
}
"
CSVViewer.java,log-6.9.380,"package org.processmining.log.csv.plugin;

import javax.swing.JComponent;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.exception.CSVConversionException;

public class CSVViewer {

	@Plugin(name = ""View CSV"", level = PluginLevel.Regular, //
	parameterLabels = { ""CSV"" }, returnLabels = { ""XES Event Log"" }, // 
	returnTypes = { JComponent.class }, userAccessible = true)
	@Visualizer
	public JComponent viewCSV(final UIPluginContext context, final CSVFile csvFile) throws CSVConversionException {
		return new CSVViewerPanel(csvFile, new CSVConfig(csvFile));
	}

}
"
CSVViewerPanel.java,log-6.9.380,"package org.processmining.log.csv.plugin;

import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.List;

import javax.swing.BoxLayout;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.SwingWorker;

import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csv.config.CSVQuoteCharacter;
import org.processmining.log.csv.config.CSVSeperator;
import org.processmining.log.csvimport.ui.preview.CSVPreviewPanel;

import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * CSV Viewer
 * 
 * @author F. Mannhardt
 *
 */
final class CSVViewerPanel extends JPanel {

	private static final long serialVersionUID = 2L;

	private static final int MAX_PREVIEW = 1000;
	private static final int COLUMN_WIDTH = 240;

	private final CSVFile csv;
	private final CSVConfig importConfig;

	private final ProMComboBox<String> charsetCbx;
	private final ProMComboBox<CSVSeperator> separatorField;
	private final ProMComboBox<CSVQuoteCharacter> quoteField;

	private final CSVPreviewPanel previewPanel;

	private SwingWorker<Void, String[]> worker;

	public CSVViewerPanel(final CSVFile csv, final CSVConfig importConfig) {
		super();
		this.importConfig = importConfig;
		this.csv = csv;
		this.previewPanel = new CSVPreviewPanel();

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setOpaque(false);

		JLabel header = new JLabel(
				""<HTML><H2>Read-only CSV Viewer</H2>""
				+ ""<H3>This visualization is a read-only preview of the CSV file. Please use plug-in 'Convert CSV to XES' for conversion to XES</H3></HTML>"");
		header.setAlignmentX(CENTER_ALIGNMENT);

		add(header);

		JPanel topPanel = new JPanel();

		GroupLayout layout = new GroupLayout(topPanel);
		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		topPanel.setOpaque(false);
		topPanel.setLayout(layout);

		JPanel charsetPanel = new JPanel();
		charsetPanel.setOpaque(false);
		charsetPanel.setLayout(new BoxLayout(charsetPanel, BoxLayout.Y_AXIS));
		charsetCbx = new ProMComboBox<>(Charset.availableCharsets().keySet());
		charsetCbx.setSelectedItem(importConfig.getCharset());
		charsetCbx.setPreferredSize(null);
		charsetCbx.setMinimumSize(null);
		JLabel charsetLabel = createLabel(""Charset"", ""Configure the character encoding that is used by the CSV file"");
		charsetLabel.setAlignmentX(LEFT_ALIGNMENT);
		charsetCbx.setAlignmentX(LEFT_ALIGNMENT);
		charsetPanel.add(charsetLabel);
		charsetPanel.add(charsetCbx);
		charsetCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setCharset(charsetCbx.getSelectedItem().toString());
				refreshPreview();
			}
		});

		JPanel separatorPanel = new JPanel();
		separatorPanel.setOpaque(false);
		separatorPanel.setLayout(new BoxLayout(separatorPanel, BoxLayout.Y_AXIS));
		separatorField = new ProMComboBox<>(CSVSeperator.values());
		separatorField.setPreferredSize(null);
		separatorField.setMinimumSize(null);
		separatorField.setSelectedItem(importConfig.getSeparator());
		JLabel seperationLabel = createLabel(""Separator Character"",
				""Configure the character that is used by the CSV file to separate two fields"");
		seperationLabel.setAlignmentX(LEFT_ALIGNMENT);
		separatorField.setAlignmentX(LEFT_ALIGNMENT);
		separatorPanel.add(seperationLabel);
		separatorPanel.add(separatorField);
		separatorField.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setSeparator(((CSVSeperator) separatorField.getSelectedItem()));
				refreshPreview();
			}
		});

		JPanel quotePanel = new JPanel();
		quotePanel.setOpaque(false);
		quotePanel.setLayout(new BoxLayout(quotePanel, BoxLayout.Y_AXIS));
		quoteField = new ProMComboBox<>(CSVQuoteCharacter.values());
		quoteField.setPreferredSize(null);
		quoteField.setMinimumSize(null);
		quoteField.setSelectedItem(importConfig.getQuoteChar());
		JLabel quoteLabel = createLabel(
				""Quote Character"",
				""Configure the character that is used by the CSV file that is used to quote values if they contain the separator character or a newline"");
		quoteLabel.setAlignmentX(LEFT_ALIGNMENT);
		quoteField.setAlignmentX(LEFT_ALIGNMENT);
		quotePanel.add(quoteLabel);
		quotePanel.add(quoteField);
		quoteField.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setQuoteChar((CSVQuoteCharacter) quoteField.getSelectedItem());
				refreshPreview();
			}
		});		

		ParallelGroup verticalGroup = layout.createParallelGroup().addComponent(charsetPanel, Alignment.TRAILING)
				.addComponent(separatorPanel, Alignment.TRAILING).addComponent(quotePanel, Alignment.TRAILING);

		SequentialGroup horizontalGroup = layout.createSequentialGroup()
				.addComponent(charsetPanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
				.addComponent(separatorPanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
				.addComponent(quotePanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH);

		layout.linkSize(SwingConstants.HORIZONTAL, separatorPanel, charsetPanel, quotePanel);

		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		layout.setVerticalGroup(verticalGroup);
		layout.setHorizontalGroup(horizontalGroup);

		add(topPanel);
		add(previewPanel);
		refreshPreview();
	}

	private void refreshPreview() {

		if (worker != null) {
			worker.cancel(true);
		}

		previewPanel.clear();

		// Update Header
		try {
			previewPanel.setHeader(csv.readHeader(importConfig));
		} catch (IOException | ArrayIndexOutOfBoundsException e) {
			ProMUIHelper.showWarningMessage(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"");
			return;
		}

		worker = new SwingWorker<Void, String[]>() {

			protected Void doInBackground() throws Exception {

				try (ICSVReader reader = csv.createReader(importConfig)) {
					// Skip header
					reader.readNext();
					String[] nextLine;
					int i = 0;
					while ((nextLine = reader.readNext()) != null && i < MAX_PREVIEW) {
						publish(nextLine);
						i++;
					}
				}

				return null;
			}

			protected void process(List<String[]> chunks) {
				for (String[] row : chunks) {
					previewPanel.addRow(row);
				}
			}

		};

		try {
			worker.execute();
		} catch (Exception e) {
			JOptionPane.showMessageDialog(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"",
					JOptionPane.ERROR_MESSAGE);
		}
	}

	private static JLabel createLabel(String caption, String description) {
		JLabel eventLabel = SlickerFactory.instance().createLabel(
				""<HTML><B>"" + caption + ""</B><BR/><I>"" + description + ""</I></HTML>"");
		eventLabel.setFont(eventLabel.getFont().deriveFont(Font.PLAIN));
		return eventLabel;
	}

}"
CSVExportPlugin.java,log-6.9.380,"package org.processmining.log.csvexport;

import java.io.File;
import java.io.IOException;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.csv.CSVFile;

import com.google.common.io.Files;

/**
 * Exports a CSVFile
 * 
 * @author F. Mannhardt
 *
 */
@Plugin(name = ""Export CSV"", returnLabels = {}, returnTypes = {},
		level = PluginLevel.Regular, parameterLabels = { ""CSVFile"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Export CSV"", extension = ""csv"")
public final class CSVExportPlugin  {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export CSV File"")
	public void export(PluginContext context, CSVFile csvFile, File file) throws IOException {
		Files.copy(csvFile.getFile().toFile(), file);
	}
}
"
ExportLogCsv.java,log-6.9.380,"package org.processmining.log.csvexport;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.out.XSerializer;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Export Log to CSV File"", level= PluginLevel.PeerReviewed, parameterLabels = { ""Log"", ""File"" }, returnLabels = {}, returnTypes = {}, userAccessible = true)
@UIExportPlugin(description = ""CSV files"", extension = ""csv"")
public final class ExportLogCsv {
	
//TODO: Export plug-in cannot show any Dialog :(
	
/*	private class DateFormatPanel extends BorderPanel {

		private static final long serialVersionUID = -6547392010448275699L;
		private final ProMTextField dateFormatTextField;

		public DateFormatPanel() {
			super(0, 0);
			dateFormatTextField = new ProMTextField(""yyyy-MM-dd'T'HH:mm:ssZ"");
			add(dateFormatTextField);
		}	
		
		public String getDateFormat() {
			return dateFormatTextField.getText().trim();		
		}

		public InteractionResult getUserChoice(UIPluginContext context) {
			return context.showConfiguration(""Specify date format"", this);
		}

	}*/
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt, M. de Leoni"", email = ""m.d.leoni@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Log to CSV File"")
	public void export(UIPluginContext context, XLog log, File file) throws IOException {
		FileOutputStream out = new FileOutputStream(file);

		long instanceNumber=1;

		//final XLog result = XFactoryRegistry.instance().currentDefault().createLog(log.getAttributes());
		final XLifecycleExtension lfExt = XLifecycleExtension.instance();
		final XFactory factory=XFactoryRegistry.instance().currentDefault();
		final XConceptExtension cpExt=XConceptExtension.instance();
		final HashMap<String,List<Long>> map=new HashMap<String, List<Long>>();
		String activityName;
		
		for (XTrace trace : log) {
			map.clear();
			for (XEvent event : trace) {
				switch(lfExt.extractStandardTransition(event))
				{
					case START :
						activityName=cpExt.extractName(event);
						if (activityName!=null)
						{
							//event=factory.createEvent(e.getAttributes());
							if (cpExt.extractInstance(event)==null)
							{						
								List<Long> listInstances=map.get(activityName);
								if (listInstances==null)
								{
									listInstances=new LinkedList<Long>();
									map.put(activityName, listInstances);
								}
								cpExt.assignInstance(event, String.valueOf(instanceNumber));
								listInstances.add(instanceNumber++);
							}
						}
						break;					
					case COMPLETE :
						activityName=cpExt.extractName(event);
						if (activityName!=null)
						{
							event=factory.createEvent(event.getAttributes());							
							if (cpExt.extractInstance(event)==null)
							{
								List<Long> listInstances=map.get(activityName);
								if (listInstances==null || listInstances.isEmpty())									
									cpExt.assignInstance(event, String.valueOf(instanceNumber++));
								else
								{
									cpExt.assignInstance(event, String.valueOf(listInstances.remove(0)));
								}
							}
						}
						break;
					default :
						//event=null;
						break;
				}
				//copy.add(event);
			}
		}
		XSerializer logSerializer = new XesCsvSerializer(""yyyy/MM/dd HH:mm:ss.SSS"");
		logSerializer.serialize(log, out);
		out.close();	
	}
}
"
XesCsvSerializer.java,log-6.9.380,"package org.processmining.log.csvexport;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.time.FastDateFormat;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension.StandardModel;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.info.XAttributeInfo;
import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.logging.XLogging;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.out.XSerializer;
import org.processmining.log.utils.XUtils;

import au.com.bytecode.opencsv.CSVWriter;

/**
 * XES serialization to CSV including all trace/event attributes. The names of
 * trace attributes are prefixed with ""trace_"", those of event attributes are
 * prefixed with ""event_"".
 *
 * @author F. Mannhardt
 *
 */
public final class XesCsvSerializer implements XSerializer {

	private final FastDateFormat dateFormat;

	public XesCsvSerializer(String dateFormatString) {
		super();
		dateFormat = FastDateFormat.getInstance(dateFormatString);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.deckfour.xes.out.XesSerializer#getDescription()
	 */
	public String getDescription() {
		return ""XES CSV Serialization"";
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.deckfour.xes.out.XesSerializer#getName()
	 */
	public String getName() {
		return ""XES CSV"";
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.deckfour.xes.out.XesSerializer#getAuthor()
	 */
	public String getAuthor() {
		return ""F. Mannhardt"";
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.deckfour.xes.out.XesSerializer#getSuffices()
	 */
	public String[] getSuffices() {
		return new String[] { ""csv"" };
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.deckfour.xes.out.XesSerializer#serialize(org.deckfour.xes.model.XLog,
	 * java.io.OutputStream)
	 */
	public void serialize(XLog log, OutputStream out) throws IOException {
		XLogging.log(""start serializing log to .csv"", XLogging.Importance.DEBUG);
		long start = System.currentTimeMillis();

		CSVWriter writer = new CSVWriter(new OutputStreamWriter(out, ""UTF-8""));
		Map<String, Integer> columnMap = new HashMap<String, Integer>();

		String[] header = compileHeader(log, columnMap);
		writer.writeNext(header);

		for (XTrace trace : log) {
			writer.writeAll(compileTrace(trace, columnMap, header.length));
		}

		writer.close();
		String duration = "" ("" + (System.currentTimeMillis() - start) + "" msec.)"";
		XLogging.log(""finished serializing log"" + duration, XLogging.Importance.DEBUG);
	}

	private List<String[]> compileTrace(XTrace trace, Map<String, Integer> columnMap, int rowLength) {
		List<String[]> traceList = new ArrayList<String[]>();
		String[] currentRow = null;
		Set<XEvent> convertedEvents = new HashSet<>();
		for (ListIterator<XEvent> iterator = trace.listIterator(); iterator.hasNext();) {
			XEvent event = iterator.next();
			if (!convertedEvents.contains(event)) {
				StandardModel lifecycle = XLifecycleExtension.instance().extractStandardTransition(event);
				if (lifecycle == null) {
					// treat as complete
					currentRow = compileEvent(trace, null, event, columnMap, rowLength, currentRow);
					convertedEvents.add(event);
				} else if (lifecycle == StandardModel.START) {
					XEvent completionEvent = null;
					if (lifecycle == StandardModel.START) {
						completionEvent = lookup(trace.listIterator(iterator.nextIndex()), event,
								StandardModel.COMPLETE);
					}
					currentRow = compileEvent(trace, event, completionEvent, columnMap, rowLength, currentRow);
					convertedEvents.add(event);
					if (completionEvent != null) {
						convertedEvents.add(completionEvent);
					}
				} else if (lifecycle == StandardModel.COMPLETE) {
					//XEvent startEvent = null;
					//MASSIMILIANO: Not sure what the aim: if lifecycle==COMPLETE, we are in this block. Hence, lifecycle cannot be
					//START. Therefore, we never enter the loop below.
					/*if (lifecycle == StandardModel.START) {
						startEvent = lookup(trace.listIterator(iterator.nextIndex()), event, StandardModel.START);
					}*/
					currentRow = compileEvent(trace, null, event, columnMap, rowLength, currentRow);
					convertedEvents.add(event);

					//MASSIMILIANO: I've removed the following part. I have the feeling that you're trying to map with some
					//start event following the complete. This would mean that the end event might be larger than the start event.
					/*convertedEvents.add(event);
					if (startEvent != null) {
						convertedEvents.add(startEvent);*/
				//}
				} else {
					// ignore we only export start and complete
				}
			traceList.add(currentRow);
			}
		}
		return traceList;
	}

	private XEvent lookup(ListIterator<XEvent> listIterator, XEvent event, StandardModel model) {
		XConceptExtension concept = XConceptExtension.instance();
		String eventInstance = concept.extractInstance(event);
		while (listIterator.hasNext()) {
			XEvent e = listIterator.next();
			if (eventInstance != null && eventInstance.equals(concept.extractInstance(e))) {
				StandardModel lifecycle = XLifecycleExtension.instance().extractStandardTransition(e);
				if (lifecycle == model) {
					return e;
				}
			}
		}
		return null;
	}

	private String[] compileEvent(XTrace trace, XEvent startEvent, XEvent completionEvent,
			Map<String, Integer> columnMap, int rowLength, String[] lastRow) {
		XEvent mainEvent = completionEvent != null ? completionEvent : startEvent;
		String[] row = new String[rowLength];
		row[0] = XConceptExtension.instance().extractName(trace);
		row[1] = XConceptExtension.instance().extractName(mainEvent);
		if (startEvent != null) {
			Date date = XTimeExtension.instance().extractTimestamp(startEvent);
			if (date != null) {
				row[2] = dateFormat.format(date);
			}
		} else {
			Date date = XTimeExtension.instance().extractTimestamp(completionEvent);
			if (date != null) {
				row[2] = dateFormat.format(date);
			}
		}
		if (completionEvent != null) {
			Date date = XTimeExtension.instance().extractTimestamp(completionEvent);
			if (date != null) {
				row[3] = dateFormat.format(date);
			}
		} else {
			Date date = XTimeExtension.instance().extractTimestamp(startEvent);
			if (date != null) {
				row[3] = dateFormat.format(date);
			}
		}

		for (XAttribute attr : trace.getAttributes().values()) {
			if (!XUtils.isStandardExtensionAttribute(attr) || attr.getKey().startsWith(""org:"")) {
				assert columnMap.containsKey(""trace_"" + attr.getKey()) : ""Column unkown "" + attr.getKey();
				row[columnMap.get(""trace_"" + attr.getKey())] = convertAttribute(attr);
			}
		}
		for (XAttribute attr : mainEvent.getAttributes().values()) {
			if (!XUtils.isStandardExtensionAttribute(attr) || attr.getKey().startsWith(""org:"")) {
				assert columnMap.containsKey(""event_"" + attr.getKey()) : ""Column unkown "" + attr.getKey();
				row[columnMap.get(""event_"" + attr.getKey())] = convertAttribute(attr);
			}
		}
		if (lastRow != null) {
			for (int i = 0; i < row.length; i++) {
				if (row[i] == null) {
					row[i] = lastRow[i];
				}
			}
		}
		return row;
	}

	private String[] compileHeader(XLog log, Map<String, Integer> columnMap) {
		XLogInfo logInfo = XLogInfoFactory.createLogInfo(log);

		List<String> headerList = new ArrayList<String>();
		headerList.add(""case"");
		headerList.add(""event"");
		headerList.add(""startTime"");
		headerList.add(""completeTime"");

		int i = headerList.size() - 1;
		XAttributeInfo traceAttributeInfo = logInfo.getTraceAttributeInfo();
		for (XAttribute attr : traceAttributeInfo.getAttributes()) {
			if (!XUtils.isStandardExtensionAttribute(attr) || attr.getKey().startsWith(""org:"")) {
				i++;
				headerList.add(attr.getKey());
				columnMap.put(""trace_"" + attr.getKey(), i);
			}
		}
		XAttributeInfo eventAttributeInfo = logInfo.getEventAttributeInfo();
		for (XAttribute attr : eventAttributeInfo.getAttributes() ) {
			if (!XUtils.isStandardExtensionAttribute(attr) || attr.getKey().startsWith(""org:"")) {
				i++;
				if (headerList.contains(attr.getKey())) {
					headerList.add(""event_"" + attr.getKey());
					columnMap.put(""event_"" + attr.getKey(), i);
				} else {
					headerList.add(attr.getKey());
					columnMap.put(""event_"" + attr.getKey(), i);
				}
			}
		}
		return headerList.toArray(new String[headerList.size()]);
	}

	/**
	 * Helper method, returns the String representation of the attribute
	 *
	 * @param attribute
	 *            The attributes to convert
	 */
	protected String convertAttribute(XAttribute attribute) {
		if (attribute instanceof XAttributeTimestamp) {
			Date timestamp = ((XAttributeTimestamp) attribute).getValue();
			return dateFormat.format(timestamp);
		} else {
			return attribute.toString();
		}
	}

	/**
	 * toString() defaults to getName().
	 */
	public String toString() {
		return this.getName();
	}

}
"
CSVConversionConfig.java,log-6.9.380,"package org.processmining.log.csvimport.config;

import java.io.IOException;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.Format;
import java.text.MessageFormat;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XCostExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.formats.StandardDateFormats;

import com.google.common.collect.ImmutableList;

/**
 * Configuration regarding the conversion of the CSV file.
 * 
 * @author F. Mannhardt
 * 
 */
public final class CSVConversionConfig {

	private static final int DATA_TYPE_FORMAT_AUTO_DETECT_NUM_LINES = 5000;

	private static final Set<String> CASE_COLUMN_IDS = new HashSet<String>() {
		private static final long serialVersionUID = 1113995381788343439L;
		{
			add(""case"");
			add(""trace"");
			add(""traceid"");
			add(""caseid"");
		}
	};

	private static final Set<String> EVENT_COLUMN_IDS = new HashSet<String>() {
		private static final long serialVersionUID = -4218883319932959922L;
		{
			add(""event"");
			add(""eventname"");
			add(""activity"");
			add(""eventid"");
			add(""activityid"");
			add(""task"");
			add(""action"");
			add(""actie"");
		}
	};

	private static final Set<String> START_TIME_COLUMN_IDS = new HashSet<String>() {
		private static final long serialVersionUID = 6419129336151793063L;
		{
			add(""starttime"");
			add(""startdate"");
			add(""datumtijdbegin"");
		}
	};

	private static final Set<String> COMPLETION_TIME_COLUMN_IDS = new HashSet<String>() {
		private static final long serialVersionUID = 6419129336151793063L;
		{
			add(""timecomplete"");
			add(""completetime"");
			add(""completiontime"");
			add(""time"");
			add(""date"");
			add(""enddate"");
			add(""endtime"");
			add(""timestamp"");
			add(""datetime"");
			add(""date"");
			add(""eventtime"");
			add(""eindtijd"");
			add(""tijd"");
			add(""datum"");
			add(""datumtijdeind"");
		}
	};

	public static final class ExtensionAttribute {

		public ExtensionAttribute(String key, XExtension extension) {
			this.key = key;
			this.extension = extension;
		}

		public XExtension extension;
		public String key;

		public String toString() {
			if (key != null) {
				return String.format(""%s (%s)"", key, extension.getName());
			} else {
				return """";
			}
		}

		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((extension == null) ? 0 : extension.hashCode());
			result = prime * result + ((key == null) ? 0 : key.hashCode());
			return result;
		}

		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			ExtensionAttribute other = (ExtensionAttribute) obj;
			if (extension == null) {
				if (other.extension != null)
					return false;
			} else if (!extension.equals(other.extension))
				return false;
			if (key == null) {
				if (other.key != null)
					return false;
			} else if (!key.equals(other.key))
				return false;
			return true;
		}

	}

	public static final ExtensionAttribute NO_EXTENSION_ATTRIBUTE = new ExtensionAttribute(null, null);
	public static final ExtensionAttribute[] AVAILABLE_EVENT_EXTENSIONS_ATTRIBUTES;
	static {
		List<ExtensionAttribute> list = new ArrayList<>();
		list.add(NO_EXTENSION_ATTRIBUTE);
		addAttributesFromExtension(XConceptExtension.instance(), XConceptExtension.instance().getEventAttributes(),
				list);
		addAttributesFromExtension(XOrganizationalExtension.instance(),
				XOrganizationalExtension.instance().getEventAttributes(), list);
		addAttributesFromExtension(XTimeExtension.instance(), XTimeExtension.instance().getEventAttributes(), list);
		addAttributesFromExtension(XLifecycleExtension.instance(), XLifecycleExtension.instance().getEventAttributes(),
				list);
		addAttributesFromExtension(XCostExtension.instance(), XCostExtension.instance().getEventAttributes(), list);
		AVAILABLE_EVENT_EXTENSIONS_ATTRIBUTES = list.toArray(new ExtensionAttribute[list.size()]);
	}

	private static void addAttributesFromExtension(XExtension extension, Collection<XAttribute> attributes,
			List<ExtensionAttribute> list) {
		for (XAttribute attr : attributes) {
			list.add(new ExtensionAttribute(attr.getKey(), extension));
		}
	}

	public enum CSVErrorHandlingMode {
		ABORT_ON_ERROR(""Stop on Error""), OMIT_TRACE_ON_ERROR(""Omit Trace on Error""), OMIT_EVENT_ON_ERROR(
				""Omit Event on Error""), BEST_EFFORT(""Omit Attribute on Error"");

		private String desc;

		CSVErrorHandlingMode(String desc) {
			this.desc = desc;
		}

		@Override
		public String toString() {
			return desc;
		}
	}

	public enum CSVAttributeConversionMode {
		ADD_TO_COMPLETE(""Add attributes to complete event""), ADD_TO_BOTH(
				""Add attributes to both start and complete event"");

		private String desc;

		CSVAttributeConversionMode(String desc) {
			this.desc = desc;
		}

		@Override
		public String toString() {
			return desc;
		}
	}

	public enum CSVEmptyCellHandlingMode {
		DENSE(""Dense (Include empty cells)""), SPARSE(""Sparse (Exclude empty cells)"");

		private String desc;

		CSVEmptyCellHandlingMode(String desc) {
			this.desc = desc;
		}

		@Override
		public String toString() {
			return desc;
		}

	}

	public enum Datatype {
		LITERAL, DISCRETE, CONTINUOUS, TIME, BOOLEAN
	}

	public static final class CSVMapping {

		public static final String DEFAULT_DATE_PATTERN = """";
		public static final String DEFAULT_DISCRETE_PATTERN = """";
		public static final String DEFAULT_CONTINUOUS_PATTERN = """";
		public static final String DEFAULT_LITERAL_PATTERN = """";

		private Datatype dataType = Datatype.LITERAL;
		private String dataPattern = """";
		private DateFormat cachedDateFormat = null;
		private String traceAttributeName = """";
		private String eventAttributeName = """";
		private ExtensionAttribute eventExtensionAttribute = NO_EXTENSION_ATTRIBUTE;

		public Datatype getDataType() {
			return dataType;
		}

		public void setDataType(Datatype dataType) {
			this.dataType = dataType;
		}

		public String getPattern() {
			return dataPattern;
		}

		/**
		 * @return a format to parse the value, which might be NOT be thread safe
		 */
		public Format getFormat() {
			switch (getDataType()) {
				case BOOLEAN :
					return null;
				case CONTINUOUS :
					if (dataPattern.isEmpty()) {
						return null;
					} else {
						return new DecimalFormat(dataPattern);
					}
				case DISCRETE :
					if (dataPattern.isEmpty()) {
						return null;
					} else {
						DecimalFormat integerFormat = new DecimalFormat(dataPattern);
						integerFormat.setMaximumFractionDigits(0);
						integerFormat.setDecimalSeparatorAlwaysShown(false);
						integerFormat.setParseIntegerOnly(true);
						return integerFormat;
					}
				case LITERAL :
					if (dataPattern.isEmpty()) {
						return null;
					} else {
						return new MessageFormat(dataPattern);
					}
				case TIME :
					if (dataPattern.isEmpty()) {
						return null;
					} else {
						if (cachedDateFormat == null) {
							cachedDateFormat = new SimpleDateFormat(dataPattern);
						} 
						return cachedDateFormat; 
					}
			}
			throw new RuntimeException(""Unkown data type "" + getDataType());
		}

		public void setPattern(String dataPattern) {
			this.dataPattern = dataPattern;
			this.cachedDateFormat = null;
		}

		public String getTraceAttributeName() {
			return traceAttributeName;
		}

		public void setTraceAttributeName(String traceAttributeName) {
			this.traceAttributeName = traceAttributeName;
		}

		public String getEventAttributeName() {
			return eventAttributeName;
		}

		public void setEventAttributeName(String eventAttributeName) {
			this.eventAttributeName = eventAttributeName;
		}

		public void setEventExtensionAttribute(ExtensionAttribute extensionAttribute) {
			this.eventExtensionAttribute = extensionAttribute;
		}

		public ExtensionAttribute getEventExtensionAttribute() {
			return eventExtensionAttribute;
		}

	}

	// XFactory to use for conversion if XESConversionHandler is used
	private XFactory factory = XFactoryRegistry.instance().currentDefault();

	// Mapping to some of the XES standard extensions
	private List<String> caseColumns = Collections.emptyList();
	private List<String> eventNameColumns = Collections.emptyList();
	private String completionTimeColumn = null; // may be NULL
	private String startTimeColumn = null; // may be NULL

	// How to concatenate attributes built from multiple columns
	private String compositeAttributeSeparator = ""|"";

	// Data-type mapping
	private Map<String, CSVMapping> conversionMap = new HashMap<>();

	// Various ""expert"" configuration options	
	private CSVErrorHandlingMode errorHandlingMode = CSVErrorHandlingMode.OMIT_TRACE_ON_ERROR;
	private CSVEmptyCellHandlingMode emptyCellHandlingMode = CSVEmptyCellHandlingMode.SPARSE;
	private Set<String> treatAsEmptyValues = new HashSet<>();
	private boolean shouldAddStartEventAttributes = true;

	// Internal only
	private final CSVFile csvFile;
	private final CSVConfig csvConfig;

	public CSVConversionConfig(CSVFile csvFile, CSVConfig csvConfig) throws CSVConversionException {
		this.csvFile = csvFile;
		this.csvConfig = csvConfig;

		try {
			String[] headers = csvFile.readHeader(csvConfig);
			for (String columnHeader : headers) {
				CSVMapping mapping = new CSVMapping();
				if (!conversionMap.containsKey(columnHeader) && columnHeader != null) {
					// We do not support duplicate column names or empty column names!
					mapping.setEventAttributeName(columnHeader);
					conversionMap.put(columnHeader, mapping);
				} else {
					if (columnHeader == null) {
						throw new CSVConversionException(MessageFormat.format(
								""The CSV file contains two columns with an empty name! The CSV importer cannot handle such CSV files. Please rename the columns (i.e., the first line of the CSV file) such that columns have unique names."",
								columnHeader));
					} else {
						throw new CSVConversionException(MessageFormat.format(
								""The CSV file contains two columns with the same name: {0}! The CSV importer cannot handle such CSV files. Please rename the columns (i.e., the first line of the CSV file) such that columns have unique names."",
								columnHeader));
					}
				}
			}
		} catch (IOException e) {
			throw new CSVConversionException(""Could not read headers of CSV"", e);
		}

		// Standard settings for empty/NULL or N/A values
		treatAsEmptyValues.add("""");
		treatAsEmptyValues.add(""NULL"");
		treatAsEmptyValues.add(""null"");
		treatAsEmptyValues.add(""NOT_SET"");
		treatAsEmptyValues.add(""N/A"");
		treatAsEmptyValues.add(""n/a"");
	}

	public void autoDetect() throws CSVConversionException {
		try {
			String[] headers = csvFile.readHeader(csvConfig);
			//TODO put those auto detection methods in a new class
			autoDetectCaseColumn(headers);
			autoDetectEventColumn(headers);
			autoDetectCompletionTimeColumn(headers);
			autoDetectStartTimeColumn(headers);
			autoDetectDataTypes();
		} catch (IOException e) {
			throw new CSVConversionException(""Could not auto-detect column types."", e);
		}
	}

	private void autoDetectCaseColumn(String[] headers) {
		List<String> caseColumns = new ArrayList<>();
		for (int i = 0; i < headers.length; i++) {
			String header = headers[i];
			if (header != null && CASE_COLUMN_IDS.contains(header.toLowerCase(Locale.US).trim())) {
				caseColumns.add(header);
			}
		}
		setCaseColumns(caseColumns);
	}

	private void autoDetectEventColumn(String[] headers) {
		List<String> eventColumns = new ArrayList<>();
		for (int i = 0; i < headers.length; i++) {
			String header = headers[i];
			if (header != null && EVENT_COLUMN_IDS.contains(header.toLowerCase(Locale.US).trim())) {
				eventColumns.add(header);
			}
		}
		setEventNameColumns(eventColumns);
	}

	private void autoDetectCompletionTimeColumn(String[] headers) {
		for (int i = 0; i < headers.length; i++) {
			String header = headers[i];

			if (header != null && COMPLETION_TIME_COLUMN_IDS.contains(header.toLowerCase(Locale.US).trim())) {
				setCompletionTimeColumn(header);
				return;
			}
		}
	}

	private void autoDetectStartTimeColumn(String[] headers) {
		for (int i = 0; i < headers.length; i++) {
			String header = headers[i];
			if (header != null && START_TIME_COLUMN_IDS.contains(header.toLowerCase(Locale.US).trim())) {
				setStartTimeColumn(header);
				return;
			}
		}
	}

	public void autoDetectDataTypes() throws CSVConversionException {
		try (ICSVReader reader = csvFile.createReader(csvConfig)) {
			String[] header = reader.readNext();

			//TODO FM, can't this be done in a more streaming fashion?
			Map<String, List<String>> valuesPerColumn = new HashMap<>();
			for (String h : header) {
				if (h != null) {
					valuesPerColumn.put(h, new ArrayList<String>(DATA_TYPE_FORMAT_AUTO_DETECT_NUM_LINES));
				}
			}
			// now read some lines or so to guess the data type
			for (int i = 0; i < DATA_TYPE_FORMAT_AUTO_DETECT_NUM_LINES; i++) {
				String[] cells = reader.readNext();
				if (cells == null) {
					//TODO FM, shouldn't that be a return?
					break;
				}
				for (int j = 0; j < cells.length; j++) {
					if (header[j] != null) {
						List<String> values = valuesPerColumn.get(header[j]);
						values.add(cells[j]);
						valuesPerColumn.put(header[j], values);
					}
				}
			}
			// now we can guess the data type
			for (String column : header) {
				if (column != null) {
					List<String> values = valuesPerColumn.get(column);
					if (values != null) {
						DatatypeWithPattern inferred = inferDataType(values);
						getConversionMap().get(column).setDataType(inferred.getType());
						getConversionMap().get(column).setPattern(inferred.getPattern());
					}

				}
			}
		} catch (IOException e) {
			throw new CSVConversionException(""Could not auto-detect column types."", e);
		}
	}

	private static boolean isInteger(String s) {
		return isInteger(s, 10); // check for base-10 number (plus optional minus sign)
	}

	private static boolean isInteger(String s, int radix) {
		if (s.isEmpty())
			return false;
		for (int i = 0; i < s.length(); i++) {
			if (i == 0 && s.charAt(i) == '-') {
				if (s.length() == 1)
					return false;
				else
					continue;
			}
			if (Character.digit(s.charAt(i), radix) < 0)
				return false;
		}
		return true;
	}

	public interface DatatypeWithPattern {
		Datatype getType();

		String getPattern();
	}

	private DatatypeWithPattern inferDataType(List<String> values) {

		boolean allEmpty = true;
		for (String value : values) {
			if (value != null && !value.isEmpty()) {
				allEmpty = false;
				break;
			}
		}
		if (allEmpty)
			return new DatatypeWithPattern() {

				public Datatype getType() {
					return Datatype.LITERAL;
				}

				public String getPattern() {
					return """";
				}
			};

		boolean hasParsed = false;

		// check whether type is boolean
		boolean isBoolean = true;
		for (String value : values) {
			if (value == null || value.isEmpty() || treatAsEmptyValues.contains(value)) {
				continue;
			}
			hasParsed = true;
			//TODO what about mixed
			if (!(""J"".equalsIgnoreCase(value) || ""Y"".equalsIgnoreCase(value) || ""T"".equalsIgnoreCase(value)
					|| ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value) || ""N"".equalsIgnoreCase(value)
					|| ""F"".equalsIgnoreCase(value))) {
				isBoolean = false;
				break;
			}
		}
		if (hasParsed && isBoolean)
			return new DatatypeWithPattern() {

				public Datatype getType() {
					return Datatype.BOOLEAN;
				}

				public String getPattern() {
					return """";
				}
			};

		// check whether type is discrete
		hasParsed = false;
		boolean isDiscrete = true;
		for (String value : values) {
			if (value == null || value.isEmpty() || treatAsEmptyValues.contains(value)) {
				continue;
			}
			hasParsed = true;
			if (!isInteger(value)) {
				isDiscrete = false;
				break;
			}
		}
		if (hasParsed && isDiscrete)
			return new DatatypeWithPattern() {

				public Datatype getType() {
					return Datatype.DISCRETE;
				}

				public String getPattern() {
					return """";
				}
			};

		// check whether type is continuous
		final Pattern CONTINUOUS_PATTERN = Pattern
				.compile(""((-)?[0-9]*\\.[0-9]+)|((-)?[0-9]+(\\.[0-9]+)?(e|E)\\+[0-9]+)"");
		hasParsed = false;
		boolean isContinuous = true;
		for (String value : values) {
			if (value == null || value.isEmpty() || treatAsEmptyValues.contains(value)) {
				continue;
			}
			hasParsed = true;
			if (!CONTINUOUS_PATTERN.matcher(value).matches()) {
				isContinuous = false;
				break;
			}
		}
		if (hasParsed && isContinuous)
			return new DatatypeWithPattern() {

				public Datatype getType() {
					return Datatype.CONTINUOUS;
				}

				public String getPattern() {
					return """";
				}
			};

		// check whether type is date
		boolean isConsistentDateFormat = true;
		// Millisecond fix for Java SimpleDateFormat in case of a date like this 14:08:09.100000 
		// where the milliseconds would be treated as 100000ms instead of 100ms
		// Only matche when at the end of the string to avoid capturing year values when using the '.' as separator
		final Pattern INVALID_MS_PATTERN = Pattern.compile(""(\\.[0-9]{3})[0-9]*$""); 
		for (SimpleDateFormat formatter : StandardDateFormats.getStandardDateFormats()) {
			if (canParseAllValues(values, isConsistentDateFormat, INVALID_MS_PATTERN, formatter)) {
				final String pattern = formatter.toPattern();
				return new DatatypeWithPattern() {

					public Datatype getType() {
						return Datatype.TIME;
					}

					public String getPattern() {
						return pattern;
					}
				};
			}
		}

		return new DatatypeWithPattern() {

			public Datatype getType() {
				return Datatype.LITERAL;
			}

			public String getPattern() {
				return """";
			}
		};
	}

	private boolean canParseAllValues(List<String> values, boolean isConsistentDateFormat,
			final Pattern INVALID_MS_PATTERN, DateFormat formatter) {
		boolean hasParsed = false;
		for (String value : values) {
			if (value == null || value.isEmpty() || treatAsEmptyValues.contains(value))
				continue;

			// Millisecond fix for Java SimpleDateFormat
			String fixedValue = INVALID_MS_PATTERN.matcher(value).replaceFirst(""$1"");

			ParsePosition pos = new ParsePosition(0);
			pos.setIndex(0);
			Date date = formatter.parse(fixedValue, pos);

			hasParsed = true;

			// check whether date is not parsable, or date format for parsing is inconsistent
			if (date == null) {
				return false;
			}

		}
		return hasParsed;
	}

	public XFactory getFactory() {
		return factory;
	}

	public void setFactory(XFactory factory) {
		this.factory = factory;
	}

	public List<String> getCaseColumns() {
		return ImmutableList.copyOf(caseColumns);
	}

	public void setCaseColumns(List<String> caseColumns) {
		// Remove old mapping
		for (String caseColumn : this.caseColumns) {
			getConversionMap().get(caseColumn).setTraceAttributeName("""");
		}
		// Set new mapping
		for (String caseColumn : caseColumns) {
			if (caseColumn != null) {
				getConversionMap().get(caseColumn).setTraceAttributeName(""concept:name"");
				getConversionMap().get(caseColumn).setDataType(Datatype.LITERAL);	
			} else {
				throw new NullPointerException(""Tried to set a column with NULL identifier as case column!"");
			}
		}
		this.caseColumns = caseColumns;
	}

	public List<String> getEventNameColumns() {
		return ImmutableList.copyOf(eventNameColumns);
	}

	public void setEventNameColumns(List<String> eventNameColumns) {
		// Remove old mapping
		for (String eventColumn : this.eventNameColumns) {
			getConversionMap().get(eventColumn).setEventExtensionAttribute(NO_EXTENSION_ATTRIBUTE);
			getConversionMap().get(eventColumn).setEventAttributeName(eventColumn);
		}
		// Set new mapping
		for (String eventColumn : eventNameColumns) {
			if (eventColumn != null) {
				getConversionMap().get(eventColumn)
						.setEventExtensionAttribute(new ExtensionAttribute(""concept:name"", XConceptExtension.instance()));
				getConversionMap().get(eventColumn).setEventAttributeName(""concept:name"");
				getConversionMap().get(eventColumn).setDataType(Datatype.LITERAL);
			} else {
				throw new NullPointerException(""Tried to set a column with NULL identifier as event column!"");
			}
		}
		this.eventNameColumns = eventNameColumns;
	}

	public String getCompletionTimeColumn() {
		return completionTimeColumn;
	}

	private ExtensionAttribute previousCompletionTimeExtension;
	private Datatype previousCompletionTimeDataType;

	public void setCompletionTimeColumn(String completionTimeColumn) {
		// Reset mapping for old column		
		if (this.completionTimeColumn != null && !this.completionTimeColumn.isEmpty()) {
			getConversionMap().get(this.completionTimeColumn).setDataType(previousCompletionTimeDataType);
			getConversionMap().get(this.completionTimeColumn).setEventExtensionAttribute(previousCompletionTimeExtension);
			getConversionMap().get(this.completionTimeColumn).setEventAttributeName(this.completionTimeColumn);
		}

		if (completionTimeColumn != null && !completionTimeColumn.isEmpty()) {
			CSVMapping mapping = getConversionMap().get(completionTimeColumn);
			previousCompletionTimeDataType = mapping.getDataType();
			mapping.setDataType(Datatype.TIME);
			previousCompletionTimeExtension = mapping.getEventExtensionAttribute();
			mapping.setEventExtensionAttribute(new ExtensionAttribute(""time:timestamp"", XTimeExtension.instance()));
			mapping.setEventAttributeName(""time:timestamp"");
		}
		this.completionTimeColumn = completionTimeColumn;
	}

	public String getStartTimeColumn() {
		return startTimeColumn;
	}

	private ExtensionAttribute previousStartTimeExtension;
	private Datatype previousStartTimeDataType;

	public void setStartTimeColumn(String startTimeColumn) {
		// Reset mapping for old column
		if (this.startTimeColumn != null && !this.startTimeColumn.isEmpty()) {
			getConversionMap().get(this.startTimeColumn).setDataType(previousStartTimeDataType);
			getConversionMap().get(this.startTimeColumn).setEventExtensionAttribute(previousStartTimeExtension);
			getConversionMap().get(this.startTimeColumn).setEventAttributeName(this.startTimeColumn);
		}

		if (startTimeColumn != null && !startTimeColumn.isEmpty()) {
			CSVMapping mapping = getConversionMap().get(startTimeColumn);
			previousStartTimeDataType = mapping.getDataType();
			mapping.setDataType(Datatype.TIME);
			previousStartTimeExtension = mapping.getEventExtensionAttribute();
			mapping.setEventExtensionAttribute(new ExtensionAttribute(""time:timestamp"", XTimeExtension.instance()));
			mapping.setEventAttributeName(""time:timestamp"");
		}
		this.startTimeColumn = startTimeColumn;
	}

	public String getCompositeAttributeSeparator() {
		return compositeAttributeSeparator;
	}

	public void setCompositeAttributeSeparator(String compositeAttributeSeparator) {
		this.compositeAttributeSeparator = compositeAttributeSeparator;
	}

	public CSVErrorHandlingMode getErrorHandlingMode() {
		return errorHandlingMode;
	}

	public void setErrorHandlingMode(CSVErrorHandlingMode errorHandlingMode) {
		this.errorHandlingMode = errorHandlingMode;
	}

	public Map<String, CSVMapping> getConversionMap() {
		return conversionMap;
	}

	public Set<String> getTreatAsEmptyValues() {
		return treatAsEmptyValues;
	}

	public CSVEmptyCellHandlingMode getEmptyCellHandlingMode() {
		return emptyCellHandlingMode;
	}

	public void setEmptyCellHandlingMode(CSVEmptyCellHandlingMode emptyCellHandlingMode) {
		this.emptyCellHandlingMode = emptyCellHandlingMode;
	}

	public boolean isShouldAddStartEventAttributes() {
		return shouldAddStartEventAttributes;
	}

	public void setShouldAddStartEventAttributes(boolean shouldAddStartEventAttributes) {
		this.shouldAddStartEventAttributes = shouldAddStartEventAttributes;
	}

}"
CSVConversion.java,log-6.9.380,"package org.processmining.log.csvimport;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.text.DateFormat;
import java.text.MessageFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.Progress;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.CSVFileReferenceOpenCSVImpl;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVEmptyCellHandlingMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVErrorHandlingMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVMapping;
import org.processmining.log.csvimport.exception.CSVConversionConfigException;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.csvimport.exception.CSVSortException;
import org.processmining.log.csvimport.handler.CSVConversionHandler;
import org.processmining.log.csvimport.handler.XESConversionHandlerImpl;

import com.google.common.collect.ObjectArrays;
import com.google.common.collect.Ordering;
import com.google.common.primitives.Ints;
import com.ning.compress.lzf.LZFInputStream;

/**
 * Conversion from CSV to a structure like XES. Use
 * {@link #doConvertCSVToXES(ProgressListener, CSVFile, CSVConfig, CSVConversionConfig)}
 * to convert to XES, use
 * {@link #convertCSV(ProgressListener, CSVConfig, CSVConversionConfig, CSVFile, CSVConversionHandler)}
 * to use your own {@link CSVConversionHandler} for some other format.
 * <p>
 * Example usage:
 * <p>
 * 
 * <pre>
 * CSVFileReferenceUnivocityImpl csvFile = new CSVFileReferenceUnivocityImpl(getFile().toPath());
 * CSVConfig config = new CSVConfig(csvFile);
 * try (ICSVReader reader = csvFile.createReader(config)) {
 * 	CSVConversion conversion = new CSVConversion();
 * 	CSVConversionConfig conversionConfig = new CSVConversionConfig(csvFile, config);
 * 	conversionConfig.autoDetect();
 * 
 * 	conversionConfig.setCaseColumns(ImmutableList.of(&quot;case&quot;));
 * 	conversionConfig.setEventNameColumns(ImmutableList.of(&quot;event&quot;));
 * 	conversionConfig.setCompletionTimeColumn(&quot;time&quot;);
 * 	conversionConfig.setEmptyCellHandlingMode(CSVEmptyCellHandlingMode.SPARSE);
 * 	conversionConfig.setErrorHandlingMode(CSVErrorHandlingMode.ABORT_ON_ERROR);
 * 	Map&lt;String, CSVMapping&gt; conversionMap = conversionConfig.getConversionMap();
 * 	CSVMapping mapping = conversionMap.get(&quot;time&quot;);
 * 	mapping.setDataType(Datatype.TIME);
 * 	mapping.setPattern(&quot;yyyy/MM/dd&quot;);
 * 
 * 	ConversionResult&lt;XLog&gt; result = conversion.doConvertCSVToXES(new NoOpProgressListenerImpl(), csvFile, config,
 * 			conversionConfig);
 * 
 * 	XLog log = result.getResult();
 * }
 * </pre>
 * 
 * @author F. Mannhardt
 *
 */
public final class CSVConversion {

	private static final int PROGRESS_REPORT_WINDOW = 10000;

	public interface ConversionResult<R> {
		R getResult();

		boolean hasConversionErrors();

		String getConversionErrors();
	}

	public interface ProgressListener {
		Progress getProgress();

		void log(String message);
	}

	public static class NoOpProgressListenerImpl implements ProgressListener {

		public void log(String message) {
		}

		public Progress getProgress() {
			return new NoOpProgressImpl();
		}

	}

	public static class NoOpProgressImpl implements Progress {

		public void setValue(int value) {
		}

		public void setMinimum(int value) {
		}

		public void setMaximum(int value) {
		}

		public void setIndeterminate(boolean makeIndeterminate) {
		}

		public void setCaption(String message) {
		}

		public boolean isIndeterminate() {
			return false;
		}

		public boolean isCancelled() {
			return false;
		}

		public void inc() {
		}

		public int getValue() {
			return 0;
		}

		public int getMinimum() {
			return 0;
		}

		public int getMaximum() {
			return 0;
		}

		public String getCaption() {
			return """";
		}

		public void cancel() {
		}

	}

	/**
	 * Convert a {@link CSVFileReferenceOpenCSVImpl} into an {@link XLog} using
	 * the supplied configuration. Without progress information.
	 * 
	 * @param csvFile
	 * @param importConfig
	 * @param conversionConfig
	 * @return
	 * @throws CSVConversionException
	 * @throws CSVConversionConfigException
	 */
	public ConversionResult<XLog> doConvertCSVToXES(CSVFile csvFile, CSVConfig importConfig,
			CSVConversionConfig conversionConfig) throws CSVConversionException, CSVConversionConfigException {
		return doConvertCSVToXES(new NoOpProgressListenerImpl(), csvFile, importConfig, conversionConfig);
	}

	/**
	 * Convert a {@link CSVFileReferenceOpenCSVImpl} into an {@link XLog} using
	 * the supplied configuration.
	 * 
	 * @param progressListener
	 * @param csvFile
	 * @param importConfig
	 * @param conversionConfig
	 * @return
	 * @throws CSVConversionException
	 * @throws CSVConversionConfigException
	 */
	public ConversionResult<XLog> doConvertCSVToXES(final ProgressListener progressListener, CSVFile csvFile,
			CSVConfig importConfig, CSVConversionConfig conversionConfig)
			throws CSVConversionException, CSVConversionConfigException {
		return convertCSV(progressListener, importConfig, conversionConfig, csvFile,
				new XESConversionHandlerImpl(importConfig, conversionConfig));
	}

	/**
	 * Converts a {@link CSVFileReferenceOpenCSVImpl} into something determined
	 * by the supplied {@link CSVConversionHandler}. Use
	 * {@link #doConvertCSVToXES(ProgressListener, CSVFileReferenceOpenCSVImpl, CSVConfig, CSVConversionConfig)}
	 * in case you want to convert to an {@link XLog}.
	 * 
	 * @param progress
	 * @param importConfig
	 * @param conversionConfig
	 * @param csvFile
	 * @param conversionHandler
	 * @return
	 * @throws CSVConversionException
	 * @throws CSVConversionConfigException
	 */
	public <R> ConversionResult<R> convertCSV(ProgressListener progress, CSVConfig importConfig,
			CSVConversionConfig conversionConfig, CSVFile csvFile, final CSVConversionHandler<R> conversionHandler)
			throws CSVConversionException, CSVConversionConfigException {

		Progress p = progress.getProgress();

		p.setMinimum(0);
		p.setMaximum(1);
		p.setValue(0);
		p.setIndeterminate(true);

		long startCSVTime = System.currentTimeMillis();

		conversionHandler.startLog(csvFile);

		int[] caseColumnIndex = new int[conversionConfig.getCaseColumns().size()];
		int[] eventNameColumnIndex = new int[conversionConfig.getEventNameColumns().size()];
		int completionTimeColumnIndex = -1;
		int startTimeColumnIndex = -1;
		String[] header = null;

		final Map<String, Integer> headerMap = new HashMap<>();
		final Map<Integer, CSVMapping> columnMap = new HashMap<>();

		try {
			header = csvFile.readHeader(importConfig);
			for (int i = 0; i < header.length; i++) {
				String columnHeader = header[i];
				Integer oldIndex = headerMap.put(columnHeader, i);
				if (oldIndex != null) {
					throw new CSVConversionException(String.format(
							""Ambigous header in the CSV file: Two columns (%s, %s) have the same header %s. Please fix this in the CSV file!"",
							oldIndex, i, columnHeader));
				}
				CSVMapping columnMapping = conversionConfig.getConversionMap().get(columnHeader);
				columnMap.put(i, columnMapping);
			}

			for (int i = 0; i < conversionConfig.getCaseColumns().size(); i++) {
				caseColumnIndex[i] = headerMap.get(conversionConfig.getCaseColumns().get(i));
			}
			for (int i = 0; i < conversionConfig.getEventNameColumns().size(); i++) {
				eventNameColumnIndex[i] = headerMap.get(conversionConfig.getEventNameColumns().get(i));
			}
			if (conversionConfig.getCompletionTimeColumn() != null
					&& !conversionConfig.getCompletionTimeColumn().isEmpty()) {
				completionTimeColumnIndex = headerMap.get(conversionConfig.getCompletionTimeColumn());
			}
			if (conversionConfig.getStartTimeColumn() != null && !conversionConfig.getStartTimeColumn().isEmpty()) {
				startTimeColumnIndex = headerMap.get(conversionConfig.getStartTimeColumn());
			}
		} catch (IOException e) {
			throw new CSVConversionException(""Could not read first row of CSV file with header information"", e);
		}

		InputStream sortedCsvInputStream = null;
		File sortedFile = null;

		try {
			try {
				long startSortTime = System.currentTimeMillis();
				int maxMemory = (int) ((Runtime.getRuntime().maxMemory() * maxSortingMemory) / 1024 / 1024);
				progress.log(
						String.format(""Sorting CSV file (%.2f MB) by case and time using maximal %s MB of memory ..."",
								(getFileSizeInBytes(csvFile) / 1024 / 1024), maxMemory));
				Ordering<String[]> caseComparator = new StringBasedImportOrdering(caseColumnIndex);
				sortedFile = CSVSorter.sortCSV(csvFile, caseComparator, importConfig, maxMemory, header.length,
						progress);
				sortedCsvInputStream = new LZFInputStream(new FileInputStream(sortedFile));
				long endSortTime = System.currentTimeMillis();
				progress.log(
						String.format(""Finished sorting in %.2f seconds"", (endSortTime - startSortTime) / 1000.0d));
			} catch (IllegalArgumentException e) {
				throw new CSVSortException(""Could not sort CSV file"", e);
			} catch (IOException e) {
				throw new CSVSortException(""Could not sort CSV file"", e);
			}

			// The following code assumes that the file is sorted by cases and written to disk compressed with LZF
			progress.log(""Reading cases ..."");
			try (ICSVReader reader = csvFile.getCSV().createReader(sortedCsvInputStream, importConfig)) {

				int caseIndex = 0;
				int eventIndex = 0;
				int lineIndex = -1;
				String[] nextLine;
				String currentCaseId = null;

				while ((nextLine = reader.readNext()) != null && (caseIndex % 100 != 0 || !p.isCancelled())) {
					lineIndex++;

					final String newCaseID = readCompositeAttribute(caseColumnIndex, nextLine,
							conversionConfig.getCompositeAttributeSeparator());

					// Handle new traces
					if (!newCaseID.equals(currentCaseId)) {

						if (currentCaseId != null) {
							// Finished with current case
							conversionHandler.endTrace(currentCaseId);
						}

						// Update current case id to next case id
						currentCaseId = newCaseID;

						// Create new case
						conversionHandler.startTrace(currentCaseId);
						caseIndex++;

						if (caseIndex % PROGRESS_REPORT_WINDOW == 0) {
							progress.log(""Reading line "" + lineIndex + "", already "" + caseIndex + "" cases and ""
									+ eventIndex + "" events processed ..."");
						}

					}

					// Create new event

					// Read event name
					final String eventClass = readCompositeAttribute(eventNameColumnIndex, nextLine,
							conversionConfig.getCompositeAttributeSeparator());

					// Read time stamps
					Date completionTime = parseTime(conversionHandler, completionTimeColumnIndex, columnMap, lineIndex,
							nextLine);
					Date startTime = parseTime(conversionHandler, startTimeColumnIndex, columnMap, lineIndex, nextLine);

					conversionHandler.startEvent(eventClass, completionTime, startTime);

					for (int i = 0; i < nextLine.length; i++) {
						if (Ints.contains(eventNameColumnIndex, i) || Ints.contains(caseColumnIndex, i)
								|| i == completionTimeColumnIndex || i == startTimeColumnIndex) {
							// Is already mapped to a special column, do not include again
							continue;
						}

						final String name = header[i];
						final String value = nextLine[i];

						if (!(conversionConfig.getEmptyCellHandlingMode() == CSVEmptyCellHandlingMode.SPARSE
								&& (value == null || conversionConfig.getTreatAsEmptyValues().contains(value)
										|| value.isEmpty()))) {
							parseAttributes(progress, conversionConfig, conversionHandler, columnMap.get(i), lineIndex,
									i, name, nextLine);
						}
					}

					// Already sorted by time
					conversionHandler.endEvent();
					eventIndex++;
				}

				// Close last trace
				if (currentCaseId != null) { // at least one trace is present
					conversionHandler.endTrace(currentCaseId);	
				}				

			} catch (IOException e) {
				throw new CSVConversionException(""Error converting the CSV file to XES"", e);
			}
		} finally {
			if (sortedCsvInputStream != null) {
				try {
					sortedCsvInputStream.close();
				} catch (Exception e) {
					throw new CSVConversionException(""Error closing the CSV file"", e);
				}
			}
			if (sortedFile != null) {
				sortedFile.delete();
			}
		}
		commitFactoryIfNeeded(conversionConfig.getFactory());
		long endConvertTime = System.currentTimeMillis();
		progress.log(String.format(""Finished reading cases in %d seconds."", (endConvertTime - startCSVTime) / 1000));

		return new ConversionResult<R>() {

			public R getResult() {
				return conversionHandler.getResult();
			}

			public boolean hasConversionErrors() {
				return conversionHandler.hasConversionErrors();
			}

			public String getConversionErrors() {
				return conversionHandler.getConversionErrors();
			}
		};
	}

	/**
	 * Calls the XESLite commit method if available. Uses reflection to not
	 * introduce a dependency on XESLite.
	 * 
	 * @param factory
	 */
	private void commitFactoryIfNeeded(XFactory factory) {
		try {
			Method method = factory.getClass().getMethod(""commit"");
			if (method != null) {
				method.invoke(factory);
			}
		} catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException
				| InvocationTargetException e) {
		}
	}

	private <R> Date parseTime(final CSVConversionHandler<R> conversionHandler, int timeColumnIndex,
			final Map<Integer, CSVMapping> columnMap, int lineIndex, String[] nextLine) throws CSVConversionException {
		if (timeColumnIndex == -1) {
			return null;
		} else {
			String timeValue = nextLine[timeColumnIndex];
			try {
				return parseDate((DateFormat) columnMap.get(timeColumnIndex).getFormat(), timeValue);
			} catch (ParseException e) {
				conversionHandler.errorDetected(lineIndex, timeColumnIndex,
						columnMap.get(timeColumnIndex).getEventAttributeName(), timeValue, e);
				return null;
			}
		}
	}

	private static double getFileSizeInBytes(CSVFile csvFile) throws IOException {
		return Files.size(csvFile.getFile());
	}

	private <R> void parseAttributes(ProgressListener progress, CSVConversionConfig conversionConfig,
			CSVConversionHandler<R> conversionHandler, CSVMapping csvMapping, int lineIndex, int columnIndex,
			String name, String[] line) throws CSVConversionException {

		String value = line[columnIndex];
		if (name == null) // TODO: Nicer would be to create names like ""unknown-1"", ""unknown-2"", etc. instead of skipping the attribute
			return;
		if (csvMapping.getDataType() == null) {
			conversionHandler.startAttribute(name, value);
		} else {
			try {
				switch (csvMapping.getDataType()) {
					case BOOLEAN :
						boolean boolVal;
						if (""true"".equalsIgnoreCase(value) || ""J"".equalsIgnoreCase(value) || ""Y"".equalsIgnoreCase(value)
								|| ""T"".equalsIgnoreCase(value) || ""1"".equals(value)) {
							boolVal = true;
						} else if (""false"".equalsIgnoreCase(value) || ""N"".equalsIgnoreCase(value)
								|| ""F"".equalsIgnoreCase(value) || ""0"".equals(value)) {
							boolVal = false;
						} else {
							throw new ParseException(value + "" cannot be converted to a boolean"", 0);
						}
						conversionHandler.startAttribute(name, boolVal);
						break;
					case CONTINUOUS :
						if (csvMapping.getFormat() != null) {
							conversionHandler.startAttribute(name, (Double) csvMapping.getFormat().parseObject(value));
						} else {
							conversionHandler.startAttribute(name, Double.parseDouble(value));
						}
						break;
					case DISCRETE :
						if (csvMapping.getFormat() != null) {
							conversionHandler.startAttribute(name, (Integer) csvMapping.getFormat().parseObject(value));
						} else {
							conversionHandler.startAttribute(name, Long.parseLong(value));
						}
						break;
					case TIME :
						conversionHandler.startAttribute(name, parseDate((DateFormat) csvMapping.getFormat(), value));
						break;
					case LITERAL :
					default :
						if (csvMapping.getFormat() != null) {
							value = ((MessageFormat) csvMapping.getFormat())
									.format(ObjectArrays.concat(value, line), new StringBuffer(), null).toString();
						}
						conversionHandler.startAttribute(name, value);
						break;
				}
			} catch (NumberFormatException e) {
				conversionHandler.errorDetected(lineIndex, columnIndex, name, value, e);
				if (conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.BEST_EFFORT) {
					conversionHandler.startAttribute(name, value);
				}
			} catch (ParseException e) {
				conversionHandler.errorDetected(lineIndex, columnIndex, name, value, e);
				if (conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.BEST_EFFORT) {
					conversionHandler.startAttribute(name, value);
				}
			}
		}
		conversionHandler.endAttribute();
	}

	/**
	 * Concatenates multiple composite attributes to a String representation.
	 * 
	 * @param columnIndex
	 * @param line
	 * @param compositeSeparator
	 * @return the composite attributes concatenated or an empty String in case
	 *         no columns are selected
	 */
	private static String readCompositeAttribute(int[] columnIndex, String[] line, String compositeSeparator) {
		if (columnIndex.length == 0) {
			return """";
		}
		int size = 0;
		for (int index : columnIndex) {
			String cell = line[index];
			size += (cell == null ? 0 : cell.length());
		}
		StringBuilder sb = new StringBuilder(size + columnIndex.length);
		for (int index : columnIndex) {
			String cell = line[index];
			if (cell != null) {
				sb.append(cell);
			}
			sb.append(compositeSeparator);
		}
		return sb.substring(0, sb.length() - 1);
	}

	private static Pattern INVALID_MS_PATTERN = Pattern.compile(""(:[0-5][0-9]\\.[0-9]{3})[0-9]*$"");
	private double maxSortingMemory = 0.30;

	private static Date parseDate(DateFormat customDateFormat, String value) throws ParseException {

		if (value == null) {
			throw new ParseException(""Could not parse NULL timestamp!"", 0);
		}

		if (customDateFormat != null) {
			ParsePosition pos = new ParsePosition(0);
			Date date = customDateFormat.parse(value, pos);
			
			// Fix if there are more than 3 digits for ms for example 44.00.540000, do not return and
			// ensure string is formatted to 540 ms instead of 540000 ms
			if (date != null && !INVALID_MS_PATTERN.matcher(value).find()) {
				return date;
			} else {
				String fixedValue = INVALID_MS_PATTERN.matcher(value).replaceFirst(""$1"");
				pos.setIndex(0);
				date = customDateFormat.parse(fixedValue, pos);
				if (date != null) {
					return date;
				} else {
					String pattern = ""unkown"";
					if (customDateFormat instanceof SimpleDateFormat) {
						pattern = ((SimpleDateFormat) customDateFormat).toPattern();
					}
					throw new ParseException(""Could not parse "" + value + "" using pattern '"" + pattern + ""'"",
							pos.getErrorIndex());
				}
			}
		}

		throw new ParseException(""Could not parse "" + value, -1);
	}

	public double getMaxSortingMemory() {
		return maxSortingMemory;
	}

	public void setMaxSortingMemory(double maxSortingMemory) {
		this.maxSortingMemory = maxSortingMemory;
	}

}
"
CSVConversionCLI.java,log-6.9.380,"package org.processmining.log.csvimport;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.OptionBuilder;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.PosixParser;
import org.deckfour.xes.model.XLog;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.CSVFileReferenceUnivocityImpl;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.CSVConversion.ConversionResult;
import org.processmining.log.csvimport.CSVConversion.ProgressListener;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.exception.CSVConversionConfigException;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.utils.XUtils;

import com.google.common.collect.ImmutableList;

/**
 * CLI interface to the ProM XES conversion
 * 
 * @author F. Mannhardt
 *
 */
public final class CSVConversionCLI {

	private static final class ProgressListenerPrintStreamImpl extends CSVConversion.NoOpProgressListenerImpl {

		private final PrintStream out;

		public ProgressListenerPrintStreamImpl(PrintStream out) {
			this.out = out;
		}

		public void log(String message) {
			out.println(message);
		}

	}

	private static final Options OPTIONS = new Options();

	private static final Option HELP = OptionBuilder.withDescription(""help"").create('h');
	private static final Option XES = OptionBuilder.hasArg().withArgName(""filename"").create(""xes"");
	private static final Option TRACE = OptionBuilder.hasArg().withArgName(""traceColumn"").create(""trace"");
	private static final Option EVENT = OptionBuilder.hasArg().withArgName(""eventColumn"").create(""event"");
	private static final Option START = OptionBuilder.hasArg().withArgName(""startColumn"").create(""start"");
	private static final Option COMPLETE = OptionBuilder.hasArg().withArgName(""completionColumn"").create(""complete"");

	static {
		OPTIONS.addOption(HELP);
		OPTIONS.addOption(XES);
		OPTIONS.addOption(TRACE);
		OPTIONS.addOption(EVENT);
		OPTIONS.addOption(START);
		OPTIONS.addOption(COMPLETE);
	}

	public static void main(String[] args) {

		try {
			CommandLineParser parser = new PosixParser();
			CommandLine commandLine = parser.parse(OPTIONS, args);

			if (commandLine.hasOption(HELP.getOpt())) {
				printUsage();
				return;
			}

			if (commandLine.getArgs().length != 1) {
				printUsage();
				System.err.println(""Missing filename of the CSV file!"");
				return;
			}

			File logFile = new File(commandLine.getArgs()[0]);

			try {
				XLog log = parseCSV(logFile, commandLine);

				if (commandLine.hasOption(XES.getOpt())) {
					XUtils.saveLogGzip(log, new File(commandLine.getOptionValue(XES.getOpt())));
				} else {
					XUtils.saveLogGzip(log, new File(logFile.getAbsolutePath() + "".xes.gz""));
				}
			} catch (CSVConversionException | IOException e) {
				if (e.getMessage() != null) {
					System.err.println(e.getMessage());
				}
				e.printStackTrace();
			}

			System.out.println(""Log converted successfully!"");

		} catch (ParseException e) {
			printUsage();
			if (e.getMessage() != null) {
				System.err.println(e.getMessage());
			}
		}
		
		System.exit(0);

	}

	private static XLog parseCSV(File inputFile, CommandLine commandLine) throws CSVConversionException, CSVConversionConfigException {
		CSVConversion conversion = new CSVConversion();
		CSVFile csvFile = new CSVFileReferenceUnivocityImpl(inputFile.toPath());
		CSVConfig importConfig = new CSVConfig(csvFile);
		CSVConversionConfig conversionConfig = new CSVConversionConfig(csvFile, importConfig);
		conversionConfig.autoDetect();

		if (commandLine.hasOption(TRACE.getOpt())) {
			conversionConfig.setCaseColumns(ImmutableList.of(commandLine.getOptionValue(TRACE.getOpt())));
		}
		
		if (commandLine.hasOption(EVENT.getOpt())) {
			conversionConfig.setEventNameColumns(ImmutableList.of(commandLine.getOptionValue(EVENT.getOpt())));
		}
		
		if (commandLine.hasOption(START.getOpt())) {
			conversionConfig.setStartTimeColumn(commandLine.getOptionValue(START.getOpt()));
		}
		
		if (commandLine.hasOption(COMPLETE.getOpt())) {
			conversionConfig.setCompletionTimeColumn(commandLine.getOptionValue(COMPLETE.getOpt()));
		}
		
		ProgressListener cmdLineProgressListener = new ProgressListenerPrintStreamImpl(System.out);
		ConversionResult<XLog> result = conversion.doConvertCSVToXES(cmdLineProgressListener, csvFile, importConfig,
				conversionConfig);
		return result.getResult();
	}

	private static void printUsage() {
		HelpFormatter helpFormatter = new HelpFormatter();
		helpFormatter.printHelp(""mpe [CSVFILE]"", OPTIONS, true);
		return;
	}

}"
CSVConversionPlugin.java,log-6.9.380,"package org.processmining.log.csvimport;

import java.io.IOException;

import javax.swing.JOptionPane;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.CSVConversion.ConversionResult;
import org.processmining.log.csvimport.CSVConversion.ProgressListener;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.exception.CSVConversionConfigException;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.csvimport.handler.XESConversionHandlerImpl;
import org.processmining.log.csvimport.ui.ConversionConfigUI;
import org.processmining.log.csvimport.ui.ExpertConfigUI;
import org.processmining.log.csvimport.ui.ImportConfigUI;

import com.google.common.base.Throwables;

/**
 * CSV to XES XLog conversion plug-in
 * 
 * @author F. Mannhardt
 * 
 */
public final class CSVConversionPlugin {

	@Plugin(name = ""Convert CSV to XES"", level = PluginLevel.PeerReviewed, parameterLabels = { ""CSV"" }, returnLabels = {
			""XES Event Log"" }, // 
			returnTypes = { XLog.class }, userAccessible = true, mostSignificantResult = 1, // 
			keywords = { ""CSV"", ""OpenXES"", ""Conversion"",
					""Import"" }, help = ""Converts the CSV file to a OpenXES XLog object."")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = "" F. Mannhardt, N. Tax, D.M.M. Schunselaar"", // 
			email = ""f.mannhardt@tue.nl, n.tax@tue.nl, d.m.m.schunselaar@vu.nl"", pack = ""Log"")
	public XLog convertCSVToXES(final UIPluginContext context, CSVFile csvFile) {

		InteractionResult result = InteractionResult.CONTINUE;

		try {
			CSVConfig importConfig = new CSVConfig(csvFile);
			CSVConversionConfig csvConversionConfig = null;

			int i = 0;
			wizardLoop: while (result != InteractionResult.FINISHED) {
				switch (i) {
					case 0 :
						result = queryImportConfig(context, csvFile, importConfig);
						try {
							csvConversionConfig = new CSVConversionConfig(csvFile, importConfig);
							csvConversionConfig.autoDetect();
						} catch (CSVConversionException e) {								
							// Due to the strange wizard framework, we cannot cancel this dialog. So show again. The only way to cancel is through the user.
							if (result != InteractionResult.CANCEL) {
								ProMUIHelper.showErrorMessage(context, e.getMessage(), ""CSV Conversion Failed"");
								continue wizardLoop;	
							}
						}
						break;
					case 1 :
						result = queryConversionConfig(context, csvFile, importConfig, csvConversionConfig);
						if (result == InteractionResult.NEXT || result == InteractionResult.CONTINUE) {
							boolean reconfigure = queryMissingConfiguration(context, csvConversionConfig);
							if (reconfigure) {
								// Show same dialog again
								continue wizardLoop;
							}
						}
						break;
					case 2 :
						result = queryExpertConfig(context, csvFile, importConfig, csvConversionConfig);
						break;
				}
				if (result == InteractionResult.NEXT || result == InteractionResult.CONTINUE) {
					i++;
				} else if (result == InteractionResult.PREV) {
					i--;
				} else if (result == InteractionResult.CANCEL) {
					return cancel(context);
				}
			}

			CSVConversion csvConversion = new CSVConversion();
			ConversionResult<XLog> conversionResult = doConvertCSVToXes(context, csvFile, importConfig,
					csvConversionConfig, csvConversion);
			if (conversionResult.hasConversionErrors()) {
				ProMUIHelper.showWarningMessage(context, conversionResult.getConversionErrors(),
						""Warning: Some issues have been detected during conversion"");
			}
			return conversionResult.getResult();
		} catch (CSVConversionException e) {
			Throwable rootCause = Throwables.getRootCause(e);
			String errorMessage;
			if (rootCause != null) {
				errorMessage = rootCause.getMessage();
			} else {
				errorMessage = e.toString();
			}
			String stackTrace = Throwables.getStackTraceAsString(e);
			ProMUIHelper.showErrorMessage(context, errorMessage + ""\n\nDebug information:\n"" + stackTrace,
					""CSV Conversion Failed"");
			return cancel(context);
		}

	}

	private boolean queryMissingConfiguration(final UIPluginContext context, CSVConversionConfig csvConversionConfig) {
		boolean noCase = csvConversionConfig.getCaseColumns().isEmpty();
		boolean noEvents = csvConversionConfig.getEventNameColumns().isEmpty();
		Object[] options = { ""Continue"", ""Reconfigure"" };
		String message;
		String title;
		if (noCase) {
			message = ""<HTML>You did not select a column containing the case identifier. This will result in an event log with a single trace.<BR/> ""
					+ ""Do you want to continue without case identifier or reconfigure the conversion?</HTML>"";
			title = ""Missing event column"";
		} else if (noEvents) {
			message = ""<HTML>You did not select a column containing the event name. This will result in an event log with unamed events.<BR/> ""
					+ ""Do you want to continue without event name or reconfigure the conversion?</HTML>"";
			title = ""Missing event column"";
		} else if (noEvents && noCase) {
			message = ""You did not select columns containing the case identifier and event name. This will result in an event log with a single trace and unnamed events. ""
					+ ""Do you want to continue or reconfigure the conversion?"";
			title = ""Missing case and event columns"";
		} else {
			return false;
		}
		int warningResult = JOptionPane.showOptionDialog(context.getGlobalContext().getUI(), message, title,
				JOptionPane.PLAIN_MESSAGE, JOptionPane.WARNING_MESSAGE, null, options, options[0]);
		return warningResult == 1; // reconfigure
	}

	private XLog cancel(final UIPluginContext context) {
		context.getFutureResult(0).cancel(false);
		return null;
	}

	public ConversionResult<XLog> doConvertCSVToXes(final PluginContext context, CSVFile csvFile,
			CSVConfig importConfig, CSVConversionConfig conversionConfig, CSVConversion csvConversion)
			throws CSVConversionConfigException, CSVConversionException {

		ProgressListener progressListener = new ProgressListener() {

			public Progress getProgress() {
				return context.getProgress();
			}

			public void log(String message) {
				context.log(message);

			}
		};

		XESConversionHandlerImpl xesHandler = new XESConversionHandlerImpl(importConfig, conversionConfig);
		final ConversionResult<XLog> conversionResult = csvConversion.convertCSV(progressListener, importConfig,
				conversionConfig, csvFile, xesHandler);
		final XLog convertedLog = conversionResult.getResult();

		if (xesHandler.hasConversionErrors()) {
			context.log(xesHandler.getConversionErrors(), MessageLevel.WARNING);
		}

		return new ConversionResult<XLog>() {

			public boolean hasConversionErrors() {
				return conversionResult.hasConversionErrors();
			}

			public XLog getResult() {
				return convertedLog;
			}

			public String getConversionErrors() {
				return conversionResult.getConversionErrors();
			}
		};

	}

	public static InteractionResult queryExpertConfig(UIPluginContext context, CSVFile csv, CSVConfig importConfig,
			CSVConversionConfig converionConfig) {
		ExpertConfigUI expertConfigUI = new ExpertConfigUI(csv, importConfig, converionConfig);
		return context.showWizard(""Configure Additional Conversion Settings"", false, true, expertConfigUI);
	}

	public static InteractionResult queryImportConfig(UIPluginContext context, CSVFile csv, CSVConfig importConfig) {
		ImportConfigUI importConfigUI = new ImportConfigUI(csv, importConfig);
		return context.showWizard(""Configure CSV Parser Settings"", true, false, importConfigUI);
	}

	public static InteractionResult queryConversionConfig(UIPluginContext context, CSVFile csv, CSVConfig importConfig,
			CSVConversionConfig conversionConfig) throws CSVConversionException {
		try (ConversionConfigUI conversionConfigUI = new ConversionConfigUI(csv, importConfig, conversionConfig)) {
			return context.showWizard(""Configure Conversion from CSV to XES"", false, false, conversionConfigUI);
		} catch (IOException e) {
			throw new CSVConversionConfigException(""Could not query conversion config."", e);
		}
	}

}
"
CSVImportPlugin.java,log-6.9.380,"package org.processmining.log.csvimport;

import java.io.InputStream;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.CSVFileReferenceOpenCSVImpl;

/**
 * Converts a {@link CSVFile} to {@link XLog}.
 * 
 * @author F. Mannhardt
 *
 */
// Old OpenCSV parser
//@Plugin(name = ""Import a CSV file and convert it to XES"", parameterLabels = { ""Filename"" }, returnLabels = { ""Imported CSV File"" }, returnTypes = { CSVFile.class })
//@UIImportPlugin(description = ""CSV File (XES Conversion with Log package)"", extensions = { ""csv"", ""zip"", ""csv.gz"", ""txt"" })
@Deprecated
final class CSVImportPlugin extends AbstractImportPlugin {

	@Override
	protected CSVFile importFromStream(final PluginContext context, final InputStream input, final String filename,
			final long fileSizeInBytes) throws Exception {
		context.getFutureResult(0).setLabel(""Imported CSV: ""+filename);
		return new CSVFileReferenceOpenCSVImpl(getFile().toPath(), filename, fileSizeInBytes);
	}

}
"
CSVImportPluginUnivocity.java,log-6.9.380,"package org.processmining.log.csvimport;

import java.io.InputStream;

import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.CSVFileReferenceUnivocityImpl;

/**
 * Converts a {@link CSVFile} to {@link XLog}.
 * 
 * @author N. Tax
 *
 */
@Plugin(name = ""Import a CSV file and convert it to XES"", level= PluginLevel.PeerReviewed, parameterLabels = { ""Filename"" }, returnLabels = { ""Imported CSV File"" }, returnTypes = { CSVFile.class })
@UIImportPlugin(description = ""CSV File (XES Conversion with Log package)"", extensions = { ""csv"", ""zip"", ""csv.gz"", ""txt"", ""rpt"" })
public final class CSVImportPluginUnivocity extends AbstractImportPlugin {

	@Override
	protected CSVFile importFromStream(final PluginContext context, final InputStream input, final String filename,
			final long fileSizeInBytes) throws Exception {
		context.getFutureResult(0).setLabel(""Imported CSV: ""+filename);
		return new CSVFileReferenceUnivocityImpl(getFile().toPath());
	}

}
"
CSVSorter.java,log-6.9.380,"package org.processmining.log.csvimport;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.text.MessageFormat;
import java.util.Comparator;
import java.util.Iterator;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.ICSVWriter;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.CSVConversion.ProgressListener;
import org.processmining.log.csvimport.exception.CSVSortException;

import com.fasterxml.sort.DataReader;
import com.fasterxml.sort.DataReaderFactory;
import com.fasterxml.sort.DataWriter;
import com.fasterxml.sort.DataWriterFactory;
import com.fasterxml.sort.IteratingSorter;
import com.fasterxml.sort.SortConfig;
import com.fasterxml.sort.SortingState.Phase;
import com.fasterxml.sort.TempFileProvider;
import com.ning.compress.lzf.LZFInputStream;
import com.ning.compress.lzf.parallel.PLZFOutputStream;

/**
 * Sorts an {@link CSVFile}
 * 
 * @author F. Mannhardt
 * 
 */
final class CSVSorter {

	private static final class UncompressedCSVReaderWithoutHeader extends DataReader<String[]> {

		private static final int MAX_COLUMNS_FOR_ERROR_REPORTING = 32;
		private static final int MAX_FIELD_LENGTH_FOR_ERROR_REPORTING = 64;

		private final ICSVReader reader;
		private final int numColumns;
		private int currentRow = 1;

		private UncompressedCSVReaderWithoutHeader(CSVFile csvFile, CSVConfig importConfig, int numColumns)
				throws IOException {
			this.numColumns = numColumns;
			this.reader = csvFile.createReader(importConfig);
			// Skip header line
			this.reader.readNext();
		}

		public void close() throws IOException {
			reader.close();
		}

		public int estimateSizeInBytes(String[] val) {
			return estimateSize(val);
		}

		public String[] readNext() throws IOException {
			String[] val = reader.readNext();
			if (val != null && val.length != numColumns) {
				String offendingLine = safeToString(val);
				throw new IOException(
						MessageFormat
								.format(""The number of fields in rows of the CSV file is inconsistent. There should be {0} fields in each row according to the header, but there was a row with {1} fields in the CSV file! Row {2} is invalid: {3}"",
										numColumns, val.length, currentRow, offendingLine));
			}
			currentRow++;
			return val;
		}

		private String safeToString(String[] valueArray) {
			if (valueArray == null) {
				return ""NULL"";
			} else if (valueArray.length == 0) {
				return ""[]"";
			} else {
				StringBuilder sb = new StringBuilder();
				sb.append('[');
				for (int i = 0; i < valueArray.length; i++) {
					String value = valueArray[i];
					if (value != null) {
						if (value.length() < MAX_FIELD_LENGTH_FOR_ERROR_REPORTING) {
							sb.append(value);
						} else {
							sb.append(value.substring(0, MAX_FIELD_LENGTH_FOR_ERROR_REPORTING - 1));
						}
						if (i > MAX_COLUMNS_FOR_ERROR_REPORTING) {
							return sb.append(String.format(""[... omitted %s further columns]"", valueArray.length - i))
									.toString();
						}
						if (i < valueArray.length - 1) {
							sb.append("", "");
						}
					}
				}
				return sb.append(']').toString();
			}
		}
	}

	private static final class CompressedCSVDataWriterFactory extends DataWriterFactory<String[]> {

		private final CSVConfig importConfig;
		private final CSVFile csvFile;

		private CompressedCSVDataWriterFactory(CSVFile csvFile, CSVConfig importConfig) {
			this.csvFile = csvFile;
			this.importConfig = importConfig;
		}

		public DataWriter<String[]> constructWriter(OutputStream os) throws IOException {
			final ICSVWriter writer = csvFile.getCSV().createWriter(new PLZFOutputStream(os), importConfig);
			// Write Header
			return new DataWriter<String[]>() {

				public void close() throws IOException {
					writer.close(); // catch IllegalStateException
				}

				public void writeEntry(String[] val) throws IOException {
					writer.writeNext(val);
				}
			};
		}
	}

	private static final class CompressedCSVDataReaderFactory extends DataReaderFactory<String[]> {

		private final CSVConfig importConfig;
		private final CSVFile csvFile;

		private CompressedCSVDataReaderFactory(CSVFile csvFile, CSVConfig importConfig) {
			this.csvFile = csvFile;
			this.importConfig = importConfig;
		}

		public DataReader<String[]> constructReader(InputStream is) throws IOException {
			final ICSVReader reader = csvFile.getCSV().createReader(new LZFInputStream(is), importConfig);
			return new DataReader<String[]>() {

				public void close() throws IOException {
					reader.close();
				}

				public int estimateSizeInBytes(String[] item) {
					return estimateSize(item);
				}

				public String[] readNext() throws IOException {
					return reader.readNext();
				}
			};
		}
	}

	private CSVSorter() {
	}

	/**
	 * Sorts an {@link CSVFile} using only a configurable, limited amount of
	 * memory.
	 * 
	 * @param csvFile
	 * @param rowComparator
	 * @param importConfig
	 * @param maxMemory
	 * @param numOfColumnsInCSV
	 * @param progress
	 * @return a {@link File} containing the sorted CSV
	 * @throws CSVSortException
	 */
	public static File sortCSV(final CSVFile csvFile, final Comparator<String[]> rowComparator,
			final CSVConfig importConfig, final int maxMemory, final int numOfColumnsInCSV,
			final ProgressListener progress) throws CSVSortException {

		// Create Sorter
		final CompressedCSVDataReaderFactory dataReaderFactory = new CompressedCSVDataReaderFactory(csvFile,
				importConfig);
		final CompressedCSVDataWriterFactory dataWriterFactory = new CompressedCSVDataWriterFactory(csvFile,
				importConfig);
		final IteratingSorter<String[]> sorter = new IteratingSorter<>(new SortConfig().withMaxMemoryUsage(
				maxMemory * 1024l * 1024l).withTempFileProvider(new TempFileProvider() {

			public File provide() throws IOException {
				return Files.createTempFile(csvFile.getFilename() + ""-merge-sort"", "".lzf"").toFile();
			}
		}), dataReaderFactory, dataWriterFactory, rowComparator);

		ExecutorService executorService = Executors.newSingleThreadExecutor();
		Future<File> future = executorService.submit(new Callable<File>() {

			public File call() throws Exception {

				// Read uncompressed CSV
				DataReader<String[]> inputDataReader = new UncompressedCSVReaderWithoutHeader(csvFile, importConfig,
						numOfColumnsInCSV);
				try {
					Iterator<String[]> result = sorter.sort(inputDataReader);

					// Write sorted result to compressed file
					if (result != null) {
						File sortedCsvFile = Files.createTempFile(csvFile.getFilename() + ""-sorted"", "".lzf"").toFile();
						DataWriter<String[]> dataWriter = dataWriterFactory.constructWriter(new FileOutputStream(
								sortedCsvFile));
						try {
							while (result.hasNext()) {
								dataWriter.writeEntry(result.next());
							}
						} finally {
							try {
								dataWriter.close();
							} catch (IllegalStateException e) {
								// already closed - ignore here to propagate the real exception
							}
						}
						return sortedCsvFile;
					} else {
						throw new CSVSortException(""Could not sort file! Unkown error while sorting."");
					}

				} finally {
					sorter.close();
				}

			}
		});

		try {
			executorService.shutdown();
			int sortRound = -1;
			int preSortFiles = -1;
			while (!executorService.awaitTermination(100, TimeUnit.MILLISECONDS)) {
				if (progress.getProgress().isCancelled()) {
					progress.log(""Cancelling sorting, this might take a while ..."");
					sorter.cancel(new RuntimeException(""Cancelled""));
					throw new CSVSortException(""User cancelled sorting"");
				}
				if (sorter.getPhase() == Phase.PRE_SORTING) {
					if (sorter.getSortRound() != sortRound) {
						sortRound = sorter.getSortRound();
						progress.log(MessageFormat.format(""Pre-sorting finished segment {0} in memory ..."",
								sortRound + 1));
					}
					if (sorter.getNumberOfPreSortFiles() != preSortFiles) {
						preSortFiles = sorter.getNumberOfPreSortFiles();
						progress.log(MessageFormat.format(""Pre-sorting finished segment {0} ..."", preSortFiles + 1));
					}
				} else if (sorter.getPhase() == Phase.SORTING) {
					if (sorter.getSortRound() != sortRound) {
						sortRound = sorter.getSortRound();
						progress.log(MessageFormat.format(""Sorting finished round {0}/{1} ..."", sortRound + 1,
								sorter.getNumberOfSortRounds() + 1));
					}
				}
			}
			return future.get();
		} catch (InterruptedException e) {
			progress.log(""Cancelling sorting, this might take a while ..."");
			sorter.cancel();
			throw new CSVSortException(""Cancelled sorting"", e);
		} catch (ExecutionException e) {
			throw new CSVSortException(""Could not sort file."", e);
		}
	}

	private static int estimateSize(String[] item) {
		int size = 8 * ((item.length * 4 + 12) / 8);
		for (String s : item) {
			if (s != null) {
				size += 8 * ((((s.length()) * 4) + 45) / 8);
			}
		}
		return size;
	}

}
"
CSVConversionConfigException.java,log-6.9.380,"package org.processmining.log.csvimport.exception;


/**
 * @author F. Mannhardt
 *
 */
public class CSVConversionConfigException extends CSVConversionException {

	private static final long serialVersionUID = 4329858720296484283L;

	public CSVConversionConfigException() {
	}

	public CSVConversionConfigException(String message) {
		super(message);
	}

	public CSVConversionConfigException(Throwable cause) {
		super(cause);
	}

	public CSVConversionConfigException(String message, Throwable cause) {
		super(message, cause);
	}

	public CSVConversionConfigException(String message, Throwable cause, boolean enableSuppression,
			boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
	}

}
"
CSVConversionException.java,log-6.9.380,"package org.processmining.log.csvimport.exception;


/**
 * @author F. Mannhardt
 *
 */
public class CSVConversionException extends Exception {

	private static final long serialVersionUID = -4532347650248107292L;

	public CSVConversionException() {
		super();
	}

	public CSVConversionException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
	}

	public CSVConversionException(String message, Throwable cause) {
		super(message, cause);
	}

	public CSVConversionException(String message) {
		super(message);
	}

	public CSVConversionException(Throwable cause) {
		super(cause);
	}
	

}
"
CSVSortException.java,log-6.9.380,"package org.processmining.log.csvimport.exception;

/**
 * @author F. Mannhardt
 *
 */
public class CSVSortException extends CSVConversionException {

	private static final long serialVersionUID = 5352796938595731289L;

	public CSVSortException() {
	}

	public CSVSortException(String message) {
		super(message);
	}

	public CSVSortException(Throwable cause) {
		super(cause);
	}

	public CSVSortException(String message, Throwable cause) {
		super(message, cause);
	}

	public CSVSortException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
	}

}
"
CSVConversionHandler.java,log-6.9.380,"package org.processmining.log.csvimport.handler;

import java.util.Date;

import org.processmining.log.csv.CSVFile;
import org.processmining.log.csvimport.exception.CSVConversionException;

/**
 * Handler for the conversion following a visitor-like pattern.
 * 
 * @author F. Mannhardt
 *
 * @param <R>
 */
public interface CSVConversionHandler<R> {

	/**
	 * Called upon start parsing the {@link CSVFile}.
	 * 
	 * @param inputFile
	 */
	void startLog(CSVFile inputFile);

	/**
	 * Called when a new trace is encountered. Traces are assumed to be sorted
	 * by caseId, therefore, this is only called once per trace.
	 * 
	 * @param caseId
	 */
	void startTrace(String caseId);

	/**
	 * Called after a traces has been fully parsed.
	 * 
	 * @param caseId
	 */
	void endTrace(String caseId);

	/**
	 * Called when parsing a row, thereby creating an event.
	 * 
	 * @param eventClass
	 *            the name (class) of the event
	 * @param completionTime
	 *            the completion time possibly NULL
	 * @param startTime
	 *            the start time possibly NULL
	 */
	void startEvent(String eventClass, Date completionTime, Date startTime);

	/**
	 * Called when a string attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, String value);

	/**
	 * Called when a long attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, long value);

	/**
	 * Called when a double attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, double value);

	/**
	 * Called when a date attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, Date value);

	/**
	 * Called when a boolean attribute is parsed
	 * 
	 * @param name
	 * @param value
	 */
	void startAttribute(String name, boolean value);

	/**
	 * Called after the attribute has been parsed
	 */
	void endAttribute();

	/**
	 * Called when the full row (including all attributes) have been parsed.
	 */
	void endEvent();

	/**
	 * Detected an error in the conversion.
	 * 
	 * @param lineNumber
	 * @param columnIndex
	 * @param attributeName
	 * @param cellContent
	 * @param e
	 * @throws CSVConversionException
	 */
	void errorDetected(int lineNumber, int columnIndex, String attributeName, Object cellContent, Exception e) throws CSVConversionException;

	/**
	 * @return the result of the parse
	 */
	R getResult();

	/**
	 * @return whether any errors have been encountered during the conversion
	 */
	boolean hasConversionErrors();

	/**
	 * @return a descriptive String of the error
	 */
	String getConversionErrors();

}
"
XESConversionHandlerImpl.java,log-6.9.380,"package org.processmining.log.csvimport.handler;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension.StandardModel;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.info.impl.XLogInfoImpl;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVErrorHandlingMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVMapping;
import org.processmining.log.csvimport.config.CSVConversionConfig.ExtensionAttribute;
import org.processmining.log.csvimport.exception.CSVConversionException;
import org.processmining.log.utils.XUtils;

import com.google.common.collect.Ordering;

/**
 * Handler that creates an XLog from a CSV
 * 
 * @author F. Mannhardt
 *
 */
public class XESConversionHandlerImpl implements CSVConversionHandler<XLog> {

	private static final int MAX_ERROR_LENGTH = 1 * 1024 * 1024;

	private static final Comparator<? super XEvent> TIME_COMPARATOR = new Comparator<XEvent>() {

		public int compare(XEvent o1, XEvent o2) {
			// assumes stable sorting so start events will be always before complete events
			Date time1 = XUtils.getTimestamp(o1);
			Date time2 = XUtils.getTimestamp(o2);
			return Ordering.natural() // use Date built-in comparator
					.nullsFirst() // null aware since some events might not have times
					.compare(time1, time2);
		}
	};

	private final XFactory factory;
	private final CSVConversionConfig conversionConfig;
	private final StringBuilder conversionErrors;

	private XLog log = null;

	private XTrace currentTrace = null;
	private List<XEvent> currentEvents = new ArrayList<>();

	private int instanceCounter = 0;

	private XEvent currentEvent = null;
	private XEvent currentStartEvent;

	private boolean errorDetected = false;

	public XESConversionHandlerImpl(CSVConfig importConfig, CSVConversionConfig conversionConfig) {
		this.conversionConfig = conversionConfig;
		this.factory = conversionConfig.getFactory();
		this.conversionErrors = new StringBuilder();
	}

	@Override
	public String getConversionErrors() {
		if (conversionErrors.length() >= MAX_ERROR_LENGTH) {
			return conversionErrors.toString()
					.concat(""... (multiple error messages have been omitted to avoid running out of memory)"");
		} else {
			return conversionErrors.toString();
		}
	}

	@Override
	public boolean hasConversionErrors() {
		return conversionErrors.length() != 0;
	}

	@Override
	public void startLog(CSVFile inputFile) {
		log = factory.createLog();
		if (conversionConfig.getEventNameColumns() != null) {
			log.getExtensions().add(XConceptExtension.instance());
			log.getClassifiers().add(XLogInfoImpl.NAME_CLASSIFIER);
		}
		if (conversionConfig.getCompletionTimeColumn() != null || conversionConfig.getStartTimeColumn() != null) {
			log.getExtensions().add(XTimeExtension.instance());
			log.getExtensions().add(XLifecycleExtension.instance());
			log.getClassifiers().add(XUtils.STANDARDCLASSIFIER);
		}
		assignName(factory, log, inputFile.getFilename());
	}

	@Override
	public void startTrace(String caseId) {
		currentEvents.clear();
		errorDetected = false;
		currentTrace = factory.createTrace();
		assignName(factory, currentTrace, caseId);
	}

	@Override
	public void endTrace(String caseId) {
		if (errorDetected && conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.OMIT_TRACE_ON_ERROR) {
			// Skip the entire trace
			return;
		}
		sortEventsByTimestamp();
		currentTrace.addAll(currentEvents);
		log.add(currentTrace);
	}

	private void sortEventsByTimestamp() {
		Collections.sort(currentEvents, TIME_COMPARATOR);
	}

	@Override
	public void startEvent(String eventClass, Date completionTime, Date startTime) {
		if (conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.OMIT_EVENT_ON_ERROR) {
			// Include the other events in that trace
			errorDetected = false;
		}

		currentEvent = factory.createEvent();
		if (eventClass != null) {
			assignName(factory, currentEvent, eventClass);
		}

		if (startTime == null && completionTime == null) {
			// Both times are unknown only create an event assuming it is the completion event
			assignLifecycleTransition(factory, currentEvent, XLifecycleExtension.StandardModel.COMPLETE);
		} else if (startTime != null && completionTime != null) {
			// Both start and complete are present
			String instance = String.valueOf((instanceCounter++));

			// Assign attribute for complete event (currentEvent)			
			assignTimestamp(factory, currentEvent, completionTime);
			assignInstance(factory, currentEvent, instance);
			assignLifecycleTransition(factory, currentEvent, XLifecycleExtension.StandardModel.COMPLETE);

			// Add additional start event
			currentStartEvent = factory.createEvent();
			if (eventClass != null) {
				assignName(factory, currentStartEvent, eventClass);
			}
			assignTimestamp(factory, currentStartEvent, startTime);
			assignInstance(factory, currentStartEvent, instance);
			assignLifecycleTransition(factory, currentStartEvent, XLifecycleExtension.StandardModel.START);

		} else {
			// Either start or complete are present
			if (completionTime != null) {
				// Only create Complete
				assignTimestamp(factory, currentEvent, completionTime);
				assignLifecycleTransition(factory, currentEvent, XLifecycleExtension.StandardModel.COMPLETE);
			} else if (startTime != null) {
				// Only create Start
				assignTimestamp(factory, currentEvent, startTime);
				assignLifecycleTransition(factory, currentEvent, XLifecycleExtension.StandardModel.START);
			} else {
				throw new IllegalStateException(
						""Both start and complete time are NULL. This should never be the case here!"");
			}
		}
	}

	@Override
	public void startAttribute(String name, String value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createLiteral(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createLiteral(name, value));
			}
		}
	}

	private XAttributeLiteral createLiteral(String name, String value) {
		return factory.createAttributeLiteral(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	@Override
	public void startAttribute(String name, long value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createDiscrete(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createDiscrete(name, value));
			}
		}
	}

	private XAttributeDiscrete createDiscrete(String name, long value) {
		return factory.createAttributeDiscrete(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	@Override
	public void startAttribute(String name, double value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createContinuous(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createContinuous(name, value));
			}
		}
	}

	private XAttributeContinuous createContinuous(String name, double value) {
		return factory.createAttributeContinuous(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	@Override
	public void startAttribute(String name, Date value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createDate(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createDate(name, value));
			}
		}
	}

	private XAttributeTimestamp createDate(String name, Date value) {
		return factory.createAttributeTimestamp(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	@Override
	public void startAttribute(String name, boolean value) {
		if (!specialColumn(name)) {
			assignAttribute(currentEvent, createBoolean(name, value));
			if (isShouldAddStartEventAttributes() && currentStartEvent != null) {
				assignAttribute(currentStartEvent, createBoolean(name, value));
			}
		}
	}

	private XAttributeBoolean createBoolean(String name, boolean value) {
		return factory.createAttributeBoolean(getNameFromConfig(name), value, getExtensionFromConfig(name));
	}

	private XExtension getExtensionFromConfig(String name) {
		ExtensionAttribute extensionAttribute = getExtensionAttribute(name);
		return extensionAttribute == null ? null : extensionAttribute.extension;
	}

	private String getNameFromConfig(String columnName) {
		CSVMapping csvMapping = getMapping(columnName);
		if (csvMapping.getEventExtensionAttribute() != null
				&& csvMapping.getEventExtensionAttribute() != CSVConversionConfig.NO_EXTENSION_ATTRIBUTE) {
			return csvMapping.getEventExtensionAttribute().key;
		} else if (csvMapping.getEventAttributeName() != null && !csvMapping.getEventAttributeName().isEmpty()) {
			return csvMapping.getEventAttributeName();
		} else {
			return columnName;
		}
	}

	private ExtensionAttribute getExtensionAttribute(String name) {
		return getMapping(name).getEventExtensionAttribute();
	}

	private CSVMapping getMapping(String name) {
		return conversionConfig.getConversionMap().get(name);
	}

	@Override
	public void endAttribute() {
		//No-op
	}

	@Override
	public void endEvent() {
		if (errorDetected && conversionConfig.getErrorHandlingMode() == CSVErrorHandlingMode.OMIT_EVENT_ON_ERROR) {
			// Do not include the event
			return;
		}
		// Add start event before complete event to guarantee order for events with same time-stamp
		if (currentStartEvent != null) {
			currentEvents.add(currentStartEvent);
			currentStartEvent = null;
		}
		currentEvents.add(currentEvent);
		currentEvent = null;
	}

	public XLog getResult() {
		return log;
	}

	private static void assignAttribute(XAttributable a, XAttribute value) {
		XUtils.putAttribute(a, value);
	}

	private static void assignLifecycleTransition(XFactory factory, XAttributable a, StandardModel lifecycle) {
		assignAttribute(a, factory.createAttributeLiteral(XLifecycleExtension.KEY_TRANSITION, lifecycle.getEncoding(),
				XLifecycleExtension.instance()));
	}

	private static void assignInstance(XFactory factory, XAttributable a, String value) {
		assignAttribute(a,
				factory.createAttributeLiteral(XConceptExtension.KEY_INSTANCE, value, XConceptExtension.instance()));
	}

	private static void assignTimestamp(XFactory factory, XAttributable a, Date value) {
		assignAttribute(a,
				factory.createAttributeTimestamp(XTimeExtension.KEY_TIMESTAMP, value, XTimeExtension.instance()));
	}

	private static void assignName(XFactory factory, XAttributable a, String value) {
		assignAttribute(a,
				factory.createAttributeLiteral(XConceptExtension.KEY_NAME, value, XConceptExtension.instance()));
	}

	@Override
	public void errorDetected(int lineNumber, int columnIndex, String attributeName, Object content, Exception e)
			throws CSVConversionException {
		CSVErrorHandlingMode errorMode = conversionConfig.getErrorHandlingMode();
		errorDetected = true;
		String columnInfo = String.format(""Attribute '%s' with column index %s "", attributeName, columnIndex);
		switch (errorMode) {
			case BEST_EFFORT :
				if (conversionErrors.length() < MAX_ERROR_LENGTH) {
					conversionErrors.append(""Line: "" + lineNumber + "", "" + columnInfo + ""\n"" + ""Skipping attribute ""
							+ nullSafeToString(content) + ""\nError: "" + e + ""\n\n"");
				}
				break;
			case OMIT_EVENT_ON_ERROR :
				if (conversionErrors.length() < MAX_ERROR_LENGTH) {
					conversionErrors.append(
							""Line: "" + lineNumber + "", "" + columnInfo + ""\n"" + ""Skipping event, could not convert ""
									+ nullSafeToString(content) + ""\nError: "" + e + ""\n\n"");
				}
				break;
			case OMIT_TRACE_ON_ERROR :
				if (conversionErrors.length() < MAX_ERROR_LENGTH) {
					conversionErrors.append(""Line: "" + lineNumber + "", "" + columnInfo + ""\n"" + ""Skipping trace ""
							+ XUtils.getConceptName(currentTrace) + "", could not convert "" + nullSafeToString(content)
							+ ""\nError: "" + e + ""\n\n"");
				}
				break;
			default :
			case ABORT_ON_ERROR :
				throw new CSVConversionException(
						""Error converting "" + content + "" at line "" + lineNumber + ""and column "" + columnIndex, e);
		}
	}

	private static String nullSafeToString(Object obj) {
		if (obj == null) {
			return ""NULL"";
		} else if (obj.getClass().isArray()) {
			return Arrays.toString((Object[]) obj);
		} else {
			return obj.toString();
		}
	}

	private boolean specialColumn(String columnName) {
		return columnName == null
				|| (XConceptExtension.KEY_NAME.equals(columnName) && !conversionConfig.getEventNameColumns().isEmpty())
				|| (XTimeExtension.KEY_TIMESTAMP.equals(columnName)
						&& conversionConfig.getCompletionTimeColumn() != null)
				|| (XConceptExtension.KEY_INSTANCE.equals(columnName) && conversionConfig.getStartTimeColumn() != null);
	}

	public boolean isShouldAddStartEventAttributes() {
		return conversionConfig.isShouldAddStartEventAttributes();
	}

}"
StringBasedImportOrdering.java,log-6.9.380,"package org.processmining.log.csvimport;

import com.google.common.collect.Ordering;

final class StringBasedImportOrdering extends Ordering<String[]> {

	private final int[] sortingIndices;

	public StringBasedImportOrdering(int[] sortingIndicies) {
		this.sortingIndices = sortingIndicies;
	}

	public int compare(String[] o1, String[] o2) {
		if (o1.length != o2.length) {
			throw new IllegalArgumentException(
					""Can only compare lines in a CSV file with the same number of columns!"");
		}
		// First compare on all the case columns
		for (int i = 0; i < sortingIndices.length; i++) {
			int index = sortingIndices[i];
			// We treat empty and NULL cells as the same as there is no concept of a NULL cell in CSV 
			String s1 = o1[index] == null ? """" : o1[index];
			String s2 = o2[index] == null ? """" : o2[index];
			int comp = s1.compareTo(s2);
			if (comp != 0) {
				// Case ID is different on current index
				return comp;
			}
		}
		// Keep ordering -> using a stable sort algorithm
		return 0;
	}

}"
ConversionConfigUI.java,log-6.9.380,"package org.processmining.log.csvimport.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.List;

import javax.swing.DefaultComboBoxModel;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.SwingWorker;
import javax.swing.Timer;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;

import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.framework.util.ui.widgets.ProMListSortableWithComboBox;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVMapping;
import org.processmining.log.csvimport.ui.preview.CSVPreviewFrame;

import com.fluxicon.slickerbox.components.SlickerButton;
import com.fluxicon.slickerbox.factory.SlickerFactory;
import com.google.common.collect.Lists;

/**
 * UI for the configuration of the actual conversion
 * 
 * @author F. Mannhardt
 *
 */
public final class ConversionConfigUI extends CSVConfigurationPanel implements AutoCloseable {

	private static final int COLUMN_WIDTH = 360;

	private final class ChangeListenerImpl implements ActionListener {

		public void actionPerformed(ActionEvent e) {
			updateSettings();
		}

		public void updateSettings() {
			try {
				conversionConfig.setCaseColumns(caseComboBox.getElements());
				conversionConfig.setEventNameColumns(eventComboBox.getElements());
				conversionConfig.setStartTimeColumn(startTimeColumnCbx.getSelectedItem().toString());
				conversionConfig.setCompletionTimeColumn(completionTimeColumnCbx.getSelectedItem().toString());

				if (conversionConfig.getStartTimeColumn().isEmpty()) {
					startTimeFormat.setText("""");
					startTimeFormat.setEnabled(false);
				} else {
					startTimeFormat.setEnabled(true);
					if (hasManipulatedStartTime) {
						CSVMapping mapping = conversionConfig.getConversionMap()
								.get(conversionConfig.getStartTimeColumn());
						mapping.setPattern(startTimeFormat.getText());
					} else {
						// use originally guess format 
						startTimeFormat.setText(conversionConfig.getConversionMap()
								.get(conversionConfig.getStartTimeColumn()).getPattern());
					}
				}

				if (conversionConfig.getCompletionTimeColumn().isEmpty()) {
					completionTimeFormat.setText("""");
					completionTimeFormat.setEnabled(false);
				} else {
					completionTimeFormat.setEnabled(true);
					if (hasManipulatedCompletionTime) {
						CSVMapping mapping = conversionConfig.getConversionMap()
								.get(conversionConfig.getCompletionTimeColumn());
						mapping.setPattern(completionTimeFormat.getText());
					} else {
						// use originally guess format 
						completionTimeFormat.setText(conversionConfig.getConversionMap()
								.get(conversionConfig.getCompletionTimeColumn()).getPattern());
					}
				}
			} catch (RuntimeException e) {
				ProMUIHelper.showErrorMessage(previewFrame, e.getMessage() != null ? e.getMessage() : e.toString(), ""Error updating configuration"", e);
			}

			previewFrame.refresh();
		}

	}

	private final class LoadCSVRecordsWorker extends SwingWorker<Void, String[]> {
		protected Void doInBackground() throws Exception {
			String[] oldLine = null;
			String[] nextLine;
			int i = 0;
			while ((nextLine = reader.readNext()) != null && i < maxLoad) {
				if (oldLine != null) {
					if (oldLine.length != nextLine.length) {
						throw new IllegalArgumentException(
								""CSV file has inconsistent number of columns, please check CSV config."");
					}
				}
				publish(nextLine);
				oldLine = nextLine;
				i++;
			}
			return null;
		}

		protected void process(List<String[]> chunks) {
			previewFrame.addRows(chunks);
			previewFrame.setTitle(String.format(""CSV Preview (%s rows - scroll down to load more)"",
					previewFrame.getPreviewTable().getModel().getRowCount()));
		}
	}

	private static final long serialVersionUID = 2L;

	private static final int ACTION_DELAY = 500;

	private final CSVConversionConfig conversionConfig;

	private final String[] headers;
	private final String[] headersInclEmpty;

	private final ProMListSortableWithComboBox<String> caseComboBox;
	private final ProMListSortableWithComboBox<String> eventComboBox;
	private final ProMComboBox<String> completionTimeColumnCbx;
	private final ProMComboBox<String> startTimeColumnCbx;

	private final ChangeListenerImpl changeListener;
	private final Timer updateTimer;

	private final ICSVReader reader;
	private final CSVPreviewFrame previewFrame;
	private int maxLoad = 1000;

	private ProMTextField completionTimeFormat;
	private ProMTextField startTimeFormat;

	private boolean hasManipulatedStartTime = false;
	private boolean hasManipulatedCompletionTime = false;

	public ConversionConfigUI(final CSVFile csv, final CSVConfig importConfig, CSVConversionConfig conversionConfig)
			throws IOException {
		this.conversionConfig = conversionConfig;

		reader = csv.createReader(importConfig);
		headers = reader.readNext();
		headersInclEmpty = Lists.asList("""", headers).toArray(new String[headers.length + 1]);
		changeListener = new ChangeListenerImpl();
		updateTimer = new Timer(ACTION_DELAY, new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				changeListener.updateSettings();
			}
		});
		updateTimer.setRepeats(false);

		GroupLayout layout = new GroupLayout(this);
		setLayout(layout);
		setMaximumSize(new Dimension(COLUMN_WIDTH * 2, Short.MAX_VALUE));
		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		JLabel standardAttributesLabel = SlickerFactory.instance()
				.createLabel(""<HTML><H2>Mapping to Standard XES Attributes</H2></HTML>"");
		JButton showPreviewButton = new SlickerButton(""Show Expert Configuration"");
		showPreviewButton.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				togglePreviewFrame();
			}
		});

		caseComboBox = new ProMListSortableWithComboBox<>(new DefaultComboBoxModel<>(headers));
		JLabel caseLabel = createLabel(""Case Column (Optional)"",
				""Groups events into traces, and is mapped to 'concept:name' of the trace. Select one or more columns, re-order by drag & drop."");
		for (String caseColumn : conversionConfig.getCaseColumns()) {
			caseComboBox.addElement(caseColumn);
		}
		caseComboBox.getSelectedItemsText().setText(""Selected case columns:"");
		caseComboBox.getListModel().addListDataListener(new ListDataListener() {

			public void intervalRemoved(ListDataEvent e) {
				changeListener.updateSettings();
			}

			public void intervalAdded(ListDataEvent e) {
				changeListener.updateSettings();
			}

			public void contentsChanged(ListDataEvent e) {
				changeListener.updateSettings();
			}
		});

		eventComboBox = new ProMListSortableWithComboBox<>(new DefaultComboBoxModel<>(headers));
		JLabel eventLabel = createLabel(""Event Column (Optional)"",
				""Mapped to 'concept:name' of the event. Select one or more columns, re-order by drag & drop."");
		for (String eventColumn : conversionConfig.getEventNameColumns()) {
			eventComboBox.addElement(eventColumn);
		}
		eventComboBox.getSelectedItemsText().setText(""Selected event columns:"");
		eventComboBox.getListModel().addListDataListener(new ListDataListener() {

			public void intervalRemoved(ListDataEvent e) {
				changeListener.updateSettings();
			}

			public void intervalAdded(ListDataEvent e) {
				changeListener.updateSettings();
			}

			public void contentsChanged(ListDataEvent e) {
				changeListener.updateSettings();
			}
		});

		completionTimeColumnCbx = new ProMComboBox<>(headersInclEmpty);
		completionTimeColumnCbx.setToolTipText(
				""Mapped to 'time:timestamp' of the main event that is created for each row in the CSV file."");
		JLabel completionTimeLabel = createLabel(""Completion Time (Optional)"", ""Mapped to 'time:timestamp'"");
		if (conversionConfig.getCompletionTimeColumn() != null) {
			completionTimeColumnCbx.setSelectedItem(conversionConfig.getCompletionTimeColumn());
		} else {
			completionTimeColumnCbx.setSelectedItem("""");
		}
		completionTimeColumnCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				hasManipulatedCompletionTime = false;
				changeListener.updateSettings();
			}
		});

		completionTimeFormat = new ProMTextField("""",
				""Could not auto-detect the used date format. Please provide a SimpleDateFormat pattern!"");
		if (conversionConfig.getCompletionTimeColumn() != null
				&& !conversionConfig.getCompletionTimeColumn().isEmpty()) {
			completionTimeFormat.setText(
					conversionConfig.getConversionMap().get(conversionConfig.getCompletionTimeColumn()).getPattern());
		}
		completionTimeFormat.addKeyListener(new KeyAdapter() {

			public void keyPressed(KeyEvent e) {
				hasManipulatedCompletionTime = true;
				update();
			}

			private void update() {
				try {
					new SimpleDateFormat(completionTimeFormat.getText());
					updateTimer.restart();
					completionTimeFormat.getTextField().setForeground(Color.WHITE);
				} catch (IllegalArgumentException e) {
					completionTimeFormat.getTextField().setForeground(Color.RED);
				}
			}

		});

		startTimeColumnCbx = new ProMComboBox<>(headersInclEmpty);
		startTimeColumnCbx.setToolTipText(
				""<HTML>Mapped to 'time:timestamp' of an extra 'start' event that is created for each row in the CSV file. ""
						+ ""<BR/>In case your lifecycle events such as 'start' are already separate row in the CSV file, please leave this empty and use the 'Expert Mode' to configure an appropriate mapping.</HTML>"");
		JLabel startTimeLabel = createLabel(""Start Time (Optional)"",
				""Mapped to 'time:timestamp' of a separate start event"");
		if (conversionConfig.getStartTimeColumn() != null) {
			startTimeColumnCbx.setSelectedItem(conversionConfig.getStartTimeColumn());
		} else {
			startTimeColumnCbx.setSelectedItem("""");
		}
		startTimeColumnCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				hasManipulatedStartTime = false;
				changeListener.updateSettings();
			}
		});

		startTimeFormat = new ProMTextField("""",
				""Could not auto-detect the used date format. Please provide a SimpleDateFormat pattern!"");
		if (conversionConfig.getStartTimeColumn() != null && !conversionConfig.getStartTimeColumn().isEmpty()) {
			startTimeFormat.setText(
					conversionConfig.getConversionMap().get(conversionConfig.getStartTimeColumn()).getPattern());
		}

		startTimeFormat.addKeyListener(new KeyAdapter() {

			public void keyPressed(KeyEvent e) {
				hasManipulatedStartTime = true;
				update();
			}

			private void update() {
				try {
					new SimpleDateFormat(startTimeFormat.getText());
					updateTimer.restart();
					startTimeFormat.getTextField().setForeground(Color.WHITE);
				} catch (IllegalArgumentException e) {
					startTimeFormat.getTextField().setForeground(Color.RED);
				}
			}

		});

		SequentialGroup verticalGroup = layout.createSequentialGroup();
		verticalGroup.addGroup(layout.createParallelGroup(Alignment.CENTER).addComponent(standardAttributesLabel)
				.addComponent(showPreviewButton));
		verticalGroup.addGroup(layout.createParallelGroup()
				.addGroup(layout.createSequentialGroup().addComponent(caseLabel).addComponent(caseComboBox))
				.addGroup(layout.createSequentialGroup().addComponent(eventLabel).addComponent(eventComboBox)));
		verticalGroup.addGroup(layout.createParallelGroup()
				.addGroup(layout.createSequentialGroup().addComponent(startTimeLabel).addComponent(startTimeColumnCbx)
						.addComponent(startTimeFormat))
				.addGroup(layout.createSequentialGroup().addComponent(completionTimeLabel)
						.addComponent(completionTimeColumnCbx).addComponent(completionTimeFormat)));

		ParallelGroup horizontalGroup = layout.createParallelGroup();
		horizontalGroup.addGroup(
				layout.createSequentialGroup().addComponent(standardAttributesLabel).addComponent(showPreviewButton));
		horizontalGroup.addGroup(layout.createSequentialGroup()
				.addGroup(layout.createParallelGroup().addComponent(caseLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(caseComboBox, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH))
				.addGroup(
						layout.createParallelGroup().addComponent(eventLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
								.addComponent(eventComboBox, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)));
		horizontalGroup.addGroup(layout.createSequentialGroup()
				.addGroup(layout.createParallelGroup()
						.addComponent(startTimeLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(startTimeColumnCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(startTimeFormat, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH))
				.addGroup(layout.createParallelGroup()
						.addComponent(completionTimeLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(completionTimeColumnCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
						.addComponent(completionTimeFormat, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)));

		layout.linkSize(eventLabel, caseLabel);
		layout.linkSize(completionTimeLabel, startTimeLabel);

		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		layout.setVerticalGroup(verticalGroup);
		layout.setHorizontalGroup(horizontalGroup);

		previewFrame = new CSVPreviewFrame(headers, conversionConfig);
		previewFrame.setTitle(""Expert Configuration & Preview - Scroll down to load more rows"");
		previewFrame.getMainScrollPane().getVerticalScrollBar().addAdjustmentListener(new AdjustmentListener() {

			public void adjustmentValueChanged(AdjustmentEvent e) {
				int maximum = e.getAdjustable().getMaximum();
				int current = e.getValue();
				if (Math.abs(maximum - current) < 1000 && !e.getValueIsAdjusting()) {
					new LoadCSVRecordsWorker().execute();
				}
			}
		});

		changeListener.updateSettings();
	}

	private void togglePreviewFrame() {
		if (!previewFrame.isVisible()) {
			previewFrame.showFrame(this);
			try {
				// Update Content
				new LoadCSVRecordsWorker().execute();
			} catch (Exception e) {
				JOptionPane.showMessageDialog(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"",
						JOptionPane.ERROR_MESSAGE);
			}
		} else {
			previewFrame.setVisible(false);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#addNotify()
	 */
	@Override
	public void addNotify() {
		super.addNotify();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#removeNotify()
	 */
	@Override
	public void removeNotify() {
		super.removeNotify();
		changeListener.updateSettings();
		previewFrame.save();
		previewFrame.setVisible(false);
	}

	public CSVConversionConfig getConversionConfig() {
		return conversionConfig;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.AutoCloseable#close()
	 */
	public void close() {
		try {
			reader.close();
		} catch (IOException e) {
			JOptionPane.showMessageDialog(null, e.toString());
		}
	}

}
"
CSVConfigurationPanel.java,log-6.9.380,"package org.processmining.log.csvimport.ui;

import java.awt.Font;

import javax.swing.JLabel;
import javax.swing.JPanel;

import com.fluxicon.slickerbox.factory.SlickerFactory;

public class CSVConfigurationPanel extends JPanel {

	private static final long serialVersionUID = 6462901867808436259L;

	protected static JLabel createLabel(String caption, String description) {
		JLabel eventLabel = SlickerFactory.instance().createLabel(
				""<HTML><B>"" + caption + ""</B><BR/><I>"" + description + ""</I></HTML>"");
		eventLabel.setFont(eventLabel.getFont().deriveFont(Font.PLAIN));
		return eventLabel;
	}


}
"
ExpertConfigUI.java,log-6.9.380,"package org.processmining.log.csvimport.ui;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.lang.reflect.InvocationTargetException;
import java.util.Set;

import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import javax.swing.JLabel;

import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVAttributeConversionMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVEmptyCellHandlingMode;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVErrorHandlingMode;

import com.fluxicon.slickerbox.factory.SlickerFactory;
import com.google.common.base.Function;
import com.google.common.collect.Iterables;

public class ExpertConfigUI extends CSVConfigurationPanel {

	private static final long serialVersionUID = 7749368962812585099L;

	private static final int COLUMN_WIDTH = 360;

	private static final class XFactoryUI {

		private final XFactory factory;

		public XFactoryUI(XFactory factory) {
			super();
			this.factory = factory;
		}

		public XFactory getFactory() {
			return factory;
		}

		@Override
		public String toString() {
			return factory.getName();
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((factory == null) ? 0 : factory.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (!(obj instanceof XFactoryUI))
				return false;
			XFactoryUI other = (XFactoryUI) obj;
			if (factory == null) {
				if (other.factory != null)
					return false;
			} else if (!factory.equals(other.factory))
				return false;
			return true;
		}

	}

	private final ProMComboBox<XFactoryUI> xFactoryChoice;
	private final ProMComboBox<CSVEmptyCellHandlingMode> emptyCellHandlingModeCbx;
	private final ProMComboBox<CSVErrorHandlingMode> errorHandlingModeCbx;
	private final ProMComboBox<CSVAttributeConversionMode> attributeConversionModeCbx;

	public ExpertConfigUI(final CSVFile csv, final CSVConfig importConfig, final CSVConversionConfig conversionConfig) {
		super();
		GroupLayout layout = new GroupLayout(this);
		setLayout(layout);
		setMaximumSize(new Dimension(COLUMN_WIDTH * 2, Short.MAX_VALUE));

		JLabel conversionOptionsLabel = SlickerFactory.instance().createLabel(
				""Additional Conversion Options (Defaults are a good guess)"");
		conversionOptionsLabel.setFont(conversionOptionsLabel.getFont().deriveFont(Font.BOLD, 20));

		xFactoryChoice = new ProMComboBox<>(Iterables.transform(getAvailableXFactories(),
				new Function<XFactory, XFactoryUI>() {

					public XFactoryUI apply(XFactory factory) {
						return new XFactoryUI(factory);
					}

				}));
		xFactoryChoice.setSelectedItem(new XFactoryUI(conversionConfig.getFactory()));
		JLabel xFactoryLabel = createLabel(
				""XFactory"",
				""XFactory implementation that is used to create the log. Some implementations might be more memory efficient, consider changing this in case you import a huge log."");

		xFactoryChoice.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				conversionConfig.setFactory(((XFactoryUI) xFactoryChoice.getSelectedItem()).getFactory());
			}
		});

		errorHandlingModeCbx = new ProMComboBox<>(CSVErrorHandlingMode.values());
		errorHandlingModeCbx.setSelectedItem(conversionConfig.getErrorHandlingMode());
		JLabel errorHandlingModeLabel = createLabel(""Error Handling"",
				""Stop conversion upon malformed input or try to import as much as possible?"");
		errorHandlingModeCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				conversionConfig.setErrorHandlingMode((CSVErrorHandlingMode) errorHandlingModeCbx.getSelectedItem());
			}
		});

		emptyCellHandlingModeCbx = new ProMComboBox<>(CSVEmptyCellHandlingMode.values());
		emptyCellHandlingModeCbx.setSelectedItem(conversionConfig.getEmptyCellHandlingMode());
		JLabel emptyCellHandlingModeLabel = createLabel(
				""Sparse / Dense Log"",
				""Exclude (sparse) or include (dense) empty cells in the conversion. This affects how empty cells in the CSV are handled. ""
						+ ""Some plug-ins require the log to be dense, i.e., all attributes are defined for each event. ""
						+ ""In other cases it might be more efficient or even required to only add attributes to events if the attributes actually contain data."");
		emptyCellHandlingModeCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				conversionConfig.setEmptyCellHandlingMode((CSVEmptyCellHandlingMode) emptyCellHandlingModeCbx
						.getSelectedItem());
			}
		});

		attributeConversionModeCbx = new ProMComboBox<>(CSVAttributeConversionMode.values());
		attributeConversionModeCbx
				.setSelectedItem(conversionConfig.isShouldAddStartEventAttributes() ? CSVAttributeConversionMode.ADD_TO_BOTH
						: CSVAttributeConversionMode.ADD_TO_COMPLETE);
		JLabel attributeConversionModeLabel = createLabel(
				""Attribute Conversion Mode"",
				""Add attributes either to both start and complete events, or only to the complete event. ""
				+ ""This is only relevant if your log contains information on the 'start' and 'completion' of an activity."");
		attributeConversionModeCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				conversionConfig.setShouldAddStartEventAttributes(attributeConversionModeCbx.getSelectedItem() == CSVAttributeConversionMode.ADD_TO_BOTH);
			}
		});

		SequentialGroup verticalGroup = layout.createSequentialGroup();
		verticalGroup.addGroup(layout
				.createParallelGroup()
				.addGroup(
						layout.createSequentialGroup().addComponent(errorHandlingModeLabel)
								.addComponent(errorHandlingModeCbx))
				.addGroup(
						layout.createSequentialGroup().addComponent(xFactoryLabel)
								.addComponent(xFactoryChoice)));
		verticalGroup.addGroup(layout
				.createParallelGroup()
				.addGroup(
						layout.createSequentialGroup().addComponent(emptyCellHandlingModeLabel)
							.addComponent(emptyCellHandlingModeCbx))
				.addGroup(layout.createSequentialGroup().addComponent(attributeConversionModeLabel).addComponent(attributeConversionModeCbx)));

		ParallelGroup horizontalGroup = layout.createParallelGroup();
		horizontalGroup.addGroup(layout
				.createSequentialGroup()
				.addGroup(
						layout.createParallelGroup()
								.addComponent(errorHandlingModeLabel, Alignment.LEADING, COLUMN_WIDTH, COLUMN_WIDTH,
										COLUMN_WIDTH)
								.addComponent(errorHandlingModeCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH))
				.addGroup(
						layout.createParallelGroup()
								.addComponent(xFactoryLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
								.addComponent(xFactoryChoice, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)));
		horizontalGroup.addGroup(layout
				.createSequentialGroup()
				.addGroup(
						layout.createParallelGroup()
								.addComponent(emptyCellHandlingModeLabel, Alignment.LEADING, COLUMN_WIDTH, COLUMN_WIDTH,
										COLUMN_WIDTH)
								.addComponent(emptyCellHandlingModeCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH))
				.addGroup(
						layout.createParallelGroup()
								.addComponent(attributeConversionModeLabel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
								.addComponent(attributeConversionModeCbx, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)));

		layout.linkSize(errorHandlingModeLabel, xFactoryLabel, emptyCellHandlingModeLabel, attributeConversionModeLabel);

		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		layout.setVerticalGroup(verticalGroup);
		layout.setHorizontalGroup(horizontalGroup);
	}

	private Set<XFactory> getAvailableXFactories() {
		//Try to register XESLite Factories
		tryRegisterFactory(""org.xeslite.lite.factory.XFactoryLiteImpl"");
		tryRegisterFactory(""org.xeslite.external.XFactoryExternalStore$MapDBDiskImpl"");
		tryRegisterFactory(""org.xeslite.external.XFactoryExternalStore$MapDBDiskWithoutCacheImpl"");
		tryRegisterFactory(""org.xeslite.external.XFactoryExternalStore$MapDBDiskSequentialAccessImpl"");
		tryRegisterFactory(""org.xeslite.external.XFactoryExternalStore$InMemoryStoreImpl"");
		return XFactoryRegistry.instance().getAvailable();
	}

	/**
	 * Tries to load the class and call the 'register' method.
	 * 
	 * @param className
	 */
	private void tryRegisterFactory(String className) {
		try {
			getClass().getClassLoader().loadClass(className).getDeclaredMethod(""register"").invoke(null);
		} catch (ClassNotFoundException | NoSuchMethodException | SecurityException | IllegalAccessException
				| IllegalArgumentException | InvocationTargetException e) {
		}
	}

}
"
ImportConfigUI.java,log-6.9.380,"package org.processmining.log.csvimport.ui;

import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.List;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.SwingWorker;

import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.log.csv.CSVFile;
import org.processmining.log.csv.ICSVReader;
import org.processmining.log.csv.config.CSVConfig;
import org.processmining.log.csv.config.CSVQuoteCharacter;
import org.processmining.log.csv.config.CSVSeperator;
import org.processmining.log.csvimport.ui.preview.CSVPreviewPanel;

/**
 * UI for the import configuration (charset, separator, ..)
 * 
 * @author F. Mannhardt
 *
 */
public final class ImportConfigUI extends CSVConfigurationPanel {

	private static final long serialVersionUID = 2L;

	private static final int MAX_PREVIEW = 1000;
	private static final int COLUMN_WIDTH = 240;

	private final CSVFile csv;
	private final CSVConfig importConfig;

	private final ProMComboBox<String> charsetCbx;
	private final ProMComboBox<CSVSeperator> separatorField;
	private final ProMComboBox<CSVQuoteCharacter> quoteField;

	private final CSVPreviewPanel previewPanel;

	private SwingWorker<Void, String[]> worker;

	public ImportConfigUI(final CSVFile csv, final CSVConfig importConfig) {
		super();
		this.importConfig = importConfig;
		this.csv = csv;
		this.previewPanel = new CSVPreviewPanel();

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setOpaque(false);		

		JLabel header = new JLabel(""<HTML><H2>CSV Parser: Settings</H2></HTML>"");
		header.setAlignmentX(CENTER_ALIGNMENT);
		
		add(header);

		add(Box.createVerticalStrut(10));

		JPanel topPanel = new JPanel();
		
		GroupLayout layout = new GroupLayout(topPanel);
		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		topPanel.setOpaque(false);
		topPanel.setLayout(layout);
		
		JPanel charsetPanel = new JPanel();
		charsetPanel.setOpaque(false);
		charsetPanel.setLayout(new BoxLayout(charsetPanel, BoxLayout.Y_AXIS));
		charsetCbx = new ProMComboBox<>(Charset.availableCharsets().keySet());
		charsetCbx.setSelectedItem(importConfig.getCharset());
		charsetCbx.setPreferredSize(null);
		charsetCbx.setMinimumSize(null);
		JLabel charsetLabel = createLabel(""Charset"", 
				""Configure the character encoding that is used by the CSV file"");
		charsetLabel.setAlignmentX(LEFT_ALIGNMENT);
		charsetCbx.setAlignmentX(LEFT_ALIGNMENT);
		charsetPanel.add(charsetLabel);
		charsetPanel.add(charsetCbx);
		charsetCbx.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setCharset(charsetCbx.getSelectedItem().toString());
				refreshPreview();
			}
		});

		JPanel separatorPanel = new JPanel();
		separatorPanel.setOpaque(false);
		separatorPanel.setLayout(new BoxLayout(separatorPanel, BoxLayout.Y_AXIS));
		separatorField = new ProMComboBox<>(CSVSeperator.values());
		separatorField.setPreferredSize(null);
		separatorField.setMinimumSize(null);
		separatorField.setSelectedItem(importConfig.getSeparator());
		JLabel seperationLabel = createLabel(""Separator Character"", 
				""Configure the character that is used by the CSV file to separate two fields"");
		seperationLabel.setAlignmentX(LEFT_ALIGNMENT);
		separatorField.setAlignmentX(LEFT_ALIGNMENT);
		separatorPanel.add(seperationLabel);
		separatorPanel.add(separatorField);
		separatorField.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setSeparator(((CSVSeperator) separatorField.getSelectedItem()));
				refreshPreview();
			}
		});

		JPanel quotePanel = new JPanel();
		quotePanel.setOpaque(false);
		quotePanel.setLayout(new BoxLayout(quotePanel, BoxLayout.Y_AXIS));
		quoteField = new ProMComboBox<>(CSVQuoteCharacter.values());
		quoteField.setPreferredSize(null);
		quoteField.setMinimumSize(null);
		JLabel quoteLabel = createLabel(""Quote Character"", 
				""Configure the character that is used by the CSV file that is used to quote values if they contain the separator character or a newline"");
		quoteLabel.setAlignmentX(LEFT_ALIGNMENT);
		quoteField.setAlignmentX(LEFT_ALIGNMENT);
		quotePanel.add(quoteLabel);
		quotePanel.add(quoteField);
		quoteField.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				importConfig.setQuoteChar((CSVQuoteCharacter) quoteField.getSelectedItem());
				refreshPreview();
			}
		});
		quoteField.setSelectedItem(importConfig.getQuoteChar());

		ParallelGroup verticalGroup = layout.createParallelGroup()
				.addComponent(charsetPanel, Alignment.TRAILING)
				.addComponent(separatorPanel, Alignment.TRAILING)
				.addComponent(quotePanel, Alignment.TRAILING);

		SequentialGroup horizontalGroup = layout.createSequentialGroup()
				.addComponent(charsetPanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH)
				.addComponent(separatorPanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH )
				.addComponent(quotePanel, COLUMN_WIDTH, COLUMN_WIDTH, COLUMN_WIDTH);

		layout.linkSize(SwingConstants.HORIZONTAL, separatorPanel, charsetPanel, quotePanel);
		
		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);

		layout.setVerticalGroup(verticalGroup);
		layout.setHorizontalGroup(horizontalGroup);
		
		add(topPanel);
		previewPanel.setMaximumSize(new Dimension(725, 350));
		add(previewPanel);
	}

	private void refreshPreview() {

		if (worker != null) {
			worker.cancel(true);
		}

		previewPanel.clear();

		// Update Header
		try {
			previewPanel.setHeader(csv.readHeader(importConfig));
		} catch (IOException | ArrayIndexOutOfBoundsException e) {
			ProMUIHelper.showWarningMessage(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"");
			return;
		}

		worker = new SwingWorker<Void, String[]>() {

			protected Void doInBackground() throws Exception {

				try (ICSVReader reader = csv.createReader(importConfig)) {
					// Skip header
					reader.readNext();
					String[] nextLine;
					int i = 0;
					while ((nextLine = reader.readNext()) != null && i < MAX_PREVIEW) {
						publish(nextLine);
						i++;
					}
				}

				return null;
			}

			protected void process(List<String[]> chunks) {
				for (String[] row : chunks) {
					previewPanel.addRow(row);
				}
			}

		};

		try {
			worker.execute();
		} catch (Exception e) {
			JOptionPane.showMessageDialog(this, ""Error parsing CSV "" + e.getMessage(), ""CSV Parsing Error"",
					JOptionPane.ERROR_MESSAGE);
		}
	}

	public CSVConfig getImportConfig() {
		return importConfig;
	}

}"
CSVPreviewFrame.java,log-6.9.380,"package org.processmining.log.csvimport.ui.preview;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.util.Enumeration;
import java.util.List;
import java.util.Vector;

import javax.swing.AbstractCellEditor;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultCellEditor;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.TableColumnModelEvent;
import javax.swing.event.TableColumnModelListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;

import org.processmining.framework.util.ui.widgets.ProMScrollPane;
import org.processmining.framework.util.ui.widgets.ProMTableWithoutPanel;
import org.processmining.log.csvimport.config.CSVConversionConfig;
import org.processmining.log.csvimport.config.CSVConversionConfig.CSVMapping;
import org.processmining.log.csvimport.config.CSVConversionConfig.Datatype;
import org.processmining.log.csvimport.config.CSVConversionConfig.ExtensionAttribute;

/**
 * Frame showing a part of the CSV file.
 * 
 * @author F. Mannhardt
 * 
 */
public final class CSVPreviewFrame extends JFrame {

	private final class MappingCellEditor extends AbstractCellEditor implements TableCellEditor {

		private static final long serialVersionUID = -8465152263165430372L;

		private TableCellEditor editor;

		public Object getCellEditorValue() {
			if (editor != null) {
				return editor.getCellEditorValue();
			}
			return null;
		}

		public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
			if (value instanceof Datatype) {
				editor = new DefaultCellEditor(new JComboBox<>(new DefaultComboBoxModel<>(Datatype.values())));
			} else if (value instanceof String) {
				editor = new DefaultCellEditor(new JTextField());
			} else if (value instanceof ExtensionAttribute) {
				editor = new DefaultCellEditor(new JComboBox<ExtensionAttribute>(
						CSVConversionConfig.AVAILABLE_EVENT_EXTENSIONS_ATTRIBUTES));
			} else {
				throw new RuntimeException(""Unkown value type "" + value.getClass().getSimpleName());
			}
			return editor.getTableCellEditorComponent(table, value, isSelected, row, column);
		}
	}

	private final class BatchUpdateDefaultTableModel extends DefaultTableModel {

		private static final long serialVersionUID = 1L;

		private BatchUpdateDefaultTableModel(Vector<String> columnNames, int rowCount) {
			super(columnNames, rowCount);
		}

		@SuppressWarnings(""unchecked"")
		public void addRows(List<String[]> rowData) {
			int firstRow = dataVector.size();
			for (Object[] row : rowData) {
				dataVector.add(convertToVector(row));
			}
			int lastRow = dataVector.size() - 1;
			fireTableRowsInserted(firstRow, lastRow);
		}

	}

	public static class DataTypeTableModel extends AbstractTableModel {

		private static final long serialVersionUID = 1L;

		private final CSVConversionConfig conversionConfig;
		private final String[] header;

		public DataTypeTableModel(CSVConversionConfig conversionConfig, String[] header) {
			this.conversionConfig = conversionConfig;
			this.header = header;
		}

		public int getRowCount() {
			return 5;
		}

		public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
			String columnHeader = header[columnIndex];
			CSVMapping csvMapping = conversionConfig.getConversionMap().get(columnHeader);
			switch (rowIndex) {
				case 0 :
					Datatype newType = (Datatype) aValue;
					if (csvMapping.getDataType() != newType) {
						csvMapping.setPattern("""");
						fireTableCellUpdated(1, columnIndex);
					}
					csvMapping.setDataType(newType);
					break;
				case 1 :
					csvMapping.setPattern((String) aValue);
					break;
				case 2 :
					csvMapping.setTraceAttributeName((String) aValue);
					break;
				case 3 :
					if (aValue != null) {
						ExtensionAttribute extAttr = (ExtensionAttribute) aValue;
						if (extAttr != CSVConversionConfig.NO_EXTENSION_ATTRIBUTE) {
							csvMapping.setEventExtensionAttribute(extAttr);
							csvMapping.setEventAttributeName(extAttr.key);
						} else {
							csvMapping.setEventExtensionAttribute(CSVConversionConfig.NO_EXTENSION_ATTRIBUTE);
							csvMapping.setEventAttributeName(nullSafe(columnHeader));
						}
					} else {
						csvMapping.setEventExtensionAttribute(null);
						csvMapping.setEventAttributeName(nullSafe(columnHeader));
					}
					fireTableCellUpdated(4, columnIndex);
					break;
				case 4 :
					csvMapping.setEventAttributeName((String) aValue);
					break;
				default :
					throw new IllegalStateException(""Could not find value at row "" + rowIndex + "" column ""
							+ columnIndex);
			}
			conversionConfig.getConversionMap().put(columnHeader, csvMapping);
		}

		private static String nullSafe(String s) {
			return s == null ? """" : s;
		}

		public Object getValueAt(int rowIndex, int columnIndex) {
			String columnHeader = header[columnIndex];
			CSVMapping csvMapping = conversionConfig.getConversionMap().get(columnHeader);
			switch (rowIndex) {
				case 0 :
					return csvMapping.getDataType();
				case 1 :
					return csvMapping.getPattern();
				case 2 :
					return csvMapping.getTraceAttributeName();
				case 3 :
					return csvMapping.getEventExtensionAttribute();
				case 4 :
					return csvMapping.getEventAttributeName();
			}
			throw new IllegalStateException(""Could not find value at row "" + rowIndex + "" column "" + columnIndex);
		}

		public int getColumnCount() {
			return header.length;
		}

		public String getColumnName(int column) {
			return nullSafe(header[column]);
		}

		public Class<?> getColumnClass(int columnIndex) {
			return super.getColumnClass(columnIndex);
		}

		public boolean isCellEditable(int rowIndex, int columnIndex) {
			return rowIndex == 2 ? false : true;
		}

	}

	private static final long serialVersionUID = 1L;

	private final BatchUpdateDefaultTableModel previewTableModel;
	private final JTable previewTable;
	private final JScrollPane mainScrollPane;

	private JTable datatypeTable;

	public CSVPreviewFrame() {
		this(null);
	}

	public CSVPreviewFrame(String[] header) {
		this(null, null);
	}

	@SuppressWarnings(""serial"")
	public CSVPreviewFrame(String[] header, CSVConversionConfig conversionConfig) {
		super();
		setTitle(""CSV Import: Preview of the Import"");
		getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));

		Vector<String> columnIds = prepareNullSafeColumnNames(header);
		previewTableModel = new BatchUpdateDefaultTableModel(columnIds, 0);
		previewTable = new ProMTableWithoutPanel(previewTableModel);
		previewTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
		Enumeration<TableColumn> columns = previewTable.getColumnModel().getColumns();
		while (columns.hasMoreElements()) {
			final TableColumn column = columns.nextElement();
			column.setPreferredWidth(130);
			column.setCellEditor(new DefaultCellEditor(new JTextField()) {

				protected void fireEditingStopped() {
					this.cancelCellEditing();
					super.fireEditingStopped();
				}

				protected void fireEditingCanceled() {
					super.fireEditingCanceled();
				}

			});
		}
		previewTable.getColumnModel().setColumnSelectionAllowed(false);
		previewTable.getTableHeader().setReorderingAllowed(false);

		mainScrollPane = new ProMScrollPane(previewTable);

		JPanel mainPanel = new JPanel();
		mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.X_AXIS));

		JPanel rightPanel = new JPanel();
		rightPanel.setLayout(new BoxLayout(rightPanel, BoxLayout.Y_AXIS));

		if (conversionConfig != null) {
			TableModel dataModel = new DataTypeTableModel(conversionConfig, header);
			datatypeTable = new JTable(dataModel);
			datatypeTable.setTableHeader(null);
			datatypeTable.setDefaultEditor(Object.class, new MappingCellEditor());
			datatypeTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
			datatypeTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
			ProMScrollPane dataTypeScrollpane = new ProMScrollPane(datatypeTable) {

				public Dimension getPreferredSize() {
					Dimension preferredSize = super.getPreferredSize();
					preferredSize.height = datatypeTable.getPreferredSize().height;
					preferredSize.width = Short.MAX_VALUE;
					return preferredSize;
				}

				public Dimension getMaximumSize() {
					return getPreferredSize();
				}

			};
			dataTypeScrollpane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);
			getMainScrollPane().setHorizontalScrollBar(dataTypeScrollpane.getHorizontalScrollBar());

			previewTable.getColumnModel().addColumnModelListener(new TableColumnModelListener() {

				public void columnSelectionChanged(ListSelectionEvent e) {
				}

				public void columnRemoved(TableColumnModelEvent e) {
				}

				public void columnMoved(TableColumnModelEvent e) {
				}

				public void columnMarginChanged(ChangeEvent e) {
					final TableColumnModel tableColumnModel = previewTable.getColumnModel();
					TableColumnModel dataTypeColumnModel = datatypeTable.getColumnModel();
					for (int i = 0; i < tableColumnModel.getColumnCount(); i++) {
						int w = tableColumnModel.getColumn(i).getWidth();
						dataTypeColumnModel.getColumn(i).setMinWidth(w);
						dataTypeColumnModel.getColumn(i).setMaxWidth(w);
					}
					datatypeTable.doLayout();
					datatypeTable.repaint();
					repaint();
				}

				public void columnAdded(TableColumnModelEvent e) {
				}

			});

			JPanel leftPanel = new JPanel();
			leftPanel.setLayout(new BoxLayout(leftPanel, BoxLayout.Y_AXIS));
			JLabel dataType = new JLabel(""Data Type"");
			leftPanel.add(dataType);
			JLabel dataPattern = new JLabel(""Data Pattern"");
			dataPattern
					.setToolTipText(""<HTML>Pattern describing how to parse the value to the selected data type. </BR>""
							+ ""<ul><li>For 'DATE' this is a pattern parseable by SimpleDateFormat,</li> ""
							+ ""<li>for 'DISCRETE' and 'CONTINUOUS' this is a pattern parseable by DecimalFormat, ""
							+ ""<li>for 'LITERAL' this is parsed by MessageFormat whereby the first parameter {0} is the value in the column itself, and the following parameters {1}-{n} are the values in the other columns starting from the first column (including the selected column itself).<li>""
							+ ""<HTML>"");
			leftPanel.add(dataPattern);
			JLabel traceAttribute = new JLabel(""Trace Attribute"");
			traceAttribute.setToolTipText(""Attribute in the trace (Read-only)"");
			leftPanel.add(traceAttribute);
			JLabel extensionAttribute = new JLabel(""XES Extension"");
			extensionAttribute.setToolTipText(""XES extension that is attached to the attribute."");
			leftPanel.add(extensionAttribute);
			JLabel eventAttribute = new JLabel(""Event Attribute"");
			eventAttribute.setToolTipText(""Attribute name in the event"");
			leftPanel.add(eventAttribute);
			leftPanel.add(Box.createVerticalGlue());
			mainPanel.add(leftPanel);

			rightPanel.add(dataTypeScrollpane);
		}

		rightPanel.add(mainScrollPane);
		mainPanel.add(rightPanel);
		getContentPane().add(mainPanel);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
	}

	private Vector<String> prepareNullSafeColumnNames(String[] header) {
		Vector<String> columnIds = new Vector<String>();
		for (String obj: header) {
			if (obj == null) {
				columnIds.add("""");
			} else {
				columnIds.add(obj);	
			}				
		}
		return columnIds;
	}

	public void showFrame(JComponent parent) {
		GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
		GraphicsDevice[] gs = ge.getScreenDevices();
		if (gs.length > 1) {
			for (int i = 0; i < gs.length; i++) {
				if (gs[i] != parent.getGraphicsConfiguration().getDevice()) {
					JFrame dummy = new JFrame(gs[i].getDefaultConfiguration());
					setLocationRelativeTo(dummy);
					setExtendedState(Frame.MAXIMIZED_BOTH);
					setAlwaysOnTop(false);
					dummy.dispose();
					break;
				}
			}
		} else {
			setLocationRelativeTo(parent);
			setAlwaysOnTop(false);
			setPreferredSize(new Dimension(800, 800));
		}
		setVisible(true);
	}

	public void addRow(String[] data) {
		previewTableModel.addRow(data);
	}

	public void addRows(List<String[]> rows) {
		previewTableModel.addRows(rows);
	}

	public void refresh() {
		if (datatypeTable != null) {
			datatypeTable.repaint();
		}
	}

	public JTable getPreviewTable() {
		return previewTable;
	}

	public JScrollPane getMainScrollPane() {
		return mainScrollPane;
	}

	public void save() {
		if (datatypeTable.isEditing()) {
			datatypeTable.getCellEditor().stopCellEditing();
		}
	}

}
"
CSVPreviewPanel.java,log-6.9.380,"package org.processmining.log.csvimport.ui.preview;

import java.util.Enumeration;
import java.util.List;
import java.util.Vector;

import javax.swing.BoxLayout;
import javax.swing.DefaultCellEditor;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;

import org.processmining.framework.util.ui.widgets.ProMScrollPane;
import org.processmining.framework.util.ui.widgets.ProMTableWithoutPanel;

public final class CSVPreviewPanel extends JPanel {

	private static final long serialVersionUID = 3007836604602201962L;

	private final class BatchUpdateDefaultTableModel extends DefaultTableModel {

		private static final long serialVersionUID = -3423057642229809442L;

		private BatchUpdateDefaultTableModel(Object[] columnNames, int rowCount) {
			super(columnNames, rowCount);
		}

		@SuppressWarnings(""unchecked"")
		public void addRows(List<String[]> rowData) {
			int firstRow = dataVector.size();
			for (String[] row : rowData) {
				dataVector.add(convertToVector(row));
			}
			int lastRow = dataVector.size() - 1;
			fireTableRowsInserted(firstRow, lastRow);
		}
	}

	private final BatchUpdateDefaultTableModel previewTableModel;
	private final JTable previewTable;
	private final JScrollPane mainScrollPane;

	private JTable datatypeTable;

	public CSVPreviewPanel() {
		super();
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setOpaque(false);
		
		previewTableModel = new BatchUpdateDefaultTableModel(null, 0);
		previewTable = new ProMTableWithoutPanel(previewTableModel);
		previewTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
		
		Enumeration<TableColumn> columns = previewTable.getColumnModel().getColumns();
		
		while (columns.hasMoreElements()) {
			final TableColumn column = columns.nextElement();
			column.setPreferredWidth(130);
			column.setCellEditor(new DefaultCellEditor(new JTextField()) {

				private static final long serialVersionUID = -2741181064062738008L;

				protected void fireEditingStopped() {
					this.cancelCellEditing();
					super.fireEditingStopped();
				}

				protected void fireEditingCanceled() {
					super.fireEditingCanceled();
				}

			});
		}
		previewTable.getColumnModel().setColumnSelectionAllowed(false);
		previewTable.getTableHeader().setReorderingAllowed(false);

		mainScrollPane = new ProMScrollPane(previewTable);
		
		add(mainScrollPane);
	}

	public void addRow(String[] data) {
		previewTableModel.addRow(data);
	}

	public void addRows(List<String[]> rows) {
		previewTableModel.addRows(rows);
	}

	public void setHeader(String[] header) {
		if (header == null) {
			previewTable.setTableHeader(null);
		} else {			
			Vector<String> columnIds = new Vector<String>();
			for (String obj: header) {
				if (obj == null) {
					columnIds.add("""");
				} else {
					columnIds.add(obj);	
				}				
			}
			previewTableModel.setColumnIdentifiers(columnIds);
		}
	}

	public void clear() {
		previewTableModel.getDataVector().clear();
		previewTable.repaint();
	}

	public void refresh() {
		if (datatypeTable != null) {
			datatypeTable.repaint();
		}
	}

	public JTable getPreviewTable() {
		return previewTable;
	}

	public JScrollPane getMainScrollPane() {
		return mainScrollPane;
	}

}
"
ClassifierPanel.java,log-6.9.380,"package org.processmining.log.dialogs;

import java.awt.Dimension;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.log.parameters.ClassifierParameter;
import org.processmining.log.parameters.UpdateParameter;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class ClassifierPanel extends JPanel {
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -7242932924333294111L;

	public ClassifierPanel(List<XEventClassifier> classifiers, final ClassifierParameter classifierParameter) {
		this (classifiers, classifierParameter, null);
	}
	
	public ClassifierPanel(List<XEventClassifier> classifiers, final ClassifierParameter classifierParameter, final UpdateParameter updateParameter) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));

		setOpaque(false);
		
		DefaultListModel<XEventClassifier> listModel = new DefaultListModel<XEventClassifier>();
		for (XEventClassifier classifier: classifiers) {
			listModel.addElement(classifier);
		}
		final ProMList<XEventClassifier> list = new ProMList<XEventClassifier>(""Select classifier"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final XEventClassifier defaultClassifier = classifierParameter.getClassifier();
		list.setSelection(defaultClassifier);
		classifierParameter.setClassifier(wrap(defaultClassifier));
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<XEventClassifier> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					classifierParameter.setClassifier(wrap(selected.get(0)));
					if (updateParameter != null) {
						updateParameter.update();
					}
				} else {
					/*
					 * Nothing selected. Revert to selection of default classifier.
					 */
					list.setSelection(defaultClassifier);
					classifierParameter.setClassifier(wrap(defaultClassifier));
					if (updateParameter != null) {
						updateParameter.update();
					}
				}
			}
		});
		list.setPreferredSize(new Dimension(100, 100));
		add(list, ""0, 0"");

	}
	
	private XEventClassifier wrap(XEventClassifier classifier) {
//		if (classifier instanceof StartEndClassifier) {
			return classifier;
//		}
//		return new StartEndClassifier(classifier);
	}

}
"
HighFrequencyFilterDialog.java,log-6.9.380,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.deckfour.xes.model.XLog;
import org.processmining.log.parameters.HighFrequencyFilterParameters;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class HighFrequencyFilterDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 5152781639823196889L;

	public HighFrequencyFilterDialog(XLog eventLog, final HighFrequencyFilterParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30, 30 } };
		setLayout(new TableLayout(size));
		
		add(new ClassifierPanel(eventLog.getClassifiers(), parameters), ""0, 0"");

		final NiceSlider frequenceThresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(""Frequency threshold"", 0, 100,
				parameters.getFrequencyThreshold(), Orientation.HORIZONTAL);
		frequenceThresholdSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setFrequencyThreshold(frequenceThresholdSlider.getSlider().getValue());
			}
		});
		add(frequenceThresholdSlider, ""0, 1"");

		final NiceSlider distanceThresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(""Distance threshold"", 0, 100,
				parameters.getDistanceThreshold(), Orientation.HORIZONTAL);
		distanceThresholdSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setDistanceThreshold(distanceThresholdSlider.getSlider().getValue());
			}
		});
		add(distanceThresholdSlider, ""0, 2"");
	}

}
"
LogCentralityDialog.java,log-6.9.380,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.Dimension;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityParameters;

public class LogCentralityDialog extends JPanel{

	/**
	 * 
	 */
	private static final long serialVersionUID = 8634000584911454942L;

	public LogCentralityDialog(final UIPluginContext context, final XLog log, final LogCentrality centrality, final LogCentralityParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));

		DefaultListModel<XEventClassifier> listModel = new DefaultListModel<XEventClassifier>();
		for (XEventClassifier classifier: log.getClassifiers()) {
			listModel.addElement(classifier);
		}
		final ProMList<XEventClassifier> list = new ProMList<XEventClassifier>(""Select Happy Classifier"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final XEventClassifier defaultClassifier = parameters.getClassifier();
		list.setSelection(defaultClassifier);
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<XEventClassifier> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					parameters.setClassifier(selected.get(0));
				} else {
					/*
					 * Nothing selected. Revert to selection of default classifier.
					 */
					list.setSelection(defaultClassifier);
					parameters.setClassifier(defaultClassifier);
				}
				centrality.setClassifier(context, parameters);
			}
		});
		list.setPreferredSize(new Dimension(100, 100));
		add(list, ""0, 0"");	
	}
}
"
LogCentralityFilterDialog.java,log-6.9.380,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.log.algorithms.LogCentralityVisualizerAlgorithm;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class LogCentralityFilterDialog extends JPanel{

	/**
	 * 
	 */
	private static final long serialVersionUID = 1184378045381402638L;

	private JComponent holder;
	
	public LogCentralityFilterDialog(final UIPluginContext context, final LogCentrality centrality, final LogCentralityFilterParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30, 30 } };
		setLayout(new TableLayout(size));

		holder = new JPanel();
		add(holder, ""0, 0"");
		double holderSize[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		holder.setLayout(new TableLayout(holderSize));
		holder.add((new LogCentralityVisualizerAlgorithm()).apply(centrality, parameters), ""0, 0"");
		
		final NiceSlider percSlider = SlickerFactory.instance().createNiceIntegerSlider(""Select Happy Percentage"", 0, 100,  parameters.getPercentage(),
				Orientation.HORIZONTAL);
		percSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setPercentage(percSlider.getSlider().getValue());
				holder.removeAll();
				holder.add((new LogCentralityVisualizerAlgorithm()).apply(centrality, parameters), ""0, 0"");
				revalidate();
				repaint();
			}
		});
		add(percSlider, ""0, 1"");

		final JCheckBox filterInBox = SlickerFactory.instance().createCheckBox(""Select if Happy (otherwise unhappy)"",
				false);
		filterInBox.setSelected(parameters.isFilterIn());
		filterInBox.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setFilterIn(filterInBox.isSelected());
				holder.removeAll();
				holder.add((new LogCentralityVisualizerAlgorithm()).apply(centrality, parameters), ""0, 0"");
				revalidate();
				repaint();
			}

		});
		filterInBox.setOpaque(false);
		add(filterInBox, ""0, 2"");
		
	}
}
"
LogFrequencyDialog.java,log-6.9.380,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import javax.swing.JPanel;

import org.deckfour.xes.model.XLog;
import org.processmining.log.parameters.LogFrequencyParameters;

public class LogFrequencyDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2707936407167128579L;

	public LogFrequencyDialog(XLog eventLog, final LogFrequencyParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, } };
		setLayout(new TableLayout(size));
		
		add(new ClassifierPanel(eventLog.getClassifiers(), parameters), ""0, 0"");

	}
}"
LowFrequencyFilterDialog.java,log-6.9.380,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.deckfour.xes.model.XLog;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class LowFrequencyFilterDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1217093745565528989L;

	public LowFrequencyFilterDialog(XLog eventLog, final LowFrequencyFilterParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30 } };
		setLayout(new TableLayout(size));
		
		add(new ClassifierPanel(eventLog.getClassifiers(), parameters), ""0, 0"");

		final NiceSlider thresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(""Frequency threshold"", 0, 100,
				parameters.getThreshold(), Orientation.HORIZONTAL);
		thresholdSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setThreshold(thresholdSlider.getSlider().getValue());
			}
		});
		add(thresholdSlider, ""0, 1"");
	}
}
"
LowOccurrencesFilterDialog.java,log-6.9.380,"package org.processmining.log.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.deckfour.xes.model.XLog;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class LowOccurrencesFilterDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 9093478331292093365L;

	public LowOccurrencesFilterDialog(XLog eventLog, final LowOccurrencesFilterParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30 } };
		setLayout(new TableLayout(size));
		
		add(new ClassifierPanel(eventLog.getClassifiers(), parameters), ""0, 0"");

		final NiceSlider thresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(""Occurrence threshold"", 0, 100,
				parameters.getThreshold(), Orientation.HORIZONTAL);
		thresholdSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setThreshold(thresholdSlider.getSlider().getValue());
			}
		});
		add(thresholdSlider, ""0, 1"");
	}
}
"
MergeLogsDialog.java,log-6.9.380,"package org.processmining.log.dialogs;

import java.awt.Dimension;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.log.parameters.MergeLogsParameters;
import org.processmining.log.utils.MergeLogsUtils;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class MergeLogsDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -5486690145975904628L;

	public MergeLogsDialog(final MergeLogsParameters parameters, final XLog log) {
		double size[][] = { { 100, 700 }, { 30, TableLayoutConstants.FILL, 30, 30, 30, 30, 30, 30, 30 } };
		setLayout(new TableLayout(size));
		int row = 0;
		DateFormat df;
		final Collection<String> ids = new HashSet<String>();
		for (XTrace trace : log) {
			String id = XConceptExtension.instance().extractName(trace);
			if (id != null) {
				ids.add(id);
			}
		}
		
		final ProMTextField idField = new ProMTextField(parameters.getTraceId());
		idField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				String value = idField.getText().trim();
				if (value.isEmpty() || !ids.contains(value)) {
					value = null;
				} 
				parameters.setTraceId(value);
				idField.visualizeStatus(idField.getText().trim().isEmpty() || value != null);
			}
		});
		add(new JLabel(""Choose Trace ID""), ""0, "" + row);
		add(idField, ""1, "" + row);
		row++;

		DefaultListModel<String> listModel = new DefaultListModel<String>();
		listModel.addElement(parameters.getDateFormat());
		listModel.addElement(""MM/dd/yyyy HH:mm:ss"");
		listModel.addElement(""MM/dd/yyyy hh:mm"");
		listModel.addElement(""MM/dd/yyyy hh:mm:ss"");
		listModel.addElement(""MM/dd/yyyy"");
		listModel.addElement(""dd/MM/yyyy HH:mm"");
		listModel.addElement(""dd/MM/yyyy HH:mm:ss"");
		listModel.addElement(""dd/MM/yyyy hh:mm"");
		listModel.addElement(""dd/MM/yyyy hh:mm:ss"");
		listModel.addElement(""dd/MM/yyyy"");
		listModel.addElement(""dd-MMM-yyyy HH:mm"");
		listModel.addElement(""dd-MMM-yyyy HH:mm:ss"");
		listModel.addElement(""dd-MMM-yyyy hh:mm"");
		listModel.addElement(""dd-MMM-yyyy hh:mm:ss"");
		listModel.addElement(""dd-MMM-yyyy"");
		listModel.addElement(""MM/dd/yy HH:mm"");
		listModel.addElement(""MM/dd/yy HH:mm:ss"");
		listModel.addElement(""MM/dd/yy hh:mm"");
		listModel.addElement(""MM/dd/yy hh:mm:ss"");
		listModel.addElement(""MM/dd/yy"");
		listModel.addElement(""dd/MM/yy HH:mm"");
		listModel.addElement(""dd/MM/yy HH:mm:ss"");
		listModel.addElement(""dd/MM/yy hh:mm"");
		listModel.addElement(""dd/MM/yy hh:mm:ss"");
		listModel.addElement(""dd/MM/yy"");
		listModel.addElement(""dd-MMM-yy HH:mm"");
		listModel.addElement(""dd-MMM-yy HH:mm:ss"");
		listModel.addElement(""dd-MMM-yy hh:mm"");
		listModel.addElement(""dd-MMM-yy hh:mm:ss"");
		listModel.addElement(""dd-MMM-yy"");
		final ProMList<String> list = new ProMList<String>(""Select date format"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final String defaultConfiguration = parameters.getDateFormat();
		list.setSelection(defaultConfiguration);
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					parameters.setDateFormat(selected.get(0));
				} else {
					/*
					 * Nothing selected. Revert to selection of default classifier.
					 */
					list.setSelection(defaultConfiguration);
					parameters.setDateFormat(defaultConfiguration);
				}
			}
		});
		list.setPreferredSize(new Dimension(10, 10));
		add(list, ""0, "" + row + "", 1, "" + row);
		row++;

		String fromDate = """";
		df = new SimpleDateFormat(parameters.getDateFormat());
		if (parameters.getFromDate() != null) {
			fromDate = df.format(parameters.getFromDate());
		}
		final ProMTextField fromField = new ProMTextField(fromDate);
		fromField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				Date date = MergeLogsUtils.getDate(parameters, fromField.getText().trim());
				parameters.setFromDate(date);
				fromField.visualizeStatus(fromField.getText().trim().isEmpty() || date != null); 
			}
			
		});
		add(new JLabel(""From Date""), ""0, "" + row);
		add(fromField, ""1, "" + row);
		row++;

		String toDate = """";
		df = new SimpleDateFormat(parameters.getDateFormat());
		if (parameters.getToDate() != null) {
			toDate = df.format(parameters.getToDate());
		}
		final ProMTextField toField = new ProMTextField(toDate);
		toField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				Date date = MergeLogsUtils.getDate(parameters, toField.getText().trim());
				parameters.setToDate(date);
				toField.visualizeStatus(toField.getText().trim().isEmpty() || date != null); 
			}
			
		});
		add(new JLabel(""To Date""), ""0, "" + row);
		add(toField, ""1, "" + row);
		row++;

		String specificDate = """";
		df = new SimpleDateFormat(parameters.getDateFormat());
		if (parameters.getSpecificDate() != null) {
			specificDate = df.format(parameters.getSpecificDate());
		}
		final ProMTextField specificField = new ProMTextField(specificDate);
		specificField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				Date date = MergeLogsUtils.getDate(parameters, specificField.getText().trim());
				parameters.setSpecificDate(date);
				specificField.visualizeStatus(specificField.getText().trim().isEmpty() || date != null); 
			}
			
		});
		add(new JLabel(""Specific Date""), ""0, "" + row);
		add(specificField, ""1, "" + row);
		row++;

		final ProMTextField requiredField = new ProMTextField(parameters.getRequiredWords());
		requiredField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				String value = requiredField.getText().trim();
				if (value.isEmpty()) {
					value = null;
				}
				parameters.setRequiredWords(requiredField.getText());
			}
			
		});
		add(new JLabel(""Required Words""), ""0, "" + row);
		add(requiredField, ""1, "" + row);
		row++;

		final ProMTextField forbiddenField = new ProMTextField(parameters.getForbiddenWords());
		forbiddenField.addKeyListener(new KeyListener() {

			public void keyPressed(KeyEvent e) {
			}

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				String value = forbiddenField.getText().trim();
				if (value.isEmpty()) {
					value = null;
				}
				parameters.setForbiddenWords(value);
			}
			
		});
		add(new JLabel(""Forbidden Words""), ""0, "" + row);
		add(forbiddenField, ""1, "" + row);
		row++;


		final NiceSlider clusterSlider = SlickerFactory.instance().createNiceIntegerSlider(""Set related"", 0, 100,
				parameters.getRelated(), Orientation.HORIZONTAL);
		clusterSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setRelated(clusterSlider.getSlider().getValue());
			}
		});
		add(clusterSlider, ""0, ""+ row + "", 1, "" + row);
		row++;


		final NiceSlider wordSlider = SlickerFactory.instance().createNiceIntegerSlider(""Set matching words"", 0, 100,
				parameters.getMinMatches(), Orientation.HORIZONTAL);
		clusterSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				parameters.setMinMatches(wordSlider.getSlider().getValue());
			}
		});
		add(wordSlider, ""0, ""+ row + "", 1, "" + row);
		row++;

		
	}
	
}
"
MinerPanel.java,log-6.9.380,"package org.processmining.log.dialogs;

import java.awt.Dimension;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.log.parameters.MinerParameter;
import org.processmining.log.parameters.UpdateParameter;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class MinerPanel extends JPanel {
	
	/**
	 * 
	 */
	private static final long serialVersionUID = 7656913719419272750L;

	public MinerPanel(List<String> miners, final MinerParameter minerParameter) {
		this(miners, minerParameter, null);
	}
	
	public MinerPanel(List<String> miners, final MinerParameter minerParameter, final UpdateParameter updateParameter) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));

		setOpaque(false);
		
		DefaultListModel<String> listModel = new DefaultListModel<String>();
		for (String miner: miners) {
			listModel.addElement(miner);
		}
		final ProMList<String> list = new ProMList<String>(""Select miner"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final String defaultMiner = minerParameter.getMiner();
		list.setSelection(defaultMiner);
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					minerParameter.setMiner(selected.get(0));
					if (updateParameter != null) {
						updateParameter.update();
					}
				} else {
					/*
					 * Nothing selected. Revert to selection of default classifier.
					 */
					list.setSelection(defaultMiner);
					minerParameter.setMiner(defaultMiner);
					if (updateParameter != null) {
						updateParameter.update();
					}
				}
			}
		});
		list.setPreferredSize(new Dimension(100, 100));
		add(list, ""0, 0"");

	}

}
"
SplitLogDialog.java,log-6.9.380,"package org.processmining.log.dialogs;

import java.awt.Dimension;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import javax.swing.DefaultListModel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.log.parameters.SplitLogParameters;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class SplitLogDialog extends JPanel{

	/**
	 * 
	 */
	private static final long serialVersionUID = -5028679044691450395L;

	public SplitLogDialog(final SplitLogParameters parameters, XLog log) {
		double size[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));
		DefaultListModel<String> listModel = new DefaultListModel<String>();
		Set<String> keys = new TreeSet<String>();
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				for (XAttribute attribute : event.getAttributes().values()) {
					if (attribute instanceof XAttributeLiteral) {
						keys.add(attribute.getKey());
					}
				}
			}
		}
		for (String key : keys) {
			listModel.addElement(key);
		}
		final ProMList<String> list = new ProMList<String>(""Select attribute key"", listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		final String defaultKey = parameters.getKey();
		list.setSelection(defaultKey);
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selected = list.getSelectedValuesList();
				if (selected.size() == 1) {
					parameters.setKey(selected.get(0));
				} else {
					/*
					 * Nothing selected. Revert to selection of default key.
					 */
					list.setSelection(defaultKey);
					parameters.setKey(defaultKey);
				}
			}
		});
		list.setPreferredSize(new Dimension(10, 10));
		add(list, ""0, 0"");		
	}
}
"
FileFormat.java,log-6.9.380,"package org.processmining.log;

/**
 * @see LogFileFormat
 */
@Deprecated
public enum FileFormat {
	XES(""xes""), XES_GZ(""xes.gz""), MXML(""mxml""), MXML_GZ(""mxml.gz"");

	private String desc;

	private FileFormat(String desc) {
		this.desc = desc;
	}

	@Override
	public String toString() {
		return desc;
	}
}
"
AddIdentityFilter.java,log-6.9.380,"
package org.processmining.log.filters;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import org.deckfour.xes.extension.std.XIdentityExtension;
import org.deckfour.xes.id.XID;
import org.deckfour.xes.id.XIDFactory;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeID;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.xes.extensions.id.IdentityConnection;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XEventEditor;
import org.processmining.plugins.log.logfilters.XTraceEditor;

public class AddIdentityFilter implements XEventEditor, XTraceEditor {

	public static XLog addIdentities(PluginContext context, XLog log) {
		AddIdentityFilter af = new AddIdentityFilter(log);

		try {
			return af.filter(context);
		} catch (LogFilterException e) {
			e.printStackTrace();
		}

		return null;
	}

	protected AddIdentityFilter(XLog log) {
		this.log = log;
	}

	private XLog log;

	public XLog filter(PluginContext context) throws LogFilterException {
		idmapping = new HashMap<String, XAttributable>();

		attributeValueMapping = new HashMap<String, Map<Object, XID>>();

		addIdentity(log);
		XLog filtered = LogFilter.filter(context.getProgress(), log.size(), log, null, this, this);
		//create connection
		context.addConnection(getConnection(filtered));

		return filtered;
	}

	public IdentityConnection getConnection(XLog filtered) {
		return new IdentityConnection(filtered, idmapping);
	}

	public XTrace editTrace(XTrace trace) {
		addIdentity(trace);
		return trace;
	}

	public XEvent editEvent(XEvent event) {
		XEvent editedEvent = (XEvent) event.clone();
		addIdentity(editedEvent);

		return editedEvent;
	}

	private Map<String, XAttributable> idmapping;

	private void addIdentity(XAttributable target) {
		//if I'm the identity, ignore me!
		if (target instanceof XAttribute) {
			if (((XAttribute) target).getKey() == XIdentityExtension.KEY_ID) {
				return;
			}
		}

		//first add an identity to my kids...
		for (Entry<String, XAttribute> attr : target.getAttributes().entrySet()) {
			addIdentity(attr.getValue());
		}

		//then to me
		XID id = XIdentityExtension.instance().extractID(target);
		if (id == null) {

			//first check, whether ""I""already have an id in my attribute mapping...
			if (target instanceof XAttribute) {
				id = getIdFromMemory((XAttribute) target);
			} else {
				id = XIDFactory.instance().createId();
			}
		}
		XIdentityExtension.instance().assignID(target, id);

		//store the mapping
		idmapping.put(id.toString(), target);
	}

	private Map<String, Map<Object, XID>> attributeValueMapping;

	private XID getIdFromMemory(XAttribute attr) {
		String key = attr.getKey();

		Map<Object, XID> values = attributeValueMapping.get(key);
		if (values == null) {
			values = new HashMap<Object, XID>();
			attributeValueMapping.put(key, values);
		}

		Object value = getValueOf(attr);
		XID id = values.get(value);
		if (id == null) {
			id = XIDFactory.instance().createId();
			values.put(value, id);
		}

		return id;
	}

	private Object getValueOf(XAttribute attr) {

		if (attr instanceof XAttributeBoolean) {
			return ((XAttributeBoolean) attr).getValue();
		} else if (attr instanceof XAttributeContinuous) {
			return ((XAttributeContinuous) attr).getValue();
		} else if (attr instanceof XAttributeDiscrete) {
			return ((XAttributeDiscrete) attr).getValue();
		} else if (attr instanceof XAttributeTimestamp) {
			return ((XAttributeTimestamp) attr).getValue();
		} else if (attr instanceof XAttributeLiteral) {
			return ((XAttributeLiteral) attr).getValue();
		} else if (attr instanceof XAttributeID) {
			return ((XAttributeID) attr).getValue();
		} else {
			return new Object();
		}
	}

}
"
ExtensionFilter.java,log-6.9.380,"package org.processmining.log.filters;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Set;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.Progress;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XEventEditor;
import org.processmining.plugins.log.logfilters.XTraceEditor;

/**
 * 
 * 
 * 
 * @author jvdwerf
 *
 */
public class ExtensionFilter implements XEventEditor, XTraceEditor {

	public static XLog removeExtensions(XLog log, XExtension extension) {		
		return removeExtensions(null, log, extension);
	}
	
	public static XLog removeExtensions(XLog log, String extension) {		
		return removeExtensions(null, log, extension);
	}
	
	
	public static XLog removeExtensions(Progress progress, XLog log, XExtension extension) {
		return removeExtensions(progress, log, extension.getName());
	}
	
	public static XLog removeExtensions(Progress progress, XLog log, String extension) {
		Set<String> names = new HashSet<String>();
		names.add(extension);
		
		return removeExtensions(progress, log, names);
	}
	
	public static XLog removeExtensions(Progress progress, XLog log, String... extensions) {
		return removeExtensions(progress, log, Arrays.asList(extensions));
	}
	
	public static XLog removeExtensions(Progress progress, XLog log, Collection<String> extensions) {

		ExtensionFilter ef = new ExtensionFilter((XLog) log.clone());
		
		try {
			return ef.filter(progress, extensions);
			
		} catch (LogFilterException e) {
			e.printStackTrace();
		}
		
		return null;
	}
	
	//////
	///
	
	private Set<String> attrKeys;
	private Set<String> logKeys;
	private Set<String> traceKeys;
	private Set<String> eventKeys;
	
	private XLog log;
	
	public ExtensionFilter(XLog log) {
		this.log = log;
	}
	
	public XLog getLog() {
		return log;
	}
	
	public XLog filter(Progress progress, Collection<String> extensions) throws LogFilterException {
		
		//set the attribute sets, and remove extensions from log
		prepareExtensionList(extensions);
		
		removeAttributes(log, logKeys);
		
		return LogFilter.filter(progress, log.size(), log, null, this, this);
	}
	
	private void prepareExtensionList(Collection<String> extensions) {
		attrKeys = new HashSet<String>();
		logKeys = new HashSet<String>();
		traceKeys = new HashSet<String>();
		eventKeys = new HashSet<String>();
		
		Collection<XExtension> tbr = new ArrayList<XExtension>();
		
		for(XExtension ext : log.getExtensions()) {
			if (extensions.contains(ext.getName())) {
				for(XAttribute attr : ext.getLogAttributes()) {
					logKeys.add(attr.getKey());
				}
				for(XAttribute attr : ext.getTraceAttributes()) {
					traceKeys.add(attr.getKey());
				}
				for(XAttribute attr : ext.getEventAttributes()) {
					eventKeys.add(attr.getKey());
				}
				for(XAttribute attr : ext.getMetaAttributes()) {
					attrKeys.add(attr.getKey());
				}
				
				tbr.add(ext);
			}
		}
		
		log.getExtensions().removeAll(tbr);
	}
	
	public XTrace editTrace(XTrace trace) {
		
		removeAttributes(trace, traceKeys);
		
		return trace;
	}

	public XEvent editEvent(XEvent event) {
		XEvent editedEvent = (XEvent) event.clone();
		
		removeAttributes(editedEvent, eventKeys);
		
		return editedEvent;
	}
	
	private void removeAttributes(XAttributable target, Set<String> items) {
		for(String key : items) {
			target.getAttributes().remove(key);
		}
		for(Entry<String,XAttribute> attr : target.getAttributes().entrySet()) {
			removeAttributes(attr.getValue(), attrKeys);
		}
	}
	
	
	
	
}
"
AddIdentityFilterUI.java,log-6.9.380,"package org.processmining.log.filters.ui;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.filters.AddIdentityFilter;

@Plugin(name = ""Add identity attribute"", returnLabels = { ""Log with identities"" }, returnTypes = {
		XLog.class }, parameterLabels = { ""Log"" })
public class AddIdentityFilterUI {

	@UITopiaVariant(uiLabel = ""Add identities to log"", affiliation = UITopiaVariant.EHV, author = ""J.M.E.M. van der Werf"", email = ""j.m.e.m.v.d.werf@tue.nl"", pack = ""Ontologies"")
	@PluginVariant(variantLabel = ""Add identities to log"", requiredParameterLabels = { 0 })
	public XLog addIdentitiesUI(UIPluginContext context, XLog log) {
		return addIdentities(context, log);
	}

	@PluginVariant(variantLabel = ""Add identities to log"", requiredParameterLabels = { 0 })
	public XLog addIdentities(PluginContext context, XLog log) {
		XLog filtered = AddIdentityFilter.addIdentities(context, log);
		if (filtered != null) {
			String name = XConceptExtension.instance().extractName(log);
			if (name == null) {
				name = ""Log"";
			}
			context.getFutureResult(0).setLabel(name + "" with identities"");
			return filtered;
		} else {
			context.getFutureResult(0).cancel(true);
			return null;
		}
	}

}
"
ExtensionFilterUI.java,log-6.9.380,"package org.processmining.log.filters.ui;

import java.util.HashSet;
import java.util.Set;

import javax.swing.DefaultListModel;
import javax.swing.JComponent;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.framework.util.ui.widgets.ProMPropertiesPanel;
import org.processmining.framework.util.ui.wizard.ListWizard;
import org.processmining.framework.util.ui.wizard.ProMWizardDisplay;
import org.processmining.framework.util.ui.wizard.ProMWizardStep;
import org.processmining.log.filters.ExtensionFilter;

@Plugin(name = ""Extension Filter"", returnLabels = { ""Filtered log"" }, returnTypes = { XLog.class }, parameterLabels = {
		""Log"" })
public class ExtensionFilterUI {

	@UITopiaVariant(uiLabel = ""Remove extensions from log"", affiliation = UITopiaVariant.EHV, author = ""J.M.E.M. van der Werf"", email = ""j.m.e.m.v.d.werf@tue.nl"", pack = ""Ontologies"")
	@PluginVariant(variantLabel = ""Remove extensions from log"", requiredParameterLabels = { 0 })
	public XLog removeExtensions(final UIPluginContext context, final XLog log) {

		Step wizardStep = new Step(log);
		ListWizard<Set<String>> wizard = new ListWizard<Set<String>>(wizardStep);

		Set<String> extensions = ProMWizardDisplay.show(context, wizard, new HashSet<String>());

		if (extensions == null || extensions.size() == 0) {
			context.getFutureResult(0).cancel(true);
			return null;
		}

		return ExtensionFilter.removeExtensions(context.getProgress(), log, extensions);
	}

	/*
	 * ProMPropertiesPanel props = new ProMPropertiesPanel(""Remove extensions"");
	 * //ProMList extList = new ProMList(""Extensions"", listModel);
	 * props.add(extList);
	 * 
	 */
	private class Step implements ProMWizardStep<Set<String>> {

		public String getTitle() {
			return ""Remove extensions"";
		}

		private ProMPropertiesPanel panel;
		private ProMList listbox;

		public Step(XLog log) {
			panel = new ProMPropertiesPanel(null);

			DefaultListModel model = new DefaultListModel();

			for (XExtension ext : log.getExtensions()) {
				model.addElement(ext.getName());
			}

			//add a list
			listbox = new ProMList(""Extensions"", model);
			panel.addProperty(""Extensions to be removed"", listbox);
		}

		public JComponent getComponent(Set<String> model) {

			listbox.setSelection(model);

			return panel;
		}

		public Set<String> apply(Set<String> model, JComponent component) {
			//set the model to all selected items.
			Set<String> items = new HashSet<String>();
			for (Object o : listbox.getSelectedValues()) {
				items.add((String) o);
			}
			return items;
		}

		public boolean canApply(Set<String> model, JComponent component) {
			return true;
		}

	}

}
"
StandardDateFormats.java,log-6.9.380,"package org.processmining.log.formats;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedHashSet;
import java.util.Set;

/**
 * Standard formats for Dates that might be encountered in log data, e.g. in CSV
 * format.
 */
public final class StandardDateFormats {

	@SuppressWarnings(""serial"")
	private static final Set<SimpleDateFormat> STANDARD_DATE_FORMATS = new LinkedHashSet<SimpleDateFormat>() {
		{
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm:ss""));
			add(new SimpleDateFormat(""yyyy-M-d H:mm""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm:ss""));
			add(new SimpleDateFormat(""yyyy-M-d'T'H:mm""));
			add(new SimpleDateFormat(""yyyy-M-d""));

			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy-MM-dd HH:mm""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm""));
			add(new SimpleDateFormat(""yyyy-MM-dd""));

			add(new SimpleDateFormat(""yyyy/M/d H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm:ss""));
			add(new SimpleDateFormat(""yyyy/M/d H:mm""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm:ss""));
			add(new SimpleDateFormat(""yyyy/M/d'T'H:mm""));
			add(new SimpleDateFormat(""yyyy/M/d""));

			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy/MM/dd HH:mm""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy/MM/dd'T'HH:mm""));
			add(new SimpleDateFormat(""yyyy/MM/dd""));

			add(new SimpleDateFormat(""M/d/yyyy H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ss.SSS""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ssXXX""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ssz""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm:ss""));
			add(new SimpleDateFormat(""M/d/yyyy H:mm""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ss.SSS""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ssXXX""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ssz""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm:ss""));
			add(new SimpleDateFormat(""M/d/yyyy'T'H:mm""));
			add(new SimpleDateFormat(""M/d/yyyy""));

			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ssXXX""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ssz""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""MM/dd/yyyy HH:mm""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ssXXX""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ssz""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm:ss""));
			add(new SimpleDateFormat(""MM/dd/yyyy'T'HH:mm""));
			add(new SimpleDateFormat(""MM/dd/yyyy""));
			
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ssXXX""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ssz""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""dd/MM/yyyy HH:mm""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ssXXX""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ssz""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm:ss""));
			add(new SimpleDateFormat(""dd/MM/yyyy'T'HH:mm""));	

			add(new SimpleDateFormat(""yyyy.M.d H:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ssz""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm:ss""));
			add(new SimpleDateFormat(""yyyy.M.d H:mm""));

			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ssXXX""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ssz""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss""));
			add(new SimpleDateFormat(""yyyy.MM.dd HH:mm""));
			
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ss.SSSXXX""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ss.SSSz""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ss.SSS""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ssXXX""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ssz""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""dd.MM.yyyy HH:mm""));

			add(new SimpleDateFormat(""d-M-yyyy:H:mm:ss""));
			add(new SimpleDateFormat(""EEE, d MMM yyyy H:mm:ss z""));
			add(new SimpleDateFormat(""M-d-yyyy H:mm:ss""));
			add(new SimpleDateFormat(""M-d-yyyy H:mm""));
			add(new SimpleDateFormat(""M-d-yyyy""));
			add(new SimpleDateFormat(""d-M-yyyy H:mm:ss""));
			add(new SimpleDateFormat(""d-M-yyyy H:mm""));
			add(new SimpleDateFormat(""d-M-yyyy""));

			add(new SimpleDateFormat(""dd-MM-yyyy:HH:mm:ss""));
			add(new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss z""));
			add(new SimpleDateFormat(""MM-dd-yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""MM-dd-yyyy HH:mm""));
			add(new SimpleDateFormat(""MM-dd-yyyy""));
			add(new SimpleDateFormat(""dd-MM-yyyy HH:mm:ss""));
			add(new SimpleDateFormat(""dd-MM-yyyy HH:mm""));
			add(new SimpleDateFormat(""dd-MM-yyyy""));
			
			add(new SimpleDateFormat(""dd.MM.yyyy HH.mm""));
		}
	};

	static {
		for (DateFormat df : STANDARD_DATE_FORMATS) {
			df.setLenient(false);
		}
	}

	private StandardDateFormats() {
		super();
	}

	/**
	 * @return {@link SimpleDateFormat} for various {@link Date} patterns in
	 *         order from most specific to least specific.
	 */
	public static Iterable<SimpleDateFormat> getStandardDateFormats() {
		return STANDARD_DATE_FORMATS;
	}

}
"
HighFrequencyFilterArrayHelp.java,log-6.9.380,"package org.processmining.log.help;

public class HighFrequencyFilterArrayHelp {

	public final static String TEXT = """"
			+ ""Filters every log in the array using a frequency threshold (a percentage) and a distance threshold (edit distance). ""
			+ ""Any trace that either<ol>""
			+ ""<li>has a high-enough frequency or</li>""
			+ ""<li>is close enough to a trace with high-enough frequency</li>""
			+ ""</ol>will be filtered in. ""
			+ ""A trace has high-enough frequency if its frequency is required to reach the overall frequency threshold."";

}
"
HighFrequencyFilterHelp.java,log-6.9.380,"package org.processmining.log.help;

public class HighFrequencyFilterHelp {

	public final static String TEXT = """"
			+ ""Filters a log using a frequency threshold (a percentage) and a distance threshold (edit distance). ""
			+ ""Any trace that either<ol>""
			+ ""<li>has a high-enough frequency or</li>""
			+ ""<li>is close enough to a trace with high-enough frequency</li>""
			+ ""</ol>will be filtered in. ""
			+ ""A trace has high-enough frequency if its frequency is required to reach the overall frequency threshold."";

}
"
LogCentralityFilterHelp.java,log-6.9.380,"package org.processmining.log.help;

public class LogCentralityFilterHelp {

	public final static String TEXT = """"
			+ ""Filters a log using a centrality threshold (edit distance). ""
			+ ""Any trace that is close enough to the centre will be filtered in."";

}
"
LogCentralityHelp.java,log-6.9.380,"package org.processmining.log.help;

public class LogCentralityHelp {

	public final static String TEXT = """"
			+ ""Extends the log with centrality information, that is, with distances between all traces."";

}
"
LogCheckerHelp.java,log-6.9.380,"package org.processmining.log.help;

public class LogCheckerHelp {

	public final static String TEXT = """"
			+ ""Checks a log for common problems."";
}
"
LogFrequencyArrayHelp.java,log-6.9.380,"package org.processmining.log.help;

public class LogFrequencyArrayHelp {

	public final static String TEXT = """"
			+ ""Builds frequency overviews (how often traces occur) for every log in the array. ""
			+ ""The classifier provided determines which traces are considered equal."";

}
"
LogFrequencyHelp.java,log-6.9.380,"package org.processmining.log.help;

public class LogFrequencyHelp {

	public final static String TEXT = """"
			+ ""Filters a log using a frequency threshold (a percentage). ""
			+ ""Any trace that has a high-enough frequency will be filtered in. ""
			+ ""A trace has high-enough frequency if its frequency is required to reach the overall frequency threshold."";

}
"
LowFrequencyFilterArrayHelp.java,log-6.9.380,"package org.processmining.log.help;

public class LowFrequencyFilterArrayHelp {

	public final static String TEXT = """"
			+ ""Filters every log in the array using a frequency threshold. ""
			+ ""Traces that do not appear frequent enough, will be filtered out."";

}
"
LowFrequencyFilterHelp.java,log-6.9.380,"package org.processmining.log.help;

public class LowFrequencyFilterHelp {

	public final static String TEXT = """"
			+ ""Filters a log using a frequency threshold. ""
			+ ""Traces that do not appear frequent enough, will be filtered out. "";

}
"
LowOccurrencesFilterArrayHelp.java,log-6.9.380,"package org.processmining.log.help;

public class LowOccurrencesFilterArrayHelp {

	public final static String TEXT = """"
			+ ""Filters every log in the array using an absolute threshold. ""
			+ ""Traces that do not appear often enough, will be filtered out. "";

}
"
LowOccurrencesFilterHelp.java,log-6.9.380,"package org.processmining.log.help;

public class LowOccurrencesFilterHelp {

	public final static String TEXT = """"
			+ ""Filters a log using an absolute threshold. ""
			+ ""Traces that do not appear often enough, will be filtered out. "";

}
"
MergeLogsHelp.java,log-6.9.380,"package org.processmining.log.help;

public class MergeLogsHelp {

	public final static String TEXT = """"
			+ ""Merges two logs."";
}
"
SplitLogHelp.java,log-6.9.380,"package org.processmining.log.help;

public class SplitLogHelp {

	public final static String TEXT = """"
			+ ""Splits traces in a log on a selected event attribute. ""
			+ ""If the attribute exists for an event, then it is assumed to be a white-space spearated list of values. ""
			+ ""A trace will be split into as many subtraces as there are values in its events for the selected attribute. ""
			+ ""The subtrace for a given value contains (in the same order as in the trace) all events that: ""
			+ ""(1) either contain this value in the attribute value or (2) have no such attribute."";
}
"
LogCheckConsistentTypes.java,log-6.9.380,"package org.processmining.log.logchecks.impl;

import java.util.HashMap;
import java.util.Map;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeID;
import org.deckfour.xes.model.XAttributeList;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.logchecks.LogCheck;
import org.processmining.log.models.LogCheckerReport;

public class LogCheckConsistentTypes implements LogCheck {

	private enum Type {
		LITERAL(""string""), //
		DISCRETE(""int""), //
		CONTINUOUS(""double""), //
		TIMESTAMP(""date""), // 
		BOOLEAN(""boolean""), //
		ID(""id""), //
		LIST(""list""), //
		UNKNOWN(""unknown""); //

		private String label;

		Type(String label) {
			this.label = label;
		}

		public String toString() {
			return label;
		}
	};

	private static LogCheck instance;

	private LogCheckConsistentTypes() {

	}

	public static LogCheck getInstance() {
		if (instance == null) {
			instance = new LogCheckConsistentTypes();
		}
		return instance;
	}

	public boolean checkTraces(PluginContext context, XLog log, LogCheckerReport report) {
		boolean allOk = true;
		Map<String, Type> traceAttributeTypes = new HashMap<String, Type>();
		for (XAttribute attribute : log.getGlobalTraceAttributes()) {
			Type existingType = traceAttributeTypes.get(attribute.getKey());
			Type type = getType(attribute);
			if (existingType == null) {
				traceAttributeTypes.put(attribute.getKey(), type);
			} else if (type != existingType) {
				report.add(allOk ? ""<h2>Inconsistent types for trace attribute</h2><ul>"" : """");
				report.add(""<li>Global attribute key "" + attribute.getKey() + "": "" + type + "" vs. "" + existingType + ""</li>"");
				allOk = false;
			}
		}
		int traceCtr = 0;
		for (XTrace trace : log) {
			for (XAttribute attribute : trace.getAttributes().values()) {
				Type existingType = traceAttributeTypes.get(attribute.getKey());
				Type type = getType(attribute);
				if (existingType == null) {
					traceAttributeTypes.put(attribute.getKey(), type);
				} else if (type != existingType) {
					String traceId = "" at position "" + traceCtr;
					if (trace.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
						traceId = XConceptExtension.instance().extractName(trace) + "" "" + traceId;
					} else {
						traceId = ""<i>unknown</i> "" + traceId;
					}
					report.add(allOk ? ""<h2>Inconsistent types for trace attribute</h2><ul>"" : """");
					report.add(""<li>Trace "" + traceId + "", attribute key "" + attribute.getKey() + "": "" + type + "" vs. "" + existingType + ""</li>"");
					allOk = false;
				}
			}
			traceCtr++;
		}
		report.add(allOk ? """" : ""</ul>"");
		return allOk;
	}

	public boolean checkEvents(PluginContext context, XLog log, LogCheckerReport report) {
		boolean allOk = true;
		Map<String, Type> eventAttributeTypes = new HashMap<String, Type>();
		for (XAttribute attribute : log.getGlobalEventAttributes()) {
			Type existingType = eventAttributeTypes.get(attribute.getKey());
			Type type = getType(attribute);
			if (existingType == null) {
				eventAttributeTypes.put(attribute.getKey(), type);
			} else if (type != existingType) {
				report.add(allOk ? ""<h2>Inconsistent types for event attribute</h2><ul>"" : """");
				report.add(""<li>Attribute key "" + attribute.getKey() + "": "" + type + "" vs. "" + existingType + ""</li>"");
				allOk = false;
			}
		}
		int traceCtr = 0;
		for (XTrace trace : log) {
			int eventCtr = 0;
			for (XEvent event : trace) {
				for (XAttribute attribute : event.getAttributes().values()) {
					Type existingType = eventAttributeTypes.get(attribute.getKey());
					Type type = getType(attribute);
					if (existingType == null) {
						eventAttributeTypes.put(attribute.getKey(), getType(attribute));
					} else if (type != existingType) {
						String traceId = "" at position "" + traceCtr;
						if (trace.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
							traceId = XConceptExtension.instance().extractName(trace) + "" "" + traceId;
						} else {
							traceId = ""<i>unknown</i> "" + traceId;
						}
						String eventId = "" at position "" + eventCtr;
						if (event.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
							eventId = XConceptExtension.instance().extractName(event) + "" "" + eventId;
						} else {
							eventId = ""<i>unknown</i> "" + eventId;
						}
						report.add(allOk ? ""<h2>Inconsistent types for event attribute</h2><ul>"" : """");
						report.add(""<li>Trace "" + traceId + "", event "" + eventId + "", attribute key "" + attribute.getKey() + "": "" + type + "" vs. "" + existingType + ""</li>"");
						allOk = false;
					}
				}
				eventCtr++;
			}
			traceCtr++;
		}
		report.add(allOk ? """" : ""</ul>"");
		return allOk;
	}

	private Type getType(XAttribute attribute) {
		if (attribute instanceof XAttributeLiteral) {
			return Type.LITERAL;
		} else if (attribute instanceof XAttributeDiscrete) {
			return Type.DISCRETE;
		} else if (attribute instanceof XAttributeTimestamp) {
			return Type.TIMESTAMP;
		} else if (attribute instanceof XAttributeContinuous) {
			return Type.CONTINUOUS;
		} else if (attribute instanceof XAttributeID) {
			return Type.ID;
		} else if (attribute instanceof XAttributeBoolean) {
			return Type.BOOLEAN;
		} else if (attribute instanceof XAttributeList) {
			return Type.LIST;
		}
		return Type.UNKNOWN;
	}

	public boolean check(PluginContext context, XLog log, LogCheckerReport report) {
		boolean okTraces = checkTraces(context, log, report);
		boolean okEvents = checkEvents(context, log, report);
		return okTraces && okEvents;
	}

}
"
LogCheckEventClassifiersGlobal.java,log-6.9.380,"package org.processmining.log.logchecks.impl;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.logchecks.LogCheck;
import org.processmining.log.models.LogCheckerReport;

public class LogCheckEventClassifiersGlobal implements LogCheck {

	private static LogCheck instance;
	
	private LogCheckEventClassifiersGlobal() {
		
	}
	
	public static LogCheck getInstance() {
		if (instance == null) {
			instance = new LogCheckEventClassifiersGlobal();
		}
		return instance;
	}
	
	public boolean check(PluginContext context, XLog log, LogCheckerReport report) {
		boolean checkOk = true;
		for (XEventClassifier classifier : log.getClassifiers()) {
			for (String key : classifier.getDefiningAttributeKeys()) {
				boolean keyFound = false;
				for (XAttribute attribute : log.getGlobalEventAttributes()) {
					keyFound = attribute.getKey().equals(key);
					if (keyFound) {
						break;
					}
				}
				if (!keyFound) {
					String message = checkOk ? ""<h2>Event classifier uses non-global attribute</h2><ul>"" : """";
					checkOk = false;
					message += ""<li>Classifier "" + classifier.name() + "" uses key "" + key + "", but key "" + key + "" is not declared as being global.</li>""; 
					report.add(message);
				}
			}
		}
		if (!checkOk) {
			report.add(""</ul>"");
		}
		return checkOk;
	}

}
"
LogCheckGlobalAttributes.java,log-6.9.380,"package org.processmining.log.logchecks.impl;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.logchecks.LogCheck;
import org.processmining.log.models.LogCheckerReport;

public class LogCheckGlobalAttributes implements LogCheck {

	private static LogCheck instance;

	private LogCheckGlobalAttributes() {

	}

	public static LogCheck getInstance() {
		if (instance == null) {
			instance = new LogCheckGlobalAttributes();
		}
		return instance;
	}

	public boolean check(PluginContext context, XLog log, LogCheckerReport report) {
		boolean allOk = true;
		int traceCtr = 0;
		int eventCtr = 0;
		for (XTrace trace : log) {
			traceCtr++;
			eventCtr = 0;
			for (XAttribute attribute : log.getGlobalTraceAttributes()) {
				if (!trace.getAttributes().containsKey(attribute.getKey())) {
					if (allOk) {
						report.add(""<h2>Trace/event misses global attributes</h2><ul>"");
					}
					allOk = false;
					String traceId = "" at position "" + traceCtr;
					if (trace.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
						traceId = XConceptExtension.instance().extractName(trace) + "" "" + traceId;
					} else {
						traceId = ""<i>unknown</i> "" + traceId;
					}
					report.add(""<li>Trace "" + traceId + "" misses global attribute "" + attribute.getKey() + "".</li>"");
				}
			}
			for (XEvent event : trace) {
				eventCtr++;
				for (XAttribute attribute : log.getGlobalEventAttributes()) {
					if (!event.getAttributes().containsKey(attribute.getKey())) {
						if (allOk) {
							report.add(""<h2>Trace/event misses global attributes</h2><ul>"");
						}
						allOk = false;
						String eventId = "" at position "" + eventCtr;
						if (event.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
							eventId = XConceptExtension.instance().extractName(event) + "" "" + eventId;
						} else {
							eventId = ""<i>unknown</i> "" + eventId;
						}
						String traceId = "" at position "" + traceCtr;
						if (trace.getAttributes().containsKey(XConceptExtension.KEY_NAME)) {
							traceId = XConceptExtension.instance().extractName(trace) + "" "" + traceId;
						} else {
							traceId = ""<i>unknown</i> "" + traceId;
						}
						report.add(
								""<li>Event "" + eventId + "" in trace "" + traceId + "" misses global attribute "" + attribute.getKey() + "".</li>"");
					}
				}
			}
		}
		if (!allOk) {
			report.add(""</ul>"");
		}
		return allOk;
	}

}
"
LogCheck.java,log-6.9.380,"package org.processmining.log.logchecks;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.LogCheckerReport;

public interface LogCheck {

	public boolean check(PluginContext context, XLog log, LogCheckerReport report);
	
}
"
LogCheckType.java,log-6.9.380,"package org.processmining.log.logchecks;

import org.processmining.log.logchecks.impl.LogCheckConsistentTypes;
import org.processmining.log.logchecks.impl.LogCheckEventClassifiersGlobal;
import org.processmining.log.logchecks.impl.LogCheckGlobalAttributes;

public enum LogCheckType {
	LOG_CHECK_EVENT_CLASSIFIERS_GLOBAL(LogCheckEventClassifiersGlobal.getInstance()),
	LOG_CHECK_GLOBAL_ATTRIBUTE(LogCheckGlobalAttributes.getInstance()),
	LOG_CHECK_CONSISTENT_TYPES(LogCheckConsistentTypes.getInstance());
	
	
	private LogCheck logCheck;
	
	private LogCheckType(LogCheck logCheck) {
		this.logCheck = logCheck;
	}
	
	public LogCheck getLogCheck() {
		return logCheck;
	}
	
	
}
"
LogFileFormat.java,log-6.9.380,"package org.processmining.log;

/**
 * Specifies the different possible Log File Formats. Mainly used within
 * RapidProM.
 *
 */
public enum LogFileFormat {
	XES(""xes""), XES_GZ(""xes.gz""), MXML(""mxml""), MXML_GZ(""mxml.gz"");

	private String desc;

	private LogFileFormat(String desc) {
		this.desc = desc;
	}

	@Override
	public String toString() {
		return desc;
	}
}
"
EventLogArray.java,log-6.9.380,"package org.processmining.log.models;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XSerializer;
import org.processmining.framework.annotations.AuthoredType;
import org.processmining.framework.annotations.Icon;
import org.processmining.framework.plugin.PluginContext;

@AuthoredType(typeName = ""Event log array"", affiliation = AuthoredType.TUE, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
@Icon(icon = ""resourcetype_ela_30x35.png"")
public interface EventLogArray {

	/**
	 * Initializes the event log array.
	 */
	void init();

	/**
	 * Adds the given log to the array.
	 * 
	 * @param log
	 *            The given log.
	 * @return The index of the added log in the array.
	 */
	int addLog(XLog log);

	/**
	 * Removes the first occurrence of the given log from the array,
	 * 
	 * @param log
	 *            The given log.
	 * @return The index of the removed log, if present. -1 if not present.
	 */
	int removeLog(XLog log);

	/**
	 * Adds the given log at the given index to the array.
	 * 
	 * @param index
	 *            The given index.
	 * @param log
	 *            The given log.
	 */
	void addLog(int index, XLog log);

	/**
	 * Removes the log from the given index.
	 * 
	 * @param index
	 *            The given index.
	 */
	void removeLog(int index);

	/**
	 * Returns the log at the given index.
	 * 
	 * @param index The given index.
	 * @return The log at the given index, if valid. null if not valid.
	 */
	XLog getLog(int index);
	
	int getSize();
	
	public void importFromStream(PluginContext context, InputStream input, String parent) throws Exception;
	public void exportToFile(PluginContext context, File file, XSerializer logSerializer) throws IOException;
}
"
EventLogArrayFactory.java,log-6.9.380,"package org.processmining.log.models.impl;

import org.processmining.log.models.EventLogArray;

public class EventLogArrayFactory {

	public static EventLogArray createEventLogArray() {
		return new EventLogArrayImpl();
	}
	
}
"
EventLogArrayImpl.java,log-6.9.380,"package org.processmining.log.models.impl;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XSerializer;
import org.deckfour.xes.out.XesXmlSerializer;
import org.processmining.basicutils.models.impl.ObjectArrayImpl;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.models.EventLogArray;
import org.processmining.plugins.log.OpenLogFilePlugin;

import com.csvreader.CsvWriter;

public class EventLogArrayImpl extends ObjectArrayImpl<XLog> implements EventLogArray {

	@Deprecated 
	public int addLog(XLog log) {
		return addElement(log);
	}

	@Deprecated
	public int removeLog(XLog log) {
		return removeElement(log);
	}

	@Deprecated
	public void addLog(int index, XLog log) {
		addElement(log);
	}

	@Deprecated
	public void removeLog(int index) {
		removeElement(index);
	}

	@Deprecated
	public XLog getLog(int index) {
		return getElement(index);
	}

	public void importFromStream(PluginContext context, InputStream input, String parent) throws Exception {
		importFromStream(context, input, parent, new OpenLogFilePlugin());
	}

	public void exportToFile(PluginContext context, File file, XSerializer logSerializer) throws IOException {
		Writer fileWriter = new FileWriter(file);
		CsvWriter csvWriter = new CsvWriter(fileWriter, ',');
		int n = 1;
		for (XLog log: list) {
			String fileName = file.getName();
			File dir = file.getParentFile();
			String prefix = fileName.substring(0, fileName.indexOf("".""));
			File netFile = File.createTempFile(prefix + ""."" + n + ""."", ""."" + logSerializer.getSuffices()[0], dir);
			csvWriter.write(netFile.getName());
			csvWriter.endRecord();
			System.out.println(""Exporting Accepting Petri Net to "" + netFile.getName());
			FileOutputStream out = new FileOutputStream(netFile);
			logSerializer.serialize(log, out);
			out.close();
			n++;
		}
		csvWriter.close();
	}

	public void exportToFile(PluginContext context, File file) throws Exception {
		exportToFile(context, file, new XesXmlSerializer());
	}


}
"
LogFrequencyArrayImpl.java,log-6.9.380,"package org.processmining.log.models.impl;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.models.LogFrequencyArray;

public class LogFrequencyArrayImpl implements LogFrequencyArray {

	private String label;
	private LogFrequency[] subFrequencies;
	private int index;
	private int factor;
	private int buckets = 20;

	public LogFrequencyArrayImpl(EventLogArray logs) {
		label = null;
		if (logs.getSize() > 0) {
			label = XConceptExtension.instance().extractName(logs.getLog(0));
		}
		if (label == null) {
			label = ""<Not specified>"";
		}
		factor = (logs.getLog(0).size() / buckets) + (logs.getLog(0).size() % buckets > 0 ? 1 : 0);
		subFrequencies = new LogFrequency[logs.getSize()];
		for (int i = 0; i < logs.getSize(); i++) {
			subFrequencies[i] = LogFrequencyFactory.createLogFrequency(logs.getLog(i));
		}
		index = -1;
	}

	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buf = new StringBuffer();
		if (includeHTMLTags) {
			buf.append(""<html>"");
		}
		buf.append(""<h1>"");
		buf.append(label);
		buf.append(""</h1>"");
		buf.append(""<table>"");
		buf.append(""<tr><th>Frequency</th>"");
		for (int i = 0; i < subFrequencies.length ; i++) {
			buf.append(""<th>Log "" + (i + 1) + ""</th>"");
			
		}
		buf.append(""</tr>"");
		for (int i = 0; i < buckets; i++) {
			buf.append(""<tr><th>"");
			buf.append(i * factor + 1);
			buf.append(""</th>"");
			for (int j = 0; j < subFrequencies.length ; j++) {
				buf.append(""<td>"" + subFrequencies[j].get(i * factor + 1) + ""</td>"");
			}
			buf.append(""</tr>"");
		}
		buf.append(""</table>"");
		if (includeHTMLTags) {
			buf.append(""</html>"");
		}
		return buf.toString();
	}

	public void set(int index) {
		this.index = index;
	}

	public void add(int frequency) {
		subFrequencies[index].add(frequency);
	}

	public int get(int frequency) {
		// TODO Auto-generated method stub
		return subFrequencies[index].get(frequency);
	}
}
"
LogFrequencyFactory.java,log-6.9.380,"package org.processmining.log.models.impl;

import org.deckfour.xes.model.XLog;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.models.LogFrequencyArray;


public class LogFrequencyFactory {

	public static LogFrequency createLogFrequency(XLog log) {
		return new LogFrequencyImpl(log);
	}

	public static LogFrequencyArray createLogFrequencyArray(EventLogArray logs) {
		return new LogFrequencyArrayImpl(logs);
	}
}
"
LogFrequencyImpl.java,log-6.9.380,"package org.processmining.log.models.impl;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.log.models.LogFrequency;

public class LogFrequencyImpl implements LogFrequency {

	private String label;
	private int[] frequencies;
	private int factor;
	private int buckets = 20;
	
	public LogFrequencyImpl(XLog log) {
		label = XConceptExtension.instance().extractName(log);
		if (label == null) {
			label = ""<Not specified>"";
		}
		factor = (log.size() / buckets) + (log.size() % buckets > 0 ? 1 : 0);
		frequencies = new int[buckets];
		for (int i = 0; i < buckets; i++) {
			frequencies[i] = 0;
		}
	}
	
	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buf = new StringBuffer();
		if (includeHTMLTags) {
			buf.append(""<html>"");
		}
		buf.append(""<h1>"");
		buf.append(label);
		buf.append(""</h1>"");
		buf.append(""<table>"");
		buf.append(""<tr><th>Frequency</th><th>Log</th></tr>"");
		for (int i = 0 ; i < buckets ; i++) {
			buf.append(""<tr><th>"");
			buf.append(i * factor + 1);
			buf.append(""</th><td>"");
			buf.append(frequencies[i]);
			buf.append(""</td></tr>"");
		}
		buf.append(""</table>"");
		if (includeHTMLTags) {
			buf.append(""</html>"");
		}
		return buf.toString();
	}

	public void add(int frequency) {
		frequencies[(frequency - 1) / factor] += frequency;
	}

	public int get(int frequency) {
		return frequencies[(frequency - 1) / factor];
	}
}
"
XEventClassifierListImpl.java,log-6.9.380,"package org.processmining.log.models.impl;

import java.util.ArrayList;

import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.log.models.XEventClassifierList;

public class XEventClassifierListImpl extends ArrayList<XEventClassifier> implements XEventClassifierList {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2050835582426869158L;

}
"
LogCentrality.java,log-6.9.380,"package org.processmining.log.models;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.parameters.LogCentralityFilterParameters;
import org.processmining.log.parameters.LogCentralityParameters;

public class LogCentrality {

	private XLog log;
	private XEventClassifier classifier;
	private Map<List<String>, Double> centralityMap;
	private List<Double> centralities;
	private Map<Set<List<String>>, Integer> cache;

	public LogCentrality(XLog log) {
		this.log = log;
		this.classifier = null;
		this.cache = null;
	}

	public XLog getLog() {
		return log;
	}
	
	public XEventClassifier getClassifier() {
		return classifier;
	}
	
	public List<Double> getCentralities() {
		return centralities;
	}
	
	public void setClassifier(PluginContext context, LogCentralityParameters parameters) {
		if (context != null) {
			context.getProgress().setValue(0);
		}
		if (this.classifier == null || !this.classifier.equals(parameters.getClassifier())) {
			this.classifier = parameters.getClassifier();
			this.centralityMap = new HashMap<List<String>, Double>();
			this.centralities = new ArrayList<Double>();
			this.cache = new HashMap<Set<List<String>>, Integer>();

			for (XTrace trace : log) {
				List<String> traceId = getTraceId(trace, classifier);
				if (!centralityMap.containsKey(traceId)) {
					centralityMap.put(traceId, getTraceCentrality(trace, log, classifier));
				}
				centralities.add(centralityMap.get(traceId));
				if (context != null) {
					context.getProgress().inc();
				}
			}
			Collections.sort(centralities);
			this.cache = null;
		}
	}

	public int size() {
		return log.size();
	}
	
	public XLog filter(PluginContext context, LogCentralityFilterParameters parameters) {
		XLog log = (XLog) this.log.clone();
		int index = (parameters.getPercentage() * centralities.size()) / 100;
		if (index >= centralities.size()) {
			index = centralities.size() - 1;
		}
		Double threshold = centralities.get(index);
		Set<XTrace> removedTraces = new HashSet<XTrace>();
		for (XTrace trace : log) {
			if (parameters.isFilterIn() == (centralityMap.get(getTraceId(trace, classifier)) > threshold)) {
				removedTraces.add(trace);
			}
			if (context != null) {
				context.getProgress().inc();
			}
		}
		for (XTrace trace : removedTraces) {
			log.remove(trace);
		}
		return log;
	}

	private List<String> getTraceId(XTrace trace, XEventClassifier classifier) {
		List<String> traceId = new ArrayList<String>();
		for (XEvent event : trace) {
			traceId.add(classifier.getClassIdentity(event));
		}
		return traceId;
	}

	private double getTraceCentrality(XTrace trace, XLog log, XEventClassifier classifier) {
		int totalSquareDistance = 0;
		for (XTrace otherTrace : log) {
			int distance = getTraceDistance(trace, otherTrace, classifier);
			totalSquareDistance += (distance * distance);
		}
		return Math.sqrt(totalSquareDistance);
	}

	private int getTraceDistance(XTrace trace1, XTrace trace2, XEventClassifier classifier) {
		List<String> activities1 = new ArrayList<String>();
		List<String> activities2 = new ArrayList<String>();
		for (XEvent event : trace1) {
			activities1.add(classifier.getClassIdentity(event));
		}
		for (XEvent event : trace2) {
			activities2.add(classifier.getClassIdentity(event));
		}
		return getTraceDistance(activities1, activities2, 0, 0);
	}

	private int getTraceDistance(List<String> activities1, List<String> activities2, int index1, int index2) {
		int distance = 0;
		if (index1 >= activities1.size()) {
			distance = activities2.size() - index2;
		} else if (index2 >= activities2.size()) {
			distance = activities1.size() - index1;
		} else {
			Set<List<String>> activities = new HashSet<List<String>>();
			activities.add(activities1);
			activities.add(activities2);
			if (cache.containsKey(activities)) {
				distance = cache.get(activities);
			} else {
				if (activities1.get(index1).equals(activities2.get(index2))) {
					distance = getTraceDistance(activities1, activities2, index1 + 1, index2 + 1);
				} else {
					int distance1 = 1 + getTraceDistance(activities1, activities2, index1 + 1, index2);
					int distance2 = 1 + getTraceDistance(activities1, activities2, index1, index2 + 1);
					if (distance1 < distance2) {
						distance = distance1;
					} else {
						distance = distance2;
					}
				}
				cache.put(activities, distance);
			}
		}
		return distance;
	}
}
"
LogCheckerReport.java,log-6.9.380,"package org.processmining.log.models;

import org.processmining.framework.util.HTMLToString;

public class LogCheckerReport implements HTMLToString {

	private String report;
	
	public LogCheckerReport() {
		report = """";
	}
	
	public void add(String message) {
		report += message;
	}
	
	public String toHTMLString(boolean includeHTMLTags) {
		return includeHTMLTags ? ""<html>"" + report + ""</html>"" : report;
	}

}
"
LogFrequency.java,log-6.9.380,"package org.processmining.log.models;

import org.processmining.framework.util.HTMLToString;

public interface LogFrequency extends HTMLToString {

	public void add(int frequency);

	public int get(int index);
}
"
LogFrequencyArray.java,log-6.9.380,"package org.processmining.log.models;

public interface LogFrequencyArray extends LogFrequency {

	public void set(int i);
	
}
"
XEventClassifierList.java,log-6.9.380,"package org.processmining.log.models;

import java.util.List;

import org.deckfour.xes.classification.XEventClassifier;

public interface XEventClassifierList extends List<XEventClassifier> {

}
"
AbstractLogFilterParameters.java,log-6.9.380,"package org.processmining.log.parameters;

import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.basicutils.parameters.impl.PluginParametersImpl;

public abstract class AbstractLogFilterParameters extends PluginParametersImpl implements LogFilterParameters {

	private XEventClassifier classifier;

	public AbstractLogFilterParameters(XEventClassifier classifier) {
		super();
		setClassifier(classifier);
	}

	public AbstractLogFilterParameters(AbstractLogFilterParameters parameters) {
		super(parameters);
		setClassifier(parameters.getClassifier());
	}

	public XEventClassifier getClassifier() {
		return classifier;
	}

	public void setClassifier(XEventClassifier classifier) {
		this.classifier = classifier;
	}

	public boolean equals(Object object) {
		if (object instanceof AbstractLogFilterParameters) {
			AbstractLogFilterParameters parameters = (AbstractLogFilterParameters) object;
			return super.equals(parameters) 
					&& getClassifier().equals(parameters.getClassifier());
		}
		return false;
	}
}
"
ClassifierParameter.java,log-6.9.380,"package org.processmining.log.parameters;

import org.deckfour.xes.classification.XEventClassifier;

public interface ClassifierParameter {

	public void setClassifier(XEventClassifier classifier);
	public XEventClassifier getClassifier();
}
"
HighFrequencyFilterParameters.java,log-6.9.380,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class HighFrequencyFilterParameters extends AbstractLogFilterParameters {

	private int frequencyThreshold;

	private int distanceThreshold;

	public HighFrequencyFilterParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
		/*
		 * Keep at least 50% of the log. This determines the set of
		 * most-occurring traces.
		 */
		setFrequencyThreshold(50);
		/*
		 * Keep a trace if its distance to a most-occurring trace is less than
		 * 3.
		 */
		setDistanceThreshold(3);
	}

	public HighFrequencyFilterParameters(HighFrequencyFilterParameters parameters) {
		super(parameters);
		setFrequencyThreshold(parameters.getFrequencyThreshold());
		setDistanceThreshold(parameters.getDistanceThreshold());
	}

	public int getFrequencyThreshold() {
		return frequencyThreshold;
	}

	public void setFrequencyThreshold(int frequencyThreshold) {
		this.frequencyThreshold = frequencyThreshold;
	}

	public int getDistanceThreshold() {
		return distanceThreshold;
	}

	public void setDistanceThreshold(int distanceThreshold) {
		this.distanceThreshold = distanceThreshold;
	}

	public boolean equals(Object object) {
		if (object instanceof HighFrequencyFilterParameters) {
			HighFrequencyFilterParameters parameters = (HighFrequencyFilterParameters) object;
			return super.equals(parameters) && 
					getFrequencyThreshold() == parameters.getFrequencyThreshold() && 
					getDistanceThreshold() == parameters.getDistanceThreshold();
		}
		return false;
	}
}
"
LogCentralityFilterParameters.java,log-6.9.380,"package org.processmining.log.parameters;

import org.processmining.basicutils.parameters.impl.PluginParametersImpl;
import org.processmining.log.models.LogCentrality;


public class LogCentralityFilterParameters extends PluginParametersImpl {

	private int percentage;
	private boolean filterIn;

	public LogCentralityFilterParameters(LogCentrality centrality) {
		super();
		setPercentage(80);
		setFilterIn(true);
	}

	public LogCentralityFilterParameters(LogCentralityFilterParameters parameters) {
		super(parameters);
		setPercentage(parameters.getPercentage());
		setFilterIn(parameters.isFilterIn());
	}
	
	public void setPercentage(int percentage) {
		this.percentage = percentage;
	}

	public int getPercentage() {
		return percentage;
	}

	public void setFilterIn(boolean filterIn) {
		this.filterIn = filterIn;
	}

	public boolean isFilterIn() {
		return filterIn;
	}

	public boolean equals(Object object) {
		if (object instanceof LogCentralityFilterParameters) {
			LogCentralityFilterParameters parameters = (LogCentralityFilterParameters) object;
			return super.equals(parameters) &&
					getPercentage() == parameters.getPercentage() &&
					isFilterIn() == parameters.isFilterIn();
		}
		return false;
	}

}
"
LogCentralityParameters.java,log-6.9.380,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class LogCentralityParameters extends AbstractLogFilterParameters {

	public LogCentralityParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
	}

	public LogCentralityParameters(LogCentralityParameters parameters) {
		super(parameters);
	}

	public boolean equals(Object object) {
		if (object instanceof LogCentralityParameters) {
			LogCentralityParameters parameters = (LogCentralityParameters) object;
			return super.equals(parameters);
		}
		return false;
	}
}
"
LogCheckerParameters.java,log-6.9.380,"package org.processmining.log.parameters;

import java.util.EnumSet;

import org.processmining.log.logchecks.LogCheckType;

public class LogCheckerParameters {

	private EnumSet<LogCheckType> logChecks;

	public EnumSet<LogCheckType> getLogChecks() {
		return logChecks;
	}

	public void setLogChecks(EnumSet<LogCheckType> logChecks) {
		this.logChecks = logChecks;
	}
	
}
"
LogFilterParameters.java,log-6.9.380,"package org.processmining.log.parameters;

import org.processmining.basicutils.parameters.PluginParameters;


public interface LogFilterParameters extends PluginParameters, ClassifierParameter {


}
"
LogFrequencyParameters.java,log-6.9.380,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class LogFrequencyParameters extends AbstractLogFilterParameters {

	public LogFrequencyParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
	}
	
	public LogFrequencyParameters(LogFrequencyParameters parameters) {
		super(parameters);
	}

	public boolean equals(Object object) {
		if (object instanceof LogFrequencyParameters) {
			LogFrequencyParameters parameters = (LogFrequencyParameters) object;
			return super.equals(parameters);
		}
		return false;
	}
}
"
LowFrequencyFilterParameters.java,log-6.9.380,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class LowFrequencyFilterParameters extends AbstractLogFilterParameters {

	private int threshold;

	public LowFrequencyFilterParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
		/*
		 * The least-occurring traces that make up at least 5% of the log will be removed.
		 */
		setThreshold(5); 
	}
	
	public LowFrequencyFilterParameters(LowFrequencyFilterParameters parameters) {
		super(parameters);
		setThreshold(parameters.getThreshold());
	}

	public int getThreshold() {
		return threshold;
	}

	public void setThreshold(int threshold) {
		this.threshold = threshold;
	}

	public boolean equals(Object object) {
		if (object instanceof LowFrequencyFilterParameters) {
			LowFrequencyFilterParameters parameters = (LowFrequencyFilterParameters) object;
			return super.equals(parameters) &&
					getThreshold() == parameters.getThreshold();
		}
		return false;
	}
}
"
LowOccurrencesFilterParameters.java,log-6.9.380,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XLog;
import org.processmining.log.utils.XUtils;

public class LowOccurrencesFilterParameters extends AbstractLogFilterParameters {

	private int threshold;

	public LowOccurrencesFilterParameters(XLog log) {
		super(XUtils.getDefaultClassifier(log));
		/*
		 * Traces that occur at least 2 times will be retained.
		 */
		setThreshold(2);
	}
	
	public LowOccurrencesFilterParameters(LowOccurrencesFilterParameters parameters) {
		super(parameters);
		setThreshold(parameters.getThreshold());
	}
	
	public int getThreshold() {
		return threshold;
	}

	public void setThreshold(int threshold) {
		this.threshold = threshold;
	}
	
	public boolean equals(Object object) {
		if (object instanceof LowOccurrencesFilterParameters) {
			LowOccurrencesFilterParameters parameters = (LowOccurrencesFilterParameters) object;
			return super.equals(parameters) &&
					getThreshold() == parameters.getThreshold();
		}
		return false;
	}
}
"
MergeLogsParameters.java,log-6.9.380,"package org.processmining.log.parameters;

import java.util.Date;

public class MergeLogsParameters {

	private String traceId;
	private String dateFormat;
	private Date fromDate;
	private Date toDate;
	private Date specificDate;
	private String requiredWords;
	private String forbiddenWords;
	private int minMatches;
	private boolean maxMatch;
	private boolean multi;
	private int related;
	

	public MergeLogsParameters() {
		setTraceId(null);
		setDateFormat(""MM/dd/yyyy HH:mm"");
		setFromDate(null);
		setToDate(null);
		setSpecificDate(null);
		setRequiredWords(null);
		setForbiddenWords(null);
		setMinMatches(0);
		setMaxMatch(true);
		setMulti(false);
		setRelated(0);
	}
	
	public String getTraceId() {
		return traceId;
	}

	public void setTraceId(String id) {
		this.traceId = id;
	}

	public String getDateFormat() {
		return dateFormat;
	}

	public void setDateFormat(String dateFormat) {
		this.dateFormat = dateFormat;
	}

	public Date getFromDate() {
		return fromDate;
	}

	public void setFromDate(Date fromDate) {
		this.fromDate = fromDate;
	}

	public Date getToDate() {
		return toDate;
	}

	public void setToDate(Date toDate) {
		this.toDate = toDate;
	}

	public Date getSpecificDate() {
		return specificDate;
	}

	public void setSpecificDate(Date specificDate) {
		this.specificDate = specificDate;
	}

	public String getForbiddenWords() {
		return forbiddenWords;
	}

	public void setForbiddenWords(String remove) {
		this.forbiddenWords = remove;
	}

	public int getRelated() {
		return related;
	}

	public void setRelated(int related) {
		this.related = related;
	}

	public int getMinMatches() {
		return minMatches;
	}

	public void setMinMatches(int minMatches) {
		this.minMatches = minMatches;
	}

	public boolean isMaxMatch() {
		return maxMatch;
	}

	public void setMaxMatch(boolean maxMatch) {
		this.maxMatch = maxMatch;
	}

	public boolean isMulti() {
		return multi;
	}

	public void setMulti(boolean multi) {
		this.multi = multi;
	}

	public String getRequiredWords() {
		return requiredWords;
	}

	public void setRequiredWords(String requiredWords) {
		this.requiredWords = requiredWords;
	}
}
"
MinerParameter.java,log-6.9.380,"package org.processmining.log.parameters;

public interface MinerParameter {

	public void setMiner(String miner);
	public String getMiner();
}
"
SplitLogParameters.java,log-6.9.380,"package org.processmining.log.parameters;

import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;

public class SplitLogParameters {

	private String key;

	public SplitLogParameters(XLog log) {
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				for (XAttribute attribute : event.getAttributes().values()) {
					if (attribute instanceof XAttributeLiteral) {
						setKey(attribute.getKey());
						break;
					}
				}
			}
		}
	}
	
	public String getKey() {
		return key;
	}

	public void setKey(String key) {
		this.key = key;
	}
}
"
UpdateParameter.java,log-6.9.380,"package org.processmining.log.parameters;

public interface UpdateParameter {

	public void update();
}
"
SaxHandlerGlobalEventAttributesParser.java,log-6.9.380,"package org.processmining.log.parsers;

import java.util.List;
import java.util.Vector;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

public class SaxHandlerGlobalEventAttributesParser extends DefaultHandler {

	private static final String TAG = ""global"", KEY = ""key"", SCOPE = ""scope"", EVENT = ""event"";

	private final List<String> globals = new Vector<String>();

	private boolean isInGlobalEvent = false;

	@Override
	public void startElement(String uri, String local, String qName, Attributes attributes) throws SAXException {
		if (isInGlobalEvent == false) {
			if (qName.toLowerCase().equals(TAG)) {
				String scope = attributes.getValue(SCOPE);
				if (scope != null && scope.equals(EVENT)) {
					isInGlobalEvent = true;
				}
			}
		} else {
			if (qName.toLowerCase().equals(TAG))
				throw new SAXException();
			String key = attributes.getValue(KEY);
			if (key != null)
				globals.add(key);
		}
	}
	
	@Override
	public void endElement(String uri, String local, String qName) {
		if(isInGlobalEvent)
			if(qName.toLowerCase().equals(TAG))
				isInGlobalEvent = false;
	}
	
	public List<String> getGlobalEventAttributes(){
		return globals;
	}

}
"
SaxHandlerXEventClassifierParser.java,log-6.9.380,"package org.processmining.log.parsers;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import org.deckfour.xes.classification.XEventAttributeClassifier;
import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.log.models.XEventClassifierList;
import org.processmining.log.models.impl.XEventClassifierListImpl;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
 * This parser tries to read the classifiers contained in a log, based on the
 * global event attributes. In order to find the classifiers, the elements of
 * the list of globals are checked if they are contained in the classifier
 * definition. This is done greedily based on the global´s sting length:
 * longest first. If globals are contained in the classifier definition, then we
 * return the corresponding XEventClassifier.
 * 
 * @author abolt *
 */
public class SaxHandlerXEventClassifierParser extends DefaultHandler {

	private static final String CLASSIFIER_TAG = ""classifier"", CLASSIFIER_TAG_ATTRIBUTE_NAME = ""name"",
			CLASSIFIER_TAG_ATTRIBUTEKEY = ""keys"";

	private final XEventClassifierList classifierList = new XEventClassifierListImpl();

	public XEventClassifierList getClassifierList() {
		return classifierList;
	}

	private final List<String> globalEventAttributes;
	private XEventClassifier current = null;
	private boolean insideClassifierTag = false;

	public SaxHandlerXEventClassifierParser(List<String> globalEventAttributes) {
		Collections.sort(globalEventAttributes, new Comparator<String>() {
			public int compare(String o1, String o2) {
				return o2.length() - o1.length();
			}
		});
		this.globalEventAttributes = globalEventAttributes;
	}

	@Override
	public void startElement(String uri, String local, String qName, Attributes attributes) throws SAXException {
		if (!insideClassifierTag) {
			if (qName.toLowerCase().equals(CLASSIFIER_TAG)) {
				insideClassifierTag = true;
				String name = attributes.getValue(CLASSIFIER_TAG_ATTRIBUTE_NAME) == null ? """"
						: attributes.getValue(CLASSIFIER_TAG_ATTRIBUTE_NAME);
				String keys = attributes.getValue(CLASSIFIER_TAG_ATTRIBUTEKEY) == null ? """"
						: attributes.getValue(CLASSIFIER_TAG_ATTRIBUTEKEY);
				List<String> parsedKeys = getGlobalsInClassifier(globalEventAttributes, keys);
				if (parsedKeys != null) {
					current = new XEventAttributeClassifier(name, parsedKeys.toArray(new String[parsedKeys.size()]));
				} else {
					current = null;
				}
			}
		} else {
			if (qName.toLowerCase().equals(CLASSIFIER_TAG)) {
				throw new SAXException(""Nested xml tag in classifier tag."");
			}
			// the code here is actually not described by the standard, so we  disable this for now.
			//			if (qName.toLowerCase().equals(STRING_TAG) && attributes.getValue(STRING_TAG_ATTRIBUTE_KEY) != null) {
			//				if (attributes.getValue(STRING_TAG_ATTRIBUTE_KEY).equals(CLASSIFIER_TAG_ATTRIBUTE_NAME)) {
			//					if (attributes.getValue(STRING_TAG_ATTRIBUTE_VALUE) != null) {
			//						current.setName(attributes.getValue(STRING_TAG_ATTRIBUTE_VALUE));
			//					}
			//				} else if (attributes.getValue(STRING_TAG_ATTRIBUTE_KEY).equals(CLASSIFIER_TAG_ATTRIBUTEKEY)) {
			//					if (attributes.getValue(STRING_TAG_ATTRIBUTE_VALUE) != null) {
			//						List<String> parsedKeys = getGlobalsInClassifier(globalEventAttributes,
			//								attributes.getValue(STRING_TAG_ATTRIBUTE_VALUE));
			//						current = new XEventAttributeClassifier(current.name(),
			//								parsedKeys.toArray(new String[parsedKeys.size()]));
			//					}
			//				}
			//			}
		}
	}

	@Override
	public void endElement(String uri, String local, String qName) {
		if (qName.toLowerCase().equals(CLASSIFIER_TAG)) {
			insideClassifierTag = false;
			if (current != null) {
				classifierList.add(current);
			}
		}

	}

	private List<String> getGlobalsInClassifier(List<String> globals, String keysInClassifier) {
		List<String> classifierKeys = new ArrayList<String>();
		for (String globalElement : globalEventAttributes) {
			if (keysInClassifier.contains(globalElement)) {
				classifierKeys.add(globalElement);
				// This will replace all matches, but since the list is ordered greedily, it should not replace strings used by other globals
				keysInClassifier = keysInClassifier.replace(globalElement, """");
			}
		}
		keysInClassifier = keysInClassifier.replace("" "", """");
		keysInClassifier = keysInClassifier.replace(""'"", """");
		return keysInClassifier.isEmpty() ? classifierKeys : null;
	}

}
"
ExportEventLogArrayAsCompressedMXMLPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.out.XMxmlGZIPSerializer;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;

@Plugin(name = ""ELA export (Event Log Array)"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Event Log Array (Compressed MXML)"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Event Log Array (Compressed MXML)"", extension = ""ela"")
public class ExportEventLogArrayAsCompressedMXMLPlugin {

	@PluginVariant(variantLabel = ""ELA export to compressed MXML files (Event Log Array)"", requiredParameterLabels = { 0, 1 })
	public void exportMxmlGz(PluginContext context, EventLogArray eventLogs, File file) throws IOException {
		eventLogs.exportToFile(context, file, new XMxmlGZIPSerializer());
	}

}
"
ExportEventLogArrayAsCompressedXESPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.out.XesXmlGZIPSerializer;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;

@Plugin(name = ""ELA export (Event Log Array)"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Event Log Array (Compressed XES)"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Event Log Array (Compressed XES)"", extension = ""ela"")
public class ExportEventLogArrayAsCompressedXESPlugin {

	@PluginVariant(variantLabel = ""ELA export to compressed XES files (Event Log Array)"", requiredParameterLabels = { 0, 1 })
	public void exportXes(PluginContext context, EventLogArray eventLogs, File file) throws IOException {
		eventLogs.exportToFile(context, file, new XesXmlGZIPSerializer());
	}

}
"
ExportEventLogArrayAsMXMLPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.out.XMxmlSerializer;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;

@Plugin(name = ""ELA export (Event Log Array)"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Event Log Array (MXML)"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Event Log Array (MXML)"", extension = ""ela"")
public class ExportEventLogArrayAsMXMLPlugin {

	@PluginVariant(variantLabel = ""ELA export to MXML files (Event Log Array)"", requiredParameterLabels = { 0, 1 })
	public void exportMxml(PluginContext context, EventLogArray eventLogs, File file) throws IOException {
		eventLogs.exportToFile(context, file, new XMxmlSerializer());
	}
}
"
ExportEventLogArrayAsXESPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.out.XesXmlSerializer;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;

@Plugin(name = ""ELA export (Event Log Array)"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Event Log Array (XES)"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Event Log Array (XES)"", extension = ""ela"")
public class ExportEventLogArrayAsXESPlugin {

	@PluginVariant(variantLabel = ""ELA export to XES files (Event Log Array)"", requiredParameterLabels = { 0, 1 })
	public void exportXesGz(PluginContext context, EventLogArray eventLogs, File file) throws IOException {
		eventLogs.exportToFile(context, file, new XesXmlSerializer());
	}

}
"
HighFrequencyFilterArrayPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.dialogs.HighFrequencyFilterDialog;
import org.processmining.log.help.HighFrequencyFilterArrayHelp;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;
import org.processmining.log.parameters.HighFrequencyFilterParameters;

@Plugin(name = ""Filter In High-Frequency Traces (Multiple Logs)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Logs"" }, returnLabels = { ""Filtered Logs"" }, returnTypes = { EventLogArray.class }, userAccessible = true, help = HighFrequencyFilterArrayHelp.TEXT)
public class HighFrequencyFilterArrayPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"", pack=""Log"")
	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Multiple Logs), UI"", requiredParameterLabels = { 0 })
	public EventLogArray runUI(UIPluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			XLog log = logs.getLog(0);
			HighFrequencyFilterParameters parameters = new HighFrequencyFilterParameters(log);
			HighFrequencyFilterDialog dialog = new HighFrequencyFilterDialog(log, parameters);
			InteractionResult result = context.showWizard(""Configure High-Frequency Filter"", true, true, dialog);
			if (result != InteractionResult.FINISHED) {
				return null;
			}
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				parameters.displayMessage(""[HighFrequencyFilterArrayPlugin] Filtering log "" + i + "" of "" + logs.getSize());
				filteredLogs.addLog((new HighFrequencyFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public EventLogArray publicUIArray(UIPluginContext context, EventLogArray logs) {
		return runUI(context, logs);
	}

	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Multiple Logs), Parameters"", requiredParameterLabels = { 0 })
	public EventLogArray run(PluginContext context, EventLogArray logs,
			HighFrequencyFilterParameters parameters) {
		if (logs.getSize() > 0) {
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				parameters.displayMessage(""[HighFrequencyFilterArrayPlugin] Filtering log "" + i + "" of "" + logs.getSize());
				filteredLogs.addLog((new HighFrequencyFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public EventLogArray publicParameters(PluginContext context, EventLogArray logs,
			HighFrequencyFilterParameters parameters) {
		return run(context, logs, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"", pack=""Log"")
	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Multiple Logs), Default"", requiredParameterLabels = { 0 })
	public EventLogArray runDefault(PluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			HighFrequencyFilterParameters parameters = new HighFrequencyFilterParameters(logs.getLog(0));
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				parameters.displayMessage(""[HighFrequencyFilterArrayPlugin] Filtering log "" + i + "" of "" + logs.getSize());
				filteredLogs.addLog((new HighFrequencyFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runDefault instead.
	 */
	@Deprecated
	public EventLogArray publicDefault(PluginContext context, EventLogArray logs) {
		return runDefault(context, logs);
	}
}
"
HighFrequencyFilterPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.HighFrequencyFilterAlgorithm;
import org.processmining.log.connections.HighFrequencyFilterConnection;
import org.processmining.log.dialogs.HighFrequencyFilterDialog;
import org.processmining.log.help.HighFrequencyFilterHelp;
import org.processmining.log.parameters.HighFrequencyFilterParameters;

@Plugin(name = ""Filter In High-Frequency Traces (Single Log)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Log"" }, returnLabels = { ""Filtered Log"" }, returnTypes = { XLog.class }, userAccessible = true, help = HighFrequencyFilterHelp.TEXT)
public class HighFrequencyFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"", pack=""Log"")
	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Single Log), UI"", requiredParameterLabels = { 0 })
	public XLog runUI(UIPluginContext context, XLog log) {
		HighFrequencyFilterParameters parameters = new HighFrequencyFilterParameters(log);
		HighFrequencyFilterDialog dialog = new HighFrequencyFilterDialog(log, parameters);
		InteractionResult result = context.showWizard(""Configure High-Frequency Filter"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public XLog publicUI(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}

	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Single Log), Parameters"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log, HighFrequencyFilterParameters parameters) {
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use run() instead.
	 */
	@Deprecated
	public XLog publicParameters(PluginContext context, XLog log, HighFrequencyFilterParameters parameters) {
		return run(context, log, parameters);
	}

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"", pack=""Log"")
	@PluginVariant(variantLabel = ""Filter In High-Frequency Traces (Single Log), Default"", requiredParameterLabels = { 0 })
	public XLog runDefault(PluginContext context, XLog log) {
		HighFrequencyFilterParameters parameters = new HighFrequencyFilterParameters(log);
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runDefault() instead.
	 */
	@Deprecated
	public XLog publicDefault(PluginContext context, XLog log) {
		return runDefault(context, log);
	}

	private XLog runConnections(PluginContext context, XLog log, HighFrequencyFilterParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<HighFrequencyFilterConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(HighFrequencyFilterConnection.class,
						context, log);
				for (HighFrequencyFilterConnection connection : connections) {
					if (connection.getObjectWithRole(HighFrequencyFilterConnection.LOG).equals(log)
							&& connection.getParameters().equals(parameters)) {
						return connection.getObjectWithRole(HighFrequencyFilterConnection.FILTEREDLOG);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		XLog filteredLog = (new HighFrequencyFilterAlgorithm()).apply(context, log, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new HighFrequencyFilterConnection(log, filteredLog, parameters));
		}
		return filteredLog;
	}
}
"
ImportEventLogArrayPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import java.io.File;
import java.io.InputStream;

import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;

@Plugin(name = ""Import Event Log Array from ELA file"", parameterLabels = { ""Filename"" }, returnLabels = { ""Event Log Array"" }, returnTypes = { EventLogArray.class })
@UIImportPlugin(description = ""ELA Event Log Array files"", extensions = { ""ela"" })
public class ImportEventLogArrayPlugin extends AbstractImportPlugin {

	protected FileFilter getFileFilter() {
		return new FileNameExtensionFilter(""ELA files"", ""ela"");
	}

	protected Object importFromStream(PluginContext context, InputStream input, String filename, long fileSizeInBytes)
			throws Exception {
		EventLogArray logs = EventLogArrayFactory.createEventLogArray();
		File file = getFile();
		String parent = (file == null ? null : file.getParent());
		logs.importFromStream(context, input, parent);
		setLabel(context, logs, filename);
		return logs;
	}

	/*
	 * Sets a proper default name for the event log array.
	 */
	private void setLabel(PluginContext context, EventLogArray logs, String filename) {
		String prefix = null;
		String postfix = null;
		boolean allSame = true;
		for (int i = 0; i < logs.getSize(); i++) {
			XLog log = logs.getLog(i);
			String name = XConceptExtension.instance().extractName(log);
			if (name != null) {
				if (prefix == null) {
					prefix = name;
				} else {
					if (!name.equals(prefix)) {
						allSame = false;
						prefix = greatestCommonPrefix(prefix, name);
					}
				}
				if (postfix == null) {
					postfix = name;
				} else {
					if (!name.equals(postfix)) {
						allSame = false;
						postfix = new StringBuilder(greatestCommonPrefix(
								new StringBuilder(prefix).reverse().toString(), new StringBuilder(name).reverse()
										.toString())).reverse().toString();
					}
				}
			}
		}
		if ((prefix != null && prefix.length() > 0) || (postfix != null && postfix.length() > 0)) {
			StringBuffer buf = new StringBuffer();
			if (prefix != null) {
				buf.append(prefix);
			}
			if (!allSame) {
				buf.append("" ... "");
				if (postfix != null) {
					buf.append(postfix);
				}
			}
			context.getFutureResult(0).setLabel(buf.toString());
		} else {
			context.getFutureResult(0).setLabel(""Event log array from file '"" + filename + ""'"");
		}
	}

	private String greatestCommonPrefix(String a, String b) {
		int minLength = Math.min(a.length(), b.length());
		for (int i = 0; i < minLength; i++) {
			if (a.charAt(i) != b.charAt(i)) {
				return a.substring(0, i);
			}
		}
		return a.substring(0, minLength);
	}
}
"
ImportXEventClassifierListPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import java.io.InputStream;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.log.models.XEventClassifierList;
import org.processmining.log.parsers.SaxHandlerGlobalEventAttributesParser;
import org.processmining.log.parsers.SaxHandlerXEventClassifierParser;
import org.processmining.plugins.log.OpenLogFilePlugin;

@Plugin(name = ""Import XEvent Classifiers list form event log"", parameterLabels = { ""Filename"" }, returnLabels = {
		""XEventClassifier List"" }, returnTypes = {
				XEventClassifierList.class }, help = ""This plugin performs a lightweight read of the XLog and retrieves the available XEventClassifiers as a list. This plugins is mainly used by RapidProM"")
@UIImportPlugin(description = ""Import XEvent Classifiers list form event log"", extensions = { ""xes"", ""zip"", ""gz"" })
public class ImportXEventClassifierListPlugin extends OpenLogFilePlugin {
	protected XEventClassifierList importFromStream(PluginContext context, InputStream input, String filename,
			long fileSizeInBytes) throws Exception {
		SAXParserFactory saxFactory = SAXParserFactory.newInstance();
		try {
			saxFactory.setValidating(false);
			saxFactory.setNamespaceAware(false);
			saxFactory.setSchema(null);
		} catch (UnsupportedOperationException e) {

		}
		InputStream is = getInputStream(getFile());
		SAXParser globalsParser = saxFactory.newSAXParser();
		SaxHandlerGlobalEventAttributesParser globalsHandler = new SaxHandlerGlobalEventAttributesParser();
		globalsParser.parse(is, globalsHandler);
		is.close();

		is = getInputStream(getFile());
		SAXParser classifiersParser = saxFactory.newSAXParser();
		SaxHandlerXEventClassifierParser classifiersHandler = new SaxHandlerXEventClassifierParser(
				globalsHandler.getGlobalEventAttributes());
		classifiersParser.parse(is, classifiersHandler);
		is.close();

		return classifiersHandler.getClassifierList();
	}
}
"
LogCentralityFilterPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LogCentralityFilterAlgorithm;
import org.processmining.log.connections.LogCentralityFilterConnection;
import org.processmining.log.dialogs.LogCentralityFilterDialog;
import org.processmining.log.help.LogCentralityFilterHelp;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityFilterParameters;

@Plugin(name = ""Happify Log"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Happifiable Log"", ""Parameters"" }, returnLabels = { ""Happified Log"" }, returnTypes = { XLog.class }, help = LogCentralityFilterHelp.TEXT)
public class LogCentralityFilterPlugin extends LogCentralityFilterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack=""Log"")
	@PluginVariant(variantLabel = ""Happify Log, UI"", requiredParameterLabels = { 0 })
	public XLog runDialog(UIPluginContext context, LogCentrality centrality) {
		LogCentralityFilterParameters parameters = new LogCentralityFilterParameters(centrality);
		LogCentralityFilterDialog dialog = new LogCentralityFilterDialog(context, centrality, parameters);
		InteractionResult result = context.showWizard(""Configure Happification of Log"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, centrality, parameters);
	}
	
	@PluginVariant(variantLabel = ""Happify Log, Parameters"", requiredParameterLabels = { 0, 1 })
	public XLog runParameters(PluginContext context, LogCentrality centrality, LogCentralityFilterParameters parameters) {
		return runConnections(context, centrality, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack=""Log"")
	@PluginVariant(variantLabel = ""Happify Log, Default"", requiredParameterLabels = { 0 })
	public XLog runDefault(PluginContext context, LogCentrality centrality) {
		LogCentralityFilterParameters parameters = new LogCentralityFilterParameters(centrality);
		return runConnections(context, centrality, parameters);
	}
	
	private XLog runConnections(PluginContext context, LogCentrality centrality, LogCentralityFilterParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LogCentralityFilterConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LogCentralityFilterConnection.class, context, centrality);
				for (LogCentralityFilterConnection connection : connections) {
					if (connection.getObjectWithRole(LogCentralityFilterConnection.LOGCENTRALITY)
							.equals(centrality) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LogCentralityFilterConnection.LOG);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		XLog filteredLog = apply(context, centrality, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LogCentralityFilterConnection(filteredLog, centrality, parameters));
		}
		return filteredLog;
	}
}
"
LogCentralityPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LogCentralityAlgorithm;
import org.processmining.log.connections.LogCentralityConnection;
import org.processmining.log.dialogs.LogCentralityDialog;
import org.processmining.log.help.LogCentralityHelp;
import org.processmining.log.models.LogCentrality;
import org.processmining.log.parameters.LogCentralityParameters;

@Plugin(name = ""Create Happifiable Log"", categories = { PluginCategory.Enhancement }, parameterLabels = { ""Event Log"", ""Parameters"" }, returnLabels = { ""Happifiable Log"" }, returnTypes = { LogCentrality.class }, help = LogCentralityHelp.TEXT)
public class LogCentralityPlugin extends LogCentralityAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack=""Log"")
	@PluginVariant(variantLabel = ""Create Happifiable Log, UI"", requiredParameterLabels = { 0 })
	public LogCentrality runUI(UIPluginContext context, XLog log) {
		LogCentralityParameters parameters = new LogCentralityParameters(log);
		LogCentrality centrality = new LogCentrality(log);
		LogCentralityDialog dialog = new LogCentralityDialog(context, log, centrality, parameters);
		InteractionResult result = context.showWizard(""Configure Creation of Happifiable Log"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, centrality, parameters);
	}
	
	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public LogCentrality runDialog(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}
	
	@PluginVariant(variantLabel = ""Create Happifiable Log, Parameters"", requiredParameterLabels = { 0, 1 })
	public LogCentrality run(PluginContext context, XLog log, LogCentralityParameters parameters) {
		LogCentrality centrality = new LogCentrality(log);
		return runConnections(context, log, centrality, parameters);
	}
	
	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public LogCentrality runParameters(PluginContext context, XLog log, LogCentralityParameters parameters) {
		return run(context, log, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack=""Log"")
	@PluginVariant(variantLabel = ""Create Happifiable Log, Default"", requiredParameterLabels = { 0 })
	public LogCentrality runDefault(PluginContext context, XLog log) {
		LogCentralityParameters parameters = new LogCentralityParameters(log);
		LogCentrality centrality = new LogCentrality(log);
		return runConnections(context, log, centrality, parameters);
	}
	
	private LogCentrality runConnections(PluginContext context, XLog log, LogCentrality centrality, LogCentralityParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LogCentralityConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LogCentralityConnection.class, context, log);
				for (LogCentralityConnection connection : connections) {
					if (connection.getObjectWithRole(LogCentralityConnection.LOG)
							.equals(log) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LogCentralityConnection.LOGCENTRALITY);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		LogCentrality logCentrality = apply(context, log, centrality, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LogCentralityConnection(log, logCentrality, parameters));
		}
		return logCentrality;
	}
}
"
LogCentralityVisualizerPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import javax.swing.JComponent;

import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.XLogInfoFactory;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.log.algorithms.LogCentralityVisualizerAlgorithm;
import org.processmining.log.models.LogCentrality;

public class LogCentralityVisualizerPlugin extends LogCentralityVisualizerAlgorithm {

	@Plugin(name = ""Log Summary"", parameterLabels = ""Happifiable Log"", returnTypes = JComponent.class, returnLabels = ""Log Visualization"", userAccessible = false, mostSignificantResult = 1, help = ""Provides an overview of the centralized log"")
	@Visualizer(name = ""Log Summary"")
	public JComponent visualizeLog(PluginContext context, LogCentrality centrality) throws ConnectionCannotBeObtained {
		XLogInfo info = XLogInfoFactory.createLogInfo(centrality.getLog(), centrality.getClassifier());
		JComponent component = context.tryToFindOrConstructFirstNamedObject(JComponent.class, ""  Log Summary"", null,
				null, centrality.getLog(), info);
		return component;
	}

	@Plugin(name = ""Trace Happiness"", parameterLabels = ""Happifiable Log"", returnTypes = JComponent.class, returnLabels = ""Log Visualization"", userAccessible = false, mostSignificantResult = 1, help = ""Provides an overview of the centralized log"")
	@Visualizer(name = ""Trace Happiness Visualizer"")
	public JComponent visualize(PluginContext context, LogCentrality centrality) {
		return apply(centrality, null);
	}

}
"
LogCheckerPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import java.util.EnumSet;

import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.HTMLToString;
import org.processmining.log.algorithms.LogCheckerAlgorithm;
import org.processmining.log.help.LogCheckerHelp;
import org.processmining.log.logchecks.LogCheckType;
import org.processmining.log.models.LogCheckerReport;
import org.processmining.log.parameters.LogCheckerParameters;

@Plugin(name = ""Check Log"", categories = {}, parameterLabels = { ""Log"", ""Parameters"" }, returnLabels = {
		""Log Check Report"" }, returnTypes = { HTMLToString.class }, help = LogCheckerHelp.TEXT)
public class LogCheckerPlugin extends LogCheckerAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Check Log, default"", requiredParameterLabels = { 0 })
	public LogCheckerReport runDefault(PluginContext context, XLog log) {
		LogCheckerParameters parameters = new LogCheckerParameters();
		parameters.setLogChecks(EnumSet.of(
				LogCheckType.LOG_CHECK_EVENT_CLASSIFIERS_GLOBAL,
				LogCheckType.LOG_CHECK_GLOBAL_ATTRIBUTE, 
				LogCheckType.LOG_CHECK_CONSISTENT_TYPES));
		return apply(context, log, parameters);
	}
}
"
LogFrequencyArrayPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.dialogs.LogFrequencyDialog;
import org.processmining.log.help.LogFrequencyArrayHelp;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.LogFrequencyArray;
import org.processmining.log.parameters.LogFrequencyParameters;

@Plugin(name = ""Create Frequency Distributions"", parameterLabels = { ""Event Logs"" }, returnLabels = { ""Log Frequency Distribution"" }, returnTypes = { LogFrequencyArray.class }, userAccessible = true, help = LogFrequencyArrayHelp.TEXT)
public class LogFrequencyArrayPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Create Frequency Distributions, UI"", requiredParameterLabels = { 0 })
	public LogFrequencyArray runUI(UIPluginContext context, EventLogArray logs) {
		LogFrequencyParameters parameters = new LogFrequencyParameters(logs.getLog(0));
		LogFrequencyDialog dialog = new LogFrequencyDialog(logs.getLog(0), parameters);
		InteractionResult result = context.showWizard(""Configure Frequency Distributions (classifier)"", true, true,
				dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return (new LogFrequencyArrayPlugin()).run(context, logs, parameters);
	}

	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public LogFrequencyArray publicUI(UIPluginContext context, EventLogArray logs) {
		return runUI(context, logs);
		
	}
	@PluginVariant(variantLabel = ""Create Frequency Distributions, Parameters"", requiredParameterLabels = { 0 })
	public LogFrequencyArray run(PluginContext context, EventLogArray logs, LogFrequencyParameters parameters) {
		return (new LogFrequencyArrayPlugin()).run(context, logs, parameters);
	}

	/**
	 * @deprecated Use run() instead.
	 */
	@Deprecated
	public LogFrequencyArray publicParameters(PluginContext context, EventLogArray logs, LogFrequencyParameters parameters) {
		return run(context, logs, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Create Frequency Distributions, Default"", requiredParameterLabels = { 0 })
	public LogFrequencyArray runDefault(PluginContext context, EventLogArray logs) {
		LogFrequencyParameters parameters = new LogFrequencyParameters(logs.getLog(0));
		return (new LogFrequencyArrayPlugin()).run(context, logs, parameters);
	}
	
	/**
	 * @deprecated Use runDefault() instead.
	 */
	@Deprecated
	public LogFrequencyArray publicDefault(PluginContext context, EventLogArray logs) {
		return runDefault(context, logs);
	}
}
"
LogFrequencyPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LogFrequencyAlgorithm;
import org.processmining.log.connections.LogFrequencyConnection;
import org.processmining.log.dialogs.LogFrequencyDialog;
import org.processmining.log.help.LogFrequencyHelp;
import org.processmining.log.models.LogFrequency;
import org.processmining.log.parameters.LogFrequencyParameters;

@Plugin(name = ""Create Frequency Distribution"", parameterLabels = { ""Event Log"" }, returnLabels = { ""Log Frequency Distribution"" }, returnTypes = { LogFrequency.class }, userAccessible = true, help = LogFrequencyHelp.TEXT)
public class LogFrequencyPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Create Frequency Distribution, UI"", requiredParameterLabels = { 0 })
	public LogFrequency runUI(UIPluginContext context, XLog log) {
		LogFrequencyParameters parameters = new LogFrequencyParameters(log);
		LogFrequencyDialog dialog = new LogFrequencyDialog(log, parameters);
		InteractionResult result = context.showWizard(""Configure Frequency Distribution (classifier)"", true, true,
				dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runUI() instead.
	 */
	@Deprecated
	public LogFrequency publicUI(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}
	
	@PluginVariant(variantLabel = ""Create Frequency Distribution, Parameters"", requiredParameterLabels = { 0 })
	public LogFrequency run(PluginContext context, XLog log, LogFrequencyParameters parameters) {
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use run() instead.
	 */
	@Deprecated
	public LogFrequency publicParameters(PluginContext context, XLog log, LogFrequencyParameters parameters) {
		return run(context, log, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Create Frequency Distribution, Default"", requiredParameterLabels = { 0 })
	public LogFrequency runDefault(PluginContext context, XLog log) {
		LogFrequencyParameters parameters = new LogFrequencyParameters(log);
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runDefault() instead.
	 */
	@Deprecated
	public LogFrequency publicDefault(PluginContext context, XLog log) {
		return runDefault(context, log);
	}

	private LogFrequency runConnections(PluginContext context, XLog log, LogFrequencyParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LogFrequencyConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LogFrequencyConnection.class, context, log);
				for (LogFrequencyConnection connection : connections) {
					if (connection.getObjectWithRole(LogFrequencyConnection.LOG)
							.equals(log) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LogFrequencyConnection.LOGFREQUENCY);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		LogFrequency logFrequency = (new LogFrequencyAlgorithm()).apply(context, log, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LogFrequencyConnection(log, logFrequency, parameters));
		}
		return logFrequency;
	}
}
"
LowFrequencyFilterArrayPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LowFrequencyFilterAlgorithm;
import org.processmining.log.dialogs.LowFrequencyFilterDialog;
import org.processmining.log.help.LowFrequencyFilterArrayHelp;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

@Plugin(name = ""Filter Out Low-Frequency Traces (Multiple Logs)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Logs"" }, returnLabels = { ""Filtered Logs"" }, returnTypes = { EventLogArray.class }, userAccessible = true, help = LowFrequencyFilterArrayHelp.TEXT)
public class LowFrequencyFilterArrayPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Multiple Logs), UI"", requiredParameterLabels = { 0 })
	public EventLogArray runUI(UIPluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			XLog log = logs.getLog(0);
			LowFrequencyFilterParameters parameters = new LowFrequencyFilterParameters(log);
			LowFrequencyFilterDialog dialog = new LowFrequencyFilterDialog(log, parameters);
			InteractionResult result = context.showWizard(""Configure Low-Frequency Filter"", true, true, dialog);
			if (result != InteractionResult.FINISHED) {
				return null;
			}
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowFrequencyFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public EventLogArray publicUIArray(UIPluginContext context, EventLogArray logs) {
		return runUI(context, logs);
	}
	
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Multiple Logs), Parameters"", requiredParameterLabels = { 0 })
	public EventLogArray run(PluginContext context, EventLogArray logs,
			LowFrequencyFilterParameters parameters) {
		if (logs.getSize() > 0) {
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowFrequencyFilterAlgorithm()).apply(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public EventLogArray publicParameters(PluginContext context, EventLogArray logs,
			LowFrequencyFilterParameters parameters) {
		return run(context, logs, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Multiple Logs), Default"", requiredParameterLabels = { 0 })
	public EventLogArray runDefault(PluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			LowFrequencyFilterParameters parameters = new LowFrequencyFilterParameters(logs.getLog(0));
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowFrequencyFilterAlgorithm()).apply(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runDefault instead.
	 */
	@Deprecated
	public EventLogArray publicDefault(PluginContext context, EventLogArray logs) {
		return runDefault(context, logs);
	}
}
"
LowFrequencyFilterPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LowFrequencyFilterAlgorithm;
import org.processmining.log.connections.LowFrequencyFilterConnection;
import org.processmining.log.dialogs.LowFrequencyFilterDialog;
import org.processmining.log.help.LowFrequencyFilterHelp;
import org.processmining.log.parameters.LowFrequencyFilterParameters;

@Plugin(name = ""Filter Out Low-Frequency Traces (Single Log)"", categories = { PluginCategory.Filtering }, parameterLabels = {""Event Log""}, returnLabels = { ""Filtered Log"" }, returnTypes = {XLog.class }, userAccessible = true, help = LowFrequencyFilterHelp.TEXT)
public class LowFrequencyFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Single Log), UI"", requiredParameterLabels = { 0 })
	public XLog runUI(UIPluginContext context, XLog log) {
		LowFrequencyFilterParameters parameters = new LowFrequencyFilterParameters(log);
		LowFrequencyFilterDialog dialog = new LowFrequencyFilterDialog(log, parameters);
		InteractionResult result = context.showWizard(""Configure Low-Frequency Filter"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, parameters);
	}
	
	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public XLog publicUI(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}
	
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Single Log), Parameters"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log, LowFrequencyFilterParameters parameters) {
		return runConnections(context, log, parameters);
	}
	
	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public XLog publicParameters(PluginContext context, XLog log, LowFrequencyFilterParameters parameters) {
		return run(context, log, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Frequency Traces (Single Log), Default"", requiredParameterLabels = { 0 })
	public XLog runDefault(PluginContext context, XLog log) {
		LowFrequencyFilterParameters parameters = new LowFrequencyFilterParameters(log);
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public XLog publicDefault(PluginContext context, XLog log) {
		return runDefault(context, log);
	}
	
	private XLog runConnections(PluginContext context, XLog log, LowFrequencyFilterParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LowFrequencyFilterConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LowFrequencyFilterConnection.class, context, log);
				for (LowFrequencyFilterConnection connection : connections) {
					if (connection.getObjectWithRole(LowFrequencyFilterConnection.LOG)
							.equals(log) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LowFrequencyFilterConnection.FILTEREDLOG);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		XLog filteredLog = (new LowFrequencyFilterAlgorithm()).apply(context, log, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LowFrequencyFilterConnection(log, filteredLog, parameters));
		}
		return filteredLog;
	}
}
"
LowOccurrencesFilterArrayPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.dialogs.LowOccurrencesFilterDialog;
import org.processmining.log.help.LowOccurrencesFilterArrayHelp;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

@Plugin(name = ""Filter Out Low-Occurrence Traces (Multiple Logs)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Logs"" }, returnLabels = { ""Filtered Logs"" }, returnTypes = { EventLogArray.class }, userAccessible = true, help = LowOccurrencesFilterArrayHelp.TEXT)
public class LowOccurrencesFilterArrayPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Multiple Logs), UI"", requiredParameterLabels = { 0 })
	public EventLogArray runUI(UIPluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			XLog log = logs.getLog(0);
			LowOccurrencesFilterParameters parameters = new LowOccurrencesFilterParameters(log);
			LowOccurrencesFilterDialog dialog = new LowOccurrencesFilterDialog(log, parameters);
			InteractionResult result = context.showWizard(""Configure Low-Occurrence Filter"", true, true, dialog);
			if (result != InteractionResult.FINISHED) {
				return null;
			}
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowOccurrencesFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public EventLogArray publicUIArray(UIPluginContext context, EventLogArray logs) {
		return runUI(context, logs);
	}
	
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Multiple Logs), Parameters"", requiredParameterLabels = { 0 })
	public EventLogArray run(PluginContext context, EventLogArray logs,
			LowOccurrencesFilterParameters parameters) {
		if (logs.getSize() > 0) {
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowOccurrencesFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public EventLogArray publicParameters(UIPluginContext context, EventLogArray logs,
			LowOccurrencesFilterParameters parameters) {
		return run(context, logs, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Multiple Logs), Default"", requiredParameterLabels = { 0 })
	public EventLogArray runDefault(PluginContext context, EventLogArray logs) {
		if (logs.getSize() > 0) {
			LowOccurrencesFilterParameters parameters = new LowOccurrencesFilterParameters(logs.getLog(0));
			EventLogArray filteredLogs = EventLogArrayFactory.createEventLogArray();
			filteredLogs.init();
			for (int i = 0; i < logs.getSize(); i++) {
				filteredLogs.addLog((new LowOccurrencesFilterPlugin()).run(context, logs.getLog(i), parameters));
			}
			return filteredLogs;
		}
		return null;
	}

	/**
	 * @deprecated Use runDefault instead.
	 */
	@Deprecated
	public EventLogArray publicDefault(UIPluginContext context, EventLogArray logs) {
		return runDefault(context, logs);
	}
	
}
"
LowOccurrencesFilterPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import java.util.Collection;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.LowOccurrencesFilterAlgorithm;
import org.processmining.log.connections.LowOccurrencesFilterConnection;
import org.processmining.log.dialogs.LowOccurrencesFilterDialog;
import org.processmining.log.help.LowOccurrencesFilterHelp;
import org.processmining.log.parameters.LowOccurrencesFilterParameters;

@Plugin(name = ""Filter Out Low-Occurrence Traces (Single Log)"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Event Log"" }, returnLabels = { ""Filtered Log"" }, returnTypes = { XLog.class }, userAccessible = true, help = LowOccurrencesFilterHelp.TEXT)
public class LowOccurrencesFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Single Log), UI"", requiredParameterLabels = { 0 })
	public XLog runUI(UIPluginContext context, XLog log) {
		LowOccurrencesFilterParameters parameters = new LowOccurrencesFilterParameters(log);
		LowOccurrencesFilterDialog dialog = new LowOccurrencesFilterDialog(log, parameters);
		InteractionResult result = context.showWizard(""Configure Low-Occurrence Filter"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			return null;
		}
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use runUI instead.
	 */
	@Deprecated
	public XLog publicUI(UIPluginContext context, XLog log) {
		return runUI(context, log);
	}
	
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Single Log), Parameters"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log, LowOccurrencesFilterParameters parameters) {
		return runConnections(context, log, parameters);
	}

	/**
	 * @deprecated Use run instead.
	 */
	@Deprecated
	public XLog publicParameters(UIPluginContext context, XLog log, LowOccurrencesFilterParameters parameters) {
		return run(context, log, parameters);
	}
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""Eric Verbeek"", email = ""h.m.w.verbeek@tue.nl"", website = ""www.processmining.org"")
	@PluginVariant(variantLabel = ""Filter Out Low-Occurrence Traces (Single Log), Default"", requiredParameterLabels = { 0 })
	public XLog runDefault(PluginContext context, XLog log) {
		LowOccurrencesFilterParameters parameters = new LowOccurrencesFilterParameters(log);
		return runConnections(context, log, parameters);
	}
	
	/**
	 * @deprecated Use runDefault instead.
	 */
	@Deprecated
	public XLog publicDefault(UIPluginContext context, XLog log) {
		return runDefault(context, log);
	}
	
	private XLog runConnections(PluginContext context, XLog log, LowOccurrencesFilterParameters parameters) {
		if (parameters.isTryConnections()) {
			Collection<LowOccurrencesFilterConnection> connections;
			try {
				connections = context.getConnectionManager().getConnections(
						LowOccurrencesFilterConnection.class, context, log);
				for (LowOccurrencesFilterConnection connection : connections) {
					if (connection.getObjectWithRole(LowOccurrencesFilterConnection.LOG)
							.equals(log) && connection.getParameters().equals(parameters)) {
						return connection
								.getObjectWithRole(LowOccurrencesFilterConnection.FILTEREDLOG);
					}
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		XLog filteredLog = (new LowOccurrencesFilterAlgorithm()).apply(context, log, parameters);
		if (parameters.isTryConnections()) {
			context.getConnectionManager().addConnection(
					new LowOccurrencesFilterConnection(log, filteredLog, parameters));
		}
		return filteredLog;
	}

}
"
MergeLogsPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.MergeLogsAlgorithm;
import org.processmining.log.dialogs.MergeLogsDialog;
import org.processmining.log.help.MergeLogsHelp;
import org.processmining.log.parameters.MergeLogsParameters;

@Plugin(name = ""Merge logs"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Main Log"", ""Sub log"", ""Parameters"" }, 
returnLabels = { ""Merged logs"" }, returnTypes = { XLog.class }, help = MergeLogsHelp.TEXT)
public class MergeLogsPlugin extends MergeLogsAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Decomposed Discovery, UI"", requiredParameterLabels = { 0, 1 })
	public XLog runUI(UIPluginContext context, XLog mainLog, XLog subLog) {
		MergeLogsParameters parameters = new MergeLogsParameters();
		MergeLogsDialog dialog = new MergeLogsDialog(parameters, mainLog);
		InteractionResult result = context.showWizard(""Configure merge"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			context.getFutureResult(0).cancel(true);
			return null;
		}
		return run(context, mainLog, subLog, parameters);
	}

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Merge logs, Default"", requiredParameterLabels = { 0, 1 })
	public XLog run(PluginContext context, XLog mainLog, XLog subLog) {
		MergeLogsParameters parameters = new MergeLogsParameters();

		XLog log = apply(context, mainLog, subLog, parameters);

		return log;
	}

	@PluginVariant(variantLabel = ""Merge logs, Parameters"", requiredParameterLabels = { 0, 1, 2 })
	public XLog run(PluginContext context, XLog mainLog, XLog subLog,
			MergeLogsParameters parameters) {

		XLog log = apply(context, mainLog, subLog, parameters);

		return log;
	}
}
"
SplitLogPlugin.java,log-6.9.380,"package org.processmining.log.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.algorithms.SplitLogAlgorithm;
import org.processmining.log.dialogs.SplitLogDialog;
import org.processmining.log.help.SplitLogHelp;
import org.processmining.log.parameters.SplitLogParameters;

@Plugin(name = ""Split traces"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Parameters"" }, 
returnLabels = { ""Log containing splitted traces"" }, returnTypes = { XLog.class }, help = SplitLogHelp.TEXT)
public class SplitLogPlugin extends SplitLogAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Split traces, UI"", requiredParameterLabels = { 0 })
	public XLog runUI(UIPluginContext context, XLog log) {
		SplitLogParameters parameters = new SplitLogParameters(log);
		SplitLogDialog dialog = new SplitLogDialog(parameters, log);
		InteractionResult result = context.showWizard(""Configure split"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			context.getFutureResult(0).cancel(true);
			return null;
		}
		return run(context, log, parameters);
	}

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Merge logs, Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitLogParameters parameters = new SplitLogParameters(log);

		XLog splittedLog = apply(context, log, parameters);

		return splittedLog;
	}

	@PluginVariant(variantLabel = ""Merge logs, Parameters"", requiredParameterLabels = { 0, 1 })
	public XLog run(PluginContext context, XLog log,
			SplitLogParameters parameters) {

		XLog splittedLog = apply(context, log, parameters);

		return splittedLog;
	}
}
"
RepairAttributeDataType.java,log-6.9.380,"package org.processmining.log.repair;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.text.DateFormat;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Pattern;

import javax.swing.DefaultCellEditor;
import javax.swing.DefaultComboBoxModel;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumnModel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.util.ui.widgets.ProMScrollPane;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.framework.util.ui.widgets.helper.UserCancelledException;
import org.processmining.log.formats.StandardDateFormats;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;

/**
 * Tries to automatically guess the data type of all XES attributes and updates
 * the log accordingly.
 * <p>
 * PLEASE NOTE: This filter will update the original XLog instead of creating a
 * new XLog, to be able to process huge logs without exhausting the available
 * memory.
 * 
 * @author F. Mannhardt
 * 
 */
public final class RepairAttributeDataType {

	private static class ReviewTable {

		private Map<String, Class<? extends XAttribute>> attributeDataType;
		private final JTable datatypeTable;
		private final DefaultTableModel tableModel;

		@SuppressWarnings({ ""unchecked"", ""serial"" })
		public ReviewTable(final Map<String, Class<? extends XAttribute>> attributeDataType) {
			super();
			this.attributeDataType = attributeDataType;
			this.tableModel = new DefaultTableModel() {

				public void setValueAt(Object aValue, int row, int column) {
					super.setValueAt(aValue, row, column);
					attributeDataType.put(getColumnName(column), (Class<? extends XAttribute>) aValue);
				}

			};

			for (String attributeKey : Ordering.natural().immutableSortedCopy(attributeDataType.keySet())) {
				Class<? extends XAttribute> dataType = attributeDataType.get(attributeKey);
				tableModel.addColumn(attributeKey, new Class[] { dataType });
			}

			this.datatypeTable = new JTable(tableModel);
			JComboBox<Class<? extends XAttribute>> comboBox = new JComboBox<>(
					new DefaultComboBoxModel<Class<? extends XAttribute>>(new Class[] { XAttributeBoolean.class,
							XAttributeContinuous.class, XAttributeDiscrete.class, XAttributeLiteral.class,
							XAttributeTimestamp.class }));
			comboBox.setRenderer(new DefaultListCellRenderer() {

				@SuppressWarnings(""rawtypes"")
				public Component getListCellRendererComponent(JList<?> list, Object value, int index,
						boolean isSelected, boolean cellHasFocus) {
					JLabel superComponent = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected,
							cellHasFocus);
					superComponent.setText(((Class) value).getSimpleName());
					return superComponent;
				}

			});
			datatypeTable.setDefaultEditor(Object.class, new DefaultCellEditor(comboBox));
			datatypeTable.setDefaultRenderer(Object.class, new DefaultTableCellRenderer() {

				@SuppressWarnings(""rawtypes"")
				public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
						boolean hasFocus, int row, int column) {
					JLabel c = (JLabel) super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row,
							column);
					c.setText(((Class) value).getSimpleName());
					return c;
				}

			});

			datatypeTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
			resizeColumnWidth(datatypeTable);
		}

		public Map<String, Class<? extends XAttribute>> getDataTypeMap() {
			return attributeDataType;
		}

		public JComponent getDatatypeTable() {
			JPanel workaroundPanel = new JPanel(new BorderLayout());
			ProMScrollPane scrollPane = new ProMScrollPane(datatypeTable);
			scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
			scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);
			workaroundPanel.add(scrollPane, BorderLayout.CENTER);
			workaroundPanel.setPreferredSize(new Dimension(400, 200));
			return workaroundPanel;
		}

		public void resizeColumnWidth(JTable table) {
			final TableColumnModel columnModel = table.getColumnModel();
			for (int column = 0; column < table.getColumnCount(); column++) {
				int width = 150; // Min width
				for (int row = 0; row < table.getRowCount(); row++) {
					TableCellRenderer renderer = table.getCellRenderer(row, column);
					Component comp = table.prepareRenderer(renderer, row, column);
					width = Math.max(comp.getPreferredSize().width * 2, width);
				}
				columnModel.getColumn(column).setPreferredWidth(width);
			}
		}

	}

	public interface ReviewCallback {
		Map<String, Class<? extends XAttribute>> reviewDataTypes(
				Map<String, Class<? extends XAttribute>> guessedDataTypes);
	}

	public RepairAttributeDataType() {
		super();
	}

	public void doRepairEventAttributes(PluginContext context, XLog log, Iterable<? extends DateFormat> dateFormats) {
		doRepairEventAttributes(context, log, dateFormats, null);
	}

	public void doRepairEventAttributes(PluginContext context, XLog log, Iterable<? extends DateFormat> dateFormats,
			ReviewCallback reviewCallback) {

		Progress progBar = context.getProgress();
		progBar.setMinimum(0);
		progBar.setMaximum(log.size() * 2); // two pass
		progBar.setValue(0);

		Map<String, Class<? extends XAttribute>> guessedDataType = new HashMap<>();

		// Determine best datatype
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				buildDataTypeMap(event.getAttributes(), guessedDataType, dateFormats);
			}
			if (progBar.isCancelled()) {
				return;
			}
			progBar.inc();
		}

		boolean isDefinite = false;

		if (reviewCallback != null) {
			guessedDataType = reviewCallback.reviewDataTypes(guessedDataType);
			isDefinite = true; // Always obey user input
		}

		XFactory factory = XFactoryRegistry.instance().currentDefault();
		ListIterator<XTrace> traceIterator = log.listIterator();

		while (traceIterator.hasNext()) {

			XTrace trace = traceIterator.next();
			ListIterator<XEvent> eventIterator = trace.listIterator();

			while (eventIterator.hasNext()) {
				int eventIndex = eventIterator.nextIndex();
				XEvent event = eventIterator.next();
				XAttributeMap eventAttr = event.getAttributes();
				repairAttributes(context, factory, eventAttr, dateFormats, guessedDataType, isDefinite);
				trace.set(eventIndex, event);
			}
			if (progBar.isCancelled()) {
				return;
			}
			progBar.inc();
		}

	}

	public void doRepairTraceAttributes(PluginContext context, XLog log, Iterable<? extends DateFormat> dateFormats) {
		doRepairTraceAttributes(context, log, dateFormats, null);
	}

	public void doRepairTraceAttributes(PluginContext context, XLog log, Iterable<? extends DateFormat> dateFormats,
			ReviewCallback reviewCallback) {

		Progress progBar = context.getProgress();
		progBar.setMinimum(0);
		progBar.setMaximum(log.size() * 2); // two pass
		progBar.setValue(0);

		Map<String, Class<? extends XAttribute>> guessedDataType = new HashMap<>();

		// Determine best datatype
		for (XTrace trace : log) {
			buildDataTypeMap(trace.getAttributes(), guessedDataType, dateFormats);
			if (progBar.isCancelled()) {
				return;
			}
			progBar.inc();
		}

		boolean isDefinite = false;

		if (reviewCallback != null) {
			guessedDataType = reviewCallback.reviewDataTypes(guessedDataType);
			isDefinite = true;
		}

		XFactory factory = XFactoryRegistry.instance().currentDefault();

		ListIterator<XTrace> traceIterator = log.listIterator();

		while (traceIterator.hasNext()) {

			XTrace trace = traceIterator.next();
			XAttributeMap traceAttr = trace.getAttributes();
			repairAttributes(context, factory, traceAttr, dateFormats, guessedDataType, isDefinite);

			if (progBar.isCancelled()) {
				return;
			}
			progBar.inc();
		}

	}

	/**
	 * Shows a wizard that allows the user to specify an additional custom date
	 * format.
	 * 
	 * @param context
	 * @return a set of DateFormats including the user specified format
	 */
	public static Iterable<? extends DateFormat> queryDateFormats(UIPluginContext context) {

		try {
			String dateFormat = ProMUIHelper
					.queryForString(
							context,
							""Specify a custom DateFormat pattern (Format as defined in Java SimpleDateFormat) that is used to parse literal attributes that contain dates (LEAVE BLANK OR CANCEL TO USE DEFAULTS)"");
			SimpleDateFormat userDateFormat;
			if (dateFormat != null && !dateFormat.isEmpty()) {
				try {
					userDateFormat = new SimpleDateFormat(dateFormat);
					return Iterables.concat(ImmutableList.of(userDateFormat),
							StandardDateFormats.getStandardDateFormats());
				} catch (IllegalArgumentException e) {
					JOptionPane.showMessageDialog(null, e.getMessage(), ""Wrong Date Format"", JOptionPane.ERROR_MESSAGE);
				}
			}
		} catch (UserCancelledException e) {
		}

		return StandardDateFormats.getStandardDateFormats();
	}

	/**
	 * 
	 * 
	 * @param context
	 * @param attributeDataType
	 * @return
	 */
	public static Map<String, Class<? extends XAttribute>> queryCustomDataTypes(UIPluginContext context,
			Map<String, Class<? extends XAttribute>> attributeDataType) {
		ReviewTable reviewPanel = new ReviewTable(attributeDataType);
		InteractionResult reviewResult = context.showConfiguration(
				""Review/Adjust the automatically determined data types"", reviewPanel.getDatatypeTable());
		if (reviewResult == InteractionResult.FINISHED) {
			return reviewPanel.getDataTypeMap();
		}
		return attributeDataType;
	}

	private static void repairAttributes(PluginContext context, XFactory factory, XAttributeMap attributes,
			Iterable<? extends DateFormat> dateFormats, Map<String, Class<? extends XAttribute>> attributeDataType,
			boolean isDefinite) {
		// Use entrySet here, to avoid a lot of 'put' operations, maybe the underlying map can optimize the replacement operation using 'entry.setValue'
		Iterator<Entry<String, XAttribute>> traceAttr = attributes.entrySet().iterator();
		while (traceAttr.hasNext()) {
			Entry<String, XAttribute> entry = traceAttr.next();

			if (!isExtensionAttribute(entry.getValue())) {
				if (!(entry.getValue() instanceof XAttributeTimestamp)) {
					Class<? extends XAttribute> dataType = attributeDataType.get(entry.getKey());
					if (dataType != null) {
						try {
							XAttribute newAttribute = createAttribute(dataType, entry, factory, dateFormats);
							if (newAttribute != null) {
								entry.setValue(newAttribute);
							} else {
								throw new RuntimeException(String.format(
										""Could convert of attribute %s to %s NULL value returned."", entry.getKey(),
										dataType));
							}
						} catch (UnexpectedDataTypeException e) {
							if (isDefinite) {
								// remove non-matching entries
								traceAttr.remove();
								context.log(""Removing non-matching value "" + entry.getValue().toString());
							} else {
								throw new RuntimeException(String.format(
										""Could convert of attribute %s to data type %s."", entry.getKey(), dataType), e);
							}
						}
					} else {
						throw new RuntimeException(String.format(
								""Could not find datatype of attribute %s. Available data types are %s."",
								entry.getKey(), attributeDataType));
					}
				}
			}
		}
	}

	private static boolean isExtensionAttribute(XAttribute value) {
		return value.getExtension() != null;
	}

	private static void buildDataTypeMap(XAttributeMap attributes,
			Map<String, Class<? extends XAttribute>> attributeDataType, Iterable<? extends DateFormat> dateFormats) {
		for (XAttribute attribute : attributes.values()) {

			if (!(attribute instanceof XAttributeTimestamp)) {

				try {
					String value = getAttrAsString(attribute);
					Class<? extends XAttribute> currentDataType = inferDataType(value, dateFormats);
					Class<? extends XAttribute> lastDataType = attributeDataType.get(attribute.getKey());

					if (lastDataType == null) {
						// First occurrence
						attributeDataType.put(attribute.getKey(), currentDataType);
					} else if (!lastDataType.equals(currentDataType)) {
						// Stored data type does not match new occurrence

						if (checkChangeBothWays(currentDataType, lastDataType, XAttributeBoolean.class,
								XAttributeDiscrete.class)) {
							// Mixed Boolean (e.g. 0,1) & Integer -> XAttributeDiscrete
							if (lastDataType != XAttributeDiscrete.class) {
								attributeDataType.put(attribute.getKey(), XAttributeDiscrete.class);
							}
						} else if (checkChangeBothWays(currentDataType, lastDataType, XAttributeBoolean.class,
								XAttributeContinuous.class)) {
							// Mixed Boolean  (e.g. 0,1) & Float -> XAttributeContinuous
							if (lastDataType != XAttributeContinuous.class) {
								attributeDataType.put(attribute.getKey(), XAttributeContinuous.class);
							}
						} else if (checkChangeBothWays(currentDataType, lastDataType, XAttributeDiscrete.class,
								XAttributeContinuous.class)) {
							// Mixed Integer & Float -> XAttributeContinuous
							if (lastDataType != XAttributeContinuous.class) {
								attributeDataType.put(attribute.getKey(), XAttributeContinuous.class);
							}
						} else {
							// Fallback to Literal
							if (lastDataType != XAttributeLiteral.class) {
								attributeDataType.put(attribute.getKey(), XAttributeLiteral.class);
							}
						}
					}
				} catch (UnexpectedDataTypeException e) {
					// Ignore this attribute
				}

			}

		}
	}

	private static boolean checkChangeBothWays(Class<? extends XAttribute> dataType,
			Class<? extends XAttribute> lastDataType, Class<? extends XAttribute> class1,
			Class<? extends XAttribute> class2) {
		return (class1.equals(lastDataType) && class2.equals(dataType))
				|| (class2.equals(lastDataType) && class1.equals(dataType));
	}

	private static XAttribute createAttribute(Class<? extends XAttribute> dataType, Entry<String, XAttribute> entry,
			XFactory factory, Iterable<? extends DateFormat> dateFormats) throws UnexpectedDataTypeException {
		if (XAttributeDiscrete.class.equals(dataType)) {
			return factory.createAttributeDiscrete(entry.getKey(), getAttrAsLong(entry.getValue()), null);
		} else if (XAttributeContinuous.class.equals(dataType)) {
			return factory.createAttributeContinuous(entry.getKey(), getAttrAsDouble(entry.getValue()), null);
		} else if (XAttributeBoolean.class.equals(dataType)) {
			return factory.createAttributeBoolean(entry.getKey(), getAttrAsBoolean(entry.getValue()), null);
		} else if (XAttributeLiteral.class.equals(dataType)) {
			return factory.createAttributeLiteral(entry.getKey(), getAttrAsString(entry.getValue()), null);
		} else if (XAttributeTimestamp.class.equals(dataType)) {
			return factory.createAttributeTimestamp(entry.getKey(), getAttrAsDate(entry.getValue(), dateFormats), null);
		} else {
			throw new IllegalArgumentException(String.format(""Unexpected Attribute %s: Type %s instead %s"",
					entry.getValue(), entry.getValue().getClass().getSimpleName(), dataType.getSimpleName()));
		}
	}

	private static Date getAttrAsDate(XAttribute value, Iterable<? extends DateFormat> dateFormats)
			throws UnexpectedDataTypeException {
		if (value instanceof XAttributeLiteral) {
			Date date = tryParseDate(((XAttributeLiteral) value).getValue(), dateFormats);
			if (date == null) {
				throw new UnexpectedDataTypeException(""Unexpected date format "" + value);
			}
			return date;
		} else {
			throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
		}
	}

	private static Date tryParseDate(String value, Iterable<? extends DateFormat> dateFormats) {
		ParsePosition pos = new ParsePosition(0);
		for (DateFormat formatter : dateFormats) {
			pos.setIndex(0);
			Date date = formatter.parse(value, pos);
			if (date != null && pos.getIndex() == value.length()) {
				return date;
			}
		}
		return null;
	}

	private static String getAttrAsString(XAttribute value) throws UnexpectedDataTypeException {
		if (value instanceof XAttributeDiscrete) {
			return Long.toString(((XAttributeDiscrete) value).getValue());
		} else if (value instanceof XAttributeContinuous) {
			return Double.toString(((XAttributeContinuous) value).getValue());
		} else if (value instanceof XAttributeBoolean) {
			return Boolean.toString(((XAttributeBoolean) value).getValue());
		} else if (value instanceof XAttributeLiteral) {
			return ((XAttributeLiteral) value).getValue();
		} else {
			throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
		}
	}

	private static boolean getAttrAsBoolean(XAttribute value) throws UnexpectedDataTypeException {
		if (value instanceof XAttributeBoolean) {
			return ((XAttributeBoolean) value).getValue();
		} else if (value instanceof XAttributeLiteral) {
			String val = ((XAttributeLiteral) value).getValue();
			if (""0"".equals(val) || ""N"".equalsIgnoreCase(val)) {
				return false;
			} else if (""1"".equals(val) || ""J"".equalsIgnoreCase(val) || ""Y"".equalsIgnoreCase(val)) {
				return true;
			} else {
				return Boolean.valueOf(val);
			}
		} else if (value instanceof XAttributeDiscrete) {
			long val = ((XAttributeDiscrete) value).getValue();
			if (val != 0 && val != 1) {
				throw new UnexpectedDataTypeException(""Unexpected value "" + val);
			}
			return Boolean.valueOf(val == 0 ? false : true);
		} else {
			throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
		}
	}

	private static double getAttrAsDouble(XAttribute value) throws UnexpectedDataTypeException {
		try {
			if (value instanceof XAttributeDiscrete) {
				return ((XAttributeDiscrete) value).getValue();
			} else if (value instanceof XAttributeContinuous) {
				return ((XAttributeContinuous) value).getValue();
			} else if (value instanceof XAttributeLiteral) {
				return Double.valueOf(((XAttributeLiteral) value).getValue());
			} else {
				throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
			}
		} catch (NumberFormatException e) {
			throw new UnexpectedDataTypeException(e);
		}
	}

	private static long getAttrAsLong(XAttribute value) throws UnexpectedDataTypeException {
		try {
			if (value instanceof XAttributeDiscrete) {
				return ((XAttributeDiscrete) value).getValue();
			} else if (value instanceof XAttributeLiteral) {
				return Long.valueOf(((XAttributeLiteral) value).getValue());
			} else {
				throw new UnexpectedDataTypeException(""Unexpected attribute type "" + value);
			}
		} catch (NumberFormatException e) {
			throw new UnexpectedDataTypeException(e);
		}
	}

	private static Pattern DISCRETE_PATTERN = Pattern.compile(""(-)?[0-9]{1,19}"");
	private static Pattern CONTINUOUS_PATTERN = Pattern
			.compile(""((-)?[0-9]*\\.[0-9]+)|((-)?[0-9]+(\\.[0-9]+)?(e|E)\\+[0-9]+)"");
	private static Pattern BOOLEAN_PATTERN = Pattern.compile(""(true)|(false)|(TRUE)|(FALSE)|(0)|(1)|(Y)|(N)|(J)"");

	private static Class<? extends XAttribute> inferDataType(String value, Iterable<? extends DateFormat> dateFormats) {
		if (BOOLEAN_PATTERN.matcher(value).matches()) {
			return XAttributeBoolean.class;
		} else if (DISCRETE_PATTERN.matcher(value).matches()) {
			try {
				Long.parseLong(value);
				return XAttributeDiscrete.class;
			} catch (NumberFormatException e) {
				return XAttributeLiteral.class;
			}
		} else if (CONTINUOUS_PATTERN.matcher(value).matches()) {
			return XAttributeContinuous.class;
		} else if (tryParseDate(value, dateFormats) != null) {
			return XAttributeTimestamp.class;
		} else {
			return XAttributeLiteral.class;
		}
	}

}
"
RepairGlobalAttributesPlugin.java,log-6.9.380,"package org.processmining.log.repair;

import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;

import org.deckfour.xes.classification.XEventAttributeClassifier;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XCostExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.util.XAttributeUtils;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;
import org.processmining.framework.util.ui.widgets.helper.UserCancelledException;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.Collections2;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;

public final class RepairGlobalAttributesPlugin {

	private static final Function<XAttribute, XAttribute> PROTOTYPE_TRANSFORMER = new Function<XAttribute, XAttribute>() {

		public XAttribute apply(XAttribute firstAttr) {
			return XAttributeUtils.derivePrototype(firstAttr);
		}
	};

	public interface GlobalInfo {
		
		Collection<XAttribute> getEventAttributes();

		Collection<XAttribute> getTraceAttributes();
		
	}

	@Plugin(name = ""Repair Log: Globals, Classifiers, Extensions (In Place)"", level = PluginLevel.Regular, parameterLabels = { ""Event Log"" },//
			returnLabels = {}, returnTypes = {}, userAccessible = true, mostSignificantResult = -1, categories = { PluginCategory.Enhancement }, //
	help = ""Repairs the Event Log by detecting which attributes are global, updating the information about global attributes, adding possible classifiers, and adding correct extensions to certain attributes (time:timestamp, etc). This plug-ins changes the input event log to be able to deal with large event logs!"")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	public void repairLogInPlace(PluginContext context, XLog log) {

		context.getProgress().setMinimum(0);
		context.getProgress().setMaximum(log.size());
		doRepairLog(log);
	}

	@Plugin(name = ""Repair Log: Globals, Classifiers, Extensions"", level = PluginLevel.PeerReviewed, parameterLabels = { ""Event Log"" }, //
			returnLabels = { ""Repaired Log with Globals"" }, returnTypes = { XLog.class }, userAccessible = true, mostSignificantResult = 1, categories = { PluginCategory.Enhancement }, //
	help = ""Repairs the Event Log by detecting which attributes are global, updating the information about global attributes, adding possible classifiers, and adding correct extensions to certain attributes (time:timestamp, etc)."")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	public XLog repairLog(PluginContext context, XLog log) {

		context.getProgress().setMinimum(0);
		context.getProgress().setMaximum(log.size());

		XLog newLog = (XLog) log.clone();

		doRepairLog(newLog);

		return newLog;
	}

	@Plugin(name = ""Repair Log: Globals, Classifiers, Extensions (In Place)"", level = PluginLevel.Regular, parameterLabels = { ""Event Log"" }, returnLabels = {}, returnTypes = {}, userAccessible = true, mostSignificantResult = -1, categories = { PluginCategory.Enhancement }, //
	help = ""Repairs the Event Log by detecting which attributes are global, updating the information about global attributes, adding possible classifiers, and adding correct extensions to certain attributes (time:timestamp, etc). This plug-ins changes the input event log to be able to deal with large event logs!"")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	public void repairLogInPlaceUI(UIPluginContext context, XLog log) {

		context.getProgress().setMinimum(0);
		context.getProgress().setMaximum(log.size());

		try {
			doRepairLogUI(context, log);
		} catch (UserCancelledException e) {
			context.getFutureResult(0).cancel(false);
		}
	}

	@Plugin(name = ""Repair Log: Globals, Classifiers, Extensions"", level = PluginLevel.PeerReviewed, parameterLabels = { ""Event Log"" }, returnLabels = { ""Repaired Log with Globals"" }, returnTypes = { XLog.class }, userAccessible = true, mostSignificantResult = 1, categories = { PluginCategory.Enhancement }, //
	help = ""Repairs the Event Log by detecting which attributes are global, updating the information about global attributes, adding possible classifiers, and adding correct extensions to certain attributes (time:timestamp, etc)."")
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""F. Mannhardt"", email = ""f.mannhardt@tue.nl"")
	public XLog repairLogUI(UIPluginContext context, XLog log) {

		context.getProgress().setMinimum(0);
		context.getProgress().setMaximum(log.size());

		XLog newLog = (XLog) log.clone();

		try {
			doRepairLogUI(context, newLog);
		} catch (UserCancelledException e) {
			context.getFutureResult(0).cancel(false);
		}

		return newLog;
	}

	public void doRepairLogUI(UIPluginContext context, XLog log) throws UserCancelledException {

		GlobalInfo globals = detectGlobals(log);

		final Set<String> classifierAttribute = ImmutableSet
				.copyOf(ProMUIHelper.queryForObjects(context,
						""Which of the following global attributes should be added as classifier?"",
						Iterables.transform(globals.getEventAttributes(), new Function<XAttribute, String>() {

							public String apply(XAttribute a) {
								return a.getKey();
							}
						})));

		doRepairLog(log, globals, new Predicate<XAttribute>() {

			public boolean apply(XAttribute a) {
				return classifierAttribute.contains(a.getKey());
			}
		});
	}

	public static void doRepairLog(XLog log) {
		doRepairLog(log, detectGlobals(log), new Predicate<XAttribute>() {

			public boolean apply(XAttribute a) {
				return isClassifierAttribute(a);
			}
		});
	}

	public static void doRepairLog(XLog log, GlobalInfo info, Predicate<XAttribute> useForClassifier) {
		for (XAttribute attr : info.getEventAttributes()) {
			if (useForClassifier.apply(attr)) {
				if (!hasClassifier(attr, log.getClassifiers())) {
					log.getClassifiers().add(new XEventAttributeClassifier(attr.getKey(), attr.getKey()));
				}
			}
			switch (attr.getKey()) {
				case XConceptExtension.KEY_NAME :
				case XConceptExtension.KEY_INSTANCE :
					if (!log.getExtensions().contains(XConceptExtension.instance())) {
						log.getExtensions().add(XConceptExtension.instance());
					}
					break;
				case XTimeExtension.KEY_TIMESTAMP :
					if (!log.getExtensions().contains(XTimeExtension.instance())) {
						log.getExtensions().add(XTimeExtension.instance());
					}
					break;
				case XLifecycleExtension.KEY_MODEL :
				case XLifecycleExtension.KEY_TRANSITION :
					if (!log.getExtensions().contains(XLifecycleExtension.instance())) {
						log.getExtensions().add(XLifecycleExtension.instance());
					}
					break;
				case XOrganizationalExtension.KEY_GROUP :
				case XOrganizationalExtension.KEY_RESOURCE :
				case XOrganizationalExtension.KEY_ROLE :
					if (!log.getExtensions().contains(XOrganizationalExtension.instance())) {
						log.getExtensions().add(XOrganizationalExtension.instance());
					}
					break;
				case XCostExtension.KEY_AMOUNT :
				case XCostExtension.KEY_CURRENCY :
				case XCostExtension.KEY_DRIVER :
				case XCostExtension.KEY_TOTAL :
				case XCostExtension.KEY_TYPE :
					if (!log.getExtensions().contains(XCostExtension.instance())) {
						log.getExtensions().add(XCostExtension.instance());
					}
					break;
			}
			if (!hasGlobalAttribute(attr, log.getGlobalEventAttributes())) {
				log.getGlobalEventAttributes().add(attr);
			}
		}

		for (XAttribute attr : info.getTraceAttributes()) {
			if (!hasGlobalAttribute(attr, log.getGlobalTraceAttributes())) {
				log.getGlobalTraceAttributes().add(attr);
			}
		}
	}

	private static boolean hasGlobalAttribute(XAttribute attribute, List<XAttribute> globalAttributes) {
		for (XAttribute globalAttribute : globalAttributes) {
			if (globalAttribute.getKey().equals(attribute.getKey())) {
				return true;
			}
		}
		return false;
	}

	private static boolean hasClassifier(XAttribute attrribute, List<XEventClassifier> classifierList) {
		for (XEventClassifier classifier : classifierList) {
			for (String key : classifier.getDefiningAttributeKeys()) {
				if (key.equals(attrribute.getKey())) {
					return true;
				}
			}
		}
		return false;
	}

	private static boolean isClassifierAttribute(XAttribute attribute) {
		switch (attribute.getKey()) {
			case XConceptExtension.KEY_INSTANCE :
			case XTimeExtension.KEY_TIMESTAMP :
			case XLifecycleExtension.KEY_MODEL :
			case XLifecycleExtension.KEY_TRANSITION :
			case XCostExtension.KEY_AMOUNT :
			case XCostExtension.KEY_CURRENCY :
			case XCostExtension.KEY_DRIVER :
			case XCostExtension.KEY_TOTAL :
			case XCostExtension.KEY_TYPE :
				return false;
		}
		return true;
	}

	public static GlobalInfo detectGlobals(XLog log) {

		Set<XAttribute> eventAttributes = new HashSet<>();
		Set<XAttribute> traceAttributes = new HashSet<>();

		for (ListIterator<XTrace> logIter = log.listIterator(); logIter.hasNext();) {
			int traceIndex = logIter.nextIndex();
			XTrace trace = logIter.next();
			if (traceIndex == 0) {
				traceAttributes.addAll(trace.getAttributes().values());
			} else {
				Iterator<XAttribute> it = traceAttributes.iterator();
				while (it.hasNext()) {
					if (!trace.getAttributes().containsKey(it.next().getKey())) {
						it.remove();
					}
				}
			}
			for (ListIterator<XEvent> eventIter = trace.listIterator(); eventIter.hasNext();) {
				int eventIndex = eventIter.nextIndex();
				XEvent event = eventIter.next();
				if (traceIndex == 0 && eventIndex == 0) {
					eventAttributes.addAll(event.getAttributes().values());
				} else {
					Iterator<XAttribute> it = eventAttributes.iterator();
					while (it.hasNext()) {
						if (!event.getAttributes().containsKey(it.next().getKey())) {
							it.remove();
						}
					}
				}
			}
		}

		final Collection<XAttribute> defaultEventAttributes = Collections2.transform(eventAttributes,
				PROTOTYPE_TRANSFORMER);
		final Collection<XAttribute> defaultTraceAttributes = Collections2.transform(traceAttributes,
				PROTOTYPE_TRANSFORMER);

		return new GlobalInfo() {

			public Collection<XAttribute> getEventAttributes() {
				return defaultEventAttributes;
			}

			public Collection<XAttribute> getTraceAttributes() {
				return defaultTraceAttributes;
			}

		};
	}

}
"
UnexpectedDataTypeException.java,log-6.9.380,"package org.processmining.log.repair;

public final class UnexpectedDataTypeException extends Exception {

	private static final long serialVersionUID = 1L;

	public UnexpectedDataTypeException() {
	}

	public UnexpectedDataTypeException(String message) {
		super(message);
	}

	public UnexpectedDataTypeException(Throwable cause) {
		super(cause);
	}

	public UnexpectedDataTypeException(String message, Throwable cause) {
		super(message, cause);
	}

}
"
MergeLogsUtils.java,log-6.9.380,"package org.processmining.log.utils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.processmining.log.parameters.MergeLogsParameters;

public class MergeLogsUtils {
	
	public static Date getDate(MergeLogsParameters parameters, String date) {
		SimpleDateFormat dateFormat = new SimpleDateFormat(parameters.getDateFormat());
		dateFormat.setLenient(false);
		try {
			return dateFormat.parse(date.trim());
		} catch (ParseException pe) {
			return null;
		}
		
	}

}
"
TraceVariant.java,log-6.9.380,"package org.processmining.log.utils;

import java.util.List;

/**
 * Trace variant which should override {@link #equals(Object)} and
 * {@link #hashCode()} to provide an equivalence relation for traces. A standard
 * implementation based on the classification of events is provided in
 * {@link TraceVariantByClassifier}.
 * 
 * @author F. Mannhardt
 *
 * @param <E>
 *            what constitutes an event
 */
public interface TraceVariant<E> {

	/**
	 * @return the list of events as viewed by this variant
	 */
	List<E> getEvents();

}"
TraceVariantByClassifier.java,log-6.9.380,"package org.processmining.log.utils;

import java.util.Iterator;

import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;

import com.google.common.base.Function;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.primitives.Ints;

public final class TraceVariantByClassifier implements TraceVariant<XEventClass> {

	private final XTrace trace;
	private final XEventClasses eventClasses;

	public TraceVariantByClassifier(XTrace trace, XEventClasses eventClasses) {
		this.trace = trace;
		this.eventClasses = eventClasses;
	}

	public ImmutableList<XEventClass> getEvents() {
		return ImmutableList.copyOf(Lists.transform(trace, new Function<XEvent, XEventClass>() {

			public XEventClass apply(XEvent e) {
				return eventClasses.getClassOf(e);
			}
		}));
	}

	public int hashCode() {
		int hashCode = 1;
		for (XEvent e : trace) {
			XEventClass eventClass = eventClasses.getClassOf(e);
			hashCode = 31 * hashCode + (e == null ? 0 : Ints.hashCode(eventClass.getIndex()));
		}
		return hashCode;
	}

	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (getClass() != obj.getClass())
			return false;
		TraceVariantByClassifier other = (TraceVariantByClassifier) obj;
		if (trace == null) {
			if (other.trace != null)
				return false;
		} else if (!isEqualVariant(trace, other.trace))
			return false;
		return true;
	}

	private boolean isEqualVariant(XTrace t1, XTrace t2) {
		if (t1 == t2) {
			return true;
		}

		Iterator<XEvent> it1 = t1.iterator();
		Iterator<XEvent> it2 = t2.iterator();

		while (it1.hasNext() && it2.hasNext()) {
			XEventClass cl1 = eventClasses.getClassOf(it1.next());
			XEventClass cl2 = eventClasses.getClassOf(it2.next());
			if (cl1.getIndex() != cl2.getIndex()) {
				return false;
			}
		}
		return !(it1.hasNext() || it2.hasNext());
	}

}"
XLogBuilder.java,log-6.9.380,"/*
 * Copyright (c) 2014 F. Mannhardt (f.mannhardt@tue.nl)
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 3 of the License, or (at your option) any
 * later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package org.processmining.log.utils;

import java.util.Date;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;

/**
 * Fluent-style builder for create a XLog in an easy way. Get an instance by
 * calling {@link XLogBuilder#newInstance()}, then it can be used as follows: 

 * <pre>
 * {@code
 *  XLog log = XLogBuilder.newInstance()
 *	 	.startLog(""logName"")
 *		.addTrace(""traceName"", 2)
 *		.addAttribute(""traceAttribute"", ""test"")
 *			.addEvent(""Event1"")
 *			.addAttribute(""eventAttribute"", 21)
 *			.addEvent(""Event2"")
 *			.addEvent(""Event3"")
 *			.addEvent(""Event4"", 2)
 *		.build();
 * }
 * </pre>
 * Please note that a {@link XLogBuilder} instance is design to be used to 
 * create one log only. 
 * 
 * @author F. Mannhardt
 * 
 */
public class XLogBuilder {

	public static XLogBuilder newInstance() {
		return new XLogBuilder();
	}

	private XFactory factory = XFactoryRegistry.instance().currentDefault();
	private final XConceptExtension conceptInstance = XConceptExtension.instance();

	private XLog log = null;

	private XTrace currentTrace = null;
	private int currentTraceMultiplicity = 1;

	private XEvent currentEvent = null;
	private int currentEventMultiplicity;

	public XLogBuilder startLog(String name) {
		log = factory.createLog();
		if (log != null) {
			conceptInstance.assignName(log, name);
		}
		return this;
	}

	public XLogBuilder addTrace(String name) {
		return addTrace(name, 1);
	}

	public XLogBuilder addTrace(String name, int numberOfTraces) {
		if (log == null) {
			throw new IllegalStateException(""Please call 'startLog' first!"");
		}
		if (currentEvent != null) {
			addCurrentEventToTrace();
		}
		if (currentTrace != null) {
			addCurrentTraceToLog();
			currentEvent = null;
		}
		currentTrace = factory.createTrace();
		if (name != null) {
			conceptInstance.assignName(currentTrace, name);
		}
		currentTraceMultiplicity = numberOfTraces;
		return this;
	}

	private void addCurrentTraceToLog() {
		log.add(currentTrace);
		if (currentTraceMultiplicity > 1) {
			for (int i = 0; i < currentTraceMultiplicity - 1; i++) {
				XTrace clone = (XTrace) currentTrace.clone();
				String name = conceptInstance.extractName(clone);
				if (name != null) {
					conceptInstance.assignName(clone, name.concat(""-"").concat(String.valueOf(i+1)));
				}
				log.add(clone);
			}
		}
	}

	public XLogBuilder addEvent(String name) {
		addEvent(name, 1);
		return this;
	}

	public XLogBuilder addEvent(String name, int numberOfEvents) {
		if (currentTrace == null) {
			throw new IllegalStateException(""Please call 'addTrace' first!"");
		}
		if (currentEvent != null) {
			addCurrentEventToTrace();
		}
		currentEvent = factory.createEvent();
		conceptInstance.assignName(currentEvent, name);
		currentEventMultiplicity = numberOfEvents;
		return this;
	}

	private void addCurrentEventToTrace() {
		currentTrace.add(currentEvent);
		if (currentEventMultiplicity > 1) {
			for (int i = 0; i < currentEventMultiplicity - 1; i++) {
				currentTrace.add((XEvent) currentEvent.clone());
			}
		}
	}
	
	/**
	 * Add the given attribute
	 * 
	 * @param attribute
	 * @return {@link XLogBuilder}
	 */
	public XLogBuilder addAttribute(XAttribute attribute) {
		addAttributeInternal(attribute.getKey(), attribute);
		return this;
	}
	
	/**
	 * @param name
	 * @param value
	 * @return
	 */
	public XLogBuilder addAttribute(String name, boolean value) {
		XAttribute attribute = factory.createAttributeBoolean(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}

	/**
	 * @param name
	 * @param value
	 * @return the {@link XLogBuilder} itself
	 */
	public XLogBuilder addAttribute(String name, long value) {
		XAttribute attribute = factory.createAttributeDiscrete(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}

	/**
	 * @param name
	 * @param value
	 * @return the {@link XLogBuilder} itself
	 */
	public XLogBuilder addAttribute(String name, String value) {
		XAttribute attribute = factory.createAttributeLiteral(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}

	/**
	 * @param name
	 * @param value
	 * @return the {@link XLogBuilder} itself
	 */
	public XLogBuilder addAttribute(String name, Date value) {
		XAttribute attribute = factory.createAttributeTimestamp(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}

	/**
	 * @param name
	 * @param value
	 * @return the {@link XLogBuilder} itself
	 */
	public XLogBuilder addAttribute(String name, double value) {
		XAttribute attribute = factory.createAttributeContinuous(name, value, null);
		addAttributeInternal(name, attribute);
		return this;
	}
	
	public XLogBuilder setFactory(XFactory factory) {
		this.factory = factory;
		return this;
	}

	private void addAttributeInternal(String name, XAttribute attribute) {
		if (currentEvent == null && currentTrace == null) {
			throw new IllegalStateException(""Please call 'addEvent' or 'addTrace' first!"");
		}

		if (currentEvent == null) {
			// Trace Attributes			
			currentTrace.getAttributes().put(name, attribute);
		} else {
			// Event Attributes
			currentEvent.getAttributes().put(name, attribute);
		}
	}

	/**
	 * Builds and returns the XLog. This is only to be used once! 
	 * 
	 * @return the final XLog
	 */ 
	public XLog build() {
		if (currentEvent != null) {
			addCurrentEventToTrace();
		}
		if (currentTrace != null) {
			addCurrentTraceToLog();
		}
		return log;
	}

}
"
XUtils.java,log-6.9.380,"/*
 * Copyright (c) 2014 F. Mannhardt (f.mannhardt@tue.nl)
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 3 of the License, or (at your option) any
 * later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package org.processmining.log.utils;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.classification.XEventAndClassifier;
import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventLifeTransClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XCostExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.id.XID;
import org.deckfour.xes.in.XesXmlParser;
import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.impl.XLogInfoImpl;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeBoolean;
import org.deckfour.xes.model.XAttributeContainer;
import org.deckfour.xes.model.XAttributeContinuous;
import org.deckfour.xes.model.XAttributeDiscrete;
import org.deckfour.xes.model.XAttributeID;
import org.deckfour.xes.model.XAttributeList;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XAttributeTimestamp;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.out.XSerializer;
import org.deckfour.xes.out.XesXmlGZIPSerializer;
import org.deckfour.xes.out.XesXmlSerializer;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.plugins.utils.ProvidedObjectHelper;

import com.google.common.base.Function;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.SetMultimap;

/**
 * Commonly used methods for handling XES logs
 * 
 * @author F. Mannhardt
 *
 */
public final class XUtils {

	private XUtils() {
		//only for static methods
	}

	/**
	 * The invisible activity. Activity to be used for mapping silent
	 * transitions on.
	 */
	public final static XEventClass INVISIBLEACTIVITY = new XEventClass(""[invisible]"", 0);

	/**
	 * The move-on-model activity. Activity to be used for mapping transition on
	 * that are not covered by the log at hand. As such, they will always have
	 * to be a move-on-model.
	 */
	public final static XEventClass MOVEONMODELACTIVITY = new XEventClass(""[move on model]"", 0);

	public static final XEventClassifier STANDARDCLASSIFIER = new XEventAndClassifier(new XEventNameClassifier(),
			new XEventLifeTransClassifier());

	/**
	 * Returns whether the attribute key matches one of the registered standard
	 * extensions of XES.
	 * 
	 * @param attribute
	 * @return whether the attribute is one of the standard extension attributes
	 */
	public static boolean isStandardExtensionAttribute(XAttribute attribute) {
		// Lets hope that the JIT is clever enough to transform this to a hash table
		switch (attribute.getKey()) {
			case XConceptExtension.KEY_NAME :
			case XConceptExtension.KEY_INSTANCE :
			case XTimeExtension.KEY_TIMESTAMP :
			case XLifecycleExtension.KEY_MODEL :
			case XLifecycleExtension.KEY_TRANSITION :
			case XOrganizationalExtension.KEY_GROUP :
			case XOrganizationalExtension.KEY_RESOURCE :
			case XOrganizationalExtension.KEY_ROLE :
			case XCostExtension.KEY_AMOUNT :
			case XCostExtension.KEY_CURRENCY :
			case XCostExtension.KEY_DRIVER :
			case XCostExtension.KEY_TOTAL :
			case XCostExtension.KEY_TYPE :
				return true;
		}
		return false;
	}

	/**
	 * Added by Eric Verbeek
	 * 
	 * Returns a default classifier to use with an event log. If the log
	 * contains classifiers, then the first classifier is returned. Otherwise,
	 * the standard MXML classifier is constructed and returned.
	 * 
	 * @param log
	 * @return A default classifier to use with the provided log.
	 */
	public static XEventClassifier getDefaultClassifier(XLog log) {
		if (log.getClassifiers().isEmpty()) {
			return STANDARDCLASSIFIER;
		}
		return log.getClassifiers().get(0);
	}

	/**
	 * Returns both the event classifiers defined by the XLog, as well as the
	 * three standard classifiers {@link XLogInfoImpl#NAME_CLASSIFIER},
	 * {@link XLogInfoImpl#RESOURCE_CLASSIFIER} and
	 * {@link XLogInfoImpl#STANDARD_CLASSIFIER}.
	 * 
	 * @param log
	 * @return a list of event classifiers that can be used on the log
	 */
	public static List<XEventClassifier> getStandardAndLogDefinedEventClassifiers(XLog log) {
		List<XEventClassifier> classList = new ArrayList<>(log.getClassifiers());
		if (!classList.contains(XLogInfoImpl.RESOURCE_CLASSIFIER)) {
			classList.add(XLogInfoImpl.RESOURCE_CLASSIFIER);
		}
		if (!classList.contains(XLogInfoImpl.STANDARD_CLASSIFIER)) {
			classList.add(XLogInfoImpl.STANDARD_CLASSIFIER);
		}
		if (!classList.contains(XLogInfoImpl.NAME_CLASSIFIER)) {
			classList.add(0, XLogInfoImpl.NAME_CLASSIFIER);
		}
		return classList;
	}

	/**
	 * Returns the event name.
	 * 
	 * @param element
	 * @return the value of the ""concept:name"" attribute or ""null""
	 */
	public static String getConceptName(XAttributable element) {
		return XConceptExtension.instance().extractName(element);
	}

	public static void assignConceptName(XLog log, String name) {
		XConceptExtension.instance().assignName(log, name);
	}

	public static void assignConceptName(XEvent event, String name) {
		XConceptExtension.instance().assignName(event, name);
	}

	public static void assignConceptName(XTrace trace, String name) {
		XConceptExtension.instance().assignName(trace, name);
	}

	/**
	 * Returns the event time.
	 * 
	 * @param event
	 * @return the value of the ""time:timestamp"" attribute or ""null""
	 */
	public static Date getTimestamp(XEvent event) {
		return XTimeExtension.instance().extractTimestamp(event);
	}

	public static void assignTimestamp(XEvent event, Date timestamp) {
		XTimeExtension.instance().assignTimestamp(event, timestamp);
	}

	public static void assignTimestamp(XEvent event, long timestamp) {
		XTimeExtension.instance().assignTimestamp(event, timestamp);
	}

	public static XLog loadLog(String string) throws UnsupportedEncodingException, Exception {
		return loadLog(new ByteArrayInputStream(string.getBytes(StandardCharsets.UTF_8)));
	}

	public static XLog loadLog(File file) throws FileNotFoundException, Exception {
		return loadLog(new FileInputStream(file));
	}

	public static XLog loadLog(InputStream is) throws Exception {
		XesXmlParser xmlParser = new XesXmlParser();
		return Iterables.getFirst(xmlParser.parse(is), null);
	}

	public static void saveLog(XLog log, File file) throws FileNotFoundException, IOException {
		saveLogPlain(log, file);
	}

	public static void saveLogPlain(XLog log, File file) throws FileNotFoundException, IOException {
		saveLogWithSerializer(log, file, new XesXmlSerializer());
	}

	public static void saveLogGzip(XLog log, File file) throws FileNotFoundException, IOException {
		saveLogWithSerializer(log, file, new XesXmlGZIPSerializer());
	}

	public static void saveLogWithSerializer(XLog log, File file, XSerializer logSerializer)
			throws FileNotFoundException, IOException {
		try (FileOutputStream out = new FileOutputStream(file)) {
			logSerializer.serialize(log, out);
		}
	}

	public static boolean containsEventWithName(String eventName, XTrace trace) {
		for (XEvent xEvent : trace) {
			if (eventName.equals(getConceptName(xEvent))) {
				return true;
			}
		}
		return false;
	}

	public static XEvent getLatestEventWithName(String eventName, XTrace trace) {
		XEvent latestEvent = null;
		for (XEvent xEvent : trace) {
			if (eventName.equals(getConceptName(xEvent))) {
				latestEvent = xEvent;
			}
		}
		return latestEvent;
	}

	public static NavigableSet<String> getAllEventNamesSorted(XLog log) {
		NavigableSet<String> eventNames = new TreeSet<>();
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				eventNames.add(getConceptName(event));
			}
		}
		return eventNames;
	}

	public static String stringifyEvent(XEvent e, XEventClassifier classifier) {
		return classifier.getClassIdentity(e);
	}

	public static String stringifyEvent(XEvent e) {
		return stringifyEvent(e, new XEventNameClassifier());
	}

	public static String stringifyTrace(XTrace t, XEventClassifier classifier) {
		StringBuilder sBuilder = new StringBuilder(""["");
		Iterator<XEvent> iterator = t.iterator();
		while (iterator.hasNext()) {
			sBuilder.append(stringifyEvent(iterator.next(), classifier));
			if (iterator.hasNext()) {
				sBuilder.append("","");
			}
		}
		sBuilder.append(""]"");
		return sBuilder.toString();
	}

	public static String stringifyTrace(XTrace t) {
		return stringifyTrace(t, new XEventNameClassifier());
	}

	public static String stringifyLog(XLog l, XEventClassifier classifier) {
		StringBuilder sBuilder = new StringBuilder(""["");
		Iterator<XTrace> iterator = l.iterator();
		while (iterator.hasNext()) {
			sBuilder.append(stringifyTrace(iterator.next(), classifier));
			if (iterator.hasNext()) {
				sBuilder.append("",\n"");
			}
		}
		sBuilder.append(""]"");
		return sBuilder.toString();
	}

	public static String stringifyLog(XLog l) {
		return stringifyLog(l, new XEventNameClassifier());
	}

	public static String stringifyAttributes(XAttributeMap map) {
		StringBuilder sBuilder = new StringBuilder(""{"");
		Iterator<XAttribute> iterator = map.values().iterator();
		while (iterator.hasNext()) {
			XAttribute a = iterator.next();
			sBuilder.append(a.getKey() + "" -> "" + a.toString());
			if (iterator.hasNext()) {
				sBuilder.append("",\n"");
			}
		}
		sBuilder.append(""}"");
		return sBuilder.toString();
	}

	/**
	 * Creates a deep clone of the {@link XAttribute} with the same value, but a
	 * changed key.
	 * 
	 * @param oldAttribute
	 * @param newKey
	 * @return copy of the supplied attribute
	 */
	public static XAttribute cloneAttributeWithChangedKey(XAttribute oldAttribute, String newKey) {
		return cloneAttributeWithChangedKeyWithFactory(oldAttribute, newKey,
				XFactoryRegistry.instance().currentDefault());
	}

	/**
	 * Creates a deep clone of the {@link XAttribute} with the same value, but a
	 * changed key.
	 * 
	 * @param oldAttribute
	 * @param newKey
	 * @param factory
	 * @return copy of the supplied attribute
	 */
	public static XAttribute cloneAttributeWithChangedKeyWithFactory(XAttribute oldAttribute, String newKey,
			XFactory factory) {
		if (oldAttribute instanceof XAttributeList) {
			XAttributeList newAttribute = factory.createAttributeList(newKey, oldAttribute.getExtension());
			for (XAttribute a : ((XAttributeList) oldAttribute).getCollection()) {
				newAttribute.addToCollection(a);
			}
			return newAttribute;
		} else if (oldAttribute instanceof XAttributeContainer) {
			XAttributeContainer newAttribute = factory.createAttributeContainer(newKey, oldAttribute.getExtension());
			for (XAttribute a : ((XAttributeContainer) oldAttribute).getCollection()) {
				newAttribute.addToCollection(a);
			}
			return newAttribute;
		} else if (oldAttribute instanceof XAttributeLiteral) {
			return factory.createAttributeLiteral(newKey, ((XAttributeLiteral) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeBoolean) {
			return factory.createAttributeBoolean(newKey, ((XAttributeBoolean) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeContinuous) {
			return factory.createAttributeContinuous(newKey, ((XAttributeContinuous) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeDiscrete) {
			return factory.createAttributeDiscrete(newKey, ((XAttributeDiscrete) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeTimestamp) {
			return factory.createAttributeTimestamp(newKey, ((XAttributeTimestamp) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else if (oldAttribute instanceof XAttributeID) {
			return factory.createAttributeID(newKey, ((XAttributeID) oldAttribute).getValue(),
					oldAttribute.getExtension());
		} else {
			throw new IllegalArgumentException(""Unexpected attribute type!"");
		}
	}

	/**
	 * Creates a deep clone of the supplied event log without classifiers
	 * 
	 * @param log
	 * @return a clone of the supplied log
	 */
	public static XLog cloneLogWithoutClassifier(XLog log) {
		XLog clone = (XLog) log.clone();
		clone.getClassifiers().clear();
		return clone;
	}

	/**
	 * Creates a deep clone of the supplied event log without globals
	 * 
	 * @param log
	 * @return a clone of the supplied log
	 */
	public static XLog cloneLogWithoutGlobals(XLog log) {
		XLog clone = (XLog) log.clone();
		clone.getGlobalTraceAttributes().clear();
		clone.getGlobalEventAttributes().clear();
		return clone;
	}

	/**
	 * Creates a deep clone of the supplied event log without globals and
	 * without classifiers
	 * 
	 * @param log
	 * @return a clone of the supplied log
	 */
	public static XLog cloneLogWithoutGlobalsAndClassifiers(XLog log) {
		XLog clone = (XLog) log.clone();
		clone.getClassifiers().clear();
		clone.getGlobalTraceAttributes().clear();
		clone.getGlobalEventAttributes().clear();
		return clone;
	}

	/**
	 * Creates a new log with attributes and meta data (classifiers, globals,
	 * extension) from the oldLog.
	 * 
	 * @param oldLog
	 * @return
	 */
	public static XLog createLogFrom(XLog oldLog) {
		return createLogFrom(oldLog, XFactoryRegistry.instance().currentDefault());
	}

	/**
	 * Creates a new log with attributes and meta data (classifiers, globals,
	 * extension) from the oldLog.
	 * 
	 * @param oldLog
	 * @param factory
	 * @return
	 */
	public static XLog createLogFrom(XLog oldLog, XFactory factory) {
		XLog newLog = factory.createLog((XAttributeMap) oldLog.getAttributes().clone());
		newLog.getClassifiers().addAll(oldLog.getClassifiers());
		newLog.getExtensions().addAll(oldLog.getExtensions());
		for (XAttribute attr : oldLog.getGlobalEventAttributes()) {
			newLog.getGlobalEventAttributes().add((XAttribute) attr.clone());
		}
		for (XAttribute attr : oldLog.getGlobalTraceAttributes()) {
			newLog.getGlobalTraceAttributes().add((XAttribute) attr.clone());
		}
		return newLog;
	}

	/**
	 * Copies the meta data (classifiers, globals, extension) from the oldLog to
	 * the newLog.
	 * 
	 * @param oldLog
	 * @param newLog
	 */
	public static void copyLogMetadata(XLog oldLog, XLog newLog) {
		newLog.getClassifiers().addAll(oldLog.getClassifiers());
		newLog.getExtensions().addAll(oldLog.getExtensions());
		for (XAttribute attr : oldLog.getGlobalEventAttributes()) {
			newLog.getGlobalEventAttributes().add((XAttribute) attr.clone());
		}
		for (XAttribute attr : oldLog.getGlobalTraceAttributes()) {
			newLog.getGlobalTraceAttributes().add((XAttribute) attr.clone());
		}
	}

	/**
	 * Checks whether both objects implement the same XAttribute interface
	 * 
	 * @param obj1
	 * @param obj2
	 * @return
	 */
	public static boolean isSameType(XAttribute obj1, XAttribute obj2) {
		if (obj1 instanceof XAttributeList && obj2 instanceof XAttributeList) {
			return true;
		}
		if (obj1 instanceof XAttributeContainer && obj2 instanceof XAttributeContainer) {
			return true;
		}
		if (obj1 instanceof XAttributeLiteral && obj2 instanceof XAttributeLiteral) {
			return true;
		}
		if (obj1 instanceof XAttributeBoolean && obj2 instanceof XAttributeBoolean) {
			return true;
		}
		if (obj1 instanceof XAttributeContinuous && obj2 instanceof XAttributeContinuous) {
			return true;
		}
		if (obj1 instanceof XAttributeDiscrete && obj2 instanceof XAttributeDiscrete) {
			return true;
		}
		if (obj1 instanceof XAttributeTimestamp && obj2 instanceof XAttributeTimestamp) {
			return true;
		}		
		if (obj1 instanceof XAttributeID && obj2 instanceof XAttributeID) {
			return true;
		}	
		return false;
	}

	/**
	 * Returns the value of the {@link XAttribute} as {@link Object}
	 * 
	 * @param attribute
	 * @return value of the attribute
	 */
	public static Object getAttributeValue(XAttribute attribute) {
		if (attribute instanceof XAttributeList) {
			return ((XAttributeList) attribute).getCollection();
		} else if (attribute instanceof XAttributeContainer) {
			return ((XAttributeContainer) attribute).getCollection();
		} else if (attribute instanceof XAttributeLiteral) {
			return ((XAttributeLiteral) attribute).getValue();
		} else if (attribute instanceof XAttributeBoolean) {
			return ((XAttributeBoolean) attribute).getValue();
		} else if (attribute instanceof XAttributeContinuous) {
			return ((XAttributeContinuous) attribute).getValue();
		} else if (attribute instanceof XAttributeDiscrete) {
			return ((XAttributeDiscrete) attribute).getValue();
		} else if (attribute instanceof XAttributeTimestamp) {
			return ((XAttributeTimestamp) attribute).getValue();
		} else if (attribute instanceof XAttributeID) {
			return ((XAttributeID) attribute).getValue();
		} else {
			throw new IllegalArgumentException(""Unexpected attribute type!"");
		}
	}

	/**
	 * Returns the Java class of the {@link XAttribute} value.
	 * 
	 * @param attribute
	 * @return class of the attribute
	 */
	public static Class<?> getAttributeClass(XAttribute attribute) {
		if (attribute instanceof XAttributeLiteral) {
			return String.class;
		} else if (attribute instanceof XAttributeBoolean) {
			return Boolean.class;
		} else if (attribute instanceof XAttributeContinuous) {
			return Double.class;
		} else if (attribute instanceof XAttributeDiscrete) {
			return Long.class;
		} else if (attribute instanceof XAttributeTimestamp) {
			return Date.class;
		} else if (attribute instanceof XAttributeID) {
			return XID.class;
		} else {
			throw new IllegalArgumentException(""Unexpected attribute type!"");
		}
	}

	/**
	 * Creates an appropriate {@link XAttribute}, decided on the type of the
	 * parameter atttributeValue.
	 * 
	 * @param attributeName
	 * @param attributeValue
	 * @return
	 */
	public static XAttribute createAttribute(String attributeName, Object attributeValue) {
		return createAttributeWithFactory(attributeName, attributeValue, XFactoryRegistry.instance().currentDefault());
	}

	/**
	 * Creates an appropriate {@link XAttribute}, decided on the type of the
	 * parameter atttributeValue.
	 * 
	 * @param attributeName
	 * @param attributeValue
	 * @param factory
	 * @return
	 */
	public static XAttribute createAttributeWithFactory(String attributeName, Object attributeValue, XFactory factory) {
		return createAttributeWithFactory(attributeName, attributeValue, null, factory);
	}

	/**
	 * Creates an appropriate {@link XAttribute}, deciding by the type of the
	 * parameter atttributeValue.
	 * 
	 * @param attributeName
	 * @param attributeValue
	 * @param extension
	 * @return a {@link XAttribute} with correct type
	 */
	public static XAttribute createAttribute(String attributeName, Object attributeValue, XExtension extension) {
		return createAttributeWithFactory(attributeName, attributeValue, extension,
				XFactoryRegistry.instance().currentDefault());
	}

	/**
	 * Creates an appropriate {@link XAttribute}, deciding by the type of the
	 * parameter atttributeValue.
	 * 
	 * @param attributeName
	 * @param attributeValue
	 * @param extension
	 * @param factory
	 * @return a {@link XAttribute} with correct type
	 */
	private static XAttribute createAttributeWithFactory(String attributeName, Object attributeValue,
			XExtension extension, XFactory factory) {
		if (attributeValue instanceof Double || attributeValue instanceof Float) {
			return factory.createAttributeContinuous(attributeName, ((Number) attributeValue).doubleValue(), extension);
		} else if (attributeValue instanceof Integer || attributeValue instanceof Long) {
			return factory.createAttributeDiscrete(attributeName, ((Number) attributeValue).longValue(), extension);
		} else if (attributeValue instanceof Date) {
			return factory.createAttributeTimestamp(attributeName, ((Date) attributeValue), extension);
		} else if (attributeValue instanceof Boolean) {
			return factory.createAttributeBoolean(attributeName, ((Boolean) attributeValue), extension);
		} else {
			return factory.createAttributeLiteral(attributeName, attributeValue.toString(), extension);
		}
	}

	/**
	 * Adds multiple {@link XAttribute} to the supplied {@link XAttributable}.
	 * 
	 * @param attributable
	 * @param attributes
	 */
	public static void putAttributes(XAttributable attributable, Iterable<XAttribute> attributes) {
		for (XAttribute a : attributes) {
			putAttribute(attributable, a);
		}
	}

	/**
	 * Adds a single {@link XAttribute} to the supplied {@link XAttributable}.
	 * 
	 * @param attributable
	 * @param attribute
	 */
	public static void putAttribute(XAttributable attributable, XAttribute attribute) {
		attributable.getAttributes().put(attribute.getKey(), attribute);
	}

	/**
	 * Rename the XLog with the label for the ProM provided object
	 * 
	 * @param context
	 * @param log
	 * @return the old name
	 */
	public static String renameLogWithProMLabel(PluginContext context, XLog log) {
		String originalName = getConceptName(log);
		String promLabel = ProvidedObjectHelper.getProvidedObjectLabel(context, log);
		/*
		 * HV: Check whether promLabel equals null. This can happen if the log
		 * at hand is not a provided object.
		 */
		if (promLabel != null && !promLabel.equals(originalName)) {
			XConceptExtension.instance().assignName(log, promLabel);
		}
		return originalName;
	}

	/**
	 * Obtain the event classes from the supplied collection of traces using the
	 * specified classifier. Uses the {@link XEvent} cached in the
	 * {@link XLogInfo} if available and in case the trace are, in fact, a
	 * {@link XLog}.
	 * 
	 * @param classifier
	 * @param traces
	 * @return
	 */
	public static XEventClasses createEventClasses(XEventClassifier classifier, Iterable<XTrace> traces) {
		if (traces instanceof XLog) {
			XLog log = (XLog) traces;
			XLogInfo existingLogInfo = log.getInfo(classifier);
			if (existingLogInfo != null) {
				return existingLogInfo.getEventClasses();
			}
		}
		return deriveEventClasses(classifier, traces);
	}

	private static XEventClasses deriveEventClasses(XEventClassifier classifier, Iterable<XTrace> traces) {
		XEventClasses classes = new XEventClasses(classifier);
		for (XTrace trace : traces) {
			classes.register(trace);
		}
		classes.harmonizeIndices();
		return classes;
	}

	public static Set<String> getEventAttributeKeys(Iterable<XTrace> traces) {
		Set<String> attributeKeys = new HashSet<>();
		for (XTrace t : traces) {
			for (XEvent e : t) {
				attributeKeys.addAll(e.getAttributes().keySet());
			}
		}
		return attributeKeys;
	}

	public static Map<String, Class<?>> getEventAttributeTypes(Iterable<XTrace> traces) {
		Map<String, Class<?>> attributeTypes = new HashMap<String, Class<?>>();
		for (XTrace t : traces) {
			for (XEvent e : t) {
				for (XAttribute a : e.getAttributes().values()) {
					fillAttributeType(attributeTypes, a);
				}
			}
		}
		return attributeTypes;
	}

	public static Set<String> getTraceAttributeKeys(Iterable<XTrace> traces) {
		Set<String> attributeKeys = new HashSet<>();
		for (XTrace t : traces) {
			attributeKeys.addAll(t.getAttributes().keySet());
		}
		return attributeKeys;
	}

	public static Map<String, Class<?>> getTraceAttributeTypes(Iterable<XTrace> traces) {
		Map<String, Class<?>> attributeTypes = new HashMap<String, Class<?>>();
		for (XTrace t : traces) {
			for (XAttribute a : t.getAttributes().values()) {
				fillAttributeType(attributeTypes, a);
			}
		}
		return attributeTypes;
	}

	private static void fillAttributeType(Map<String, Class<?>> attributeTypes, XAttribute attribute) {
		if (!attributeTypes.containsKey(attribute.getKey())) {
			attributeTypes.put(attribute.getKey(), getAttributeClass(attribute));
		}
	}

	/**
	 * Groups traces in a {@link ListMultimap} by their event classification. A
	 * {@link ListMultimap} instead of an {@link SetMultimap} is returned as the
	 * input traces are not required to be a {@link Set}.
	 * 
	 * @param traces
	 * @param classifier
	 * @return
	 */
	public static ImmutableListMultimap<TraceVariantByClassifier, XTrace> getVariantsByClassifier(
			Iterable<XTrace> traces, XEventClassifier classifier) {
		final XEventClasses eventClasses = XUtils.createEventClasses(new XEventNameClassifier(), traces);
		return getVariantsByClassifier(traces, eventClasses);
	}

	public static int countVariantsByClassifier(Iterable<XTrace> traces, XEventClassifier classifier) {
		final XEventClasses eventClasses = XUtils.createEventClasses(new XEventNameClassifier(), traces);
		return countVariantsByClassifier(traces, eventClasses);
	}

	/**
	 * Groups traces in a {@link ListMultimap} by their event classification. A
	 * {@link ListMultimap} instead of an {@link SetMultimap} is returned as the
	 * input traces are not required to be a {@link Set}.
	 * 
	 * @param traces
	 * @param eventClasses
	 * @return
	 */
	public static ImmutableListMultimap<TraceVariantByClassifier, XTrace> getVariantsByClassifier(
			Iterable<XTrace> traces, final XEventClasses eventClasses) {
		return getVariants(traces, new Function<XTrace, TraceVariantByClassifier>() {

			public TraceVariantByClassifier apply(XTrace trace) {
				return new TraceVariantByClassifier(trace, eventClasses);
			}

		});
	}

	public static int countVariantsByClassifier(Iterable<XTrace> traces, final XEventClasses eventClasses) {
		return countVariants(traces, new Function<XTrace, TraceVariantByClassifier>() {

			public TraceVariantByClassifier apply(XTrace trace) {
				return new TraceVariantByClassifier(trace, eventClasses);
			}

		});
	}

	/**
	 * Groups traces in a {@link ListMultimap} by a generic {@link Function}. A
	 * {@link ListMultimap} instead of an {@link SetMultimap} is returned as the
	 * input traces are not required to be a {@link Set}.
	 * 
	 * @param traces
	 * @param variantFunction
	 * @return
	 */
	public static <T extends TraceVariant<E>, E> ImmutableListMultimap<T, XTrace> getVariants(Iterable<XTrace> traces,
			Function<XTrace, T> variantFunction) {
		return Multimaps.index(traces, variantFunction);
	}

	public static <T extends TraceVariant<?>> int countVariants(Iterable<XTrace> traces,
			Function<XTrace, T> variantFunction) {
		return ImmutableSet.copyOf(Iterables.transform(traces, variantFunction)).size();
	}

}"
IdentitiesMissingException.java,log-6.9.380,"package org.processmining.log.xes.extensions.id;

import java.util.Collection;

import org.deckfour.xes.model.XAttributable;

public class IdentitiesMissingException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8593596865075088429L;
	
	private Collection<XAttributable> missing;

	public IdentitiesMissingException() {
		super(""Not all elements in the log have an identifier"");
	}
	
	public IdentitiesMissingException(Collection<XAttributable> missing) {
		this();
		
		this.missing = missing;
	}
	
}
"
IdentityConnection.java,log-6.9.380,"package org.processmining.log.xes.extensions.id;

import java.util.HashMap;
import java.util.Map;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.id.XID;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractConnection;


/**
 * This class provides a mapping for the identity of XAttributeable elements. 
 * Given an ID, it returns the corresponding XAttributeable element.
 * 
 * TODO 
 * 
 * @author jvdwerf
 *
 */
public class IdentityConnection extends AbstractConnection {

	private final Map<String,XAttributable> idmapping;
	
	private final String LOG = ""LOG"";
	
	public IdentityConnection(XLog log) throws IdentitiesMissingException {
		super(""Identity connection for "" + 
				(XConceptExtension.instance().extractName(log) == null ? log.toString() : XConceptExtension.instance().extractName(log))				
		);
		
		IdentityMappingVisitor visitor = new IdentityMappingVisitor();
		log.accept(visitor);
		if (!visitor.allLogElementsHaveIdentifier()) {
			throw new IdentitiesMissingException(visitor.getElementsWithoutIdentity());
		}
		this.idmapping = visitor.getMapping();
		
		put(LOG, log);
	}
	
	
	
	public IdentityConnection(XLog log, Map<String,XAttributable> idmapping) {
		super(""Identity connection for "" + 
				(XConceptExtension.instance().extractName(log) == null ? log.toString() : XConceptExtension.instance().extractName(log))				
		);
		
		this.idmapping = new HashMap<String, XAttributable>(idmapping);
		
		put(LOG, log);
	}
	
	public XAttributable getElement(String id) {
		return idmapping.get(id);
	}
	
	public XAttributable getElement(XID id) {
		return getElement(id.toString());
	}
	
	public XLog getLog() {
		return (XLog) this.get(LOG);
	}
	
}
"
IdentityMappingVisitor.java,log-6.9.380,"package org.processmining.log.xes.extensions.id;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.extension.std.XIdentityExtension;
import org.deckfour.xes.id.XID;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.model.XVisitor;

/**
 * This visitor creates a mapping for the identities.
 * @author jvdwerf
 *
 */
class IdentityMappingVisitor extends XVisitor {

	private Map<String, XAttributable> idmap;
	private List<XAttributable> missing;
	
	//these are just standard
	public boolean precondition() { 
		return true; 
	}
	
	public void init(XLog log) {
		idmap = new HashMap<String, XAttributable>();
		missing = new ArrayList<XAttributable>();
	}
	
	public Map<String, XAttributable> getMapping() {
		return idmap;
	}
	
	public Collection<XAttributable> getElementsWithoutIdentity() {
		return missing;
	}
	
	public boolean allLogElementsHaveIdentifier() {
		return (missing.size() == 0);
	}
	
	@Override
	public void visitLogPre(XLog log) {
		visitXAttributable(log);
	}
	
	@Override
	public void visitTracePre(XTrace trace, XLog log) {
		visitXAttributable(trace);
	}
	
	@Override
	public void visitEventPre(XEvent event, XTrace trace) {
		visitXAttributable(event);
	}
	
	@Override
	public void visitAttributePre(XAttribute attr, XAttributable parent) {
		if (attr.getKey().equals(XIdentityExtension.KEY_ID)) {
			return;
		}
		
		visitXAttributable(attr);
	}
	
	private void visitXAttributable(XAttributable target) {
		XID id = XIdentityExtension.instance().extractID(target);
		if (id != null) {
			idmap.put(id.toString(), target);
		} else {
			missing.add(target);
		}
	}
}"
XPathExecutor.java,log-6.9.380,"package org.processmining.log.xpath.engine.ui;

import java.io.IOException;

import javax.swing.JComponent;

import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.log.xes.extensions.id.IdentitiesMissingException;

/**
 * 
 * ""Vizualises"" a log so that XPath queries can be executed.
 * 
 * @author jvdwerf
 *
 */

public class XPathExecutor {

	@Visualizer(name = ""XPath executor"")
	@Plugin(name = ""XPath executor"", parameterLabels = ""XLog Event Log"", returnTypes = JComponent.class, returnLabels = ""XPath executor"", userAccessible = false)
	public JComponent showXPathExecutor(UIPluginContext context, XLog source) {

		try {
			return new XPathExecutorPanel(context, source);
		} catch (IdentitiesMissingException e) {
			try {
				XLog log = context.tryToFindOrConstructFirstNamedObject(XLog.class, ""Add identity attribute"", null,
						null, source);
				return new XPathExecutorPanel(context, log);
			} catch (ConnectionCannotBeObtained e1) {
			} catch (IdentitiesMissingException e1) {
				e1.printStackTrace();
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}

		context.getFutureResult(0).cancel(true);
		return null;
	}
}
"
XPathExecutorPanel.java,log-6.9.380,"package org.processmining.log.xpath.engine.ui;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputMethodEvent;
import java.awt.event.InputMethodListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.event.TableModelListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableModel;

import org.deckfour.xes.extension.std.XIdentityExtension;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.ui.widgets.ProMHeaderPanel;
import org.processmining.framework.util.ui.widgets.ProMSplitPane;
import org.processmining.framework.util.ui.widgets.ProMTable;
import org.processmining.framework.util.ui.widgets.ProMTextArea;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.log.xes.extensions.id.IdentitiesMissingException;
import org.processmining.log.xpath.engine.XPathEngine;

import com.fluxicon.slickerbox.factory.SlickerFactory;

import net.sf.saxon.s9api.SaxonApiException;

public class XPathExecutorPanel extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8961837431111952562L;

	private final XLog _log;
	private final PluginContext _context;

	private XPathEngine _engine;

	private ProMSplitPane splitter;
	private ProMTextArea errorText;
	private JPanel topPanel;
	private JPanel queryPanel;
	private ProMTextField queryText;
	private ProMTextField relQueryText;
	private JPanel buttonPanel;
	private JButton queryButton;
	private JButton clearButton;
	private JLabel resultCounter;

	private JPanel queryHistory;
	private JButton prevQuery;
	private JButton nextQuery;

	private ProMTable table;

	private Stack<Pair<String, String>> queryPast = new Stack<Pair<String, String>>();
	private Stack<Pair<String, String>> queryFuture = new Stack<Pair<String, String>>();

	private JPanel bottomPanel;
	private ProMSplitPane bottomSplitter;
	private JPanel bottomRight;

	private Logger logging;

	public XPathExecutorPanel(final PluginContext context, final XLog log)
			throws IdentitiesMissingException, IOException {
		_log = log;
		_context = context;

		_engine = new XPathEngine(_context, _log);

		logging = Logger.getLogger(""XPathExecutor"");
		logging.setLevel(Level.FINEST);

		initializeUI();
	}

	public XLog getLog() {
		return _log;
	}

	public PluginContext getContext() {
		return _context;
	}

	protected XPathEngine getEngine() {
		return _engine;
	}

	private void initializeUI() {
		this.setLayout(new BorderLayout());

		setTopPanel();
		setBottomPanel();
		setSplitter();
	}

	private void setTopPanel() {
		topPanel = new JPanel(new BorderLayout());

		setQueryPanel();
		topPanel.add(queryPanel, BorderLayout.CENTER);

		buttonPanel = new JPanel();
		queryButton = SlickerFactory.instance().createButton(""Query"");
		queryButton.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				executeQuery(queryText.getText(), relQueryText.getText());
			}
		});

		clearButton = SlickerFactory.instance().createButton(""Clear"");
		clearButton.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				executeClear();
			}
		});

		resultCounter = SlickerFactory.instance().createLabel("""");

		buttonPanel.add(queryButton);
		buttonPanel.add(clearButton);
		buttonPanel.add(resultCounter);
		topPanel.add(buttonPanel, BorderLayout.SOUTH);
	}

	private void setBottomPanel() {

		bottomPanel = new JPanel(new BorderLayout());

		bottomRight = new JPanel(new BorderLayout());
		errorText = new ProMTextArea(false);

		bottomSplitter = new ProMSplitPane(ProMSplitPane.HORIZONTAL_SPLIT);
		bottomSplitter.setLeftComponent(errorText);
		bottomSplitter.setRightComponent(bottomRight);

		bottomPanel.add(bottomSplitter);
	}

	private void setSplitter() {

		splitter = new ProMSplitPane(ProMSplitPane.VERTICAL_SPLIT);
		splitter.setTopComponent(topPanel);
		splitter.setBottomComponent(bottomPanel);
		add(splitter, BorderLayout.CENTER);
	}

	private void setQueryPanel() {
		queryPanel = new JPanel(new BorderLayout());

		JPanel qr = new JPanel(new BorderLayout());

		queryText = new ProMTextField();
		queryText.setText(""//trace"");
		relQueryText = new ProMTextField();

		InputMethodListener l = new InputMethodListener() {

			public void inputMethodTextChanged(InputMethodEvent event) {
				if (event.getCommittedCharacterCount() > 0) {
					resetQueryFuture();
				}
			}

			public void caretPositionChanged(InputMethodEvent event) {
			}
		};

		queryText.addInputMethodListener(l);
		relQueryText.addInputMethodListener(l);

		qr.add(queryText, BorderLayout.NORTH);
		qr.add(relQueryText, BorderLayout.SOUTH);

		queryPanel.add(qr, BorderLayout.CENTER);

		queryHistory = new JPanel(new BorderLayout());

		prevQuery = SlickerFactory.instance().createButton(""<"");
		prevQuery.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				setPrevQuery();
			}
		});

		nextQuery = SlickerFactory.instance().createButton("">"");
		nextQuery.setEnabled(false);
		nextQuery.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				setNextQuery();
			}
		});

		queryHistory.add(prevQuery, BorderLayout.NORTH);
		queryHistory.add(nextQuery, BorderLayout.SOUTH);

		queryPanel.add(queryHistory, BorderLayout.EAST);
	}

	private boolean queryChanged = false;

	public boolean isQueryChanged() {
		return queryChanged;
	}

	private void setPrevQuery() {

		if (!queryPast.isEmpty()) {
			queryFuture.push(new Pair<String, String>(queryText.getText(), relQueryText.getText()));

			Pair<String, String> pop = queryPast.pop();
			queryText.setText(pop.getFirst());
			relQueryText.setText(pop.getSecond());
		}

		prevQuery.setEnabled(!(queryPast.isEmpty()));
		nextQuery.setEnabled(true);

		queryChanged = false;
	}

	private void setNextQuery() {
		if (!queryFuture.isEmpty()) {
			queryPast.push(new Pair<String, String>(queryText.getText(), relQueryText.getText()));

			Pair<String, String> pop = queryFuture.pop();
			queryText.setText(pop.getFirst());
			relQueryText.setText(pop.getSecond());
		}

		nextQuery.setEnabled(!(queryFuture.isEmpty()));
		prevQuery.setEnabled(true);

		queryChanged = false;
	}

	private void resetQueryFuture() {
		queryFuture.clear();
		nextQuery.setEnabled(false);
	}

	private void executeClear() {
		queryText.setText("""");
		relQueryText.setText("""");
		errorText.setText("""");
		resultCounter.setText("""");
		bottomSplitter.setLeftComponent(errorText);
		bottomSplitter.setRightComponent(bottomRight);

		repaint();
	}

	private void executeQuery(String query, String relQuery) {
		queryPast.add(new Pair<String, String>(query, relQuery));

		long start = Calendar.getInstance().getTimeInMillis();
		logging.log(Level.INFO, ""start query '"" + query + ""'"");

		//get solution
		SolutionTable solTable = null;

		String error = """";

		if (relQuery.equals("""")) {
			List<XAttributable> solution = null;
			try {
				solution = getEngine().query(query, true);
			} catch (SaxonApiException e) {
				error = e.getMessage();
			}

			if (solution != null) {

				solTable = new SolutionTable(false);
				solTable.setSingleSolution(solution);

			}

		} else {

			List<Pair<XAttributable, XAttributable>> solution = null;
			try {
				solution = getEngine().query(query, relQuery, true);
			} catch (SaxonApiException e) {
				error = e.getMessage();
			}

			if (solution != null) {
				solTable = new SolutionTable(true);
				solTable.setPairSolution(solution);
			}
		}

		long end = Calendar.getInstance().getTimeInMillis();
		logging.log(Level.INFO, ""end query. Duration: '"" + (end - start) + "" ms"");

		if (solTable == null) {

			errorText.setText(error);
			resultCounter.setText(""Errors found"");
			bottomSplitter.setLeftComponent(errorText);
			bottomSplitter.setRightComponent(bottomRight);

		} else {
			//populate result table
			table = new ProMTable(solTable);
			table.getTable().setDefaultRenderer(XAttributable.class, new XAttributableRenderer());

			table.getTable().addMouseListener(new MouseListener() {

				public void mouseReleased(MouseEvent e) {
				}

				public void mousePressed(MouseEvent e) {
				}

				public void mouseExited(MouseEvent e) {
				}

				public void mouseEntered(MouseEvent e) {
				}

				public void mouseClicked(MouseEvent e) {
					int row = table.getTable().rowAtPoint(e.getPoint());
					int col = table.getTable().columnAtPoint(e.getPoint());

					if ((row >= 0 && row <= table.getTable().getRowCount())
							&& (col >= 0 && col <= table.getTable().getColumnCount())) {
						setPropertiesTable(table.getValueAt(row, col));
					}
				}
			});

			bottomSplitter.setLeftComponent(table);
			bottomSplitter.setRightComponent(bottomRight);
			resultCounter.setText(""Solutions found: "" + solTable.getRowCount());
		}

		repaint();
	}

	private void setPropertiesTable(Object value) {
		if (value instanceof XAttributable) {
			XAttributable parent = (XAttributable) value;

			ProMHeaderPanel php;
			if (value instanceof XAttribute) {
				XAttribute attr = (XAttribute) parent;
				php = new ProMHeaderPanel(""Attribute: "" + attr.getKey() + "" (value: "" + attr.toString() + "")"");
			} else {
				php = new ProMHeaderPanel(value.getClass().getSimpleName());
			}

			ProMTable propTable = new ProMTable(new PropertiesTable(parent));
			propTable.getTable().setDefaultRenderer(XAttribute.class, new XAttributeRender());
			php.add(propTable);
			bottomSplitter.setRightComponent(php);
		}
	}

	private class PropertiesTable implements TableModel {

		private XAttributeMap attrMap;
		private List<String> keys;

		public PropertiesTable(XAttributable parent) {

			attrMap = parent.getAttributes();
			keys = new ArrayList<String>(attrMap.keySet());

		}

		public int getRowCount() {
			return keys.size();
		}

		public int getColumnCount() {
			return 2;
		}

		public String getColumnName(int columnIndex) {
			switch (columnIndex) {
				case 0 :
					return ""Attribute"";
				case 1 :
					return ""Value"";
				default :
					return ""ERROR FIELD"";
			}
		}

		public Class<?> getColumnClass(int columnIndex) {
			switch (columnIndex) {
				case 0 :
					return String.class;
				case 1 :
					return XAttribute.class;
				default :
					return null;
			}
		}

		public boolean isCellEditable(int rowIndex, int columnIndex) {
			return false;
		}

		public Object getValueAt(int rowIndex, int columnIndex) {
			switch (columnIndex) {
				case 0 :
					return keys.get(rowIndex);
				case 1 :
					return attrMap.get(keys.get(rowIndex));
			}
			return null;
		}

		public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
		}

		public void addTableModelListener(TableModelListener l) {
		}

		public void removeTableModelListener(TableModelListener l) {
		}

	}

	private class XAttributeRender extends DefaultTableCellRenderer {

		private static final long serialVersionUID = -4820042181333426306L;

		public void setValue(Object value) {
			if (value == null) {
				super.setValue(""Not set"");
			} else {
				if (value instanceof XAttribute) {
					super.setValue(value);
				} else {
					super.setValue(value);
				}
			}
		}

	}

	private class XAttributableRenderer extends DefaultTableCellRenderer {

		private static final long serialVersionUID = -4649231822102709523L;

		public void setValue(Object value) {
			if (value instanceof XAttributable) {
				super.setValue(XIdentityExtension.instance().extractID((XAttributable) value));
			} else {
				super.setValue(value);
			}
		}
	}

	private class SolutionTable implements TableModel {

		private List<Pair<XAttributable, XAttributable>> pairSolution;

		private boolean pairs;

		List<XAttributable> sol;

		public SolutionTable(boolean pairs) {
			this.pairs = pairs;
		}

		public void setPairSolution(List<Pair<XAttributable, XAttributable>> solution) {
			pairSolution = solution;
		}

		public void setSingleSolution(List<XAttributable> solution) {
			sol = solution;
		}

		public int getRowCount() {
			if (pairs)
				return pairSolution.size();
			else
				return sol.size();
		}

		public int getColumnCount() {
			if (pairs) {
				return 2;
			} else {
				return 1;
			}
		}

		public String getColumnName(int columnIndex) {
			switch (columnIndex) {
				case 0 :
					return ""First"";
				case 1 :
					return ""Second"";
				default :
					return ""Wrong"";
			}
		}

		public Class<?> getColumnClass(int columnIndex) {
			return XAttributable.class;
		}

		public boolean isCellEditable(int rowIndex, int columnIndex) {
			return false;
		}

		public Object getValueAt(int rowIndex, int columnIndex) {
			XAttributable attr = null;

			if (pairs) {
				Pair<XAttributable, XAttributable> item = pairSolution.get(rowIndex);

				if (item == null) {
					return null;
				}

				switch (columnIndex) {
					case 0 :
						attr = item.getFirst();
						break;
					case 1 :
						attr = item.getSecond();
						break;
				}

			} else {
				attr = sol.get(rowIndex);
			}
			return attr;

			//if (attr == null)
			//	return null;
			//else
			//	return XIdentityExtension.instance().extractID(attr);
		}

		public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
		}

		public void addTableModelListener(TableModelListener l) {
		}

		public void removeTableModelListener(TableModelListener l) {
		}

	}

}
"
XPathEngine.java,log-6.9.380,"package org.processmining.log.xpath.engine;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;

import org.deckfour.xes.extension.std.XIdentityExtension;
import org.deckfour.xes.model.XAttributable;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.util.Pair;
import org.processmining.log.xes.extensions.id.IdentitiesMissingException;
import org.processmining.log.xes.extensions.id.IdentityConnection;
import org.processmining.plugins.log.exporting.ExportLogXes;

import net.sf.saxon.s9api.Axis;
import net.sf.saxon.s9api.DocumentBuilder;
import net.sf.saxon.s9api.Processor;
import net.sf.saxon.s9api.QName;
import net.sf.saxon.s9api.SaxonApiException;
import net.sf.saxon.s9api.WhitespaceStrippingPolicy;
import net.sf.saxon.s9api.XPathCompiler;
import net.sf.saxon.s9api.XPathSelector;
import net.sf.saxon.s9api.XdmItem;
import net.sf.saxon.s9api.XdmNode;
import net.sf.saxon.s9api.XdmSequenceIterator;

public class XPathEngine {

	private XLog log;
	private PluginContext context;
	private IdentityConnection idConnection;
	private XdmNode logXMLDoc;
	private XPathCompiler xpath;
	private File logFile;

	private String logNameSpace = ""http://www.xes-standard.org/"";

	private static QName KEYNAME = new QName(""key"");
	private static QName VALUENAME = new QName(""value"");
	private static QName IDNode = new QName("""", ""http://www.xes-standard.org/"", ""id"");

	public void setLogNameSpace(String namespace) {
		logNameSpace = namespace;

		IDNode = new QName("""", namespace, ""id"");
	}

	public String getLogNameSpace() {
		return logNameSpace;
	}

	public XPathEngine(PluginContext context, XLog log) throws IdentitiesMissingException, IOException {
		this.context = context;
		setLog(log);

		init();
	}

	public XLog getLog() {
		return log;
	}

	private void setLog(XLog log) throws IdentitiesMissingException {
		this.log = log;

		//get the connection
		try {
			Collection<IdentityConnection> cons = context.getConnectionManager()
					.getConnections(IdentityConnection.class, context, log);
			//context.log(""I found: "" + cons.size() + "" connections"", MessageLevel.DEBUG );

			for (IdentityConnection con : cons) {
				idConnection = con;
				break;
			}

		} catch (ConnectionCannotBeObtained e) {
			//context.log(""No connection found :-( We need to create one"", MessageLevel.DEBUG );
			idConnection = new IdentityConnection(log);

			context.addConnection(idConnection);
		}

	}

	private void init() throws IOException {
		//transform the log into a XES XML file

		PluginContext child = context.createChildContext(""export xes"");
		logFile = File.createTempFile(""ProM"", "".xes"");

		context.log(""Created temporary file: "" + logFile.getAbsolutePath(), MessageLevel.DEBUG);

		Set<PluginParameterBinding> plugins = context.getPluginManager().getPluginsAcceptingOrdered(child.getClass(),
				false, log.getClass(), File.class);

		//export log to temporary file
		(new ExportLogXes()).export(null, log, logFile);

		//and load the generated document in the XPath engine
		Processor proc = new Processor(false);
		xpath = proc.newXPathCompiler();
		xpath.declareNamespace("""", getLogNameSpace());

		DocumentBuilder builder = proc.newDocumentBuilder();
		builder.setLineNumbering(true);
		builder.setWhitespaceStrippingPolicy(WhitespaceStrippingPolicy.ALL);

		try {
			logXMLDoc = builder.build(logFile);

		} catch (SaxonApiException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public List<Pair<XAttributable, XAttributable>> query(String query, String relQuery) {

		try {
			return query(query, relQuery, false);
		} catch (SaxonApiException e) {
		}

		return null;
	}

	public List<Pair<XAttributable, XAttributable>> query(String query, String relQuery, boolean throwException)
			throws SaxonApiException {
		try {
			return query(logXMLDoc, query, relQuery);
		} catch (SaxonApiException e) {
			if (throwException) {
				throw e;
			}
		}
		return null;
	}

	protected List<Pair<XAttributable, XAttributable>> query(XdmNode startNode, String query, String relQuery)
			throws SaxonApiException {
		List<Pair<XAttributable, XAttributable>> results = new ArrayList<Pair<XAttributable, XAttributable>>();

		XPathSelector selector;

		selector = xpath.compile(query).load();

		selector.setContextItem(startNode);

		int counter = 0;

		for (XdmItem item : selector) {
			XAttributable first = getItem(item);

			//now create a second selector
			XPathSelector relSel = xpath.compile(relQuery).load();
			relSel.setContextItem(item);

			for (XdmItem relItem : relSel) {
				XAttributable second = getItem(relItem);

				results.add(new Pair<XAttributable, XAttributable>(first, second));
				counter++;
			}

		}

		System.out.println(""Counter: "" + counter);

		return results;
	}

	/**
	 * Main function that actually queries the log object.
	 * 
	 * @param query
	 * @return
	 */
	public List<XAttributable> query(String query) {
		try {
			return query(query, false);
		} catch (SaxonApiException e) {
		}
		return null;
	}

	public List<XAttributable> query(String query, boolean throwException) throws SaxonApiException {
		try {
			return query(logXMLDoc, query);
		} catch (SaxonApiException e) {
			if (throwException) {
				throw e;
			}
		}

		return null;
	}

	protected List<XAttributable> query(XdmNode startNode, String query) throws SaxonApiException {
		//execute the query. Look whether the internal things have an ID...
		XPathSelector selector;

		selector = xpath.compile(query).load();

		selector.setContextItem(startNode);

		List<XAttributable> result = new ArrayList<XAttributable>();

		int counter = 0;

		for (XdmItem item : selector) {
			//check whether each element has an id.
			//if you find an id, use it :-)

			XAttributable target = getItem(item);
			counter++;
			if (target != null) {
				result.add(target);
			}
		}
		System.out.println(""Counter <single>: "" + counter);
		System.out.println(""   in result set: "" + result.size());

		return result;
	}

	public void close() {
		//remove the log file
		logFile.delete();
	}

	public void finalize() {
		close();
	}

	private XAttributable getItem(XdmItem item) {
		if (item instanceof XdmNode) {
			return getItem((XdmNode) item);
		}
		return null;
	}

	private XAttributable getItem(XdmNode node) {
		//get the type of this element, if it is an id node,
		//get the key, and if the key equals identity:id
		if (node.getNodeName().getLocalName().equals(""id"")) {
			if (node.getAttributeValue(KEYNAME) != null
					&& node.getAttributeValue(KEYNAME).equals(XIdentityExtension.KEY_ID)) {
				return idConnection.getElement(node.getAttributeValue(VALUENAME));
			}
		} else {
			XdmSequenceIterator iterator = node.axisIterator(Axis.CHILD, IDNode);
			while (iterator.hasNext()) {

				XAttributable item = getItem(iterator.next());
				if (item != null) {
					return item;
				}
			}
		}

		return null;
	}

}
"
XSLTTransformer.java,log-6.9.380,"package org.processmining.log.xsl.transformer;

import javax.xml.transform.Source;

import net.sf.saxon.s9api.Processor;
import net.sf.saxon.s9api.SaxonApiException;
import net.sf.saxon.s9api.XsltCompiler;
import net.sf.saxon.s9api.XsltExecutable;

public class XSLTTransformer {

	
	
	private void executeXSLT(Source xslt) {
		
        try {
        	Processor proc = new Processor(false);
            XsltCompiler comp = proc.newXsltCompiler();
            
        	XsltExecutable exp = comp.compile(xslt);
			
			
			
		} catch (SaxonApiException e) {

			e.printStackTrace();
		}
        
		
	}
	
}
"
AbstractLogModelConnection.java,log-6.9.380,"package org.processmining.models.connections;

import java.lang.ref.WeakReference;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.impl.AbstractStrongReferencingConnection;
import org.processmining.framework.util.Pair;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

public abstract class AbstractLogModelConnection<N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>>
		extends AbstractStrongReferencingConnection {

	public final static String LOG = ""Log"";
	public final static String MODEL = ""Model"";
	public final static String CLASSES = ""XEventClasses"";
	protected final Map<N, Set<XEventClass>> node2activity = new WeakHashMap<N, Set<XEventClass>>();
	private int minNodePerActivity = Integer.MAX_VALUE;
	private int maxNodePerActivity = Integer.MIN_VALUE;
	private int minActivityPerNode = Integer.MAX_VALUE;
	private int maxActivityPerNode = Integer.MIN_VALUE;
	private final Collection<WeakReference<N>> mappableNodes;
	
	private AbstractLogModelConnection(XLog log, XEventClasses classes, DirectedGraph<N, E> graph,
			Collection<? extends N> mappableNodes) {
		super(graph.getLabel() + "" generated from "" + XConceptExtension.instance().extractName(log));
		this.mappableNodes = new HashSet<WeakReference<N>>();
		for (N n : mappableNodes) {
			this.mappableNodes.add(new WeakReference<N>(n));
		}
		put(LOG, log);
		put(MODEL, graph);
		putStrong(CLASSES, classes);
	}

	protected AbstractLogModelConnection(XLog log, XEventClasses classes, DirectedGraph<N, E> graph,
			Collection<? extends N> mappableNodes,
			Collection<? extends Pair<? extends N, ? extends XEventClass>> relations) {
		this(log, classes, graph, mappableNodes);
		for (Pair<? extends N, ? extends XEventClass> pair : relations) {
			if (!node2activity.containsKey(pair.getFirst())) {
				node2activity.put(pair.getFirst(), new HashSet<XEventClass>());
			}
			node2activity.get(pair.getFirst()).add(pair.getSecond());
		}
		initialize(classes, graph);
	}

	protected AbstractLogModelConnection(XLog log, XEventClasses classes, DirectedGraph<N, E> graph,
			Collection<? extends N> mappableNodes, Map<? extends N, ? extends XEventClass> relations) {
		this(log, classes, graph, mappableNodes);
		for (Map.Entry<? extends N, ? extends XEventClass> pair : relations.entrySet()) {
			if (!node2activity.containsKey(pair.getKey())) {
				node2activity.put(pair.getKey(), new HashSet<XEventClass>());
			}
			node2activity.get(pair.getKey()).add(pair.getValue());

		}
		initialize(classes, graph);
	}

	private void initialize(XEventClasses classes, DirectedGraph<N, E> graph) {
		for (XEventClass clazz : classes.getClasses()) {
			Set<N> nodes = getNodesFor(clazz);
			minNodePerActivity = Math.min(minNodePerActivity, nodes.size());
			maxNodePerActivity = Math.max(maxNodePerActivity, nodes.size());
		}
		for (WeakReference<N> node : mappableNodes) {
			Set<XEventClass> events = getActivitiesFor(node.get());
			minActivityPerNode = Math.min(minActivityPerNode, events.size());
			maxActivityPerNode = Math.max(maxActivityPerNode, events.size());
		}
	}

	public Set<XEventClass> getActivitiesFor(N node) {
		Set<XEventClass> s = node2activity.get(node);
		return s == null ? Collections.<XEventClass>emptySet() : s;
	}

	public Set<N> getNodesFor(XEventClass clazz) {
		Set<N> s = new HashSet<N>();
		for (Map.Entry<N, Set<XEventClass>> entry : node2activity.entrySet()) {
			if (entry.getValue().contains(clazz)) {
				s.add(entry.getKey());
			}
		}
		return s;
	}

	public boolean isInjectionFromNodeToActivity() {
		return maxNodePerActivity <= 1;
	}

	public boolean isInjectionFromActivityToNode() {
		return maxActivityPerNode <= 1;
	}

	public boolean isSurjectionFromNodeToActivity() {
		return minNodePerActivity >= 1;
	}

	public boolean isSurjectionFromActivityToNode() {
		return minActivityPerNode >= 1;
	}

	public boolean isBijectionFromNodeToActivity() {
		return isInjectionFromNodeToActivity() && isSurjectionFromNodeToActivity();
	}

	public boolean isBijectionFromActivityToNode() {
		return isInjectionFromActivityToNode() && isSurjectionFromActivityToNode();
	}

	public Collection<N> getMappableNodes() {
		HashSet<N> set = new HashSet<N>();
		for (WeakReference<N> n : mappableNodes) {
			set.add(n.get());
		}
		return Collections.unmodifiableCollection(set);
	}

	public XEventClasses getEventClasses() {
		return (XEventClasses) get(CLASSES);
	}
}
"
LogDirectedGraphConnection.java,log-6.9.380,"package org.processmining.models.connections;

import java.util.Collection;
import java.util.Map;

import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.connections.annotations.ConnectionDoesntExistMessage;
import org.processmining.framework.util.Pair;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

@ConnectionDoesntExistMessage(message = ""No mapping is known between the given XEventClasses and the nodes of the given graph."")
public class LogDirectedGraphConnection extends
		AbstractLogModelConnection<DirectedGraphNode, DirectedGraphEdge<DirectedGraphNode, DirectedGraphNode>> {

	public LogDirectedGraphConnection(XLog log, XEventClasses classes,
			DirectedGraph<DirectedGraphNode, DirectedGraphEdge<DirectedGraphNode, DirectedGraphNode>> graph,
			Collection<Pair<DirectedGraphNode, XEventClass>> relations) {
		super(log, classes, graph, graph.getNodes(), relations);
	}

	public LogDirectedGraphConnection(XLog log, XEventClasses classes,
			DirectedGraph<DirectedGraphNode, DirectedGraphEdge<DirectedGraphNode, DirectedGraphNode>> graph,
			Map<DirectedGraphNode, XEventClass> relations) {
		super(log, classes, graph, graph.getNodes(), relations);
	}

}
"
ResourceType.java,log-6.9.380,"package org.processmining.models;

import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.model.ProMResourceTypeInformation;

public class ResourceType {
	static {
		ProMResourceTypeInformation.getInstance().setInfoFor(XLog.class, ""Event Log"",
				""Eindhoven University of Technology"", ""h.m.w.verbeek@tue.nl"", ""Eric Verbeek"",
				""http://www.processmining.org"", ""resourcetype_log_30x35.png"");

	}
}
"
AbstractLogExporter.java,log-6.9.380,"package org.processmining.plugins.log.exporting;

import java.io.File;
import java.io.IOException;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.log.utils.XUtils;

abstract class AbstractLogExporter {

	/**
	 * Temporarily changes the name of the XLog object, then calls the
	 * {@link #doExport(XLog, File)} method and, afterwards, changes the name of
	 * the XLog object back to the original one.
	 * 
	 * @param context
	 * @param log
	 * @param file
	 * @throws IOException
	 */
	protected void exportWithNameFromContext(PluginContext context, XLog log, File file) throws IOException {
		if (context == null) {
			doExport(log, file);
		} else {
			String originalName = XUtils.renameLogWithProMLabel(context, log);
			try {
				doExport(log, file);
			} finally {
				// Re-assign the original name to avoid changing the XLog object as ProMs connection framework might depend on it
				XUtils.assignConceptName(log, originalName);
			}
		}
	}

	/**
	 * Do the actual export
	 * 
	 * @param log
	 * @param file
	 * @throws IOException
	 */
	abstract void doExport(XLog log, File file) throws IOException;

}"
ExportLogMxml.java,log-6.9.380,"package org.processmining.plugins.log.exporting;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XMxmlSerializer;
import org.deckfour.xes.out.XSerializer;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Export Log to MXML File"", level = PluginLevel.Regular, parameterLabels = { ""Log"", ""File"" }, returnLabels = {}, returnTypes = {}, userAccessible = true)
@UIExportPlugin(description = ""MXML files"", extension = ""mxml"")
public class ExportLogMxml extends AbstractLogExporter {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Log to XMXL File"")
	public void export(UIPluginContext context, XLog log, File file) throws IOException {		
		exportWithNameFromContext(context, log, file);
	}

	public static void export(XLog log, File file) throws IOException {
		FileOutputStream out = new FileOutputStream(file);
		XSerializer logSerializer = new XMxmlSerializer();
		logSerializer.serialize(log, out);
		out.close();
	}

	void doExport(XLog log, File file) throws IOException {
		export(log, file);
	}

}"
ExportLogMxmlGz.java,log-6.9.380,"package org.processmining.plugins.log.exporting;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XMxmlGZIPSerializer;
import org.deckfour.xes.out.XSerializer;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Export Log to compressed MXML File"", level = PluginLevel.Regular, parameterLabels = { ""Log"",
		""File"" }, returnLabels = {}, returnTypes = {}, userAccessible = true)
@UIExportPlugin(description = ""Compressed MXML files"", extension = ""mxml.gz"")
public class ExportLogMxmlGz extends AbstractLogExporter {
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Log to compressed XMXL File"")
	public void export(UIPluginContext context, XLog log, File file) throws IOException {
		exportWithNameFromContext(context, log, file);
	}

	public static void export(XLog log, File file) throws IOException {
		FileOutputStream out = new FileOutputStream(file);
		XSerializer logSerializer = new XMxmlGZIPSerializer();
		logSerializer.serialize(log, out);
		out.close();
	}

	void doExport(XLog log, File file) throws IOException {
		export(log, file);
	}
	
}"
ExportLogXes.java,log-6.9.380,"package org.processmining.plugins.log.exporting;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XSerializer;
import org.deckfour.xes.out.XesXmlSerializer;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Export Log to XES File"", level = PluginLevel.PeerReviewed, parameterLabels = { ""Log"", ""File"" }, returnLabels = {}, returnTypes = {}, userAccessible = true)
@UIExportPlugin(description = ""XES files"", extension = ""xes"")
public class ExportLogXes extends AbstractLogExporter {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Log to XES File"")
	public void export(UIPluginContext context, XLog log, File file) throws IOException {
		exportWithNameFromContext(context, log, file);
	}

	void doExport(XLog log, File file) throws IOException {
		// Calls the static method for backwards compatibility
		export(log, file);
	}

	public static void export(XLog log, File file) throws IOException {
		FileOutputStream out = new FileOutputStream(file);
		XSerializer logSerializer = new XesXmlSerializer();
		logSerializer.serialize(log, out);
		out.close();
	}

}"
ExportLogXesGz.java,log-6.9.380,"package org.processmining.plugins.log.exporting;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import org.deckfour.xes.model.XLog;
import org.deckfour.xes.out.XSerializer;
import org.deckfour.xes.out.XesXmlGZIPSerializer;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Export Log to compressed XES File"", level = PluginLevel.PeerReviewed, parameterLabels = { ""Log"", ""File"" }, returnLabels = {}, returnTypes = {}, userAccessible = true)
@UIExportPlugin(description = ""Compressed XES files"", extension = ""xes.gz"")
public class ExportLogXesGz extends AbstractLogExporter {
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Export Log to compressed XES File"")
	public void export(UIPluginContext context, XLog log, File file) throws IOException {
		exportWithNameFromContext(context, log, file);
	}

	public static void export(XLog log, File file) throws IOException {
		FileOutputStream out = new FileOutputStream(file);
		XSerializer logSerializer = new XesXmlGZIPSerializer();
		logSerializer.serialize(log, out);
		out.close();
	}

	void doExport(XLog log, File file) throws IOException {
		export(log, file);
	}
}
"
AttributeLogFilter.java,log-6.9.380,"package org.processmining.plugins.log.filter;

import java.util.HashSet;
import java.util.Set;

import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;

public class AttributeLogFilter {

	public static final String NONE = ""none"";
	public static final String TRACE_ATTRIBUTE = ""trace attribute"";
	public static final String EVENT_ATTRIBUTE = ""trace with an event having this attribute"";

	public String attribute_filterOn = TRACE_ATTRIBUTE;

	public boolean attribute_include = true;
	public String attribute_key = null;
	public Set<String> attribute_values = new HashSet<String>();

	public int length_min_value = 0;
	public int length_max_value = Integer.MAX_VALUE;

	public XLog log;

	public AttributeLogFilter(XLog log) {
		this.log = log;
		setDefaultValues();
	}

	public void setDefaultValues() {
		this.attribute_filterOn = NONE;
		int min_length = Integer.MAX_VALUE;
		int max_length = Integer.MIN_VALUE;
		for (XTrace t : log) {
			if (t.size() < min_length)
				min_length = t.size();
			if (t.size() > max_length)
				max_length = t.size();
		}
		length_min_value = min_length;
		length_max_value = max_length;
	}

	public boolean satisfies(XAttributeMap attributes) {
		if (!attributes.containsKey(attribute_key)) {
			return false;
		}
		XAttribute attr = attributes.get(attribute_key);
		// the only way to get the value consistently out of all the attribute subclasses
		String attr_value = attr.toString();

		return attribute_values.contains(attr_value);
	}

	public boolean keepTraceOnAttributes(XTrace trace) {

		if (attribute_filterOn == TRACE_ATTRIBUTE) {
			XAttributeMap attributes = trace.getAttributes();
			if (satisfies(attributes)) {
				return attribute_include;
			} else {
				return !attribute_include;
			}

		} else if (attribute_filterOn == EVENT_ATTRIBUTE) {
			for (XEvent e : trace) {
				XAttributeMap attributes = e.getAttributes();
				if (satisfies(attributes)) {
					if (attribute_include)
						return true;
					else
						return false;
				}
			}
			if (attribute_include)
				return false;
			else
				return true;
		}
		return false;
	}

	public boolean keepTraceOnLength(XTrace trace) {
		if (length_min_value <= trace.size() && trace.size() <= length_max_value)
			return true;
		else
			return false;
	}

	public boolean keepTrace(XTrace trace) {

		if (attribute_filterOn != NONE) {
			if (!keepTraceOnAttributes(trace))
				return false;
		}
		if (!keepTraceOnLength(trace))
			return false;

		return true;
	}

}"
AttributeLogFilterPlugin.java,log-6.9.380,"package org.processmining.plugins.log.filter;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Filter Log by Attributes"",
	parameterLabels = { ""a log"", ""filter settings""}, //
	returnLabels = { ""filtered log"" },
	returnTypes = { XLog.class }, 
	userAccessible = true,
	help = ""Filter traces and individual events from the log based on the presence or absence of attributes with particular values."",
	mostSignificantResult = 1)
public class AttributeLogFilterPlugin {
	
	// take log and net as input and guess initial marking
	@UITopiaVariant(
			affiliation=""TU/e"",
			author=""D. Fahland"",
			email=""d.fahland@tue.nl"",
			website = ""http://www.processmining.org/"",
			pack=""Uma"")
	@PluginVariant(variantLabel = ""Filter Log by Attributes"", requiredParameterLabels = { 0 })
	public XLog filterLog(UIPluginContext context, XLog log) {
		
		AttributeLogFilter filter = new AttributeLogFilter(log);
		AttributeLogFilter_UI ui = new AttributeLogFilter_UI(filter);
		if (ui.setParameters(context, filter) != InteractionResult.CANCEL)
			return filterLog(context, log, filter);
		else
			return cancel(context, ""Canceled by user."");
				
	}
	
	@PluginVariant(variantLabel = ""Filter Log by Attributes"", requiredParameterLabels = { 0, 1 })
	public XLog filterLog(PluginContext context, XLog log, AttributeLogFilter filter) {

		XFactory f = XFactoryRegistry.instance().currentDefault();
		
		// create new log, copy original attributes
		XLog filtered = f.createLog(log.getAttributes());
		
		// HV: Copy log metadata.
		filtered.getExtensions().addAll(log.getExtensions());
		filtered.getGlobalEventAttributes().addAll(log.getGlobalEventAttributes());
		filtered.getGlobalTraceAttributes().addAll(log.getGlobalTraceAttributes());
		filtered.getClassifiers().addAll(log.getClassifiers());
		
		for (XTrace t : log) {
			if (filter.keepTrace(t)) {
				filtered.add(t);
			}
		}
		
		DateFormat dateFormat = new SimpleDateFormat(""HH:mm:ss"");
		Date date = new Date();
		String timeString = dateFormat.format(date);
		
		String logName = XConceptExtension.instance().extractName(log);
		if (logName == null) logName = ""log"";
		logName = logName+"" (filtered @ ""+timeString+"")"";
		context.getFutureResult(0).setLabel(logName);
		
		return filtered;
	}

	protected static XLog cancel(PluginContext context, String message) {
		System.out.println(""[AttributeFilter]: ""+message);
		context.log(message);
		context.getFutureResult(0).cancel(true);
		return null;
	}
}
"
AttributeLogFilter_UI.java,log-6.9.380,"package org.processmining.plugins.log.filter;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import javax.swing.AbstractListModel;
import javax.swing.ComboBoxModel;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JCheckBox;
import javax.swing.JLabel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.collection.AlphanumComparator;
import org.processmining.framework.util.ui.widgets.BorderPanel;
import org.processmining.framework.util.ui.widgets.ProMComboBox;
import org.processmining.framework.util.ui.widgets.ProMPropertiesPanel;
import org.processmining.framework.util.ui.widgets.WidgetColors;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.components.SlickerTabbedPane;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class AttributeLogFilter_UI extends BorderPanel {

	private static final long serialVersionUID = 1L;

	public final static String DIALOG_TITLE = ""Filter Log by Properties"";
	public final static String ATTRIBUTE_DIALOG_TITLE = ""Filter Log by Attributes"";
	public final static String LENGTH_DIALOG_TITLE = ""Filter Log by Trace Length"";

	private XLog log;

	private JCheckBox attribute_filter_include_box;
	private ProMComboBox<String> attribute_filter_filter_on;
	private ProMComboBox<String> attribute_filter_log_attributes;
	private ProMComboBox<String> attribute_filter_log_values;

	private NiceSlider length_filter_min;
	private NiceSlider length_filter_max;

	@SuppressWarnings(""unchecked"")
	public AttributeLogFilter_UI(AttributeLogFilter filter) {
		super(0, 0);

		this.log = filter.log;

		SlickerTabbedPane tabs = SlickerFactory.instance().createTabbedPane("""", WidgetColors.COLOR_LIST_BG,
				WidgetColors.COLOR_LIST_FG, Color.GREEN);
		setLayout(new BorderLayout());
		add(tabs);

		ProMPropertiesPanel attributePanel = new ProMPropertiesPanel(ATTRIBUTE_DIALOG_TITLE);
		tabs.addTab(ATTRIBUTE_DIALOG_TITLE, attributePanel);
		attribute_filter_filter_on = new ProMComboBox<String>(new Object[] { AttributeLogFilter.NONE,
				AttributeLogFilter.TRACE_ATTRIBUTE, AttributeLogFilter.EVENT_ATTRIBUTE });
		attributePanel.addProperty(""filter on"", attribute_filter_filter_on);
		attribute_filter_filter_on.addActionListener(new FilterOnListener());

		// use
		attribute_filter_log_attributes = new ProMComboBox<String>(
				getAttributes((String) attribute_filter_filter_on.getSelectedItem()));
		attributePanel.addProperty(""attribute"", attribute_filter_log_attributes);
		attribute_filter_log_attributes.addActionListener(new AttributeListener());

		Set<String> values = getValues((String) attribute_filter_filter_on.getSelectedItem(),
				(String) attribute_filter_log_attributes.getSelectedItem());
		attribute_filter_log_values = new ProMComboBox<String>(values);
		MyComboBoxModel model = new MyComboBoxModel(MyComboBoxModel.NONE);
		attribute_filter_log_values.setModel(model);
		model.setSelectedItem(null);
		attributePanel.addProperty(""value"", attribute_filter_log_values);

		attribute_filter_include_box = SlickerFactory.instance().createCheckBox(null, true);
		attributePanel.addProperty(""keep matching traces"", attribute_filter_include_box);

		ProMPropertiesPanel lengthPanel = new ProMPropertiesPanel(LENGTH_DIALOG_TITLE);
		tabs.addTab(LENGTH_DIALOG_TITLE, lengthPanel);
		int min_length = Integer.MAX_VALUE;
		int max_length = Integer.MIN_VALUE;
		for (XTrace t : log) {
			if (t.size() < min_length)
				min_length = t.size();
			if (t.size() > max_length)
				max_length = t.size();
		}

		length_filter_min = new NiceSlider(null, min_length, max_length, min_length, Orientation.HORIZONTAL) {
			private static final long serialVersionUID = 1L;

			protected String formatValue(int arg0) {
				return Integer.toString(arg0);
			}
		};
		length_filter_min.remove(0); // remove the slider's label we already have one
		// set size and text of value label
		length_filter_min.getComponent(0).setForeground(WidgetColors.TEXT_COLOR);
		length_filter_min.getComponent(0).setMinimumSize(new Dimension(200, 16));
		length_filter_min.getComponent(0).setPreferredSize(new Dimension(200, 16));
		((JLabel) length_filter_min.getComponent(0)).setHorizontalAlignment(JLabel.RIGHT);
		// and put slider into the panel
		lengthPanel.addProperty(""minimum trace length"", length_filter_min);

		length_filter_max = new NiceSlider(null, min_length, max_length, max_length, Orientation.HORIZONTAL) {
			private static final long serialVersionUID = 1L;

			protected String formatValue(int arg0) {
				return Integer.toString(arg0);
			}
		};
		length_filter_max.remove(0); // remove the slider's label we already have one
		// set size and text of value label
		length_filter_max.getComponent(0).setForeground(WidgetColors.TEXT_COLOR);
		length_filter_max.getComponent(0).setMinimumSize(new Dimension(200, 16));
		length_filter_max.getComponent(0).setPreferredSize(new Dimension(200, 16));
		((JLabel) length_filter_max.getComponent(0)).setHorizontalAlignment(JLabel.RIGHT);
		// and put slider into the panel
		lengthPanel.addProperty(""maximum trace length"", length_filter_max);

		setFilterValues(filter);
	}

	/**
	 * Set values of controls based on values in the filter.
	 * 
	 * @param filter
	 */
	protected void setFilterValues(AttributeLogFilter filter) {
		attribute_filter_filter_on.setSelectedItem(filter.attribute_filterOn);
		attribute_filter_include_box.setSelected(filter.attribute_include);
		if (filter.attribute_key != null)
			attribute_filter_log_attributes.setSelectedItem(filter.attribute_key);
		if (filter.attribute_values != null)
			for (Object o : filter.attribute_values) {
				attribute_filter_log_values.setSelectedItem(o);
			}

		length_filter_min.getSlider().setValue(filter.length_min_value);
		length_filter_max.getSlider().setValue(filter.length_max_value);
	}

	/**
	 * display a dialog to ask user what to do
	 * 
	 * @param context
	 * @return
	 */
	protected InteractionResult getUserChoice(UIPluginContext context) {
		return context.showConfiguration(DIALOG_TITLE, this);
	}

	/**
	 * Populate filter object from settings in the panel.
	 * 
	 * @param filter
	 */
	@SuppressWarnings(""unchecked"")
	protected void getFilterValues(AttributeLogFilter filter) {
		filter.attribute_include = attribute_filter_include_box.isSelected();
		filter.attribute_filterOn = (String) attribute_filter_filter_on.getSelectedItem();
		filter.attribute_key = (String) attribute_filter_log_attributes.getSelectedItem();
		filter.attribute_values.clear();
		filter.attribute_values.addAll((List<String>) attribute_filter_log_values.getSelectedItem());

		filter.length_min_value = length_filter_min.getSlider().getValue();
		filter.length_max_value = length_filter_max.getSlider().getValue();
	}

	/**
	 * Open UI dialogue to populate the given configuration object with settings
	 * chosen by the user.
	 * 
	 * @param context
	 * @param config
	 * @return result of the user interaction
	 */
	public InteractionResult setParameters(UIPluginContext context, AttributeLogFilter filter) {
		InteractionResult wish = getUserChoice(context);
		if (wish != InteractionResult.CANCEL)
			getFilterValues(filter);
		return wish;
	}

	/**
	 * Listener to watch
	 * {@link AttributeLogFilter_UI#attribute_filter_filter_on} and store
	 * attribute names in
	 * {@link AttributeLogFilter_UI#attribute_filter_log_attributes} and updated
	 * {@link AttributeLogFilter_UI#attribute_filter_log_values} accordingly
	 */
	private class FilterOnListener implements ActionListener {

		@SuppressWarnings({ ""rawtypes"", ""unchecked"" })
		public void actionPerformed(ActionEvent e) {
			if (e.getID() == ActionEvent.ACTION_PERFORMED && e.getSource() == attribute_filter_filter_on) {

				TreeSet<String> attributeNames = getAttributes((String) attribute_filter_filter_on.getSelectedItem());
				attribute_filter_log_attributes.setModel(new DefaultComboBoxModel(attributeNames.toArray()));

				Set<String> values = getValues((String) attribute_filter_filter_on.getSelectedItem(),
						(String) attribute_filter_log_attributes.getSelectedItem());
				MyComboBoxModel model = new MyComboBoxModel(values.toArray());
				attribute_filter_log_values.setModel(model);
				model.setSelectedItem(null);

				//				attribute_filter_log_values.setModel(new DefaultComboBoxModel(values.toArray()));
			}
		}
	}

	/**
	 * Listener to watch
	 * {@link AttributeLogFilter_UI#attribute_filter_log_attributes} and store
	 * attribute names in
	 * {@link AttributeLogFilter_UI#attribute_filter_log_values}.
	 */
	private class AttributeListener implements ActionListener {

		@SuppressWarnings(""unchecked"")
		public void actionPerformed(ActionEvent e) {
			if (e.getID() == ActionEvent.ACTION_PERFORMED && e.getSource() == attribute_filter_log_attributes) {

				Set<String> values = getValues((String) attribute_filter_filter_on.getSelectedItem(),
						(String) attribute_filter_log_attributes.getSelectedItem());
				MyComboBoxModel model = new MyComboBoxModel(values.toArray());
				attribute_filter_log_values.setModel(model);
				model.setSelectedItem(null);

				//				attribute_filter_log_values.setModel(new DefaultComboBoxModel(values.toArray()));
			}
		}
	}

	/**
	 * Collect all attribute names of the selected category from
	 * {@link AttributeLogFilter_UI#log}
	 * 
	 * @param category
	 * @return
	 */
	private TreeSet<String> getAttributes(String category) {
		TreeSet<String> attributeNames = new TreeSet<String>();
		if (category == AttributeLogFilter.TRACE_ATTRIBUTE) {
			for (XTrace t : log) {
				XAttributeMap attributes = t.getAttributes();
				attributeNames.addAll(attributes.keySet());
			}

		} else if (category == AttributeLogFilter.EVENT_ATTRIBUTE) {
			for (XTrace trace : log) {
				for (XEvent event : trace) {
					XAttributeMap attributes = event.getAttributes();
					attributeNames.addAll(attributes.keySet());
				}
			}
		} else if (category == AttributeLogFilter.NONE) {
			attributeNames.add(""<none>"");
		}
		return attributeNames;
	}

	/**
	 * Collect all attribute values of the selected category and key from
	 * {@link AttributeLogFilter_UI#log}
	 * 
	 * @param category
	 * @return
	 */
	private Set<String> getValues(String category, String key) {
		TreeSet<String> values = new TreeSet<String>(new AlphanumComparator());
		if (category == AttributeLogFilter.TRACE_ATTRIBUTE) {
			for (XTrace t : log) {
				XAttributeMap attributes = t.getAttributes();
				if (attributes.containsKey(key))
					values.add(attributes.get(key).toString());
			}

		} else if (category == AttributeLogFilter.EVENT_ATTRIBUTE) {
			for (XTrace trace : log) {
				for (XEvent event : trace) {
					XAttributeMap attributes = event.getAttributes();
					if (attributes.containsKey(key))
						values.add(attributes.get(key).toString());
				}
			}
		} else if (category == AttributeLogFilter.NONE) {
			values.add(""<none>"");
		}
		return values;
	}

}

class MyComboBoxModel extends AbstractListModel<String> implements ComboBoxModel<String> {

	private static final long serialVersionUID = 1759722993311195116L;
	public static Object NONE = ""none"";
	List<String> values = new ArrayList<String>();
	List<String> selected = new ArrayList<String>();

	public MyComboBoxModel(Object... values) {
		for (Object object : values) {
			if (object == null || object == NONE || !(object instanceof String)) {
				continue;
			}
			this.values.add((String)object);
		}
	}

	@Override
	public int getSize() {
		return values.size();
	}

	@Override
	public String getElementAt(int index) {
		return values.get(index);
	}

	public void setSelectedItem(Object anItem) {
		if (anItem == null || anItem == NONE || !(anItem instanceof String)) {
			if (selected.isEmpty())
				return;
			selected.clear();
		} else {
			boolean removed = selected.remove(anItem);
			if (!removed) {
				selected.add((String)anItem);
			}
		}
		fireContentsChanged(this, -1, -1);
	}

	@Override
	public Object getSelectedItem() {
		return selected;
	}


}
"
BasicEventClassifier.java,log-6.9.380,"package org.processmining.plugins.log.logclassifiers;

import org.deckfour.xes.classification.XEventAttributeClassifier;
import org.deckfour.xes.classification.XEventLifeTransClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.classification.XEventResourceClassifier;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Basic event classifier"", parameterLabels = {}, returnLabels = { ""Event classifier"" }, returnTypes = { XEventAttributeClassifier.class }, userAccessible = true)
public class BasicEventClassifier {

	@PluginVariant(variantLabel = ""Activity name classifier"", requiredParameterLabels = {})
	public static XEventAttributeClassifier getEventNameClassifier(final PluginContext context) {
		return new XEventNameClassifier();
	}

	@PluginVariant(variantLabel = ""Resource classifier"", requiredParameterLabels = {})
	public static XEventAttributeClassifier getEventResourceClassifier(final PluginContext context) {
		return new XEventResourceClassifier();
	}

	@PluginVariant(variantLabel = ""Lifecycle transition classifier"", requiredParameterLabels = {})
	public static XEventAttributeClassifier getEventLifeTransClassifier(final PluginContext context) {
		return new XEventLifeTransClassifier();
	}

}
"
EventAndClassifier.java,log-6.9.380,"package org.processmining.plugins.log.logclassifiers;

import org.deckfour.xes.classification.XEventAndClassifier;
import org.deckfour.xes.classification.XEventClassifier;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;

public class EventAndClassifier {

	@Plugin(name = ""And event classifier"", parameterLabels = { ""Event classifiers"" }, returnLabels = { ""Event classifier"" }, returnTypes = { XEventAndClassifier.class }, userAccessible = true)
	public static XEventAndClassifier getEventNameClassifier(final PluginContext context, XEventClassifier[] classifiers) {
		return new XEventAndClassifier(classifiers);
	}

}
"
AttributeFilterDialog.java,log-6.9.380,"package org.processmining.plugins.log.logfilters;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.swing.DefaultListModel;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTabbedPane;
import javax.swing.ListSelectionModel;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.util.collection.AlphanumComparator;
import org.processmining.framework.util.ui.widgets.BorderPanel;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.framework.util.ui.widgets.ProMTextField;

import com.fluxicon.slickerbox.factory.SlickerFactory;

public class AttributeFilterDialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -5477222861834208877L;
	private Map<String, ProMList<String>> lists;
	private Map<String, JCheckBox> mustHaves;
	private ProMTextField textField;
	private JCheckBox removeEmptyTraces;
	AttributeFilterParameters parameters;
	
	public AttributeFilterDialog(PluginContext context, AttributeFilterParameters parameters, String namePostfix) {
		this.parameters = parameters;
		Map<String, List<String>> values = new HashMap<String, List<String>>();
		for (String key : parameters.getFilter().keySet()) {
			values.put(key, new ArrayList<String>());
			values.get(key).addAll(parameters.getFilter().get(key));
			Collections.sort(values.get(key), new AlphanumComparator());
			context.getProgress().inc();
		}

		double size[][] = { { 80, TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30, 30 } };
		setLayout(new TableLayout(size));

		setOpaque(false);
		
		lists = new HashMap<String, ProMList<String>>();
		mustHaves = new HashMap<String, JCheckBox>();
		
		JTabbedPane tabbedPane = new JTabbedPane();
		List<String> sortedKeys = new ArrayList<String>();
		sortedKeys.addAll(values.keySet());
		Collections.sort(sortedKeys, new AlphanumComparator());
		for (String key : sortedKeys) {
			DefaultListModel<String>listModel = new DefaultListModel<String>();
			int[] selected = new int[values.get(key).size()];
			int i = 0;
			for (String value: values.get(key)) {
				listModel.addElement(value);
				selected[i] = i;
				i++;
			}
			context.getProgress().inc();
			ProMList<String> list = new ProMList<String>(""Select values"", listModel);
			lists.put(key, list);
			list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
			list.setSelectedIndices(selected);
			list.setPreferredSize(new Dimension(100, 100));
			context.getProgress().inc();
			
			JCheckBox checkBox = SlickerFactory.instance().createCheckBox(""Remove if no value provided"", false);
			checkBox.setSelected(parameters.getMustHaves().contains(key));
			mustHaves.put(key, checkBox);
			
			JPanel panel = new BorderPanel(5, 2);
			double panelSize[][] = { { TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30 } };
			panel.setLayout(new TableLayout(panelSize));
			panel.add(lists.get(key), ""0, 0"");
			panel.add(mustHaves.get(key), ""0, 1"");
			
			tabbedPane.add(key, panel);
		}
		this.add(tabbedPane, ""0, 0, 1, 0"");
		
		textField = new ProMTextField();
		textField.setText(parameters.getName() + namePostfix);
		add(textField, ""1, 1"");
		textField.setPreferredSize(new Dimension(100, 25));
		add(new JLabel(""Log name:""), ""0, 1"");

		removeEmptyTraces = SlickerFactory.instance().createCheckBox(""Remove trace if all events were removed"", parameters.isRemoveEmptyTraces()); 
		add(removeEmptyTraces, ""0, 2, 1, 2"");
	}
	
	public void applyFilter() {
		Set<String> mustHaves = new HashSet<String>();
		for (String key : lists.keySet()) {
			parameters.getFilter().get(key).clear();
			parameters.getFilter().get(key).addAll(lists.get(key).getSelectedValuesList());
			if (this.mustHaves.get(key).isSelected()) {
				mustHaves.add(key);
			}
		}
		parameters.setMustHave(mustHaves);
		parameters.setName(textField.getText());
		parameters.setRemoveEmptyTraces(removeEmptyTraces.isSelected());
	}
}
"
AttributeFilterParameters.java,log-6.9.380,"package org.processmining.plugins.log.logfilters;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;

public class AttributeFilterParameters {

	protected Map<String,Set<String>> filter;
	protected Set<String> mustHaves;
	protected String name;
	private boolean removeEmptyTraces;
	
	public AttributeFilterParameters(PluginContext context) {
		filter = new HashMap<String,Set<String>>();
		mustHaves = new HashSet<String>();
		name = """";
		setRemoveEmptyTraces(false);
	}
	
	public AttributeFilterParameters(PluginContext context, XLog log) {
		filter = new HashMap<String,Set<String>>();
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				for (String key : event.getAttributes().keySet()) {
					if (!filter.containsKey(key)) {
						filter.put(key, new HashSet<String>());
					}
					filter.get(key).add(event.getAttributes().get(key).toString());
				}
			}
			context.getProgress().inc();
		}
		mustHaves = new HashSet<String>();
		for (XAttribute attribute : log.getGlobalEventAttributes()) {
			mustHaves.add(attribute.getKey());
		}
		name = XConceptExtension.instance().extractName(log);
	}
	
	public void setFilter(Map<String,Set<String>> filter) {
		this.filter = filter;
	}

	public Map<String,Set<String>> getFilter() {
		return filter;
	}
	
	public void setMustHave(Set<String> mustHaves) {
		this.mustHaves = mustHaves;
	}
	
	public Set<String> getMustHaves() {
		return mustHaves;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}

	public boolean isRemoveEmptyTraces() {
		return removeEmptyTraces;
	}

	public void setRemoveEmptyTraces(boolean removeEmptyTraces) {
		this.removeEmptyTraces = removeEmptyTraces;
	}
}
"
AttributeFilterPlugin.java,log-6.9.380,"package org.processmining.plugins.log.logfilters;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Filter Log on Event Attribute Values"", level= PluginLevel.PeerReviewed, categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Parameters"" }, returnLabels = { ""Log"" }, returnTypes = { XLog.class })
public class AttributeFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Filter Log on Event Attribute Values, UI"", requiredParameterLabels = { 0 })
	public XLog filterDialog(UIPluginContext context, XLog log) {
		context.getProgress().setMaximum(3 * log.size());
		AttributeFilterParameters parameters = new AttributeFilterParameters(context, log);
		parameters.setRemoveEmptyTraces(true);
		AttributeFilterDialog dialog = new AttributeFilterDialog(context, parameters, "" (filtered on event attributes)"");
		InteractionResult result = context.showWizard(""Configure filter (values)"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			context.log(""Canceled by user."");
			context.getFutureResult(0).cancel(true);
			return null;
		}
		dialog.applyFilter();
		return filterPrivate(context, log, parameters);
	}

	@PluginVariant(variantLabel = ""Filter Log on Event Attribute Values, Parameters"", requiredParameterLabels = { 0 })
	public XLog filterParameters(PluginContext context, XLog log, AttributeFilterParameters parameters) {
		return filterPrivate(context, log, parameters);
	}

	private XLog filterPrivate(PluginContext context, XLog log, AttributeFilterParameters parameters) {
		XFactory factory = XFactoryRegistry.instance().currentDefault();
		XLog filteredLog = factory.createLog((XAttributeMap) log.getAttributes().clone());
		filteredLog.getClassifiers().addAll(log.getClassifiers());
		filteredLog.getExtensions().addAll(log.getExtensions());
		filteredLog.getGlobalTraceAttributes().addAll(log.getGlobalTraceAttributes());
		filteredLog.getGlobalEventAttributes().addAll(log.getGlobalEventAttributes());
		for (XTrace trace : log) {
			XTrace filteredTrace = factory.createTrace(trace.getAttributes());
			for (XEvent event : trace) {
				boolean add = true;
				if (event.getAttributes().keySet().containsAll(parameters.getMustHaves())) {
					for (String key : event.getAttributes().keySet()) {
						String value = event.getAttributes().get(key).toString();
						if (!parameters.getFilter().get(key).contains(value)) {
							add = false;
							continue;
						}
					}
					if (add) {
						filteredTrace.add(event);
					}
				}
				context.getProgress().inc();
			}
			if (!parameters.isRemoveEmptyTraces() || !filteredTrace.isEmpty()) {
				filteredLog.add(filteredTrace);
			}
		}
		XConceptExtension.instance().assignName(filteredLog, parameters.getName());
		context.getFutureResult(0).setLabel(parameters.getName());
		return filteredLog;
	}
}
"
AddArtificialEndFilter.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.impl;

import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XTraceEditor;

@Plugin(name = ""Add Artificial End Event Filter"", parameterLabels = { ""Log"", ""Event Label"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class AddArtificialEndFilter {
	/**
	 * This method filters a log by adding an artificial end event to each trace
	 * in the log.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * @param log
	 *            The log that needs to be filtered.
	 * @param event
	 *            The event label of the event to be added
	 * @return the filtered log
	 * @throws LogFilterException
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Keep given events"")
	public XLog filter(PluginContext context, XLog log, final XEvent event) throws LogFilterException {
		// Construct a sorted set of events for easy lookup

		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XTraceEditor() {

					public XTrace editTrace(XTrace trace) {
						// Add the new final event
						trace.add(event);
						return trace;
					}
				});
	}
}
"
AddArtificialStartFilter.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.impl;

import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XTraceEditor;

@Plugin(name = ""Add Artificial Start Event Filter"", parameterLabels = { ""Log"", ""Event Label"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class AddArtificialStartFilter {
	/**
	 * This method filters a log by adding an artificial start event to each
	 * trace in the log.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * @param log
	 *            The log that needs to be filtered.
	 * @param event
	 *            The event label of the event to be added
	 * @return the filtered log
	 * @throws LogFilterException
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Keep given events"")
	public XLog filter(PluginContext context, XLog log, final XEvent event) throws LogFilterException {
		// Construct a sorted set of events for easy lookup

		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XTraceEditor() {

					public XTrace editTrace(XTrace trace) {
						// Keep the trace if the first event is contained in the
						// given set.
						trace.add(0, event);
						return trace;
					}
				});
	}

}
"
DayAbstractionLogEditor.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Calendar;
import java.util.Date;

import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XEventEditor;

@Plugin(name = ""Day Abstraction Log Editor"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"" }, returnLabels = { ""Log (edited)"" }, returnTypes = { XLog.class })
public class DayAbstractionLogEditor {

	XTimeExtension timeExtension = XTimeExtension.instance();
	Calendar calendar = Calendar.getInstance();

	//	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0 }, variantLabel = ""Day Abstraction Log Editor"")
	public XLog editor(PluginContext context, XLog log) throws LogFilterException {

		return LogFilter.filter(log, new XEventEditor() {

			public XEvent editEvent(XEvent event) {
				// TODO Auto-generated method stub
				XEvent editedEvent = (XEvent) event.clone();

				Date date = timeExtension.extractTimestamp(event);
				calendar.setTime(date);
				/*
				 * Abstract from the day.
				 */
				calendar.set(Calendar.YEAR, 2008);
				calendar.set(Calendar.MONTH, 0);
				calendar.set(Calendar.DAY_OF_MONTH, 1);

				timeExtension.assignTimestamp(editedEvent, calendar.getTime());
				return editedEvent;
			}
		});
	}
}
"
DefaultLogFilter.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.XEventCondition;
import org.processmining.plugins.log.logfilters.XTraceCondition;

@Plugin(name = ""Default Log Filter"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Remove"", ""Skip instance"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class DefaultLogFilter {
	/**
	 * This method filters a log by 1) removing all XEvents of which the
	 * XLifeCycleExtension
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * @param log
	 *            The log that needs to be filtered.
	 * @param event
	 *            The event label of the event to be added
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2 }, variantLabel = ""Keep given events"")
	public XLog filter(PluginContext context, XLog log, String[] lifeCycleObjectsToIgnore,
			String[] lifeCycleObjectsToRemoveCase) {
//		long time = -System.currentTimeMillis();
		final Set<?> remove = new HashSet<Object>(Arrays.asList(lifeCycleObjectsToRemoveCase));
		XLog filtered = log;
		
		if (!remove.isEmpty()) {
			// First, remove all cases containing an event of which the lifecycle extension is such
			// that the trace should be removed.
			filtered = LogFilter.filter((context != null ? context.getProgress() : null), 100, filtered,
					(context != null ? XLogInfoFactory.createLogInfo(filtered) : null), new XTraceCondition() {

						public boolean keepTrace(XTrace trace) {
							for (XEvent event : trace) {
								if (remove.contains(XLifecycleExtension.instance().extractTransition(event))) {
									return false;
								}
							}
							return true;
						}
					});
		}
//		time += System.currentTimeMillis();
//		System.err.println(""[DefaultLogFilter] remove time = "" + time);

//		time = -System.currentTimeMillis();
		final Set<?> ignore = new HashSet<Object>(Arrays.asList(lifeCycleObjectsToIgnore));

		if (!ignore.isEmpty()) {
			// Finally, remove all events of which the lifecycle extension is such
			// that it should be ignored.
			filtered = LogFilter.filter((context != null ? context.getProgress() : null), 100, filtered,
					(context != null ? XLogInfoFactory.createLogInfo(filtered) : null), new XEventCondition() {

						public boolean keepEvent(XEvent event) {
							if (ignore.contains(XLifecycleExtension.instance().extractTransition(event))) {
								return false;
							}
							return true;
						}
					});
		}
//		time += System.currentTimeMillis();
//		System.err.println(""[DefaultLogFilter] ignore time = "" + time);
		return filtered;
	}
}
"
DuplicateEventLogFilter.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.impl;

import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XTraceEditor;

@Plugin(name = ""Duplicate Event Log Filter"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Event Classes"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class DuplicateEventLogFilter {
	/**
	 * This method filters a log by removing events from a trace, if the event
	 * is of the same XEventClass as the previous event
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * @param log
	 *            The log that needs to be filtered.
	 * @param events
	 *            The event classes that are distinguished.
	 * @return the filtered log
	 * @throws LogFilterException
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Keep given events"")
	public XLog filter(PluginContext context, XLog log, final XEventClasses events) throws LogFilterException {
		// Construct a sorted set of events for easy lookup

		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XTraceEditor() {

					public XTrace editTrace(XTrace trace) {
						// Keep the trace if the first event is contained in the
						// given set.
						for (int i = 1; i < trace.size(); i++) {
							if (events.getClassOf(trace.get(i)).equals(events.getClassOf(trace.get(i - 1)))) {
								trace.remove(i);
								i--;
							}
						}

						// No check is necessary for empty traces for 2 reasons:
						// 1) the trace cannot become empty, as the first element is
						// never removed
						// 2) even if the trace becomes empty, the LogFilter code
						// removes the trace
						return trace;
					}
				});
	}
}
"
EventLogFilter.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.XEventCondition;

@Plugin(name = ""Event Log Filter"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""All Event Classes"", ""Event Classes to keep"",
		""Minimal Occurrence frequency"", ""Minimal Occurrence in cases"", ""Satisfy both"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class EventLogFilter {

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the XEventClass belonging to this XEvent is
	 * not provided in the given XEventClasses object
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param allEventClasses
	 *            All event classes
	 * @param events
	 *            The event classes that should be kept in the log. Events not
	 *            belonging to these classes are removed, after which emtpy
	 *            traces are also removed
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2 }, variantLabel = ""Filter on Event Class"")
	public XLog filterWithNames(PluginContext context, XLog log, final XEventClasses allEventClasses,
			XEventClass[] eventClassesToKeep) {
		// Construct a sorted set of names for easy lookup
		final HashSet<XEventClass> toKeep = new HashSet<XEventClass>(Arrays.asList(eventClassesToKeep));

		return LogFilter.filter((context != null ? context.getProgress() : null), 100, log, (context != null ? XLogInfoFactory.createLogInfo(log) : null),
				new XEventCondition() {

					public boolean keepEvent(XEvent event) {
						// only keep the event if:
						// 1) its name is in toKeep
						XEventClass c = allEventClasses.getClassOf(event);
						if (!toKeep.contains(c)) {
							return false;
						}
						return true;
					}

				});
	}

	public XLog filterWithClassifier(PluginContext context, XLog log, final XEventClassifier classifier,
			final String[] selectedIds) {
		final Collection<String> ids = new HashSet<String>(Arrays.asList(selectedIds));

		return LogFilter.filter((context != null ? context.getProgress() : null), 100, log, (context != null ? XLogInfoFactory.createLogInfo(log) : null),
				new XEventCondition() {

					public boolean keepEvent(XEvent event) {
						return ids.contains(classifier.getClassIdentity(event));
					}

				});
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the getName() of XEvent is not contained in
	 * the given set of labels. Note that the percentages are based on the
	 * original log, not on the log with the unnecessary events removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param allEventClasses
	 *            All event classes
	 * @param eventClassesToKeep
	 *            The event classes that should be kept in the log. Events not
	 *            belonging to these classes are removed, after which emtpy
	 *            traces are also removed
	 * @param minOccurrence
	 *            All events with an event class which represent less than this
	 *            percentage of the events in the log are removed. Value should
	 *            be 0 <= minOccurrence <= 1. If 0, then all events are kept, if
	 *            1, then no events are kept.
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2, 3 }, variantLabel = ""Filter on Frequencies names"")
	public XLog filterWithMinOccFreq(PluginContext context, XLog log, final XEventClasses allEventClasses,
			final XEventClass[] eventClassesToKeep, final Double minOccurrence) {

		final HashSet<XEventClass> toKeep = new HashSet<XEventClass>(Arrays.asList(eventClassesToKeep));
		final Map<XEventClass, Double> count = new HashMap<XEventClass, Double>();// allEventClasses
		// .
		// getOccurrenceFrequency
		// (log);
		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XEventCondition() {

					public boolean keepEvent(XEvent event) {
						// only keep the event if:
						// 1) it's name is in eventClassesToKeep
						// 2) the frequency is >= minOccurrence
						XEventClass c = allEventClasses.getClassOf(event);
						if (!toKeep.contains(c)) {
							return false;
						}

						double percentage = count.get(c);
						return percentage >= minOccurrence;
					}

				});
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the getName() of XEvent is not contained in
	 * the given set of labels. Note that the percentages are based on the
	 * original log, not on the log with the unnecessary events removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param allEventClasses
	 *            All event classes
	 * @param eventClassesToKeep
	 *            The event classes that should be kept in the log. Events not
	 *            belonging to these classes are removed, after which emtpy
	 *            traces are also removed
	 * @param minCases
	 *            All events which occur in less than minCasses percent of the
	 *            cases are removed. Value should be 0 <= minCases <= 1. If 0,
	 *            then all events are kept, if 1, then only events appearing in
	 *            all cases are kept.
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2, 4 }, variantLabel = ""Filter on Frequencies names"")
	public XLog filterWithMinCases(PluginContext context, XLog log, final XEventClasses allEventClasses,
			XEventClass[] eventClassesToKeep, final Double minCases) {

		final Map<XEventClass, Double> count = new HashMap<XEventClass, Double>();// allEventClasses
		// .
		// getCaseFrequency(log);
		final HashSet<XEventClass> toKeep = new HashSet<XEventClass>(Arrays.asList(eventClassesToKeep));

		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XEventCondition() {

					public boolean keepEvent(XEvent event) {
						// only keep the event if:
						// 1) it's name is in eventClassesToKeep
						// 2) the frequency is >= minCases
						XEventClass c = allEventClasses.getClassOf(event);
						if (!toKeep.contains(c)) {
							return false;
						}

						double percentage = count.get(c);
						return percentage >= minCases;
					}

				});
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the getName() of XEvent is not contained in
	 * the given set of labels. Note that the percentages are based on the
	 * original log, not on the log with the unnecessary events removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param allEventClasses
	 *            All event classes
	 * @param eventClassesToKeep
	 *            The event classes that should be kept in the log. Events not
	 *            belonging to these classes are removed, after which emtpy
	 *            traces are also removed
	 * @param minOccurrence
	 *            All events with an event class which represent less than this
	 *            percentage of the events in the log are removed. Value should
	 *            be 0 <= minOccurrence <= 1. If 0, then all events are kept, if
	 *            1, then no events are kept.
	 * @param minCases
	 *            All events which occur in less than minCasses percent of the
	 *            cases are removed. Value should be 0 <= minCases <= 1. If 0,
	 *            then all events are kept, if 1, then only events appearing in
	 *            all cases are kept.
	 * @param fullfillBoth
	 *            A boolean indicating wheter both minimal frequencies should be
	 *            obeyed (true) or whether one is enough (false)
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2, 3, 4, 5 }, variantLabel = ""Filter on Frequencies names"")
	public XLog filterWithBoth(PluginContext context, XLog log, final XEventClasses allEventClasses,
			XEventClass[] eventClassesToKeep, final Double minOccurrence, final Double minCases,
			final Boolean fullfillBoth) {

		final Map<XEventClass, Double> countFreq = new HashMap<XEventClass, Double>();// allEventClasses
		// .
		// getCaseFrequency
		// (log);
		final Map<XEventClass, Double> countCase = new HashMap<XEventClass, Double>();// allEventClasses
		// .
		// getCaseFrequency
		// (log);
		final HashSet<XEventClass> toKeep = new HashSet<XEventClass>(Arrays.asList(eventClassesToKeep));

		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XEventCondition() {

					public boolean keepEvent(XEvent event) {
						// only keep the event if:
						// 1) it's name is in eventClassesToKeep
						// 2) the frequency is >= minCases
						XEventClass c = allEventClasses.getClassOf(event);
						if (!toKeep.contains(c)) {
							return false;
						}
						double casePercentage = countFreq.get(c);
						double freqPercentage = countCase.get(c);
						if (fullfillBoth) {
							return (casePercentage >= minCases) && (freqPercentage >= minOccurrence);
						} else {
							return (casePercentage >= minCases) || (freqPercentage >= minOccurrence);
						}
					}

				});
	}
}
"
FinalEventLogFilter.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;

import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.XTraceCondition;

@Plugin(name = ""Final Event Log Filter"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Event Classes"", ""Classifier"", ""Start IDs"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class FinalEventLogFilter {
	/**
	 * This method filters a log by removing all traces from the log which do
	 * not end with one of the given events
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param events
	 *            The event classes that can serve as end events of a trace
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Keep given events"")
	public XLog filterWithNames(PluginContext context, XLog log, final XEventClasses events) {
		// Construct a sorted set of events for easy lookup

		return LogFilter.filter((context != null ? context.getProgress() : null), 100, log, (context != null ? XLogInfoFactory.createLogInfo(log) : null),
				new XTraceCondition() {

					public boolean keepTrace(XTrace trace) {
						// Keep the trace if the first event is contained in the
						// given set.
						return !trace.isEmpty() && events.getClasses().contains(events.getClassOf(trace.get(trace.size() - 1)));
					}

				});
	}

	@PluginVariant(requiredParameterLabels = { 0, 2, 3 }, variantLabel = ""Keep given events"")
	public XLog filterWithClassifier(PluginContext context, XLog log, final XEventClassifier classifier,
			final String[] finalIds) {
		// Construct a sorted set of events for easy lookup
		final Collection<String> ids = new HashSet<String>(Arrays.asList(finalIds));

		return LogFilter.filter((context != null ? context.getProgress() : null), 100, log, (context != null ? XLogInfoFactory.createLogInfo(log) : null),
				new XTraceCondition() {

					public boolean keepTrace(XTrace trace) {
						// Keep the trace if the first event is contained in the
						// given set.
						return !trace.isEmpty() && ids.contains(classifier.getClassIdentity(trace.get(trace.size() - 1)));
					}

				});
	}
}
"
FirstSixMonthsFilter.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;

import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;

public class FirstSixMonthsFilter {

	@Plugin(name = ""Filter log on first six months per trace"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	public XLog filter(PluginContext context, XLog log) {
		XLog filtered = (XLog) log.clone();
		Iterator<XTrace> itTrace = filtered.iterator();
		while (itTrace.hasNext()) {
			XTrace trace = itTrace.next();
			Iterator<XEvent> itEvent = trace.iterator();
			Date startDate = XTimeExtension.instance().extractTimestamp(itEvent.next());
			Calendar cal = Calendar.getInstance();
			cal.setTime(startDate);
			cal.add(Calendar.MONTH, 6);
			Date filterDate = cal.getTime();
			while (itEvent.hasNext()) {
				if (XTimeExtension.instance().extractTimestamp(itEvent.next()).after(filterDate)) {
					itEvent.remove();
				}
			}
			if (trace.isEmpty()) {
				itTrace.remove();
			}
		}
		return filtered;
	}

}
"
OriginatorLogFilter.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.XEventCondition;

@Plugin(name = ""Originator Log Filter"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Resources"", ""Groups"", ""Roles"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class OriginatorLogFilter {

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the resource of XEvent is not contained in
	 * the given set of resources.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param namesToKeep
	 *            The names of the resources to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Filter on Names"")
	public XLog filterWithNames(PluginContext context, XLog log, String[] namesToKeep) {
		return filterWithAll(context, log, namesToKeep, new String[0], new String[0]);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the group of XEvent is not contained in the
	 * given set of groups.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param groupsToKeep
	 *            The names of the groups to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 2 }, variantLabel = ""Filter on Groups"")
	public XLog filterWithGroups(PluginContext context, XLog log, String[] groupsToKeep) {
		return filterWithAll(context, log, new String[0], groupsToKeep, new String[0]);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the role of XEvent is not contained in the
	 * given set of roles.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param rolesToKeep
	 *            The names of the roles to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 3 }, variantLabel = ""Filter on Roles"")
	public XLog filterWithRoles(PluginContext context, XLog log, String[] rolesToKeep) {
		return filterWithAll(context, log, new String[0], new String[0], rolesToKeep);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the resource of XEvent is not contained in
	 * the given set of resources, or in the given set of groups.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param namesToKeep
	 *            The names of the resources to keep
	 * @param groupsToKeep
	 *            The names of the groups to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2 }, variantLabel = ""Filter on Names and Groups"")
	public XLog filterWithNamesAndGroups(PluginContext context, XLog log, String[] namesToKeep, String[] groupsToKeep) {
		return filterWithAll(context, log, namesToKeep, groupsToKeep, new String[0]);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the group of XEvent is not contained in the
	 * given set of groups, or in the given set of roles.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param groupsToKeep
	 *            The names of the groups to keep
	 * @param rolesToKeep
	 *            The names of the roles to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 2, 3 }, variantLabel = ""Filter on Groups"")
	public XLog filterWithGroupsAndRoles(PluginContext context, XLog log, final String[] groupsToKeep,
			String[] rolesToKeep) {
		return filterWithAll(context, log, new String[0], groupsToKeep, rolesToKeep);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the group of XEvent is not contained in the
	 * given set of resources, or in the given set of roles.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param namesToKeep
	 *            The names of the resources to keep
	 * @param rolesToKeep
	 *            The names of the roles to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 3 }, variantLabel = ""Filter on Groups"")
	public XLog filterWithNamesAndRoles(PluginContext context, XLog log, String[] namesToKeep, String[] rolesToKeep) {
		return filterWithAll(context, log, namesToKeep, new String[0], rolesToKeep);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the group of XEvent is not contained in the
	 * given set of resources, or in the given set of roles, or in the given set
	 * of groups.
	 * 
	 * If no resource information is available in the log, all events are
	 * removed.
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param namesToKeep
	 *            The names of the resources to keep
	 * @param groupsToKeep
	 *            The names of the resources to keep
	 * @param rolesToKeep
	 *            The names of the roles to keep
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1, 2, 3 }, variantLabel = ""Filter on Groups"")
	public XLog filterWithAll(PluginContext context, XLog log, String[] namesToKeep, String[] groupsToKeep,
			String[] rolesToKeep) {

		// Construct a sorted set of names for easy lookup
		final Set<String> names = new TreeSet<String>(Arrays.asList(namesToKeep));
		final Set<String> roles = new TreeSet<String>(Arrays.asList(rolesToKeep));
		final Set<String> groups = new TreeSet<String>(Arrays.asList(groupsToKeep));

		return LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XEventCondition() {

					public boolean keepEvent(XEvent event) {
						// Keep the event if the getName() is contained in events.
						return roles.contains(XOrganizationalExtension.instance().extractRole(event))
								|| groups.contains(XOrganizationalExtension.instance().extractGroup(event))
								|| names.contains(XOrganizationalExtension.instance().extractResource(event));
					}

				});
	}

}
"
StartEventLogFilter.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;

import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.XTraceCondition;

@Plugin(name = ""Start Event Log Filter"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Event Classes"", ""Classifier"", ""Start IDs"" }, returnLabels = { ""Log (filtered)"" }, returnTypes = { XLog.class })
public class StartEventLogFilter {
	/**
	 * This method filters a log by removing all traces from the log which do
	 * not start with one of the given events
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed
	 * @param log
	 *            The log that needs to be filtered.
	 * @param events
	 *            The event classes that can serve as start events of a trace
	 * @return the filtered log
	 */
	@PluginVariant(requiredParameterLabels = { 0, 1 }, variantLabel = ""Keep given events"")
	public XLog filterWithNames(PluginContext context, XLog log, final XEventClasses events) {
		// Construct a sorted set of events for easy lookup

		return LogFilter.filter((context != null ? context.getProgress() : null), 100, log, (context != null ? XLogInfoFactory.createLogInfo(log) : null),
				new XTraceCondition() {

					public boolean keepTrace(XTrace trace) {
						// Keep the trace if the first event is contained in the
						// given set.
						return !trace.isEmpty() && events.getClasses().contains(events.getClassOf(trace.get(0)));
					}

				});
	}

	@PluginVariant(requiredParameterLabels = { 0, 2, 3 }, variantLabel = ""Keep given events"")
	public XLog filterWithClassifier(PluginContext context, XLog log, final XEventClassifier classifier,
			final String[] startIds) {
		// Construct a sorted set of events for easy lookup
		final Collection<String> ids = new HashSet<String>(Arrays.asList(startIds));

		return LogFilter.filter((context != null ? context.getProgress() : null), 100, log, (context != null ? XLogInfoFactory.createLogInfo(log) : null),
				new XTraceCondition() {

					public boolean keepTrace(XTrace trace) {
						// Keep the trace if the first event is contained in the
						// given set.
						return !trace.isEmpty() && ids.contains(classifier.getClassIdentity(trace.get(0)));
					}

				});
	}
}
"
WeekAbstractionLogEditor.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.impl;

import java.util.Calendar;
import java.util.Date;

import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XEventEditor;

@Plugin(name = ""Week Abstraction Log Editor"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"" }, returnLabels = { ""Log (edited)"" }, returnTypes = { XLog.class })
public class WeekAbstractionLogEditor {

	XTimeExtension timeExtension = XTimeExtension.instance();
	Calendar calendar = Calendar.getInstance();

	//	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0 }, variantLabel = ""Day Abstraction Log Editor"")
	public XLog editor(PluginContext context, XLog log) throws LogFilterException {

		return LogFilter.filter(log, new XEventEditor() {

			public XEvent editEvent(XEvent event) {
				// TODO Auto-generated method stub
				XEvent editedEvent = (XEvent) event.clone();

				Date date = timeExtension.extractTimestamp(event);
				calendar.setTime(date);
				/*
				 * Abstract from the day.
				 */
				calendar.set(Calendar.YEAR, 2008);
				calendar.set(Calendar.MONTH, 0);
				calendar.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);

				timeExtension.assignTimestamp(editedEvent, calendar.getTime());
				return editedEvent;
			}
		});
	}
}
"
LogFilter.java,log-6.9.380,"package org.processmining.plugins.log.logfilters;

import java.util.Iterator;

import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.Progress;

/**
 * Class containing some static methods that are easy to use when implementing a
 * new filter on a log.
 * 
 * @author bfvdonge
 * 
 */
public class LogFilter {

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the given XEventCondition returns false.
	 * After that, the given XTrace condition is checked on the filtered trace
	 * and the trace is removed if this condition returns false.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @param eventCondition
	 *            The condition that is checked for all events in the log.
	 * @param traceCondition
	 *            The condition that is checked for all traces in the log. Note
	 *            that on each trace, the eventCondition is first checked on all
	 *            events, and then the trace condition is checked on the
	 *            filtered trace.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 */
	public static XLog filter(XLog log, XEventCondition eventCondition, XTraceCondition traceCondition) {
		return filter(null, 1, log, null, eventCondition, traceCondition);

	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the given XEventCondition returns false.
	 * After that, the given XTrace condition is checked on the filtered trace
	 * and the trace is removed if this condition returns false.
	 * 
	 * @param progress
	 *            A Progress object which is used for showing progress. steps
	 *            steps are added to the maximum and progress is increased in
	 *            steps steps. May be null.
	 * @param steps
	 *            The number of steps in which progress is provided. Should be >
	 *            0
	 * @param log
	 *            The log that needs to be filtered.
	 * @param summary
	 *            The summary of the log. Is used to determine the number of
	 *            events in the log. If null, it will be constructed if progress
	 *            is not null.
	 * @param eventCondition
	 *            The condition that is checked for all events in the log.
	 * @param traceCondition
	 *            The condition that is checked for all traces in the log. Note
	 *            that on each trace, the eventCondition is first checked on all
	 *            events, and then the trace condition is checked on the
	 *            filtered trace.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 */
	public static XLog filter(Progress progress, int steps, XLog log, XLogInfo summary, XEventCondition eventCondition,
			XTraceCondition traceCondition) {

		// set the progress indicator to the maximum number of events / 100
		if ((summary == null) && (progress != null)) {
			summary = XLogInfoFactory.createLogInfo(log);
		}
		int barSize = 100;
		if (summary != null) {
			steps = Math.min(steps, summary.getNumberOfTraces());
			barSize = summary.getNumberOfEvents() / (steps > 0 ? steps : 1);
			if (progress != null) {
				progress.setMaximum(progress.getMaximum() + steps);
			}
		}

		// Go through the log to remove all XEvents, of which the name is not
		// contains in
		// labels
		XLog filtered = (XLog) log.clone();
		int i = 0;
		Iterator<XTrace> itTrace = filtered.iterator();
//		long time = -System.currentTimeMillis();
//		long progressTime = 0;
		while (itTrace.hasNext()) {
			XTrace trace = itTrace.next();
			Iterator<XEvent> itEvent = trace.iterator();
			while (itEvent.hasNext()) {
				if (!eventCondition.keepEvent(itEvent.next())) {
					// The XEvent should be removed
					itEvent.remove();
				}
				// Check for progress and signal if necessary
//				progressTime -= System.currentTimeMillis();
				if (progress != null) {
					if (i % barSize == 0) {
						progress.inc();
					}
					i++;
				}
//				progressTime += System.currentTimeMillis();
			}
			if (trace.isEmpty() || !traceCondition.keepTrace(trace)) {
				itTrace.remove();
			}
		}
//		time += System.currentTimeMillis();
//		System.err.println(""[LogFilter] time = "" + time + "", progressTime = "" + progressTime);
		return filtered;
	}

	/**
	 * This method filters a log by checking the given XTrace condition on each
	 * trance. The trace is removed if this condition returns false.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @param traceCondition
	 *            The condition that is checked for all traces in the log. Note
	 *            that on each trace, the eventCondition is first checked on all
	 *            events, and then the trace condition is checked on the
	 *            filtered trace.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 */
	public static XLog filter(XLog log, XTraceCondition traceCondition) {
		return filter(null, 1, log, null, traceCondition);
	}

	/**
	 * This method filters a log by checking the given XTrace condition on each
	 * trance. The trace is removed if this condition returns false.
	 * 
	 * @param progress
	 *            A Progress object which is used for showing progress. steps
	 *            steps are added to the maximum and progress is increased in
	 *            steps steps. May be null.
	 * @param steps
	 *            The number of steps in which progress is provided. Should be >
	 *            0
	 * @param log
	 *            The log that needs to be filtered.
	 * @param summary
	 *            The summary of the log. Is used to determine the number of
	 *            events in the log. If null, it will be constructed if progress
	 *            is not null.
	 * @param traceCondition
	 *            The condition that is checked for all traces in the log. Note
	 *            that on each trace, the eventCondition is first checked on all
	 *            events, and then the trace condition is checked on the
	 *            filtered trace.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 */
	public static XLog filter(Progress progress, int steps, XLog log, XLogInfo summary, XTraceCondition traceCondition) {

		// set the progress indicator to the maximum number of events / 100
		if ((summary == null) && (progress != null)) {
			summary = XLogInfoFactory.createLogInfo(log);
		}
		int barSize = 100;
		if (summary != null) {
			steps = Math.max(1, Math.min(steps, summary.getNumberOfTraces()));
			barSize = summary.getNumberOfTraces() / steps;
			if (progress != null) {
				progress.setMaximum(progress.getMaximum() + steps);
			}
		}

		// Go through the log to remove all XEvents, of which the name is not
		// contains in
		// labels
		XLog filtered = (XLog) log.clone();
		int i = 0;
		Iterator<XTrace> itTrace = filtered.iterator();
//		long time = -System.currentTimeMillis();
//		long progressTime = 0;
		while (itTrace.hasNext()) {
			XTrace trace = itTrace.next();
			if (!traceCondition.keepTrace(trace)) {
				itTrace.remove();
			}
//			progressTime -= System.currentTimeMillis();
			if (progress != null) {
				if (i % barSize == 0) {
					progress.inc();
				}
				i++;
			}
//			progressTime += System.currentTimeMillis();
		}
//		time += System.currentTimeMillis();
//		System.err.println(""[LogFilter] time = "" + time + "", progressTime = "" + progressTime);
		return filtered;
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the given XEventCondition returns false.
	 * After that, the filtered trace is removed if it remains empty.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @param eventCondition
	 *            The condition that is checked for all events in the log.
	 * @return the filtered log
	 */
	public static XLog filter(XLog log, XEventCondition eventCondition) {
		return filter(null, 1, log, null, eventCondition);
	}

	/**
	 * This method filters a log by removing XEvent objects from all XTrace
	 * object in the given XLog, if the given XEventCondition returns false.
	 * After that, the filtered trace is removed if it remains empty.
	 * 
	 * @param progress
	 *            A Progress object which is used for showing progress. steps
	 *            steps are added to the maximum and progress is increased in
	 *            steps steps. May be null.
	 * @param steps
	 *            The number of steps in which progress is provided. Should be >
	 *            0
	 * @param log
	 *            The log that needs to be filtered.
	 * @param summary
	 *            The summary of the log. Is used to determine the number of
	 *            events in the log. If null, it will be constructed if progress
	 *            is not null.
	 * @param eventCondition
	 *            The condition that is checked for all events in the log.
	 * @return the filtered log
	 */
	public static XLog filter(Progress progress, int steps, XLog log, XLogInfo summary, XEventCondition eventCondition) {

		return filter(progress, steps, log, summary, eventCondition, new XTraceCondition() {

			public boolean keepTrace(XTrace trace) {
				// Keep the trace
				return true;
			}
		});
	}

	/**
	 * This method filters a log by editing the XEvent objects from all XTrace
	 * object in the given XLog. XEvent objects are removed if the given
	 * XEventEditor returns null. If a new XEvent object is returned by the
	 * XEventEditor, then the original XEvent is replaced by the new XEvent.
	 * After editing all events, the filtered trace is removed if it remains
	 * empty. If it is not empty, then it is provided to the given XTraceEditor
	 * for editing. If this editor returns null, the trace is removed. If this
	 * editor returns a new XTrace object, the original XTrace is replaces.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @param eventEditor
	 *            The editor that is applied to all XEvents in the log
	 * @param traceEditor
	 *            The editor that is applied to each trace. Note that first all
	 *            events are edited and that the trace editor is then applied to
	 *            the filtered trace, if it is not empty.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 * @throws LogFilterException
	 */
	public static XLog filter(XLog log, XEventEditor eventEditor, XTraceEditor traceEditor) throws LogFilterException {
		return filter(null, 1, log, null, eventEditor, traceEditor);
	}

	/**
	 * This method filters a log by editing the XEvent objects from all XTrace
	 * object in the given XLog. XEvent objects are removed if the given
	 * XEventEditor returns null. If a new XEvent object is returned by the
	 * XEventEditor, then the original XEvent is replaced by the new XEvent.
	 * After editing all events, the filtered trace is removed if it remains
	 * empty. If it is not empty, then it is provided to the given XTraceEditor
	 * for editing. If this editor returns null, the trace is removed. If this
	 * editor returns a new XTrace object, the original XTrace is replaces.
	 * 
	 * @param progress
	 *            A Progress object which is used for showing progress. steps
	 *            steps are added to the maximum and progress is increased in
	 *            steps steps. May be null.
	 * @param steps
	 *            The number of steps in which progress is provided. Should be >
	 *            0
	 * @param log
	 *            The log that needs to be filtered.
	 * @param summary
	 *            The summary of the log. Is used to determine the number of
	 *            events in the log. If null, it will be constructed if progress
	 *            is not null.
	 * @param eventEditor
	 *            The editor that is applied to all XEvents in the log
	 * @param traceEditor
	 *            The editor that is applied to each trace. Note that first all
	 *            events are edited and that the trace editor is then applied to
	 *            the filtered trace, if it is not empty.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 * @throws LogFilterException
	 *             if an XTraceEditor returns a new trace.
	 */
	public static XLog filter(Progress progress, int steps, XLog log, XLogInfo summary, XEventEditor eventEditor,
			XTraceEditor traceEditor) throws LogFilterException {

		int barSize = 100;
		// set the progress indicator to the maximum number of events / 100
		if (progress != null) {
			if (summary == null) {
				summary = XLogInfoFactory.createLogInfo(log);
			}
			steps = Math.min(steps, summary.getNumberOfTraces());
			barSize = summary.getNumberOfEvents() / steps;
			progress.setMaximum(progress.getMaximum() + steps);
		}

		// Go through the log to remove all XEvents, of which the name is not
		// contains in
		// labels
		XLog filtered = (XLog) log.clone();

		int progressStep = 0;

		Iterator<XTrace> it = filtered.iterator();
		while (it.hasNext()) {
			XTrace oldTrace = it.next();

			for (int eventIndex = 0; eventIndex < oldTrace.size(); eventIndex++) {
				XEvent oldEvent = oldTrace.get(eventIndex);
				XEvent newEvent = eventEditor.editEvent(oldEvent);
				if (newEvent == null) {
					// The editor returned null, so remove the event
					oldTrace.remove(eventIndex);
					eventIndex--;
				} else if (newEvent != oldEvent) {
					// The editor returned a new event, so replace the old one
					oldTrace.set(eventIndex, newEvent);
				}
				// Check for progress and signal if necessary
				if (progress != null) {
					if (progressStep % barSize == 0) {
						progress.inc();
					}
					progressStep++;
				}
			}
			if (oldTrace.isEmpty()) {
				// All events of this trace were removed, remove the trace
				it.remove();
			} else {
				// Edit the trace
				XTrace newTrace = traceEditor.editTrace(oldTrace);
				if (newTrace == null) {
					// The editor returned null, so remove the trace
					it.remove();
				} else if (newTrace != oldTrace) {
					// The editor returned a new trace, so this is wrong!
					throw new LogFilterException(""New traces cannot be produced by XTraceEditors."");
				}
			}
		}
		return filtered;
	}

	/**
	 * This method filters a log by editing all XTrace objects in the given
	 * XLog. Each XTrace object is provided to the given XTraceEditor for
	 * editing. If this editor returns null, the trace is removed. If this
	 * editor returns a new XTrace object, the original XTrace is replaces.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @param traceEditor
	 *            The editor that is applied to each trace.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 * @throws LogFilterException
	 */
	public static XLog filter(XLog log, XTraceEditor traceEditor) throws LogFilterException {
		return filter(null, 1, log, null, traceEditor);
	}

	/**
	 * This method filters a log by editing all XTrace objects in the given
	 * XLog. Each XTrace object is provided to the given XTraceEditor for
	 * editing. If this editor returns null, the trace is removed. If this
	 * editor returns a new XTrace object, the original XTrace is replaces.
	 * 
	 * @param progress
	 *            A Progress object which is used for showing progress. steps
	 *            steps are added to the maximum and progress is increased in
	 *            steps steps. May be null.
	 * @param steps
	 *            The number of steps in which progress is provided. Should be >
	 *            0
	 * @param log
	 *            The log that needs to be filtered.
	 * @param summary
	 *            The summary of the log. Is used to determine the number of
	 *            events in the log. If null, it will be constructed if progress
	 *            is not null.
	 * @param traceEditor
	 *            The editor that is applied to each trace.
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 */
	public static XLog filter(Progress progress, int steps, XLog log, XLogInfo summary, XTraceEditor traceEditor)
			throws LogFilterException {

		// set the progress indicator to the maximum number of events / 100
		if ((summary == null) && (progress != null)) {
			summary = XLogInfoFactory.createLogInfo(log);
		}
		int barSize = 100;
		if (summary != null) {
			steps = Math.min(steps, summary.getNumberOfTraces());
			barSize = summary.getNumberOfTraces() / steps;
			if (progress != null) {
				progress.setMaximum(progress.getMaximum() + steps);
			}
		}

		// Go through the log to remove all XEvents, of which the name is not
		// contains in
		// labels
		XLog filtered = (XLog) log.clone();
		int progressStep = 0;
		Iterator<XTrace> it = filtered.iterator();
		while (it.hasNext()) {
			XTrace oldTrace = it.next();

			// Edit the trace
			XTrace newTrace = traceEditor.editTrace(oldTrace);
			if (newTrace == null) {
				// The editor returned null, so remove the trace
				it.remove();
			} else if (newTrace != oldTrace) {
				// The editor returned a new trace, so this is wrong
				throw new LogFilterException(""New traces cannot be produced by XTraceEditors."");
			}
			// Check for progress and signal if necessary
			if (progress != null) {
				if (progressStep % barSize == 0) {
					progress.inc();
				}
				progressStep++;
			}
		}
		return filtered;
	}

	/**
	 * This method filters a log by editing the XEvent objects from all XTrace
	 * object in the given XLog. XEvent objects are removed if the given
	 * XEventEditor returns null. If a new XEvent object is returned by the
	 * XEventEditor, then the original XEvent is replaced by the new XEvent.
	 * After editing, the filtered trace is removed if it remains empty.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @param eventEditor
	 *            The editor that is applied to all XEvents in the log
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 * @throws LogFilterException
	 */
	public static XLog filter(XLog log, XEventEditor eventEditor) throws LogFilterException {
		return filter(null, 1, log, null, eventEditor);
	}

	/**
	 * This method filters a log by editing the XEvent objects from all XTrace
	 * object in the given XLog. XEvent objects are removed if the given
	 * XEventEditor returns null. If a new XEvent object is returned by the
	 * XEventEditor, then the original XEvent is replaced by the new XEvent.
	 * After editing, the filtered trace is removed if it remains empty.
	 * 
	 * @param progress
	 *            A Progress object which is used for showing progress. steps
	 *            steps are added to the maximum and progress is increased in
	 *            steps steps. May be null.
	 * @param steps
	 *            The number of steps in which progress is provided. Should be >
	 *            0
	 * @param log
	 *            The log that needs to be filtered.
	 * @param summary
	 *            The summary of the log. Is used to determine the number of
	 *            events in the log. If null, it will be constructed if progress
	 *            is not null.
	 * @param eventEditor
	 *            The editor that is applied to all XEvents in the log
	 * @return the filtered log. The result is a clone of the input log, i.e.
	 *         the given log object does not change
	 * @throws LogFilterException
	 */
	public static XLog filter(Progress progress, int steps, XLog log, XLogInfo summary, XEventEditor eventEditor)
			throws LogFilterException {

		return filter(progress, steps, log, summary, eventEditor, new XTraceEditor() {

			public XTrace editTrace(XTrace trace) {
				if (trace.isEmpty()) {
					return null;
				} else {
					return trace;
				}
			}
		});
	}

}
"
LogFilterException.java,log-6.9.380,"package org.processmining.plugins.log.logfilters;

public class LogFilterException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8913201243551484739L;

	public LogFilterException(String message) {
		super(message);
	}
}"
TraceAttributeFilterParameters.java,log-6.9.380,"package org.processmining.plugins.log.logfilters;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XAttribute;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;

public class TraceAttributeFilterParameters extends AttributeFilterParameters {

	public TraceAttributeFilterParameters(PluginContext context, XLog log) {
		super(context);
		filter = new HashMap<String, Set<String>>();
		for (XTrace trace : log) {
			for (String key : trace.getAttributes().keySet()) {
				if (!filter.containsKey(key)) {
					filter.put(key, new HashSet<String>());
				}
				filter.get(key).add(trace.getAttributes().get(key).toString());
			}
			context.getProgress().inc();
		}
		for (XAttribute attribute : log.getGlobalTraceAttributes()) {
			mustHaves.add(attribute.getKey());
		}
		name = XConceptExtension.instance().extractName(log);
	}
}
"
TraceAttributeFilterPlugin.java,log-6.9.380,"package org.processmining.plugins.log.logfilters;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Filter Log on Trace Attribute Values"", level= PluginLevel.PeerReviewed, categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"", ""Parameters"" }, returnLabels = { ""Log"" }, returnTypes = { XLog.class })
public class TraceAttributeFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Filter Log on Trace Attribute Values, UI"", requiredParameterLabels = { 0 })
	public XLog filterDialog(UIPluginContext context, XLog log) {
		context.getProgress().setMaximum(3 * log.size());
		TraceAttributeFilterParameters parameters = new TraceAttributeFilterParameters(context, log);
		AttributeFilterDialog dialog = new AttributeFilterDialog(context, parameters, "" (filtered on trace attributes)"");
		InteractionResult result = context.showWizard(""Configure filter (values)"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			context.log(""Canceled by user."");
			context.getFutureResult(0).cancel(true);
			return null;
		}
		dialog.applyFilter();
		return filterPrivate(context, log, parameters);
	}

	@PluginVariant(variantLabel = ""Filter Log on Trace Attribute Values, Parameters"", requiredParameterLabels = { 0 })
	public XLog filterParameters(PluginContext context, XLog log, AttributeFilterParameters parameters) {
		return filterPrivate(context, log, parameters);
	}

	private XLog filterPrivate(PluginContext context, XLog log, AttributeFilterParameters parameters) {
		XFactory factory = XFactoryRegistry.instance().currentDefault();
		XLog filteredLog = factory.createLog((XAttributeMap) log.getAttributes().clone());
		filteredLog.getClassifiers().addAll(log.getClassifiers());
		filteredLog.getExtensions().addAll(log.getExtensions());
		filteredLog.getGlobalTraceAttributes().addAll(log.getGlobalTraceAttributes());
		filteredLog.getGlobalEventAttributes().addAll(log.getGlobalEventAttributes());
		for (XTrace trace : log) {
			boolean add = true;
			if (trace.getAttributes().keySet().containsAll(parameters.getMustHaves())) {
				for (String key : trace.getAttributes().keySet()) {
					String value = trace.getAttributes().get(key).toString();
					if (!parameters.getFilter().get(key).contains(value)) {
						add = false;
						continue;
					}
				}
				if (add) {
					filteredLog.add(trace);
				}
			}
			context.getProgress().inc();
		}
		XConceptExtension.instance().assignName(filteredLog, parameters.getName());
		context.getFutureResult(0).setLabel(parameters.getName());
		return filteredLog;
	}
}
"
LogFilterPlugin.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.ui;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;

@Plugin(name = ""Filter Log using Simple Heuristics"", level= PluginLevel.PeerReviewed, categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"" }, returnLabels = { ""Log"" }, returnTypes = { XLog.class }, userAccessible = true)
public class LogFilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"", pack = ""Log"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public static XLog main(final UIPluginContext context, XLog log) {
		LogFilterUI filterUI = new LogFilterUI(context);
		XLog filteredLog = filterUI.filter(log);
		if (filteredLog != null) {
			XConceptExtension.instance().assignName(filteredLog, filterUI.getName());
			context.getFutureResult(0).setLabel(filterUI.getName());
		} else {
			context.log(""Canceled by user."");
			context.getFutureResult(0).cancel(true);
		}
		return filteredLog;
	}
}
"
LogFilterUI.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.ui;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.TreeSet;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.ListSelectionModel;
import javax.swing.ScrollPaneConstants;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.classification.XEventClass;
import org.deckfour.xes.classification.XEventClasses;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.info.XLogInfo;
import org.deckfour.xes.info.impl.XLogInfoImpl;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.collection.AlphanumComparator;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.plugins.log.logfilters.impl.DefaultLogFilter;
import org.processmining.plugins.log.logfilters.impl.EventLogFilter;
import org.processmining.plugins.log.logfilters.impl.FinalEventLogFilter;
import org.processmining.plugins.log.logfilters.impl.StartEventLogFilter;
import org.processmining.plugins.log.logfilters.ui.SlickerEventTypeConfiguration.EventTypeAction;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.factory.SlickerFactory;
import com.fluxicon.slickerbox.ui.SlickerScrollBarUI;

/**
 * Simple log filter. Allows the user to use the following filters in the given
 * order: 1. Filter events using the lifecycle transition classification. 2.
 * Filter traces on start events using the standard classification (concept name
 * and lifecycle transition). 3. Filter traces on end events using the standard
 * classification (concept name and lifecycle transition). 4. Filter events
 * using the standard classification (concept name and lifecycle transition).
 * During steps 2, 3, and 4, the user can use a slider to indicate how much
 * coverage s/he wants. The most occurring events/traces will then be selected
 * until the coverage has been reached.
 * 
 * @author hverbeek
 * 
 */
public class LogFilterUI {

	private final UIPluginContext context;
	private int nofSteps;
	private int eventTypeStep;
	private int startEventStep;
	private int endEventStep;
	private int eventFilterStep;
	private int currentStep;
	private myStep[] mySteps;
	private String name;

	/**
	 * Whether to use all events, only the start events, or only the end events.
	 */
	enum Mode {
		ALLEVENTS, STARTEVENTS, ENDEVENTS
	}

	public LogFilterUI(UIPluginContext context) {
		this.context = context;
	}

	public String getName() {
		return name;
	}
	
	/**
	 * Runs the simple log filter on the given log.
	 * 
	 * @param log
	 *            The given log.
	 * @return The filtered log (depends on the settings chosen by the user).
	 */
	public XLog filter(XLog log) {
		InteractionResult result;

		name = XConceptExtension.instance().extractName(log) + "" (filtered on simple heuristics)"";
		/*
		 * Create all filter steps.
		 */
		nofSteps = 0;
		eventTypeStep = nofSteps++;
		startEventStep = nofSteps++;
		endEventStep = nofSteps++;
		eventFilterStep = nofSteps++;

		mySteps = new myStep[nofSteps];

		mySteps[eventTypeStep] = new EventTypeStep();
		mySteps[startEventStep] = new StartEventStep();
		mySteps[endEventStep] = new EndEventStep();
		mySteps[eventFilterStep] = new EventFilterStep();

		/*
		 * Initialize the first step.
		 */
		currentStep = eventTypeStep;
		mySteps[currentStep].initComponents(log);

		/*
		 * The wizard loop.
		 */
		while (true) {
			/*
			 * Show the current step.
			 */
			result = context.showWizard(""Log Filter"", currentStep == 0, currentStep == nofSteps - 1,
					mySteps[currentStep]);
			switch (result) {
				case NEXT :
					/*
					 * Show the next step. First get the log of the previous
					 * step, then move the next step, and initialize it with the
					 * filtered log of the previous step.
					 */
					//					long time = -System.currentTimeMillis();
					XLog filteredLog = mySteps[currentStep].getLog();
					//					time += System.currentTimeMillis();
					//					System.err.println(""[LogFilterUI] log time = "" + time);
					go(1);
					//					time = -System.currentTimeMillis();
					mySteps[currentStep].initComponents(filteredLog);
					mySteps[currentStep].repaint();
					//					time += System.currentTimeMillis();
					//					System.err.println(""[LogFilterUI] UI time = "" + time);
					break;
				case PREV :
					/*
					 * Move back. The previous step should still be valid.
					 */
					go(-1);
					break;
				case FINISHED :
					/*
					 * Return the filtered log of the final step.
					 */
					return mySteps[currentStep].getLog();
				default :
					/*
					 * Should not occur.
					 */
					return null;
			}
		}
	}

	/**
	 * Move the wizard in either direction.
	 * 
	 * @param direction
	 *            The direction, use 1 for forward and -1 for backward.
	 * @return The next step.
	 */
	private int go(int direction) {
		currentStep += direction;
		if ((currentStep >= 0) && (currentStep < nofSteps)) {
			if (mySteps[currentStep].precondition()) {
				return currentStep;
			} else {
				return go(direction);
			}
		}
		return currentStep;
	}

	/*
	 * Now follows a section containing some graphical improvements. Not
	 * important for the logic.
	 */
	protected Color colorBg = new Color(140, 140, 140);
	protected Color colorOuterBg = new Color(100, 100, 100);
	protected Color colorListBg = new Color(60, 60, 60);
	protected Color colorListBgSelected = new Color(10, 90, 10);
	protected Color colorListFg = new Color(200, 200, 200, 160);
	protected Color colorListFgSelected = new Color(230, 230, 230, 200);
	protected Color colorListEnclosureBg = new Color(150, 150, 150);
	protected Color colorListHeader = new Color(10, 10, 10);
	protected Color colorListDescription = new Color(60, 60, 60);

	protected JComponent configureList(JList<Object> list, String title, String description) {
		list.setFont(list.getFont().deriveFont(13f));
		list.setBackground(colorListBg);
		list.setForeground(colorListFg);
		list.setSelectionBackground(colorListBgSelected);
		list.setSelectionForeground(colorListFgSelected);
		list.setFont(list.getFont().deriveFont(12f));
		list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		list.setSelectionInterval(0, list.getModel().getSize() - 1);
		return configureAnyScrollable(list, title, description);
	}

	protected JComponent configureAnyScrollable(JComponent scrollable, String title, String description) {
		RoundedPanel enclosure = new RoundedPanel(10, 5, 5);
		enclosure.setBackground(colorListEnclosureBg);
		enclosure.setLayout(new BoxLayout(enclosure, BoxLayout.Y_AXIS));
		JLabel headerLabel = new JLabel(title);
		headerLabel.setOpaque(false);
		headerLabel.setForeground(colorListHeader);
		headerLabel.setFont(headerLabel.getFont().deriveFont(14f));
		JLabel descriptionLabel = new JLabel(""<html>"" + description + ""</html>"");
		descriptionLabel.setOpaque(false);
		descriptionLabel.setForeground(colorListDescription);
		descriptionLabel.setFont(descriptionLabel.getFont().deriveFont(11f));
		JScrollPane listScrollPane = new JScrollPane(scrollable);
		listScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		listScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		listScrollPane.setViewportBorder(BorderFactory.createLineBorder(new Color(40, 40, 40)));
		listScrollPane.setBorder(BorderFactory.createEmptyBorder());
		JScrollBar vBar = listScrollPane.getVerticalScrollBar();
		vBar.setUI(new SlickerScrollBarUI(vBar, colorListEnclosureBg, new Color(30, 30, 30), new Color(80, 80, 80), 4,
				12));
		enclosure.add(packLeftAligned(headerLabel));
		enclosure.add(Box.createVerticalStrut(3));
		enclosure.add(packLeftAligned(descriptionLabel));
		enclosure.add(Box.createVerticalStrut(5));
		enclosure.add(listScrollPane);
		return enclosure;
	}

	protected JComponent packLeftAligned(JComponent component) {
		JPanel packed = new JPanel();
		packed.setOpaque(false);
		packed.setBorder(BorderFactory.createEmptyBorder());
		packed.setLayout(new BoxLayout(packed, BoxLayout.X_AXIS));
		packed.add(component);
		packed.add(Box.createHorizontalGlue());
		return packed;
	}

	/**
	 * Basic step class. Every step has a log, a way to check whether it should
	 * be displayed, a way to get the filtered log, and a way to initialize it
	 * with some log.
	 * 
	 * @author hverbeek
	 * 
	 */
	private abstract class myStep extends JPanel {
		/**
		 * 
		 */
		private static final long serialVersionUID = 6125158693462475923L;
		/**
		 * The log to filter using this step.
		 */
		protected XLog log;

		public void setLog(XLog log) {
			this.log = log;
		}

		/**
		 * Returns whether this step should be displayed. If not, it should be
		 * skipped.
		 * 
		 * @return Whether to display this step.
		 */
		public abstract boolean precondition();

		/**
		 * Returns the filtered log.
		 * 
		 * @return The filtered log.
		 */
		public abstract XLog getLog();

		/**
		 * Initializes the step given the log to filter.
		 * 
		 * @param log
		 *            The log to filter.
		 */
		public abstract void initComponents(XLog log);
	}

	private class EventClassComparator implements Comparator<XEventClass> {

		public int compare(XEventClass o1, XEventClass o2) {
			// TODO Auto-generated method stub
			return (new AlphanumComparator().compare(o1.toString(), o2.toString()));
		}
	}

	/**
	 * Simple step class. All steps belong to this class, but in the future
	 * additional (non-simple) steps may be added.
	 * 
	 * @author hverbeek
	 * 
	 */
	private abstract class SimpleStep extends myStep {
		/**
		 * 
		 */
		private static final long serialVersionUID = 2288113155552125657L;
		/**
		 * The classifier to use for the filtering.
		 */
		protected XEventClassifier classifier;
		/**
		 * The log info obtained for this classifier.
		 */
		private XLogInfo logInfo;
		/**
		 * The advanced selection list used in step 1.
		 */
		protected SlickerEventTypeConfiguration cfg;
		/**
		 * The simple selection list used in steps 2,3 , and 4.
		 */
		protected JComponent comp;
		protected JList<Object> list;
		/**
		 * Whether to use the advanced (true) or simple (false) selection list.
		 */
		private final boolean useCfg;
		/**
		 * The heading to display for the simple selection list.
		 */
		private final String heading;
		/**
		 * The text to display for the simple selection list.
		 */
		private final String text;
		/**
		 * Whether to use all events, only start events, or only end events.
		 */
		private final Mode mode;
		/**
		 * The event classes found.
		 */
		private XEventClasses eventClasses;
		private List<XEventClass> sortedEventClasses;
		/**
		 * The slider used for the simple selection list.
		 */
		private NiceSlider slider;

		/**
		 * Creates the simple step.
		 * 
		 * @param classifier
		 *            The classifier to use in this step.
		 * @param mode
		 *            The mode to use (all events, start events, or end events).
		 * @param useCfg
		 *            Whether to use the advanced list or the simple list.
		 * @param heading
		 *            The heading to use, if simple list (null otherwise).
		 * @param text
		 *            The text to use, if simple list (null otherwise).
		 */
		public SimpleStep(XEventClassifier classifier, Mode mode, boolean useCfg, String heading, String text) {
			this.classifier = classifier;
			this.mode = mode;
			this.useCfg = useCfg;
			this.heading = heading;
			this.text = text;
			cfg = null;
			comp = null;
			slider = null;
		}

		/**
		 * All steps may always be displayed.
		 */
		public boolean precondition() {
			// TODO Auto-generated method stub
			return true;
		}

		/**
		 * Initializes the component, given the log to filter.
		 */
		public void initComponents(XLog log) {
			setLog(log);
			double size[][] = { { 80, TableLayoutConstants.FILL }, { TableLayoutConstants.FILL, 30, 30 } };
			setLayout(new TableLayout(size));
			add(new JLabel(""Log name:""), ""0, 2"");
			final ProMTextField textField = new ProMTextField(name);
			textField.setPreferredSize(new Dimension(100, 25));
			this.add(textField, ""1, 2"");
			textField.addKeyListener(new KeyListener() {

				public void keyTyped(KeyEvent e) {
					name = textField.getText();
				}

				public void keyPressed(KeyEvent e) {
					name = textField.getText();
				}

				public void keyReleased(KeyEvent e) {
					name = textField.getText();
				}
				
			});

			/**
			 * Initialize the event classes.
			 */
			eventClasses = null;
			switch (mode) {
				case ALLEVENTS :
					logInfo = XLogInfoImpl.create(log, classifier);
					eventClasses = logInfo.getEventClasses(classifier);
					break;
				case STARTEVENTS :
					eventClasses = new XEventClasses(classifier);
					for (XTrace trace : log) {
						if (!trace.isEmpty()) {
							eventClasses.register(trace.get(0));
						}
					}
					break;
				case ENDEVENTS :
					eventClasses = new XEventClasses(classifier);
					for (XTrace trace : log) {
						if (!trace.isEmpty()) {
							eventClasses.register(trace.get(trace.size() - 1));
						}
					}
					break;
				default :
			}
			/**
			 * Initialize the selection list.
			 */
			if (eventClasses != null) {
				if (useCfg) {
					if (cfg != null) {
						this.remove(cfg);
					}
					cfg = new SlickerEventTypeConfiguration(eventClasses.getClasses().toArray());
					this.add(cfg, ""0, 0, 1, 0"");
				} else {
					if (comp != null) {
						this.remove(comp);
					}
					sortedEventClasses = new ArrayList<XEventClass>(eventClasses.getClasses());
					Collections.sort(sortedEventClasses, new EventClassComparator());
					list = new JList<Object>(sortedEventClasses.toArray());
					comp = configureList(list, heading, text);
					this.add(comp, ""0, 0, 1, 0"");
				}
			}
			/**
			 * Initialize the slider, if necessary.
			 */
			if (!useCfg) {
				if (slider != null) {
					this.remove(slider);
				}
				slider = SlickerFactory.instance().createNiceIntegerSlider(""Select top percentage"", 0, 100, 80,
						Orientation.HORIZONTAL);
				ChangeListener listener = new ChangeListener() {

					public void stateChanged(ChangeEvent e) {
						// TODO Auto-generated method stub
						int percentage = slider.getSlider().getValue();
						int size = 0;
						TreeSet<Integer> eventSizes = new TreeSet<Integer>();
						for (XEventClass event : sortedEventClasses) {
							size += event.size();
							eventSizes.add(event.size());
						}
						int treshold = size * percentage;
						int value = 0;
						list.clearSelection();
						while (100 * value < treshold) {
							int eventSize = eventSizes.last();
							eventSizes.remove(eventSize);
							int index = 0;
							for (XEventClass event : sortedEventClasses) {
								if (event.size() == eventSize) {
									value += eventSize;
									list.addSelectionInterval(index, index);
								}
								index++;
							}
						}
					}

				};
				slider.addChangeListener(listener);
				listener.stateChanged(null);
				this.add(slider, ""0, 1, 1, 1"");
			}
		}
	}

	private class EventTypeStep extends SimpleStep {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1266880064535493470L;

		public EventTypeStep() {
			super(XLogInfoImpl.LIFECYCLE_TRANSITION_CLASSIFIER, Mode.ALLEVENTS, true, null, null);
		}

		public XLog getLog() {
			String[] toRemove = cfg.getFilteredEventTypes(EventTypeAction.REMOVE);
			String[] toSkip = cfg.getFilteredEventTypes(EventTypeAction.SKIP_INSTANCE);
			//			PluginContext filterContext = context.createChildContext(""Default Log Filter"");
			DefaultLogFilter filter = new DefaultLogFilter();
			return filter.filter(null, log, toRemove, toSkip);

			/*
			 * try { return
			 * context.tryToFindOrConstructFirstNamedObject(XLog.class,
			 * ""Default Log Filter"", Connection.class, """", log, toRemove,
			 * toSkip); } catch (ConnectionCannotBeObtained e) { // TODO
			 * Auto-generated catch block e.printStackTrace(); }
			 */
			/*
			 * Set<Pair<Integer, PluginParameterBinding>> plugins =
			 * context.getPluginManager().find(Plugin.class, XLog.class,
			 * context.getPluginContextType(), true, true, true, XLog.class,
			 * String[].class, String[].class); for (Pair<Integer,
			 * PluginParameterBinding> plugin: plugins) { if
			 * (plugin.getSecond().
			 * getPlugin().getName().equals(""Default Log Filter"")) {
			 * UIPluginContext subContext =
			 * context.createChildContext(""Default Log Filter"");
			 * PluginExecutionResult result =
			 * plugin.getSecond().invoke(subContext, log, toRemove, toSkip); try
			 * { result.synchronize(); } catch (CancellationException e) { //
			 * TODO Auto-generated catch block e.printStackTrace(); } catch
			 * (ExecutionException e) { // TODO Auto-generated catch block
			 * e.printStackTrace(); } catch (InterruptedException e) { // TODO
			 * Auto-generated catch block e.printStackTrace(); } return
			 * result.getResult(plugin.getFirst()); } } return log;
			 */
		}
	}

	private class StartEventStep extends SimpleStep {
		/**
		 * 
		 */
		private static final long serialVersionUID = 8547494758416001029L;

		public StartEventStep() {
			super(XLogInfoImpl.STANDARD_CLASSIFIER, Mode.STARTEVENTS, false, ""Start events"",
					""Only instances starting with a green event will be used."");
		}

		public XLog getLog() {
			// TODO Auto-generated method stub
			List<Object> selectedObjects = list.getSelectedValuesList();
			String[] startIds = new String[selectedObjects.size()];
			for (int i = 0; i < selectedObjects.size(); i++) {
				startIds[i] = selectedObjects.get(i).toString();
			}
			//			PluginContext filterContext = context.createChildContext(""Start Event Log Filter"");
			StartEventLogFilter filter = new StartEventLogFilter();
			return filter.filterWithClassifier(null, log, classifier, startIds);

			/*
			 * try { return
			 * context.tryToFindOrConstructFirstNamedObject(XLog.class,
			 * ""Start Event Log Filter"", Connection.class, """", log, classifier,
			 * startIds); } catch (ConnectionCannotBeObtained e) { // TODO
			 * Auto-generated catch block e.printStackTrace(); } return log;
			 */
		}
	}

	private class EndEventStep extends SimpleStep {
		/**
		 * 
		 */
		private static final long serialVersionUID = 4750780067360884545L;

		public EndEventStep() {
			super(XLogInfoImpl.STANDARD_CLASSIFIER, Mode.ENDEVENTS, false, ""End events"",
					""Only instances ending with a green event will be used."");
		}

		public XLog getLog() {
			// TODO Auto-generated method stub
			List<Object> selectedObjects = list.getSelectedValuesList();
			String[] endIds = new String[selectedObjects.size()];
			for (int i = 0; i < selectedObjects.size(); i++) {
				endIds[i] = selectedObjects.get(i).toString();
			}
			//			PluginContext filterContext = context.createChildContext(""Final Event Log Filter"");
			FinalEventLogFilter filter = new FinalEventLogFilter();
			return filter.filterWithClassifier(null, log, classifier, endIds);

			/*
			 * try { return
			 * context.tryToFindOrConstructFirstNamedObject(XLog.class,
			 * ""Final Event Log Filter"", Connection.class, """", log, classifier,
			 * endIds); } catch (ConnectionCannotBeObtained e) { // TODO
			 * Auto-generated catch block e.printStackTrace(); } return log;
			 */
		}
	}

	private class EventFilterStep extends SimpleStep {
		/**
		 * 
		 */
		private static final long serialVersionUID = 2295002325162718535L;

		public EventFilterStep() {
			super(XLogInfoImpl.STANDARD_CLASSIFIER, Mode.ALLEVENTS, false, ""Event filter"",
					""Only green events will be used."");
		}

		public XLog getLog() {
			// TODO Auto-generated method stub
			List<Object> selectedObjects = list.getSelectedValuesList();
			String[] selectedIds = new String[selectedObjects.size()];
			for (int i = 0; i < selectedObjects.size(); i++) {
				selectedIds[i] = selectedObjects.get(i).toString();
			}
			//			PluginContext filterContext = context.createChildContext(""Event Log Filter"");
			EventLogFilter filter = new EventLogFilter();
			return filter.filterWithClassifier(null, log, classifier, selectedIds);

			/*
			 * try { return
			 * context.tryToFindOrConstructFirstNamedObject(XLog.class,
			 * ""Event Log Filter"", Connection.class, """", log, eventClasses,
			 * selectedClasses); } catch (ConnectionCannotBeObtained e) { //
			 * TODO Auto-generated catch block e.printStackTrace(); } return
			 * log;
			 */
		}

	}
}
"
SlickerEventTypeConfiguration.java,log-6.9.380,"package org.processmining.plugins.log.logfilters.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import com.fluxicon.slickerbox.components.GradientPanel;

public class SlickerEventTypeConfiguration extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 52715433965263148L;
	protected static Color colorText = new Color(255, 255, 255, 160);
	protected static Color colorKeep1 = new Color(10, 90, 1);
	protected static Color colorKeep2 = new Color(20, 140, 20);
	protected static Color colorRemove1 = new Color(90, 60, 10);
	protected static Color colorRemove2 = new Color(140, 100, 20);
	protected static Color colorSkipInstance1 = new Color(90, 10, 10);
	protected static Color colorSkipInstance2 = new Color(140, 20, 20);

	public enum EventTypeAction {
		KEEP, REMOVE, SKIP_INSTANCE;
	}

	protected Object[] objects;
	protected EventTypeConfigurationItem[] configurationItems;
	protected ChangeListener updateListener = null;

	public SlickerEventTypeConfiguration(Object[] objects) {
		this.objects = objects;
		setBackground(new Color(60, 60, 60));
		setMinimumSize(new Dimension(70, 40));
		setMaximumSize(new Dimension(1000, 5000));
		setBorder(BorderFactory.createEmptyBorder());
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		configurationItems = new EventTypeConfigurationItem[objects.length];
		int height = 0;
		for (int i = 0; i < objects.length; i++) {
			configurationItems[i] = new EventTypeConfigurationItem(objects[i]);
			this.add(configurationItems[i]);
			height += configurationItems[i].getPreferredSize().height + 2;
		}
		this.add(Box.createVerticalGlue());
		setPreferredSize(new Dimension(120, height));
		revalidate();
	}

	public void setUpdateListener(ChangeListener updateListener) {
		this.updateListener = updateListener;
	}

	public String[] getFilteredEventTypes(EventTypeAction action) {
		ArrayList<Object> types = new ArrayList<Object>();
		for (EventTypeConfigurationItem item : configurationItems) {
			if (item.getAction() == action) {
				types.add(item.getObject().toString());
			}
		}
		return types.toArray(new String[0]);
	}

	protected class EventTypeConfigurationItem extends GradientPanel {

		/**
		 * 
		 */
		private static final long serialVersionUID = -7596401396201481445L;
		protected Object object;
		protected EventTypeAction action;
		protected JLabel actionLabel;
		protected JLabel nameLabel;

		public EventTypeConfigurationItem(Object object) {
			super(colorKeep2, colorKeep1);
			setMinimumSize(new Dimension(70, 28));
			setMaximumSize(new Dimension(500, 28));
			setPreferredSize(new Dimension(120, 28));
			setBorder(BorderFactory.createEmptyBorder(4, 10, 4, 10));
			setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
			this.object = object;
			nameLabel = new JLabel(object.toString());
			nameLabel.setOpaque(false);
			nameLabel.setForeground(colorText);
			nameLabel.setVerticalAlignment(SwingConstants.CENTER);
			nameLabel.setFont(nameLabel.getFont().deriveFont(13f));
			actionLabel = new JLabel(""change_me"");
			actionLabel.setOpaque(false);
			actionLabel.setForeground(colorText);
			actionLabel.setVerticalAlignment(SwingConstants.CENTER);
			actionLabel.setFont(actionLabel.getFont().deriveFont(12f).deriveFont(Font.ITALIC));
			if (object.toString().equals(""reassign"") || object.toString().equals(""suspend"")
					|| object.toString().equals(""resume"")) {
				setAction(EventTypeAction.REMOVE);
			} else if (object.toString().equals(""withdraw"") || object.toString().equals(""ate_abort"")
					|| object.toString().equals(""pi_abort"")) {
				setAction(EventTypeAction.SKIP_INSTANCE);
			} else {
				// schedule, assign, start, complete, autoskip, manualskip, rest
				setAction(EventTypeAction.KEEP);
			}
			this.add(nameLabel);
			this.add(Box.createHorizontalGlue());
			this.add(actionLabel);
			addMouseListener(new MouseListener() {
				public void mouseClicked(MouseEvent arg0) {
					if (action == EventTypeAction.KEEP) {
						setAction(EventTypeAction.REMOVE);
					} else if (action == EventTypeAction.REMOVE) {
						setAction(EventTypeAction.SKIP_INSTANCE);
					} else if (action == EventTypeAction.SKIP_INSTANCE) {
						setAction(EventTypeAction.KEEP);
					}
					// notify update listener
					if (updateListener != null) {
						updateListener.stateChanged(new ChangeEvent(this));
					}
				}

				public void mouseEntered(MouseEvent arg0) { /* ignore */
				}

				public void mouseExited(MouseEvent arg0) { /* ignore */
				}

				public void mousePressed(MouseEvent arg0) { /* ignore */
				}

				public void mouseReleased(MouseEvent arg0) { /* ignore */
				}
			});
		}

		public EventTypeAction getAction() {
			return action;
		}

		public Object getObject() {
			return object;
		}

		public void setAction(EventTypeAction action) {
			this.action = action;
			if (action == EventTypeAction.KEEP) {
				actionLabel.setText(""(keep)"");
				super.setColors(colorKeep2, colorKeep1);
			} else if (action == EventTypeAction.REMOVE) {
				actionLabel.setText(""(remove)"");
				super.setColors(colorRemove2, colorRemove1);
			} else if (action == EventTypeAction.SKIP_INSTANCE) {
				actionLabel.setText(""(discard instance)"");
				super.setColors(colorSkipInstance2, colorSkipInstance1);
			}
		}
	}
}
"
XEventCondition.java,log-6.9.380,"package org.processmining.plugins.log.logfilters;

import org.deckfour.xes.model.XEvent;

/**
 * Interface used for easy filtering of XLog object. Used by LogFilter.
 * 
 * @author bfvdonge
 * 
 */
public interface XEventCondition {

	/**
	 * When filtering, this method is called for each XEvent in the log. The
	 * event should not be edited (use the XEventEditor for that). Instead, this
	 * method should test whether the event should be kept by a given filter or
	 * not.
	 * 
	 * @param event
	 *            The event that is currently being considered by the calling
	 *            filter.
	 * @return true if the event should be kept, false if the given event should
	 *         be removed.
	 */
	public boolean keepEvent(XEvent event);
}
"
XEventEditor.java,log-6.9.380,"package org.processmining.plugins.log.logfilters;

import org.deckfour.xes.model.XEvent;

/**
 * Interface used for easy filtering of XLog object. Used by LogFilter.
 * 
 * @author bfvdonge
 * 
 */
public interface XEventEditor {

	/**
	 * When filtering, this method is called for each XEvent in the log. The
	 * event can be edited, or a new one can be returned. If null is returned,
	 * the calling filter will remove the event from the log. If a new XEvent
	 * object is returned, the called filter will replace the old event with the
	 * new event.
	 * 
	 * @param event
	 *            The event that is currently being considered by the calling
	 *            filter.
	 * @return The edited event. If null is returned, then the event is removed.
	 *         If a new XEvent object is returned, the event is replaced.
	 * 
	 */
	public XEvent editEvent(XEvent event);

}
"
XTraceCondition.java,log-6.9.380,"package org.processmining.plugins.log.logfilters;

import org.deckfour.xes.model.XTrace;

/**
 * Interface used for easy filtering of XLog object. Used by LogFilter.
 * 
 * @author bfvdonge
 * 
 */
public interface XTraceCondition {

	/**
	 * When filtering, this method is called for each XTrace in the log. The
	 * trace should not be edited (use the XTraceEditor for that). Instead, this
	 * method should test whether the trace should be kept by a given filter or
	 * not.
	 * 
	 * @param trace
	 *            The trace that is currently being considered by the calling
	 *            filter. Note that it can be assumed that
	 *            trace.isEmpty()==false
	 * @return true if the trace should be kept, false if the given trace should
	 *         be removed.
	 */
	public boolean keepTrace(XTrace trace);
}
"
XTraceEditor.java,log-6.9.380,"package org.processmining.plugins.log.logfilters;

import org.deckfour.xes.model.XTrace;

/**
 * Interface used for easy filtering of XLog object. Used by LogFilter.
 * 
 * @author bfvdonge
 * 
 */
public interface XTraceEditor {

	/**
	 * When filtering, this method is called for each XTrace in the log. The
	 * trace can be edited, or a new one can be returned. If null is returned,
	 * or an empty trace is returned, the calling filter will remove the trace
	 * from the log. No new XTrace objects should be returned.
	 * 
	 * @param trace
	 *            The trace that is currently being considered by the calling
	 *            filter. Note that it can be assumed that
	 *            trace.isEmpty()==false
	 * @return The edited trace. If null, or an empty trace is returned, then
	 *         the trace is removed. No new trace objects should be returned.
	 */
	public XTrace editTrace(XTrace trace);

}
"
OpenBufferedLogFilePlugin.java,log-6.9.380,"package org.processmining.plugins.log;

import java.io.InputStream;

import org.deckfour.xes.factory.XFactoryBufferedImpl;
import org.processmining.framework.plugin.PluginContext;

//@Plugin(name = ""Open XES Log File (Buffered)"", parameterLabels = { ""Filename"" }, returnLabels = { ""Log (single process)"" }, returnTypes = { XLog.class })
//@UIImportPlugin(description = ""ProM log files (Buffered)"", extensions = { ""mxml"", ""xml"", ""gz"", ""zip"", ""xes"", ""xez"" })
public class OpenBufferedLogFilePlugin extends OpenLogFilePlugin {
	protected Object importFromStream(PluginContext context, InputStream input, String filename, long fileSizeInBytes)
	throws Exception {
		return importFromStream(context, input, filename, fileSizeInBytes, new XFactoryBufferedImpl());
	}
}
"
OpenLogFilePlugin.java,log-6.9.380,"package org.processmining.plugins.log;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.security.InvalidParameterException;
import java.util.Collection;
import java.util.Enumeration;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.in.XMxmlParser;
import org.deckfour.xes.in.XParser;
import org.deckfour.xes.in.XesXmlParser;
import org.deckfour.xes.model.XLog;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;

@Plugin(name = ""Open XES Log File"", parameterLabels = { ""Filename"" }, returnLabels = {
		""Log (single process)"" }, returnTypes = { XLog.class })
//@UIImportPlugin(description = ""ProM log files"", extensions = { ""mxml"", ""xml"", ""gz"", ""zip"", ""xes"", ""xez"" })
public class OpenLogFilePlugin extends AbstractImportPlugin {

	/**
	 * Holds zip file, if zip file is open.
	 */
	private ZipFile zipFile;
	/**
	 * Holds the name of the zipped file, if input is zip file.
	 */
	private String zipName;

	public OpenLogFilePlugin() {
		zipFile = null;
		zipName = null;
	}

	protected Object importFromStream(PluginContext context, InputStream input, String filename, long fileSizeInBytes,
			XFactory factory) throws Exception {
		context.getFutureResult(0).setLabel(filename);
		//	System.out.println(""Open file"");
		XParser parser;
		if (zipName != null) {
			/*
			 * Stream contains a zip file. Use the name of the zipped file, not
			 * of the zip file itself.
			 */
			filename = zipName;
		}
		/*
		 * Only use MXML parser if the file has th eproper extesnion. 
		 * In all other cases, use the XES parser.
		 */
		if (filename.toLowerCase().endsWith("".mxml"") || filename.toLowerCase().endsWith("".mxml.gz"")) {
			parser = new XMxmlParser(factory);
		} else {
			parser = new XesXmlParser(factory);
		}
		Collection<XLog> logs = null;
		Exception firstException = null;
		String errorMessage = """";
		try {
			logs = parser.parse(new XContextMonitoredInputStream(input, fileSizeInBytes, context.getProgress()));
		} catch (Exception e) {
			logs = null;
			firstException = e;
			errorMessage = errorMessage + e;
		}
//		if (logs == null || logs.isEmpty()) {
//			// try any other parser
//			for (XParser p : XParserRegistry.instance().getAvailable()) {
//				if (p == parser) {
//					continue;
//				}
//				try {
//					logs = p.parse(new XContextMonitoredInputStream(input, fileSizeInBytes, context.getProgress()));
//					if (logs.size() > 0) {
//						break;
//					}
//				} catch (Exception e1) {
//					// ignore and move on.
//					logs = null;
//					errorMessage = errorMessage + "" ["" + p.name() + "":"" + e1 + ""]"";
//				}
//			}
//		}

		// Log file has been read from the stream. The zip file (if present) can now be closed.
		if (zipFile != null) {
			zipFile.close();
			zipFile = null;
		}

		// log sanity checks;
		// notify user if the log is awkward / does miss crucial information
		if (logs == null) {
			//			context.getFutureResult(0).cancel(false);
			throw new Exception(""Could not open log file, possible cause: ""
					/* + errorMessage, */ + firstException);
		}
		if (logs.size() == 0) {
			//			context.getFutureResult(0).cancel(false);
			throw new Exception(""No processes contained in log!"");
		}

		XLog log = logs.iterator().next();
		if (XConceptExtension.instance().extractName(log) == null) {
			/*
			 * Log name not set. Create a default log name.
			 */
			XConceptExtension.instance().assignName(log, ""Anonymous log imported from "" + filename);
		}

		//		if (log.isEmpty()) {
		//			throw new Exception(""No process instances contained in log!"");
		//		}

		/*
		 * Set the log name as the name of the provided object.
		 */
		if (context != null) {
			context.getFutureResult(0).setLabel(XConceptExtension.instance().extractName(log));
		}

		return log;

	}

	/**
	 * This method returns an inputStream for a file. Note that the default
	 * implementation returns ""new FileInputStream(file);""
	 * 
	 * @param file
	 * @return
	 * @throws FileNotFoundException
	 */
	@Override
	protected InputStream getInputStream(File file) throws Exception {
		FileInputStream stream = new FileInputStream(file);
		if (file.getName().endsWith("".gz"") || file.getName().endsWith("".xez"")) {
			return new GZIPInputStream(stream);
		}
		if (file.getName().endsWith("".zip"")) {
			// Open zip file.
			zipFile = new ZipFile(file);
			Enumeration<? extends ZipEntry> entries = zipFile.entries();
			ZipEntry zipEntry = entries.nextElement();
			if (entries.hasMoreElements()) {
				throw new InvalidParameterException(""Zipped log files should not contain more than one entry."");
			}
			/*
			 * Store the name of the zipped file. This will override the
			 * provided filename when importing.
			 */
			zipName = zipEntry.getName();
			// Return stream of only entry in zip file.
			// Do not yet close zip file, as the retruend stream still needs to be read.
			return zipFile.getInputStream(zipEntry);
		}
		return stream;
	}

	protected Object importFromStream(PluginContext context, InputStream input, String filename, long fileSizeInBytes)
			throws Exception {
		// TODO Auto-generated method stub
		return importFromStream(context, input, filename, fileSizeInBytes,
				XFactoryRegistry.instance().currentDefault());
	}

}
"
OpenNaiveLogFilePlugin.java,log-6.9.380,"package org.processmining.plugins.log;

import java.io.InputStream;

import org.deckfour.xes.factory.XFactoryNaiveImpl;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;

@Plugin(name = ""Open XES Log File (Naive)"", level = PluginLevel.PeerReviewed, parameterLabels = { ""Filename"" }, returnLabels = { ""Log (single process)"" }, returnTypes = { XLog.class })
@UIImportPlugin(description = ""ProM log files (Naive)"", extensions = { ""mxml"", ""xml"", ""gz"", ""zip"", ""xes"", ""xez"" })
public class OpenNaiveLogFilePlugin extends OpenLogFilePlugin {
	protected Object importFromStream(PluginContext context, InputStream input, String filename, long fileSizeInBytes)
	throws Exception {
		return importFromStream(context, input, filename, fileSizeInBytes, new XFactoryNaiveImpl());
	}
}
"
ReSortLog.java,log-6.9.380,"package org.processmining.plugins.log;

import java.util.Date;

import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;

public class ReSortLog {

	@Plugin(name = ""Resort Log Based on Time"", parameterLabels = { ""log"" }, returnLabels = { ""log"" }, returnTypes = { XLog.class }, userAccessible = true)
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""B.F. van Dongen"", email = ""b.f.v.dongen@tue.nl"")
	public static XLog removeEdgePoints(PluginContext context, XLog log) {

		XLog result = XFactoryRegistry.instance().currentDefault().createLog(log.getAttributes());

		for (XTrace t : log) {
			XTrace copy = XFactoryRegistry.instance().currentDefault().createTrace(t.getAttributes());
			result.add(copy);

			for (XEvent e : t) {
				XEvent copyEvent = XFactoryRegistry.instance().currentDefault().createEvent(e.getAttributes());
				Date insertAt = XTimeExtension.instance().extractTimestamp(e);
				if (insertAt == null || copy.size() == 0) {
					copy.add(copyEvent);
					continue;
				}
				for (int i = copy.size() - 1; i >= 0; i--) {
					XEvent e2 = copy.get(i);
					Date d2 = XTimeExtension.instance().extractTimestamp(e2);
					if (d2 == null || d2.before(insertAt)) {
						copy.add(i+1, copyEvent);
						break;
					}
					if (i == 0) {
						copy.add(0, copyEvent);
					}
				}

			}

		}

		return result;

	}
}
"
TraceReverser.java,log-6.9.380,"package org.processmining.plugins.log.reverse;

import java.util.Date;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.model.impl.XTraceImpl;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;

/**
 * Reverses all events per trace (leaving the timestamps as they are)
 * 
 * @author T. van der Wiel
 * 
 */
@Plugin(name = ""Reverse Log"", parameterLabels = { ""Log"" }, returnLabels = { ""Reversed log"" }, returnTypes = { XLog.class }, userAccessible = true)
public class TraceReverser {
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""T. van der Wiel"", email = ""t.v.d.wiel@student.tue.nl"")
	@PluginVariant(requiredParameterLabels = { 0 }, variantLabel = ""Reverse Log"")
	public XLog reverse(UIPluginContext context, XLog log) {
		context.getFutureResult(0).setLabel(""Reversed "" + XConceptExtension.instance().extractName(log));
		XTimeExtension te = XTimeExtension.instance();
		XLog revLog = (XLog) log.clone();
		Date first = getFirstDate(log), last = getLastDate(log);
		revLog.clear();
		XConceptExtension.instance().assignName(revLog, ""Reversed "" + XConceptExtension.instance().extractName(log));
		for (XTrace t : log) {
			XTrace revT = new XTraceImpl(t.getAttributes());
			for (int i = t.size() - 1; i >= 0; i--) {
				XEvent e = (XEvent) t.get(i).clone();
				te.assignTimestamp(e, reverseTime(first, te.extractTimestamp(e), last));
				revT.add(e);
			}
			revLog.add(revT);
		}
		return revLog;
	}

	private Date reverseTime(Date first, Date date, Date last) {
		long f = first.getTime(), v = date.getTime(), l = last.getTime();
		return new Date((l - v) + f);
	}

	private Date getLastDate(XLog log) {
		XTimeExtension te = XTimeExtension.instance();
		Date last = te.extractTimestamp(log.get(0).get(0));
		for (XTrace t : log) {
			for (XEvent e : t) {
				Date current = te.extractTimestamp(e);
				if (current.after(last)) {
					last = current;
				}
			}
		}
		return last;
	}

	private Date getFirstDate(XLog log) {
		XTimeExtension te = XTimeExtension.instance();
		Date last = te.extractTimestamp(log.get(0).get(0));
		for (XTrace t : log) {
			for (XEvent e : t) {
				Date current = te.extractTimestamp(e);
				if (current.before(last)) {
					last = current;
				}
			}
		}
		return last;
	}
}
"
XContextMonitoredInputStream.java,log-6.9.380,"package org.processmining.plugins.log;

import java.io.InputStream;

import org.processmining.framework.plugin.Progress;
import org.processmining.framework.util.progress.XMonitoredInputStream;
import org.processmining.framework.util.progress.XProgressListener;

public class XContextMonitoredInputStream extends XMonitoredInputStream {

	public XContextMonitoredInputStream(InputStream input, long fileSizeInBytes, final Progress progress) {
		super(input, fileSizeInBytes, new XProgressListener() {

			public void updateProgress(int p, int max) {
				if (progress.isIndeterminate() && (max > 0)) {
					progress.setMinimum(0);
					progress.setMaximum(max);
					progress.setIndeterminate(false);
				} else if (progress.getMaximum() != max) {
					progress.setMaximum(max);
				}
				progress.setValue(p);
			}

			public boolean isAborted() {
				return progress.isCancelled();
			}

		});
	}

}
"
AddSt.java,log-6.9.380,"package org.processmining.plugins.loginsertstart;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import javax.swing.JPanel;

import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.Pair;

/**
 * Add Start Events
 * 
 * The main class
 * 
 * @author jnakatumba
 * 
 */

public class AddSt {

	private ObtainDurationsWithoutStart withoutStart;
	private ObtainDurationWithStart withStart;
	private AddStMain addStart;
	private AddStSecPanel inPanel;

	private BoxandWhiskerPlot graphing;
	private List<Pair<String, Long>> resDurationList;
	private Set<String> resNamesList;
	private final ArrayList<Date> startDatesList;
	private int addCounter, removeCounter;
	private String displayChoice, outlierChoice;

	private JPanel jPanel;

	private final UIPluginContext context;
	private XLog log;
	private XLog changedLog;

	public AddSt(final UIPluginContext context, XLog log) {
		this.context = context;
		this.log = log;

		jPanel = new JPanel();
		resNamesList = new TreeSet<String>();
		startDatesList = new ArrayList<Date>();
	}

	public AddStVisualizer mine() {

		context.getProgress().setMinimum(0);
		context.getProgress().setIndeterminate(false);

		inPanel = new AddStSecPanel(context);
		jPanel = inPanel.getPanel();

		/**
		 * Display the first Panel
		 */
		context.showConfiguration(""Insert Missing Events"", jPanel);
		displayChoice = inPanel.getDisplayChoice();

		/**
		 * Check if the log has any start events
		 */
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				if (XLifecycleExtension.instance().extractTransition(event).equals(""start"")) {
					Date startDate = XTimeExtension.instance().extractTimestamp(event);
					startDatesList.add(startDate);

				}
			}
		}

		context.getProgress().inc();
		/**
		 * if the log does not have any start events
		 */
		if (startDatesList.size() == 0) {
			/**
			 * Obtain the durations per activity executed for each resource
			 */
			withoutStart = new ObtainDurationsWithoutStart(log, displayChoice);
			resDurationList = withoutStart.getResDateDetails();
			resNamesList = withoutStart.getResNames();
			/**
			 * Construct a Box-and-Whisker Graph showing the durations per
			 * resource and any outliers
			 */

			graphing = new BoxandWhiskerPlot(context, resDurationList, resNamesList);
			outlierChoice = graphing.getOutlierRange();

			if (outlierChoice != null) {

				/**
				 * Add the start events to the log
				 */
				addStart = new AddStMain(context, log, displayChoice, outlierChoice);
				addCounter = addStart.getAddCounter();
				removeCounter = addStart.getRemoveCounter();
				context.log(""The Number of Start Events Added is: "" + addCounter);
				context.log(""The Number of Events Removed is: "" + removeCounter);
				/**
				 * Get the edited log
				 */
				log = addStart.getLog();
			} else {
				context.getFutureResult(0).cancel(true);

			}

			changedLog = addStart.getLog();
			/**
			 * if the log has some start events
			 */
		} else {
			withStart = new ObtainDurationWithStart(context, log);
			resDurationList = withStart.getResDateDetails();
			resNamesList = withStart.getResNames();
			/**
			 * Construct a Box-and-Whisker Graph showing the durations per
			 * resource and any outliers
			 */

			graphing = new BoxandWhiskerPlot(context, resDurationList, resNamesList);
			outlierChoice = graphing.getOutlierRange();
			if (outlierChoice != null) {
				/**
				 * Add the start events to the log
				 */
				addStart = new AddStMain(context, log, displayChoice, outlierChoice);
				addCounter = addStart.getAddCounter();
				removeCounter = addStart.getRemoveCounter();
				context.log(""The Number of Start Events Added is: "" + addCounter);
				context.log(""The Number of Events Removed is: "" + removeCounter);
				changedLog = addStart.getLog();

			} else {
				context.getFutureResult(0).cancel(true);

			}

		}

		AddStVisualizer output = new AddStVisualizer();
		output.setLog(changedLog);
		return output;
	}

}
"
AddStEvents.java,log-6.9.380,"package org.processmining.plugins.loginsertstart;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.ListIterator;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.collection.ComparablePair;

/**
 * Add Start Events
 * 
 * This is the class where the start events are actually added to the event log
 * 
 * @author jnakatumba
 * 
 */

public class AddStEvents {
	private final XTrace trace;
	private final String transition = ""start"";

	private final List<ComparablePair<String, Date>> cidDateList;
	private final List<ComparablePair<String, Date>> resDateList;
	private ComparablePair<String, Date> cidDate;
	private ComparablePair<String, Date> prevPair, prevPairCase;
	private final List<Pair<String, String>> startEventsList;
	private final List<Pair<String, String>> completeEventsList;
	private final List<Pair<String, String>> startEventsList1;
	private final List<Pair<String, String>> completeEventsList1;

	private final ArrayList<XEvent> eventList;
	private final List<XEvent> starts;
	private final List<XEvent> removeEvents;
	private Pair<String, String> typeNamePair;
	private Pair<String, String> startNamePair;
	private Integer removeCount = 0;

	private Date prevCasDate;

	private Long serviceTime = 0L, currentTimeS = 0L;
	private Long prevResTimeS = 0L, prevCasTimeS = 0L;

	private XEvent myEvent;
	private Date cDate, newDate;
	private String rName, caseId;
	private Integer count = 0;
	private final String displayChoice, outlierChoice;
	private String eventType, actName;

	/**
	 * Add start events
	 * 
	 * @param traces
	 *            The trace that is to be edited
	 * @param resDateList
	 *            The list of all the resources in the log and the particular
	 *            dates at which an event execution occurred in the log that was
	 *            done by the resources.
	 */

	public AddStEvents(XTrace trace, List<ComparablePair<String, Date>> resDateList, String displaychoice,
			String outlierChoice, Integer addcounter, Integer rCount) {

		this.resDateList = resDateList;
		displayChoice = displaychoice;
		this.outlierChoice = outlierChoice;
		count = addcounter;
		removeCount = rCount;

		startEventsList = new ArrayList<Pair<String, String>>();
		completeEventsList = new ArrayList<Pair<String, String>>();
		startEventsList1 = new ArrayList<Pair<String, String>>();
		completeEventsList1 = new ArrayList<Pair<String, String>>();
		eventList = new ArrayList<XEvent>();
		starts = new ArrayList<XEvent>();
		removeEvents = new ArrayList<XEvent>();

		cidDateList = new ArrayList<ComparablePair<String, Date>>();
		cidDate = new ComparablePair<String, Date>(null, null);

		/**
		 * Iterate through each trace in the log and see if there are duplicate
		 * events. For example if we have a start event followed by another
		 * start event, and then a complete event, we match the second start
		 * event with the complete event and then discard the first start event
		 */
		for (XEvent event : trace) {
			cDate = XTimeExtension.instance().extractTimestamp(event);
			caseId = XConceptExtension.instance().extractName(trace);
			rName = XOrganizationalExtension.instance().extractResource(event);
			eventType = XLifecycleExtension.instance().extractTransition(event);
			actName = XConceptExtension.instance().extractName(event);
			myEvent = event;
			typeNamePair = new Pair<String, String>(eventType, actName);
			starts.add(myEvent);

			if (eventType.equals(""start"")) {
				if (startEventsList1.contains(typeNamePair) == false) {
					startEventsList1.add(typeNamePair);
				} else {
					for (int i = 0; i < starts.size(); i++) {
						XEvent prevEvent = starts.get(i);
						String actvName = XConceptExtension.instance().extractName(prevEvent);
						if (actvName.equals(actName)
								&& XLifecycleExtension.instance().extractTransition(prevEvent).equals(""start"")) {
							removeEvents.add(prevEvent);
							starts.remove(prevEvent);
						}

					}
				}

			} else if (eventType.equals(""complete"")) {

				if (completeEventsList1.contains(typeNamePair) == false) {
					completeEventsList1.add(typeNamePair);

				} else {
					for (int i = 0; i < starts.size(); i++) {
						XEvent prevEvent = starts.get(i);
						String actvName = XConceptExtension.instance().extractName(prevEvent);
						if (actvName.equals(actName)
								&& XLifecycleExtension.instance().extractTransition(prevEvent).equals(""complete"")) {
							removeEvents.add(prevEvent);
							starts.remove(prevEvent);

						}
					}

				}
			}

		}

		/**
		 * Discard the events that are of the same event type per activity
		 * occurring in a trace
		 */
		for (int i = 0; i < removeEvents.size(); i++) {
			XEvent prevEvent = removeEvents.get(i);
			trace.remove(prevEvent);
			removeCount++;

		}

		/**
		 * Obtain when to insert the start events to the log
		 */
		for (XEvent event : trace) {
			cDate = XTimeExtension.instance().extractTimestamp(event);
			caseId = XConceptExtension.instance().extractName(trace);
			rName = XOrganizationalExtension.instance().extractResource(event);
			eventType = XLifecycleExtension.instance().extractTransition(event);
			actName = XConceptExtension.instance().extractName(event);
			myEvent = event;
			typeNamePair = new Pair<String, String>(eventType, actName);
			init();
			cidDate = getIdDate(caseId, cDate);
			cidDateList.add(cidDate);

		}

		/**
		 * Add the new start events to the event log. These are added before
		 * each complete event observed in the log.
		 */
		for (int i = 0; i < eventList.size(); i++) {
			XEvent events = eventList.get(i);
			String actNames = XConceptExtension.instance().extractName(events);
			int sn = 0;
			now: for (ListIterator<XEvent> eventListIt = trace.listIterator(); eventListIt.hasNext();) {
				if (eventListIt.hasNext() == true) {
					XEvent event = eventListIt.next();
					sn++;
					if (XLifecycleExtension.instance().extractTransition(event).equals(""complete"")) {
						String actName = XConceptExtension.instance().extractName(event);
						if (actNames.equals(actName)) {
							trace.add(sn - 1, events);
							count++;
							break now;
						}

					}
				}

			}
		}

		this.trace = trace;

	}

	/**
	 * Check if a start event in the log can be matched with a corresponding
	 * event and if a start event is missing,i.e., we observe only a complete
	 * event, then we insert it into the log.
	 */
	private void init() {
		if (eventType.equals(""start"")) {
			if (startEventsList.contains(typeNamePair) == false) {
				startEventsList.add(typeNamePair);
				starts.add(myEvent);
			}

		} else if (eventType.equals(""complete"")) {
			if (completeEventsList.contains(typeNamePair) == false) {
				startNamePair = new Pair<String, String>(""start"", actName);

				if (startEventsList.contains(startNamePair) == false) {
					start();

				}
			}

		}
	}

	/**
	 * The durations for each event can be checked based on either the resource
	 * perspective, case of the maximum of both the resource and case
	 * perspective.
	 */

	private void start() {
		if (displayChoice.equals(""Resource perspective"")) {
			getResourceDetails();

		} else if (displayChoice.equals(""Case perspective"")) {
			getServiceTimesOnCase();

		} else if (displayChoice.equals(""Resource/Case perspective"")) {
			getServiceTimesOnAverage();
		}

	}

	/**
	 * Check to see if the current resource executed any event before this one.
	 */
	private void getResourceDetails() {

		String rname;
		Date rDate;
		if (resDateList.size() != 0) {
			search: for (int i = 0; i < resDateList.size(); i++) {
				prevPair = resDateList.get(i);
				rname = prevPair.getFirst();
				rDate = prevPair.getSecond();
				if (rname.equals(rName) == true) {
					if (rDate.compareTo(cDate) == 0) {
						if (i != 0) {
							ComparablePair<String, Date> currentP = resDateList.get(i - 1);
							rname = currentP.getFirst();

							if (rname.equals(rName)) {
								rDate = currentP.getSecond();
								prevResTimeS = rDate.getTime();
								currentTimeS = cDate.getTime();
								serviceTime = currentTimeS - prevResTimeS;
								serviceTime = serviceTime / 1000;
								serviceTime = serviceTime / 60;

								long value = serviceTime.longValue();
								double dValue = Double.valueOf(value);

								if (outlierChoice.equals(""Estimate Values"")) {
									estimateDates(serviceTime);
									break search;

								} else {
									Double outlierRange = Double.valueOf(outlierChoice);
									if (dValue < outlierRange) {
										Date pDate = estimateStartDates(serviceTime);
										XTimeExtension.instance().assignTimestamp(myEvent, pDate);
										eventList.add(myEvent);
										break search;

									} else {
										XTimeExtension.instance().assignTimestamp(myEvent, cDate);
										eventList.add(myEvent);
										break search;

									}

								}

							}
							if (outlierChoice.equals(""Estimate Values"")) {
								estimateDates(serviceTime);
								break search;
							} else {
								XTimeExtension.instance().assignTimestamp(myEvent, cDate);
								eventList.add(myEvent);
								break search;
							}

						}
					}
				}
			}

		}

	}

	/**
	 * Checks the information based on the case perspective and then edits the
	 * event with the new information obtained.
	 */

	private void getServiceTimesOnAverage() {
		String rname;
		Date rDate;
		int listSize = cidDateList.size();
		XOrganizationalExtension.instance().assignResource(myEvent, rName);
		XLifecycleExtension.instance().assignTransition(myEvent, transition);

		if (resDateList.size() != 0) {
			search: for (int i = 0; i < resDateList.size(); i++) {
				prevPair = resDateList.get(i);
				rname = prevPair.getFirst();
				rDate = prevPair.getSecond();
				if (rname.equals(rName) == true) {
					if (rDate.compareTo(cDate) == 0) {
						if (i != 0) {
							ComparablePair<String, Date> currentP = resDateList.get(i - 1);
							rname = currentP.getFirst();

							if (rname.equals(rName)) {
								rDate = currentP.getSecond();
								prevResTimeS = rDate.getTime();
								currentTimeS = cDate.getTime();

								if (listSize != 0) {
									prevPairCase = cidDateList.get(listSize - 1);
									prevCasDate = prevPairCase.getSecond();

									if (prevCasDate.compareTo(cDate) < 0) {
										currentTimeS = cDate.getTime();
										prevCasTimeS = prevCasDate.getTime();

										serviceTime = currentTimeS - Math.max(prevCasTimeS, prevResTimeS);
										serviceTime = serviceTime / 1000;
										serviceTime = serviceTime / 60;

										if (outlierChoice.equals(""Estimate Values"")) {
											estimateDates(serviceTime);
											break search;

										} else {
											Double outlierRange = Double.valueOf(outlierChoice);
											long value = serviceTime.longValue();
											double dValue = Double.valueOf(value);
											if (dValue < outlierRange) {
												Date pDate = estimateStartDates(serviceTime);
												XTimeExtension.instance().assignTimestamp(myEvent, pDate);
												eventList.add(myEvent);
												break search;

											} else {
												XTimeExtension.instance().assignTimestamp(myEvent, cDate);
												eventList.add(myEvent);
												break search;

											}

										}

									} else {
										XTimeExtension.instance().assignTimestamp(myEvent, cDate);
										eventList.add(myEvent);
										break search;
									}

								}
							}
							XTimeExtension.instance().assignTimestamp(myEvent, cDate);
							eventList.add(myEvent);
							break search;
						}
					}
				}
			}
		}

	}

	private void getServiceTimesOnCase() {
		int listSize = cidDateList.size();
		if (listSize != 0) {
			prevPairCase = cidDateList.get(listSize - 1);
			prevCasDate = prevPairCase.getSecond();
			XOrganizationalExtension.instance().assignResource(myEvent, rName);
			XLifecycleExtension.instance().assignTransition(myEvent, transition);
			if (prevCasDate.compareTo(cDate) < 0) {
				currentTimeS = cDate.getTime();
				prevCasTimeS = prevCasDate.getTime();

				serviceTime = currentTimeS - prevCasTimeS;
				serviceTime = serviceTime / 1000;
				serviceTime = serviceTime / 60;

				if (outlierChoice.equals(""Estimate Values"")) {
					estimateDates(serviceTime);

				} else {

					Double outlierRange = Double.valueOf(outlierChoice);
					long value = serviceTime.longValue();
					double dValue = Double.valueOf(value);
					if (dValue < outlierRange) {
						Date pDate = estimateStartDates(serviceTime);
						XTimeExtension.instance().assignTimestamp(myEvent, pDate);
						eventList.add(myEvent);

					} else {
						XTimeExtension.instance().assignTimestamp(myEvent, cDate);
						eventList.add(myEvent);

					}
				}
			}

		} else {
			XTimeExtension.instance().assignTimestamp(myEvent, cDate);
			eventList.add(myEvent);

		}

	}

	/**
	 * We obtain a start date based on a duration and a complete date per event.
	 * If the complete date occurred before 13hrs we assume it was started at
	 * 8hrs or else it was started at 13hrs.
	 * 
	 * @param serviceT
	 *            Service time
	 */

	private void estimateDates(Long serviceT) {
		long st = serviceT.longValue();

		Calendar myCalendar = Calendar.getInstance();
		myCalendar.setTime(cDate);
		int currentDay = myCalendar.get(Calendar.DAY_OF_WEEK);
		int currentMonth = myCalendar.get(Calendar.MONTH);
		int currentTime = myCalendar.get(Calendar.HOUR_OF_DAY);
		int currentDayMonth = myCalendar.get(Calendar.DAY_OF_MONTH);
		int currentYear = myCalendar.get(Calendar.YEAR);

		int a = (int) st;
		myCalendar.add(Calendar.MINUTE, -a);
		newDate = myCalendar.getTime();

		if (outlierChoice.equals(""Estimate Values"")) {

			Calendar newCalendars = Calendar.getInstance();
			newCalendars.setTime(newDate);

			int prevDay = newCalendars.get(Calendar.DAY_OF_WEEK);
			int prevMonth = newCalendars.get(Calendar.MONTH);
			int prevDayMonth = newCalendars.get(Calendar.DAY_OF_MONTH);
			int prevYear = myCalendar.get(Calendar.YEAR);

			if ((prevDay < currentDay) || (prevMonth < currentMonth) || (prevDayMonth < currentDayMonth)
					|| (prevYear < currentYear)) {
				Calendar newCalendar = Calendar.getInstance();
				newCalendar.setTime(cDate);

				int cTime = newCalendar.get(Calendar.HOUR_OF_DAY);
				if (cTime < 12) {
					newCalendar.add(Calendar.HOUR_OF_DAY, -(currentTime - 8));
					newDate = newCalendar.getTime();
					XTimeExtension.instance().assignTimestamp(myEvent, newDate);
					eventList.add(myEvent);

				} else {
					newCalendar.add(Calendar.HOUR_OF_DAY, -(currentTime - 13));

					newDate = newCalendar.getTime();
					XTimeExtension.instance().assignTimestamp(myEvent, newDate);
					eventList.add(myEvent);

				}
			} else {
				XTimeExtension.instance().assignTimestamp(myEvent, newDate);
				eventList.add(myEvent);
			}
		}

	}

	/**
	 * Based on the complete date and a certain duration, we obtain a start date
	 * 
	 * @param servT
	 *            Service Time
	 * @return Start Date
	 */

	private Date estimateStartDates(Long servT) {
		long st = servT.longValue();
		Calendar myCalendar = Calendar.getInstance();
		myCalendar.setTime(cDate);

		int a = (int) st;
		myCalendar.add(Calendar.MINUTE, -a);
		Date cDate = myCalendar.getTime();

		return cDate;

	}

	private ComparablePair<String, Date> getIdDate(String caseId, Date timeStamp) {
		return new ComparablePair<String, Date>(caseId, timeStamp);
	}

	public XTrace getTrace() {
		return trace;
	}

	public int getAddevents() {
		return count;
	}

	public int getRemoveEvents() {
		return removeCount;
	}

}"
AddStMain.java,log-6.9.380,"package org.processmining.plugins.loginsertstart;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.info.XLogInfoFactory;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.collection.ComparablePair;
import org.processmining.plugins.log.logfilters.LogFilter;
import org.processmining.plugins.log.logfilters.LogFilterException;
import org.processmining.plugins.log.logfilters.XTraceEditor;

/**
 * Check the log and see if any start events exist or not in the event log and
 * then calls the class to add the add the missing start events.
 * 
 * @author jnakatumba
 * 
 */

public class AddStMain {

	private AddStEvents startEvents;

	private List<ComparablePair<String, Date>> resDateList;
	private ArrayList<Date> startDatesList;
	private ComparablePair<String, Date> resDate;
	private Set<String> resNamesList;

	private Integer addCount = 0, removeCount = 0;
	private String displaychoice, outlierChoice;

	private XLog log;

	/**
	 * Initialize the plugin by checking if any start events exist in the log
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * 
	 */

	public AddStMain(UIPluginContext context, XLog log, String displayChoice, String outLierChoice) {
		try {
			outlierChoice = outLierChoice;
			displaychoice = displayChoice;
			resDateList = new ArrayList<ComparablePair<String, Date>>();
			startDatesList = new ArrayList<Date>();
			resDate = new ComparablePair<String, Date>(null, null);
			resNamesList = new TreeSet<String>();
			getEditedLog(context, log);
		} catch (LogFilterException e) {
			e.printStackTrace();
		}

	}

	private XLog getEditedLog(final UIPluginContext context, XLog log) throws LogFilterException {
		/**
		 * check if the log has any start events at all
		 */
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				if (XLifecycleExtension.instance().extractTransition(event).equals(""start"")) {
					Date startDate = XTimeExtension.instance().extractTimestamp(event);
					startDatesList.add(startDate);

				} else if (XLifecycleExtension.instance().extractTransition(event).equals(""complete"")) {
					String rName = XOrganizationalExtension.instance().extractResource(event);
					Date cDate = XTimeExtension.instance().extractTimestamp(event);
					resDate = getResDate(rName, cDate);
					resDateList.add(resDate);
					resNamesList.add(rName);

				}
			}
			Collections.sort(resDateList);
		}
		/**
		 * For each trace per log, the start event is added per complete event
		 */
		return this.log = LogFilter.filter(context.getProgress(), 100, log, XLogInfoFactory.createLogInfo(log),
				new XTraceEditor() {
					public XTrace editTrace(XTrace trace) {
						startEvents = new AddStEvents(trace, resDateList, displaychoice, outlierChoice, addCount,
								removeCount);
						trace = startEvents.getTrace();
						addCount = startEvents.getAddevents();
						removeCount = startEvents.getRemoveEvents();
						return trace;
					}

				});

	}

	private ComparablePair<String, Date> getResDate(String rName, Date timeStamp) {
		return new ComparablePair<String, Date>(rName, timeStamp);
	}

	/**
	 * The edited log
	 * 
	 * @return XLog
	 */
	public XLog getLog() {
		return log;
	}

	/**
	 * Number of start events added
	 * 
	 * @return Start Events added
	 */

	public int getAddCounter() {
		return addCount;
	}

	/**
	 * Number of events removed
	 * 
	 * @return No of events removed
	 */
	public int getRemoveCounter() {
		return removeCount;
	}
}
"
AddStPanel.java,log-6.9.380,"package org.processmining.plugins.loginsertstart;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JSpinner;
import javax.swing.JSplitPane;
import javax.swing.SpinnerModel;
import javax.swing.SpinnerNumberModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.jfree.chart.ChartPanel;
import org.processmining.contexts.uitopia.UIPluginContext;

import com.fluxicon.slickerbox.components.HeaderBar;

/**
 * Insert Start Panel Class
 * 
 * 
 * @author jnakatumba
 * 
 */

public class AddStPanel extends JPanel {

	private static final long serialVersionUID = 1L;

	private String choice;
	private final ChartPanel chartPanel;
	private JPanel jPanel;
	private final double maxValue;
	private JSpinner jSpinner;
	private JLabel jLabel;
	protected JSplitPane splitPane;
	private JPanel jPanel1;
	private final Color colorBg;
	private String outlierValue;
	private ButtonGroup jButtonGroup;
	private JRadioButton removeOut;
	private JRadioButton noRemove;
	private JRadioButton estimate;

	AddStPanel(UIPluginContext context, ChartPanel chartPanel, Double maxValue) {

		this.maxValue = maxValue;
		this.chartPanel = chartPanel;
		colorBg = new Color(120, 120, 120);

		setLayout(new BorderLayout());

		addPanel();
		context.showConfiguration(""Insert Missing Events"", jPanel1);

	}

	private void addPanel() {

		HeaderBar header = new HeaderBar(""Start Insertion Plugin "");
		header.setHeight(40);

		jLabel = new JLabel(""Upper Bound(minutes)"");
		jPanel1 = new JPanel();

		jSpinner = new JSpinner();

		jButtonGroup = new ButtonGroup();
		removeOut = new JRadioButton();
		noRemove = new JRadioButton();
		estimate = new JRadioButton();

		jButtonGroup.add(removeOut);
		removeOut.setSelected(true);
		removeOut.setText(""Remove Outliers"");

		jButtonGroup.add(noRemove);
		noRemove.setSelected(true);
		noRemove.setText(""Do not Insert Start Events"");

		jButtonGroup.add(estimate);
		estimate.setSelected(true);
		estimate.setText(""Estimate range of Service Time"");

		int min = 0;
		int step = 5;
		int initValue = 50;
		SpinnerModel model = new SpinnerNumberModel(initValue, min, maxValue, step);
		jSpinner = new JSpinner(model);
		jSpinner.setPreferredSize(new Dimension(200, 20));
		jSpinner.setMaximumSize(new Dimension(200, 20));

		jSpinner.addChangeListener(new ChangeListener() {
			public void stateChanged(ChangeEvent e) {
				outlierValue = String.valueOf(jSpinner.getValue());

			}
		});

		//jTextField = new JTextField();
		jPanel = new JPanel();
		jPanel.setLayout(new BoxLayout(jPanel, BoxLayout.PAGE_AXIS));

		/**
		 * jTextField.addActionListener(new ActionListener() {
		 * 
		 * public void actionPerformed(ActionEvent e) { textField =
		 * jTextField.getText();
		 * 
		 * }
		 * 
		 * });
		 */

		removeOut.setAlignmentX(Component.LEFT_ALIGNMENT);
		jPanel.add(removeOut);

		jLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
		jPanel.add(jLabel);

		jSpinner.setMaximumSize(new Dimension(150, 30));
		jSpinner.setAlignmentX(Component.LEFT_ALIGNMENT);
		jPanel.add(jSpinner);

		estimate.setAlignmentX(Component.LEFT_ALIGNMENT);
		jPanel.add(estimate);

		//jTextField.setMaximumSize(new Dimension(150, 30));
		//jTextField.setAlignmentX(Component.LEFT_ALIGNMENT);
		//jPanel.add(jTextField);

		noRemove.setAlignmentX(Component.LEFT_ALIGNMENT);
		jPanel.add(noRemove);

		jPanel1 = new JPanel();
		jPanel1.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
		jPanel1.setLayout(new BorderLayout());

		splitPane = new JSplitPane();
		splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);

		splitPane.setRightComponent(chartPanel);
		splitPane.setLeftComponent(jPanel);
		splitPane.setBackground(colorBg);

		splitPane.setDividerSize(2);
		jPanel1.add(header, BorderLayout.NORTH);
		jPanel1.add(splitPane);

	}

	public String getChoice() {
		if (removeOut.isSelected() == true) {
			choice = outlierValue;

		} else if (noRemove.isSelected() == true) {
			choice = null;

		} else if (estimate.isSelected() == true) {
			choice = ""Estimate Values"";

		}

		return choice;

	}

}
"
AddStPlugin.java,log-6.9.380,"package org.processmining.plugins.loginsertstart;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginVariant;

/**
 * Add missing start events to the log
 * 
 * @author jnakatumba
 * 
 */
@Plugin(name = ""Add Missing Events"", categories = { PluginCategory.Filtering }, parameterLabels = { ""Log"" }, returnLabels = { ""Log (With Start Events)"" }, returnTypes = { AddStVisualizer.class }, userAccessible = true)
public class AddStPlugin {
	/**
	 * This class adds missing start events to the event log
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * @return the changed log.
	 */
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""J. Nakatumba"", email = ""jnakatum@tue.nl"")
	@PluginVariant(variantLabel = ""Default Settings"", requiredParameterLabels = { 0 })
	public static AddStVisualizer filter(final UIPluginContext context, final XLog log) {
		AddSt miner = new AddSt(context, log);
		AddStVisualizer output = miner.mine();

		String name = XConceptExtension.instance().extractName(log);
		context.getFutureResult(0).setLabel(name + ""(With Start Events)"");

		return output;

	}

}
"
AddStSecPanel.java,log-6.9.380,"package org.processmining.plugins.loginsertstart;

import java.awt.BorderLayout;
import java.awt.Component;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.border.Border;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;

import org.processmining.contexts.uitopia.UIPluginContext;

import com.fluxicon.slickerbox.components.HeaderBar;

/**
 * Insert Start First Panel class
 * 
 * @author jnakatumba
 * 
 */

public class AddStSecPanel extends JPanel {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private JPanel jPanel;
	private JPanel panel;
	private JLabel jLabel;
	private ButtonGroup jButtonGroup;
	private JRadioButton resourcePer;
	private JRadioButton casePer;
	private JRadioButton averageResCase;
	private String displayChoice;

	public AddStSecPanel(UIPluginContext context) {

		setLayout(new BorderLayout());

		addPanel();

	}

	private void addPanel() {

		HeaderBar header = new HeaderBar(""Start Insertion Plugin Settings"");
		header.setHeight(40);

		jLabel = new JLabel(""Show Outliers Based on:"");

		Border raisedetched = BorderFactory.createEtchedBorder(EtchedBorder.RAISED);

		TitledBorder title;
		title = BorderFactory.createTitledBorder(raisedetched);
		title.setTitleJustification(TitledBorder.CENTER);

		jButtonGroup = new ButtonGroup();
		resourcePer = new JRadioButton();
		casePer = new JRadioButton();
		averageResCase = new JRadioButton();

		jButtonGroup.add(resourcePer);
		resourcePer.setSelected(true);
		resourcePer.setText(""Resource perspective"");

		jButtonGroup.add(casePer);
		casePer.setSelected(true);
		casePer.setText(""Case perspective"");

		jButtonGroup.add(averageResCase);
		averageResCase.setSelected(true);
		averageResCase.setText(""Maximum of Case and Resource Perspectives"");

		jPanel = new JPanel(new BorderLayout());
		panel = new JPanel();

		jPanel.add(header, BorderLayout.NORTH);

		panel.setLayout(new BoxLayout(panel, BoxLayout.PAGE_AXIS));

		jLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
		panel.add(jLabel);

		resourcePer.setAlignmentX(Component.LEFT_ALIGNMENT);
		panel.add(resourcePer);

		casePer.setAlignmentX(Component.LEFT_ALIGNMENT);
		panel.add(casePer);

		averageResCase.setAlignmentX(Component.LEFT_ALIGNMENT);
		panel.add(averageResCase);

		panel.setBorder(title);

		jPanel.add(panel, BorderLayout.CENTER);

	}

	public JPanel getPanel() {
		return jPanel;
	}

	public String getDisplayChoice() {
		if (resourcePer.isSelected() == true) {

			displayChoice = ""Resource perspective"";

		} else if (casePer.isSelected() == true) {
			displayChoice = ""Case perspective"";

		} else if (averageResCase.isSelected() == true) {
			displayChoice = ""Resource/Case perspective"";

		}
		return displayChoice;
	}

}
"
AddStVisualizer.java,log-6.9.380,"package org.processmining.plugins.loginsertstart;

import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;

/**
 * 
 * Insert Start Visualizer Class
 * 
 * Visualise the edited log
 * 
 * @author jnakatumba
 * 
 */

@Plugin(name = ""Log visualizer"", returnLabels = { ""Visualized Log"" }, returnTypes = { XLog.class }, parameterLabels = ""log"")
@Visualizer
public class AddStVisualizer {

	private XLog xlog;

	public XLog setLog(XLog log) {
		xlog = log;
		return xlog;

	}

	@PluginVariant(requiredParameterLabels = { 0 }, variantLabel = ""Default Visualization"")
	public static XLog open(PluginContext context, AddStVisualizer output) throws Exception {
		return output.xlog;
	}

}
"
BoxandWhiskerPlot.java,log-6.9.380,"package org.processmining.plugins.loginsertstart;

import java.awt.Color;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import javax.swing.JScrollPane;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.CategoryAxis;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.labels.BoxAndWhiskerToolTipGenerator;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.renderer.category.BoxAndWhiskerRenderer;
import org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.Pair;

/**
 * Box- and Whisker Plot class
 * 
 * @author jnakatumba
 * 
 */

public class BoxandWhiskerPlot {

	private static Color colorBg = new Color(120, 120, 120);

	private ChartPanel chartPanel;
	private final UIPluginContext context;
	private final Set<String> resNamesList;
	private final Set<String> resourceList;
	private String resourceName;
	private final List<Pair<String, List<Double>>> resListPair;
	private List<Double> serviceTimes;
	private final List<Pair<String, Long>> resDurationList;

	private Double maxValue = 0.0;
	private String rChoice;

	private boolean bLegend = true;

	public BoxandWhiskerPlot(UIPluginContext context, List<Pair<String, Long>> resDurationLists, Set<String> resNames) {
		this.context = context;
		resDurationList = resDurationLists;
		resNamesList = resNames;

		resListPair = new ArrayList<Pair<String, List<Double>>>();
		serviceTimes = new ArrayList<Double>();

		resourceList = new TreeSet<String>();
		getOutliers();

		if (resourceList.size() > 40) {
			bLegend = false;
		} else {
			bLegend = true;
		}
		constructBoxandWhisker();

	}

	private void getOutliers() {
		Object[] reList = resNamesList.toArray();
		for (int resIndex = 0; resIndex < resNamesList.size(); resIndex++) {
			resourceName = (String) reList[resIndex];
			getPerResource();
		}
	}

	private void getPerResource() {
		List<Double> valuesList = new ArrayList<Double>();
		Double dValue = 0.0;
		for (int i = 0; i < resDurationList.size(); i++) {
			Pair<String, Long> currentPair = resDurationList.get(i);
			String rName = currentPair.getFirst();
			if (resourceName.equals(rName)) {
				long value = currentPair.getSecond();
				dValue = Double.valueOf(value);
				valuesList.add(dValue);
				resourceList.add(rName);

			}

			if (dValue > maxValue) {
				maxValue = dValue;
			}
		}
		Pair<String, List<Double>> resPair = new Pair<String, List<Double>>(resourceName, valuesList);
		resListPair.add(resPair);

	}

	@SuppressWarnings(""deprecation"")
	private void constructBoxandWhisker() {

		DefaultBoxAndWhiskerCategoryDataset datasets = createSampleDataset();

		JFreeChart chart = ChartFactory.createBoxAndWhiskerChart(""Box and Whisker Chart"", ""Service Time"",
				""Resource Names"", datasets, true);

		chart.setBackgroundPaint(new Color(249, 231, 236));

		chartPanel = new ChartPanel(chart);
		chartPanel.setPreferredSize(new java.awt.Dimension(500, 300));

		CategoryAxis xAxis = new CategoryAxis(""Resources"");
		NumberAxis yAxis = new NumberAxis(""Service Time (minutes)"");
		yAxis.setAutoRangeIncludesZero(false);
		BoxAndWhiskerRenderer renderer = new BoxAndWhiskerRenderer();
		renderer.setToolTipGenerator(new BoxAndWhiskerToolTipGenerator());
		CategoryPlot plot = new CategoryPlot(datasets, xAxis, yAxis, renderer);

		chart = new JFreeChart(null, new Font(""SansSerif"", Font.BOLD, 14), plot, bLegend);
		chartPanel = new ChartPanel(chart);
		JScrollPane scrollPane = new JScrollPane(chartPanel);
		chartPanel.setBackground(colorBg);
		scrollPane.setBackground(colorBg);

		AddStPanel stPanel = new AddStPanel(context, chartPanel, maxValue);
		rChoice = stPanel.getChoice();

	}

	private DefaultBoxAndWhiskerCategoryDataset createSampleDataset() {
		serviceTimes = new ArrayList<Double>();
		DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset();
		for (int i = 0; i < resListPair.size(); i++) {
			Pair<String, List<Double>> resList = resListPair.get(i);
			String rName = resList.getFirst();
			serviceTimes = resList.getSecond();
			dataset.add(serviceTimes, rName, """");

		}

		return dataset;

	}

	public String getOutlierRange() {
		return rChoice;
	}

}
"
ObtainDurationsWithoutStart.java,log-6.9.380,"package org.processmining.plugins.loginsertstart;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.collection.ComparablePair;

/**
 * Check the log and see if any start events exist or not in the event log.
 * 
 * @author jnakatumba
 * 
 */

public class ObtainDurationsWithoutStart {

	private final Set<String> resNamesList;
	private final List<ComparablePair<String, Date>> resDateList;
	private final List<ComparablePair<String, Date>> cidDateList;

	private Long serviceTime = 0L, currentTimeS = 0L, prevResTimeS = 0L;
	private ComparablePair<String, Date> resDate;
	private ComparablePair<String, Date> cidDate;
	private ComparablePair<String, Date> prevPair, prevPairCase;

	private List<Pair<String, Long>> resDurationList;
	private final List<Pair<String, Long>> resDurationListRes;
	private final List<Pair<String, Long>> resDurationListCase;
	private final List<Pair<String, Long>> resDurationListResAver;
	private Pair<String, Long> resDurPair;
	private String caseId;

	private XEvent myEvent;
	private Date cDate, prevCasDate;;
	private String rName;
	private final String displayChoice;

	/**
	 * Initialize the plugin by checking if any start events exist in the log
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * 
	 */

	public ObtainDurationsWithoutStart(XLog log, String choice) {
		displayChoice = choice;

		resDurationList = new ArrayList<Pair<String, Long>>();
		resDurationListRes = new ArrayList<Pair<String, Long>>();
		resDurationListCase = new ArrayList<Pair<String, Long>>();
		resDurationListResAver = new ArrayList<Pair<String, Long>>();

		resNamesList = new TreeSet<String>();
		resDateList = new ArrayList<ComparablePair<String, Date>>();
		cidDateList = new ArrayList<ComparablePair<String, Date>>();

		resDate = new ComparablePair<String, Date>(null, null);
		cidDate = new ComparablePair<String, Date>(null, null);

		for (XTrace trace : log) {
			for (XEvent event : trace) {
				if (XLifecycleExtension.instance().extractTransition(event).equals(""complete"")) {
					String rName = XOrganizationalExtension.instance().extractResource(event);
					Date cDate = XTimeExtension.instance().extractTimestamp(event);
					resDate = getDate(rName, cDate);
					resDateList.add(resDate);
					resNamesList.add(rName);

				}
			}
		}
		Collections.sort(resDateList);

		for (XTrace trace : log) {
			for (XEvent event : trace) {
				if (XLifecycleExtension.instance().extractTransition(event).equals(""complete"")) {
					insertStartEvents(trace, event);
				}
			}
		}

	}

	private void insertStartEvents(XTrace trace, XEvent event) {
		myEvent = event;
		cDate = XTimeExtension.instance().extractTimestamp(myEvent);
		caseId = XConceptExtension.instance().extractName(trace);
		rName = XOrganizationalExtension.instance().extractResource(myEvent);
		getResourceDetails();

		cidDate = getDate(caseId, cDate);
		cidDateList.add(cidDate);

	}

	/**
	 * Check to see if the current resource executed any event before
	 */
	private void getResourceDetails() {
		String rname;
		Date rDate;
		if (resDateList.size() != 0) {
			search: for (int i = 0; i < resDateList.size(); i++) {
				prevPair = resDateList.get(i);
				rname = prevPair.getFirst();
				rDate = prevPair.getSecond();
				if (rname.equals(rName) == true) {
					if (rDate.compareTo(cDate) == 0) {
						if (i != 0) {
							ComparablePair<String, Date> currentP = resDateList.get(i - 1);
							rname = currentP.getFirst();
							if (rname.equals(rName)) {
								rDate = currentP.getSecond();
								prevResTimeS = rDate.getTime();
								currentTimeS = cDate.getTime();
								serviceTime = currentTimeS - prevResTimeS;
								serviceTime = serviceTime / 1000;
								serviceTime = serviceTime / 60;

								long st = serviceTime.longValue();

								resDurPair = new Pair<String, Long>(rName, st);
								resDurationListRes.add(resDurPair);
								getServiceTimesOnCase();
								break search;

							}
							getServiceTimesOnCase();
							break search;
						}
					}
				}
			}
		}

	}

	/**
	 * Checks the information based on the case perspective and then edits the
	 * event with the new information obtained.
	 */

	private void getServiceTimesOnCase() {
		int listSize = cidDateList.size();
		if ((listSize != 0) && (listSize > 1)) {
			prevPairCase = cidDateList.get(listSize - 1);
			prevCasDate = prevPairCase.getSecond();
			if (prevCasDate.compareTo(cDate) < 0) {
				currentTimeS = cDate.getTime();
				Long prevCasTimeS = prevCasDate.getTime();

				serviceTime = currentTimeS - Math.max(prevCasTimeS, prevResTimeS);
				serviceTime = serviceTime / 1000;
				serviceTime = serviceTime / 60;

				long st = serviceTime.longValue();
				resDurPair = new Pair<String, Long>(rName, st);
				resDurationListResAver.add(resDurPair);

				serviceTime = currentTimeS - prevCasTimeS;
				serviceTime = serviceTime / 1000;
				serviceTime = serviceTime / 60;

				long stC = serviceTime.longValue();
				resDurPair = new Pair<String, Long>(rName, stC);
				resDurationListCase.add(resDurPair);

			}
		}

	}

	public List<Pair<String, Long>> getResDateDetails() {

		if (displayChoice.equals(""Resource perspective"")) {
			resDurationList = resDurationListRes;

		} else if (displayChoice.equals(""Case perspective"")) {
			resDurationList = resDurationListCase;

		} else if (displayChoice.equals(""Resource/Case perspective"")) {
			resDurationList = resDurationListResAver;
		}
		return resDurationList;
	}

	public Set<String> getResNames() {
		return resNamesList;
	}

	private ComparablePair<String, Date> getDate(String rName, Date timeStamp) {
		return new ComparablePair<String, Date>(rName, timeStamp);
	}

}
"
ObtainDurationWithStart.java,log-6.9.380,"package org.processmining.plugins.loginsertstart;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.extension.std.XLifecycleExtension;
import org.deckfour.xes.extension.std.XOrganizationalExtension;
import org.deckfour.xes.extension.std.XTimeExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.util.Pair;

/**
 * Check the log and see if any start events exist or not in the event log.
 * 
 * @author jnakatumba
 * 
 */

public class ObtainDurationWithStart {
	private final ArrayList<Date> startDatesList;
	private final List<Pair<String, Long>> resDurationList;
	private final Set<String> resNamesList;
	private Pair<String, Long> resDurPair;
	private final XLog log;

	/**
	 * Initialize the plugin by checking if any start events exist in the log
	 * 
	 * @param context
	 *            The pluginContext in which this plugin is executed.
	 * 
	 * @param log
	 *            The log that needs to be filtered.
	 * 
	 */

	public ObtainDurationWithStart(PluginContext context, XLog log) {
		this.log = log;
		resDurationList = new ArrayList<Pair<String, Long>>();
		startDatesList = new ArrayList<Date>();
		resNamesList = new TreeSet<String>();
		getEditedLog();

	}

	private void getEditedLog() {
		String rNamest = null;
		String caseId = null;
		String aName = null;
		Date startDate = null;
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				String eventType = XLifecycleExtension.instance().extractTransition(event);
				if (eventType.equals(""start"")) {
					startDate = XTimeExtension.instance().extractTimestamp(event);
					caseId = XConceptExtension.instance().extractName(trace);
					aName = XConceptExtension.instance().extractName(event);
					rNamest = XOrganizationalExtension.instance().extractResource(event);

				} else if (eventType.equals(""complete"")) {
					String cid = XConceptExtension.instance().extractName(trace);
					String aNameC = XConceptExtension.instance().extractName(event);
					Date compDate = XTimeExtension.instance().extractTimestamp(event);
					if (caseId != null) {
						if (cid.equals(caseId)) {
							if (aName != null) {
								if (aName.equals(aNameC)) {
									startDatesList.add(startDate);
									long stTime = startDate.getTime();
									long compsTime = compDate.getTime();
									long serviceTimes = compsTime - stTime;
									serviceTimes = serviceTimes / 1000;
									serviceTimes = serviceTimes / 60;

									resDurPair = new Pair<String, Long>(rNamest, serviceTimes);
									resDurationList.add(resDurPair);
									resNamesList.add(rNamest);

								}

							}

						}
					}

				}
			}
		}

	}

	public List<Pair<String, Long>> getResDateDetails() {
		return resDurationList;
	}

	public Set<String> getResNames() {
		return resNamesList;
	}

}
"
LogPartitionerAlgorithm.java,logskeleton-6.9.91,"package org.processmining.logskeleton.algorithms;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeList;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;

public class LogPartitionerAlgorithm {

	private void partition(EventLogArray logs, Set<String> positiveFilters, Set<String> negativeFilters, XEventClassifier classifier) {
		XLog log = logs.getLog(logs.getSize() - 1);
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XLog discardedLog = XFactoryRegistry.instance().currentDefault().createLog(log.getAttributes());
		for (XTrace trace : log) {
			boolean ok = true;
			Set<String> toMatch = new HashSet<String>(positiveFilters);
			for (XEvent event : trace) {
				String activity = classifier.getClassIdentity(event);
				if (negativeFilters.contains(activity)) {
					ok = false;
					;
				}
				toMatch.remove(activity);
			}
			if (ok && toMatch.isEmpty()) {
				filteredLog.add(trace);
			} else {
				discardedLog.add(trace);
			}
		}
		logs.removeLog(logs.getSize() - 1);

		logs.addLog(filteredLog);
		logs.addLog(discardedLog);
	}

	public EventLogArray apply(XLog log, XEventClassifier classifier) {
		String name = XConceptExtension.instance().extractName(log);
		Set<String> activities = new HashSet<String>();
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				activities.add(classifier.getClassIdentity(event));
			}
		}
		List<String> activityList = new ArrayList<String>(activities);
		Collections.sort(activityList);
		String line= """";
		for (String activity : activityList) {
			line = line + activity + "","";
		}
		line = line + ""#"";
		System.out.println(line);
		EventLogArray logs = EventLogArrayFactory.createEventLogArray();
		logs.addLog(log);
		Set<String> positiveFilters = new HashSet<String>();
		while (!log.isEmpty()) {
			Map<Set<String>, Double> scores = new HashMap<Set<String>, Double>();
			double maxScore = 0;
			Set<String> negativeFilters = new HashSet<String>();
			for (XTrace trace : log) {
				Set<String> score = new HashSet<String>();
				for (XEvent event : trace) {
					score.add(classifier.getClassIdentity(event));
				}
				if (!scores.containsKey(score)) {
					scores.put(score, 1.0 / (trace.size() + 1));
				} else {
					scores.put(score, scores.get(score) + (1.0 / (trace.size() + 1)));
				}
				if (scores.get(score) > maxScore) {
					maxScore = scores.get(score);
				}
			}
			List<String> bestScore = null;
			XAttributeList list = XFactoryRegistry.instance().currentDefault().createAttributeList(""activities"", null);
			for (Set<String> score : scores.keySet()) {
				if (bestScore == null && scores.get(score) == maxScore) {
					bestScore = new ArrayList<String>(score);
					Collections.sort(bestScore);
					negativeFilters.addAll(activityList);
					negativeFilters.removeAll(score);
					for (String s : bestScore) {
						list.addToCollection(XFactoryRegistry.instance().currentDefault()
								.createAttributeLiteral(XConceptExtension.KEY_NAME, s, XConceptExtension.instance()));
					}
				}
			}
			partition(logs, positiveFilters, negativeFilters, classifier);
			log = logs.getLog(logs.getSize() - 2);
			XConceptExtension.instance().assignName(log, name + "" @"" + (logs.getSize() - 1) + "" |"" + log.size() + ""| "" + bestScore);
			line= """";
			for (String activity : activityList) {
				if (bestScore.contains(activity)) {
					line = line + ""1,"";
				} else {
					line = line + ""0,"";
				}
			}
			line = line + log.size();
			System.out.println(line);
			log.getAttributes().put(""activities"", list);
			log = logs.getLog(logs.getSize() - 1);
		}
		return logs;
	}

}
"
LogPreprocessorAlgorithm.java,logskeleton-6.9.91,"package org.processmining.logskeleton.algorithms;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.logskeleton.models.ClassificationProblem;

public class LogPreprocessorAlgorithm {

	public ClassificationProblem preprocess(PluginContext context, ClassificationProblem problem) {
		return problem;
	}
	
	public String toString() {
		return ""None"";
	}
}
"
LogSkeletonBuilderAlgorithm.java,logskeleton-6.9.91,"package org.processmining.logskeleton.algorithms;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.log.models.EventLogArray;
import org.processmining.log.models.impl.EventLogArrayFactory;
import org.processmining.logskeleton.models.LogSkeleton;
import org.processmining.logskeleton.models.LogSkeletonCount;

public class LogSkeletonBuilderAlgorithm {

	public LogSkeleton apply(XLog log, XEventClassifier classifier) {
		LogSkeletonCount countModel = count(log, classifier);
		countModel.print(""Count model"");
		EventLogArray logs = split(log);
		Collection<LogSkeletonCount> counts = createCounts(logs, classifier);
		LogSkeleton constraintModel = new LogSkeleton(countModel);
		addSameCounts(counts, constraintModel);
		createCausalDependencies(log, classifier, countModel, constraintModel);
		String label = XConceptExtension.instance().extractName(log);
		constraintModel.setLabel(label == null ? ""<not specified>"" : label);
		return constraintModel;
	}

	public LogSkeletonCount count(XLog log, XEventClassifier classifier) {
		LogSkeletonCount model = new LogSkeletonCount();
		for (XTrace trace : log) {
			String activity;
			String prevActivity = LogSkeletonCount.STARTEVENT;
			model.inc(prevActivity);
			for (XEvent event : trace) {
				activity = classifier.getClassIdentity(event);
				model.inc(activity);
				model.inc(prevActivity, activity);
				prevActivity = activity;
			}
			activity = LogSkeletonCount.ENDEVENT;
			model.inc(activity);
			model.inc(prevActivity, activity);
		}
		return model;
	}

	private EventLogArray split(XLog log) {
		int N = log.size();
		EventLogArray logs = EventLogArrayFactory.createEventLogArray();
		for (int i = 0; i < N; i++) {
			logs.addLog(i, XFactoryRegistry.instance().currentDefault().createLog());
		}
		int i = 0;
		for (XTrace trace : log) {
			logs.getLog(i).add(trace);
			i++;
			if (i == N) {
				i = 0;
			}
		}
		return logs;
	}

	private Collection<LogSkeletonCount> createCounts(EventLogArray logs, XEventClassifier classifier) {
		Collection<LogSkeletonCount> models = new ArrayList<LogSkeletonCount>();
		for (int i = 0; i < logs.getSize(); i++) {
			XLog log = logs.getLog(i);
			models.add(count(log, classifier));
		}
		return models;
	}

	private void addSameCounts(Collection<LogSkeletonCount> countModels, LogSkeleton constraintModel) {
		Map<List<Integer>, Set<String>> map = new HashMap<List<Integer>, Set<String>>();
		Set<String> activities = new HashSet<String>();
		for (LogSkeletonCount countModel : countModels) {
			activities.addAll(countModel.getActivities());
		}
		for (String activity : activities) {
			List<Integer> count = new ArrayList<Integer>();
			for (LogSkeletonCount countModel : countModels) {
				count.add(countModel.get(activity));
			}
			if (map.containsKey(count)) {
				map.get(count).add(activity);
			} else {
				Set<String> newCount = new HashSet<String>();
				newCount.add(activity);
				map.put(count, newCount);
			}
		}

		boolean changed = true;
		int size = map.keySet().isEmpty() ? 0 : map.keySet().iterator().next().size();
		for (int noiseLevel = 0; noiseLevel < 21; noiseLevel++) {
			Map<List<Integer>, Set<String>> map2 = new HashMap<List<Integer>, Set<String>>();
			for (List<Integer> c : map.keySet()) {
				map2.put(c, new HashSet<String>(map.get(c)));
			}
			while (changed) {
				changed = false;
				for (List<Integer> c1 : map2.keySet()) {
					for (List<Integer> c2 : map2.keySet()) {
						int distance = distance(c1, c2);
						if (!map2.get(c1).equals(map2.get(c2)) && 100 * distance(c1, c2) < noiseLevel * size) {
							map2.get(c1).addAll(map2.get(c2));
							map2.get(c2).addAll(map2.get(c1));
							changed = true;
						}
					}
				}
			}

			for (Set<String> sameCount : map2.values()) {
				constraintModel.addSameCount(noiseLevel, sameCount);
			}
			map = map2;
			changed = true;
		}
	}

	private int distance(List<Integer> c1, List<Integer> c2) {
		int distance = 0;
		int size = Math.min(c1.size(), c2.size());
		for (int i = 0; i < size; i++) {
			distance += Math.abs(c1.get(i) - c2.get(i));
		}
		return distance;
	}

	private void createCausalDependencies(XLog log, XEventClassifier classifier, LogSkeletonCount model, LogSkeleton constraintModel) {
		for (XTrace trace : log) {
			List<String> postset = new ArrayList<String>();
			postset.add(LogSkeletonCount.STARTEVENT);
			for (XEvent event : trace) {
				postset.add(classifier.getClassIdentity(event));
			}
			postset.add(LogSkeletonCount.ENDEVENT);
			Set<String> preset = new HashSet<String>();
			String prevActivity = null;
			while (!postset.isEmpty()) {
				if (prevActivity != null) {
					preset.add(prevActivity);
				}
				String activity = postset.remove(0);
				constraintModel.addPrePost(activity, preset, postset);
				prevActivity = activity;
			}
		}
		constraintModel.cleanPrePost();
	}
}
"
LogSkeletonCheckerAlgorithm.java,logskeleton-6.9.91,"package org.processmining.logskeleton.algorithms;

import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.logskeleton.models.LogSkeleton;
import org.processmining.logskeleton.models.LogSkeletonCount;

public class LogSkeletonCheckerAlgorithm {

	public XLog apply(LogSkeleton skeleton, XLog log, XEventClassifier classifier, Set<String> messages, boolean[] checks) {
		XLog classifiedLog = XFactoryRegistry.instance().currentDefault().createLog();
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog();
		LogSkeletonBuilderAlgorithm algorithm = new LogSkeletonBuilderAlgorithm();
		
		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount traceModel = algorithm.count(traceLog, classifier);
			traceModel.print(""Trace "" + XConceptExtension.instance().extractName(trace));
			if (skeleton.check(trace, traceModel, messages, checks)) {
				classifiedLog.add(trace);
			}
		}
		return classifiedLog;
	}
}
"
LogSkeletonClassifierAlgorithm.java,logskeleton-6.9.91,"package org.processmining.logskeleton.algorithms;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.logskeleton.models.ClassificationProblem;
import org.processmining.logskeleton.models.LogSkeleton;
import org.processmining.logskeleton.models.LogSkeletonCount;
import org.processmining.logskeleton.plugins.LogSkeletonBuilderPlugin;
import org.processmining.logskeleton.plugins.LogSkeletonCheckerPlugin;

public class LogSkeletonClassifierAlgorithm {

	public XLog apply(PluginContext context, XLog trainingLog, XLog testLog, XEventClassifier classifier, LogPreprocessorAlgorithm preprocessor) {
		String name = XConceptExtension.instance().extractName(trainingLog);

		ClassificationProblem problem = new ClassificationProblem(trainingLog, testLog);

		/*
		 * Preprocess the logs.
		 */
		problem = preprocessor.preprocess(context, problem);
		XLog filteredTrainingLog = problem.getTrainingLog();
		XLog filteredTestLog = problem.getTestLog();
		

		/*
		 * Build the log skeleton.
		 */
		LogSkeletonBuilderPlugin createPlugin = new LogSkeletonBuilderPlugin();
		LogSkeleton model = createPlugin.run(context, filteredTrainingLog);
		context.getProvidedObjectManager().createProvidedObject(""Model for "" + name, model, LogSkeleton.class, context);

		/*
		 * Use the log skeleton to classify the test traces.
		 */
		System.out.println(""[LogSkeletonClassifierAlgorithm] Classify "" + name + "" ======"");
		XLog classifiedTestLog = classify(context, model, filteredTrainingLog, filteredTestLog, classifier, name);
		context.getProvidedObjectManager().createProvidedObject(""Classified Log "" + name, classifiedTestLog,
				XLog.class, context);

		/*
		 * Return the log containing all assumed positive test traces.
		 */
		return classifiedTestLog;
	}

	private static XLog classify(PluginContext context, LogSkeleton trainingModel, XLog trainingLog, XLog testLog,
			XEventClassifier classifier, String name) {
		LogSkeletonBuilderPlugin createPlugin = new LogSkeletonBuilderPlugin();
		LogSkeletonCheckerPlugin checkPlugin = new LogSkeletonCheckerPlugin();
		Set<String> messages = new HashSet<String>();
		boolean[] checks = new boolean[] { true, true, false };
		XLog classifiedTestLog = checkPlugin.run(context, trainingModel, testLog, messages, checks);
		Set<String> positiveTestTraces = new HashSet<String>();
		int threshold = 0;
		for (XTrace trace : classifiedTestLog) {
			positiveTestTraces.add(XConceptExtension.instance().extractName(trace));
		}
		for (String message : messages) {
			System.out.println(""[LogSkeletonClassifierAlgorithm] "" + message);
		}
		for (int i = 0; i < 3; i++) {
			checks[0] = (i == 0);
			checks[1] = (i == 1);
			checks[2] = (i == 2);
			for (String activity : trainingModel.getActivities()) {
				if (positiveTestTraces.size() <= threshold) {
					continue;
				}
				if (activity == LogSkeletonCount.STARTEVENT || activity == LogSkeletonCount.ENDEVENT) {
					continue;
				}
				if (!trainingModel.getSameCounts(activity).iterator().next().equals(activity)) {
					continue;
				}

				for (int f = 0; f < 2; f++) {
					if (positiveTestTraces.size() <= threshold) {
						continue;
					}
					Set<String> positiveFilters = new HashSet<String>();
					Set<String> negativeFilters = new HashSet<String>();
					if (f == 0) {
						positiveFilters.add(activity);
					} else {
						negativeFilters.add(activity);
					}
										System.out.println(""[LogSkeletonClassifierAlgorithm] Positive = "" + positiveFilters + "", Negative = "" + negativeFilters);
					XLog filteredTrainingLog = filter(trainingLog, classifier, positiveFilters, negativeFilters);
					XLog filteredTestLog = filter(testLog, classifier, positiveFilters, negativeFilters);
					if (filteredTestLog.isEmpty() || filteredTrainingLog.isEmpty() || filteredTrainingLog.size() < 16) {
						continue;
					}
					//					System.out.println(""[PDC2017TestPlugin] Remaining traces 1: "" + filteredTrainingLog.size());
					LogSkeleton filteredTrainingModel = createPlugin.run(context, filteredTrainingLog);
					messages = new HashSet<String>();
					XLog classifiedFilteredTestLog = checkPlugin.run(context, filteredTrainingModel, filteredTestLog,
							messages, checks);
					for (XTrace subTrace : filteredTestLog) {
						//						if (positiveTestTraces.size() <= threshold) {
						//							continue;
						//						}
						if (!classifiedFilteredTestLog.contains(subTrace)) {
							String caseId = XConceptExtension.instance().extractName(subTrace);
							if (positiveTestTraces.remove(caseId)) {
								System.out.println(""[LogSkeletonClassifierAlgoritmm] Case ""
										+ XConceptExtension.instance().extractName(subTrace)
										+ "" excluded by positive filter "" + positiveFilters + "" and negative filter ""
										+ negativeFilters + "", support = "" + filteredTrainingLog.size());
								for (String message : messages) {
									System.out.println(""[LogSkeletonClassifierAlgoritmm] "" + message);
								}
							}
						}
					}
				}
			}
			for (String activity : trainingModel.getActivities()) {
				if (positiveTestTraces.size() <= threshold) {
					continue;
				}
				if (activity == LogSkeletonCount.STARTEVENT || activity == LogSkeletonCount.ENDEVENT) {
					continue;
				}
				if (!trainingModel.getSameCounts(activity).iterator().next().equals(activity)) {
					continue;
				}
				for (String activity2 : trainingModel.getActivities()) {
					if (positiveTestTraces.size() <= threshold) {
						continue;
					}
					if (activity2 == LogSkeletonCount.STARTEVENT || activity2 == LogSkeletonCount.ENDEVENT) {
						continue;
					}
					if (!trainingModel.getSameCounts(activity2).iterator().next().equals(activity2)) {
						continue;
					}
					if (trainingModel.getSameCounts(activity).contains(activity2)) {
						continue;
					}
					for (int f = 0; f < 4; f++) {
						if (positiveTestTraces.size() <= threshold) {
							continue;
						}
						Set<String> positiveFilters = new HashSet<String>();
						Set<String> negativeFilters = new HashSet<String>();
						if (f == 0 || f == 1) {
							positiveFilters.add(activity);
						} else {
							negativeFilters.add(activity);
						}
						if (f == 0 || f == 2) {
							positiveFilters.add(activity2);
						} else {
							negativeFilters.add(activity2);
						}
												System.out.println(""[LogSkeletonClassifierAlgorithm] Positive = "" + positiveFilters + "", Negative = "" + negativeFilters);
						XLog filteredTrainingLog = filter(trainingLog, classifier, positiveFilters, negativeFilters);
						XLog filteredTestLog = filter(testLog, classifier, positiveFilters, negativeFilters);
						if (filteredTestLog.isEmpty() || filteredTrainingLog.isEmpty()
								|| filteredTrainingLog.size() < 16) {
							continue;
						}
						//						System.out.println(""[PDC2017TestPlugin] Remaining traces 2: "" + filteredTrainingLog.size());
						LogSkeleton filteredTrainingModel = createPlugin.run(context, filteredTrainingLog);
						messages = new HashSet<String>();
						XLog classifiedFilteredTestLog = checkPlugin.run(context, filteredTrainingModel,
								filteredTestLog, messages, checks);
						for (XTrace subTrace : filteredTestLog) {
							//							if (positiveTestTraces.size() <= threshold) {
							//								continue;
							//							}
							if (!classifiedFilteredTestLog.contains(subTrace)) {
								String caseId = XConceptExtension.instance().extractName(subTrace);
								if (positiveTestTraces.remove(caseId)) {
									System.out.println(""[LogSkeletonClassifierAlgoritmm] Case ""
											+ XConceptExtension.instance().extractName(subTrace)
											+ "" excluded by positive filter "" + positiveFilters
											+ "" and negative filter "" + negativeFilters + "", support = ""
											+ filteredTrainingLog.size());
									for (String message : messages) {
										System.out.println(""[LogSkeletonClassifierAlgoritmm] "" + message);
									}
								}
							}
						}
					}
				}
			}
			for (String activity : trainingModel.getActivities()) {
				if (positiveTestTraces.size() <= threshold) {
					continue;
				}
				if (activity == LogSkeletonCount.STARTEVENT || activity == LogSkeletonCount.ENDEVENT) {
					continue;
				}
				if (!trainingModel.getSameCounts(activity).iterator().next().equals(activity)) {
					continue;
				}
				for (String activity2 : trainingModel.getActivities()) {
					if (positiveTestTraces.size() <= threshold) {
						continue;
					}
					if (activity2 == LogSkeletonCount.STARTEVENT || activity2 == LogSkeletonCount.ENDEVENT) {
						continue;
					}
					if (!trainingModel.getSameCounts(activity2).iterator().next().equals(activity2)) {
						continue;
					}
					if (trainingModel.getSameCounts(activity).contains(activity2)) {
						continue;
					}
					for (String activity3 : trainingModel.getActivities()) {
						if (positiveTestTraces.size() <= threshold) {
							continue;
						}
						if (activity3 == LogSkeletonCount.STARTEVENT || activity3 == LogSkeletonCount.ENDEVENT) {
							continue;
						}
						if (!trainingModel.getSameCounts(activity3).iterator().next().equals(activity3)) {
							continue;
						}
						if (trainingModel.getSameCounts(activity).contains(activity3)) {
							continue;
						}
						if (trainingModel.getSameCounts(activity2).contains(activity3)) {
							continue;
						}
						for (int f = 0; f < 8; f++) {
							if (positiveTestTraces.size() <= threshold) {
								continue;
							}
							Set<String> positiveFilters = new HashSet<String>();
							Set<String> negativeFilters = new HashSet<String>();
							if (f == 0 || f == 1 || f == 2 || f == 3) {
								positiveFilters.add(activity);
							} else {
								negativeFilters.add(activity);
							}
							if (f == 0 || f == 1 || f == 4 || f == 5) {
								positiveFilters.add(activity2);
							} else {
								negativeFilters.add(activity2);
							}
							if (f == 0 || f == 2 || f == 4 || f == 6) {
								positiveFilters.add(activity3);
							} else {
								negativeFilters.add(activity3);
							}
														System.out.println(""[LogSkeletonClassifierAlgorithm] Positive = "" + positiveFilters + "", Negative = "" + negativeFilters);
							XLog filteredTrainingLog = filter(trainingLog, classifier, positiveFilters, negativeFilters);
							XLog filteredTestLog = filter(testLog, classifier, positiveFilters, negativeFilters);
							if (filteredTestLog.isEmpty() || filteredTrainingLog.isEmpty()
									|| filteredTrainingLog.size() < 16) {
								continue;
							}
							//						System.out.println(""[PDC2017TestPlugin] Remaining traces 2: "" + filteredTrainingLog.size());
							LogSkeleton filteredTrainingModel = createPlugin.run(context, filteredTrainingLog);
							messages = new HashSet<String>();
							XLog classifiedFilteredTestLog = checkPlugin.run(context, filteredTrainingModel,
									filteredTestLog, messages, checks);
							for (XTrace subTrace : filteredTestLog) {
								//							if (positiveTestTraces.size() <= threshold) {
								//								continue;
								//							}
								if (!classifiedFilteredTestLog.contains(subTrace)) {
									String caseId = XConceptExtension.instance().extractName(subTrace);
									if (positiveTestTraces.remove(caseId)) {
										System.out.println(""[LogSkeletonClassifierAlgoritmm] Case ""
												+ XConceptExtension.instance().extractName(subTrace)
												+ "" excluded by positive filter "" + positiveFilters
												+ "" and negative filter "" + negativeFilters + "", support = ""
												+ filteredTrainingLog.size());
										for (String message : messages) {
											System.out.println(""[LogSkeletonClassifierAlgoritmm] "" + message);
										}
									}
								}
							}
						}

					}
				}
			}
		}
		XLog newClassifiedTestLog = XFactoryRegistry.instance().currentDefault().createLog();
		XConceptExtension.instance().assignName(newClassifiedTestLog, name + "" (classified)"");
		for (XTrace trace : classifiedTestLog) {
			if (positiveTestTraces.contains(XConceptExtension.instance().extractName(trace))) {
				newClassifiedTestLog.add(trace);
			}
		}
		return newClassifiedTestLog;
	}

	private static XLog filter(XLog log, XEventClassifier classifier, Set<String> positiveFilters, Set<String> negativeFilters) {
		XLog filteredLog = XFactoryRegistry.instance().currentDefault().createLog();
		for (XTrace trace : log) {
			boolean ok = true;
			Set<String> toMatch = new HashSet<String>(positiveFilters);
			for (XEvent event : trace) {
				String activity = classifier.getClassIdentity(event);
				if (negativeFilters.contains(activity)) {
					ok = false;
					;
				}
				toMatch.remove(activity);
			}
			if (ok && toMatch.isEmpty()) {
				filteredLog.add(trace);
			}
		}
		return filteredLog;
	}

	private static void addTrace(XLog log, List<String> activities) {
		XFactory factory = XFactoryRegistry.instance().currentDefault();
		XTrace trace = factory.createTrace();
		for (String activity : activities) {
			XEvent event = factory.createEvent();
			XConceptExtension.instance().assignName(event, activity);
			trace.add(event);
		}
		log.add(trace);
	}

}
"
SplitterAlgorithm.java,logskeleton-6.9.91,"package org.processmining.logskeleton.algorithms;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeLiteral;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.model.impl.XAttributeLiteralImpl;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

public class SplitterAlgorithm {

	public XLog apply(XLog log, XEventClassifier classifier, SplitterParameters parameters) {
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		for (XTrace trace : log) {
			XTrace filteredTrace = XFactoryRegistry.instance().currentDefault().createTrace(trace.getAttributes());
			int milestone = 0;
			for (XEvent event : trace) {
				String activity = classifier.getClassIdentity(event);
				if (activity.equals(parameters.getDuplicateActivity())) {
					XEvent filteredEvent = (XEvent) event.clone(); //XFactoryRegistry.instance().currentDefault().createEvent();
					if (event.getAttributes().containsKey(LogSkeletonClassifier.SUFFIX)) {
						((XAttributeLiteral) filteredEvent.getAttributes().get(LogSkeletonClassifier.SUFFIX)).setValue(event.getAttributes().get(LogSkeletonClassifier.SUFFIX)+ ""."" + milestone);
					} else {
						filteredEvent.getAttributes().put(LogSkeletonClassifier.SUFFIX, new XAttributeLiteralImpl(LogSkeletonClassifier.SUFFIX, ""."" + milestone));
					}
					filteredTrace.add(filteredEvent);
				} else {
					filteredTrace.add(event);
				}
				if (parameters.getMilestoneActivities().contains(activity)) {
					if (milestone == 0) {
						milestone++;
					}
				}
			}
			filteredLog.add(filteredTrace);
		}
		//		System.out.println(""[SplitterAlgorithm] Split log contains "" + filteredLog.size() + "" traces"");
		return filteredLog;
	}

	public XLog apply7B(XLog log, XEventClassifier classifier) {
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		for (XTrace trace : log) {
			XTrace filteredTrace = XFactoryRegistry.instance().currentDefault().createTrace(trace.getAttributes());
			for (int i = 0; i < trace.size(); i++) {
				if (i == trace.size() - 1 && classifier.getClassIdentity(trace.get(i)).equals(""b"")) {
					XEvent filteredEvent = (XEvent) trace.get(i).clone();
					trace.get(i).getAttributes().put(LogSkeletonClassifier.SUFFIX, new XAttributeLiteralImpl(LogSkeletonClassifier.SUFFIX, "".1""));
					filteredTrace.add(filteredEvent);
				} else if (i == trace.size() - 2 && classifier.getClassIdentity(trace.get(i)).equals(""b"")
						&& classifier.getClassIdentity(trace.get(i + 1)).equals(""s"")) {
					XEvent filteredEvent = (XEvent) trace.get(i).clone();
					trace.get(i).getAttributes().put(LogSkeletonClassifier.SUFFIX, new XAttributeLiteralImpl(LogSkeletonClassifier.SUFFIX, "".1""));
					filteredTrace.add(filteredEvent);
				} else if (classifier.getClassIdentity(trace.get(i)).equals(""b"")) {
					XEvent filteredEvent = (XEvent) trace.get(i).clone();
					trace.get(i).getAttributes().put(LogSkeletonClassifier.SUFFIX, new XAttributeLiteralImpl(LogSkeletonClassifier.SUFFIX, "".0""));
					filteredTrace.add(filteredEvent);
				} else {
					filteredTrace.add(trace.get(i));
				}
			}
			filteredLog.add(filteredTrace);
		}
		//		System.out.println(""[SplitterAlgorithm] Split log contains "" + filteredLog.size() + "" traces"");
		return filteredLog;
	}

	public XLog apply20194(XLog log) {
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		for (XTrace trace : log) {
			XTrace filteredTrace = XFactoryRegistry.instance().currentDefault().createTrace(trace.getAttributes());

			for (int i = 0; i < trace.size(); i++) {
				XEvent filteredEvent = XFactoryRegistry.instance().currentDefault().createEvent();
				XConceptExtension.instance().assignName(filteredEvent,
						XConceptExtension.instance().extractName(trace.get(i)));
				if (XConceptExtension.instance().extractName(trace.get(i)).equals(""c"")) {
					if (i == 4 || i == 5) {
						XConceptExtension.instance().assignName(filteredEvent, ""c.0"");
					} else if (i + 1 < trace.size() && new String("" w f ac ag aj r "").contains("" "" + XConceptExtension.instance().extractName(trace.get(i + 1)) + "" "")) {
						XConceptExtension.instance().assignName(filteredEvent, ""c.3"");
					} else if (i + 1 < trace.size() && XConceptExtension.instance().extractName(trace.get(i + 1)).equals(""as"")) {
						XConceptExtension.instance().assignName(filteredEvent, ""c.1"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""c.2"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""t"")) {
					if (new String("" am c b q "").contains("" "" + XConceptExtension.instance().extractName(trace.get(i - 1)) + "" "")) {
						XConceptExtension.instance().assignName(filteredEvent, ""t.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""t.1"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""ad"")) {
					if (i == trace.size() - 1) {
						XConceptExtension.instance().assignName(filteredEvent, ""ad.1"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""ad.0"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""as"")) {
					if (XConceptExtension.instance().extractName(trace.get(i - 1)).equals(""c"")) {
						XConceptExtension.instance().assignName(filteredEvent, ""as.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""as.1"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""e"")) {
					if (XConceptExtension.instance().extractName(trace.get(i - 1)).equals(""l"")) {
						XConceptExtension.instance().assignName(filteredEvent, ""e.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""e.1"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""aj"")) {
					if (i == 0 || i == 1) {
						XConceptExtension.instance().assignName(filteredEvent, ""aj.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""aj.1"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""f"")) {
					if (i == 6) {
						XConceptExtension.instance().assignName(filteredEvent, ""f.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""f.1"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""w"")) {
					if (i == 6) {
						XConceptExtension.instance().assignName(filteredEvent, ""w.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""w.1"");
					}
				} else if (XConceptExtension.instance().extractName(trace.get(i)).equals(""r"")) {
					if (XConceptExtension.instance().extractName(trace.get(i - 1)).equals(""as"")) {
						XConceptExtension.instance().assignName(filteredEvent, ""r.0"");
					} else {
						XConceptExtension.instance().assignName(filteredEvent, ""r.1"");
					}
				}
				filteredTrace.add(filteredEvent);
			}
			filteredLog.add(filteredTrace);
		}
		//		System.out.println(""[SplitterAlgorithm] Split log contains "" + filteredLog.size() + "" traces"");
		return filteredLog;
	}
	
}
"
LogSkeletonClassifier.java,logskeleton-6.9.91,"package org.processmining.logskeleton.classifiers;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XVisitor;

public class LogSkeletonClassifier implements XEventClassifier {

	private XEventClassifier prefixClassifier;
	public final static String SUFFIX = "".suffix"";
	
	public LogSkeletonClassifier() {
		this(new XEventNameClassifier());
	}
	
	public LogSkeletonClassifier(XEventClassifier classifier) {
		this.prefixClassifier = classifier;
	}
	
	public void accept(XVisitor arg0, XLog arg1) {
	}

	public String getClassIdentity(XEvent event) {
		if (event.getAttributes().containsKey(SUFFIX)) {
			return prefixClassifier.getClassIdentity(event) + event.getAttributes().get(SUFFIX).toString();
		}
		return prefixClassifier.getClassIdentity(event);
	}

	public String[] getDefiningAttributeKeys() {
		return prefixClassifier.getDefiningAttributeKeys();
	}

	public String name() {
		return null;
	}

	public boolean sameEventClass(XEvent arg0, XEvent arg1) {
		return false;
	}

	public void setName(String arg0) {
	}

}
"
ClassificationProblem.java,logskeleton-6.9.91,"package org.processmining.logskeleton.models;

import org.deckfour.xes.model.XLog;

public class ClassificationProblem {

	private XLog trainingLog;
	private XLog testLog;
	
	public ClassificationProblem(XLog trainingLog, XLog testLog) {
		this.trainingLog = trainingLog;
		this.testLog = testLog;
	}
	
	public XLog getTrainingLog() {
		return trainingLog;
	}
	
	public void setTrainingLog(XLog trainingLog) {
		this.trainingLog = trainingLog;
	}

	public XLog getTestLog() {
		return testLog;
	}

	public void setTestLog(XLog testLog) {
		this.testLog = testLog;
	}
	
}
"
LogSkeleton.java,logskeleton-6.9.91,"package org.processmining.logskeleton.models;

import java.awt.Color;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.annotations.AuthoredType;
import org.processmining.framework.annotations.Icon;
import org.processmining.framework.util.HTMLToString;
import org.processmining.logskeleton.parameters.LogSkeletonBrowser;
import org.processmining.logskeleton.parameters.LogSkeletonBrowserParameters;
import org.processmining.plugins.graphviz.dot.Dot;
import org.processmining.plugins.graphviz.dot.DotEdge;
import org.processmining.plugins.graphviz.dot.DotNode;

import com.csvreader.CsvReader;
import com.csvreader.CsvWriter;

@AuthoredType(typeName = ""Log skeleton"", affiliation = AuthoredType.TUE, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
@Icon(icon = ""rotule_30x35.png"")
public class LogSkeleton implements HTMLToString {

	/*
	 * Holds the counters and the directly-follows relation.
	 */
	private LogSkeletonCount countModel;

	/*
	 * The equivalence relation. If S is an element of sameCounts, then all
	 * elements of S are equivalent.
	 */
	private Collection<Collection<String>> sameCounts;
	private Map<Integer, Collection<Collection<String>>> sameCountsNoise;

	/*
	 * The precedence relation. If precedence.get(a).contains(b), then if a
	 * occurs, some b must occur before.
	 */
	private Map<String, ThresholdSet> precedences;

	/*
	 * The response relation. If response.get(a).contains(b), then if a occurs,
	 * some b must occur after.
	 */
	private Map<String, ThresholdSet> responses;

	private Map<String, ThresholdSet> notPrecedences;
	private Map<String, ThresholdSet> notResponses;

	/*
	 * The not co-existence relation. If notCoExistence.get(a).contains(b), then
	 * if a occurs, b may not occur (before or after).
	 */
	private Map<String, ThresholdSet> notCoExistences;

	private Set<String> required;
	private Set<String> forbidden;
	private List<List<String>> splitters;
	private String label;

	private int equivalenceThreshold;
	private int precedenceThreshold;
	private int responseThreshold;
	private int notCoExistenceeThreshold;

	//	private Map<List<String>, List<Integer>> distances;

	public LogSkeleton() {
		this(new LogSkeletonCount());
	}

	@SuppressWarnings(""unchecked"")
	public LogSkeleton(LogSkeletonCount countModel) {
		this.countModel = countModel;
		//		sameCounts = new HashSet<Collection<String>>();
		sameCountsNoise = new HashMap<Integer, Collection<Collection<String>>>();
		for (int noiseLevel = 0; noiseLevel < 21; noiseLevel++) {
			sameCountsNoise.put(noiseLevel, new HashSet<Collection<String>>());
		}
		sameCounts = sameCountsNoise.get(0);
		precedences = new HashMap<String, ThresholdSet>();
		responses = new HashMap<String, ThresholdSet>();
		notPrecedences = new HashMap<String, ThresholdSet>();
		notResponses = new HashMap<String, ThresholdSet>();
		notCoExistences = new HashMap<String, ThresholdSet>();
		required = new HashSet<String>();
		forbidden = new HashSet<String>();
		splitters = new ArrayList<List<String>>();
		label = null;
		setEquivalenceThreshold(100);
		setPrecedenceThreshold(100);
		setResponseThreshold(100);
		setNotCoExistenceThreshold(100);
	}

	public void addSameCount(Collection<String> activities) {
		List<String> orderedActivities = new ArrayList<String>(activities);
		Collections.sort(orderedActivities);
		sameCounts.add(orderedActivities);
	}

	public void addSameCount(int noiseLevel, Collection<String> activities) {
		List<String> orderedActivities = new ArrayList<String>(activities);
		Collections.sort(orderedActivities);
		sameCountsNoise.get(noiseLevel).add(orderedActivities);
	}

	public Collection<String> getSameCounts(String activity) {
		for (Collection<String> sameCount : sameCounts) {
			if (sameCount.contains(activity)) {
				return sameCount;
			}
		}
		return null;
	}

	public void addPrePost(String activity, Collection<String> pre, Collection<String> post) {
		Set<String> preset = new HashSet<String>(pre);
		Set<String> postset = new HashSet<String>(post);
		if (!precedences.containsKey(activity)) {
			precedences.put(activity, new ThresholdSet(countModel.getActivities(), precedenceThreshold));
		}
		if (!responses.containsKey(activity)) {
			responses.put(activity, new ThresholdSet(countModel.getActivities(), responseThreshold));
		}
		if (!notPrecedences.containsKey(activity)) {
			notPrecedences.put(activity, new ThresholdSet(countModel.getActivities(), precedenceThreshold));
		}
		if (!notResponses.containsKey(activity)) {
			notResponses.put(activity, new ThresholdSet(countModel.getActivities(), responseThreshold));
		}
		if (!notCoExistences.containsKey(activity)) {
			notCoExistences.put(activity, new ThresholdSet(countModel.getActivities(), notCoExistenceeThreshold));
		}
		precedences.get(activity).addAll(preset);
		responses.get(activity).addAll(postset);
		Set<String> negPreset = new HashSet<String>(countModel.getActivities());
		negPreset.removeAll(preset);
		notPrecedences.get(activity).addAll(negPreset);
		Set<String> negPostset = new HashSet<String>(countModel.getActivities());
		negPostset.removeAll(postset);
		notResponses.get(activity).addAll(negPostset);
		Set<String> prepostset = new HashSet<String>(countModel.getActivities());
		prepostset.removeAll(preset);
		prepostset.removeAll(postset);
		notCoExistences.get(activity).addAll(prepostset);
	}

	public void cleanPrePost() {
		for (String activity : precedences.keySet()) {
			precedences.get(activity).reset();
		}
		for (String activity : responses.keySet()) {
			responses.get(activity).reset();
		}
		for (String activity : notPrecedences.keySet()) {
			notPrecedences.get(activity).reset();
		}
		for (String activity : notResponses.keySet()) {
			notResponses.get(activity).reset();
		}
		for (String activity : notCoExistences.keySet()) {
			notPrecedences.get(activity).removeAll(notCoExistences.get(activity));
			notResponses.get(activity).removeAll(notCoExistences.get(activity));
		}
		Map<String, Set<String>> precedences2 = new HashMap<String, Set<String>>();
		Map<String, Set<String>> responses2 = new HashMap<String, Set<String>>();
		Map<String, Set<String>> negPrecedences2 = new HashMap<String, Set<String>>();
		Map<String, Set<String>> negResponses2 = new HashMap<String, Set<String>>();
		for (String activity : countModel.getActivities()) {
			precedences2.put(activity, new HashSet<String>(precedences.get(activity)));
			responses2.put(activity, new HashSet<String>(responses.get(activity)));
			negPrecedences2.put(activity, new HashSet<String>(notPrecedences.get(activity)));
			negResponses2.put(activity, new HashSet<String>(notResponses.get(activity)));
		}
		for (String activity : countModel.getActivities()) {
			cleanPrePost(activity, precedences, precedences2);
			cleanPrePost(activity, responses, responses2);
			cleanPrePost(activity, notPrecedences, negPrecedences2);
			cleanPrePost(activity, notResponses, negResponses2);
		}
	}

	private void cleanPrePost(String activity, Map<String, ThresholdSet> map, Map<String, Set<String>> map2) {
		Set<String> mappedActivities = map2.get(activity);
		Set<String> mappedMappedActivities = new HashSet<String>();
		for (String mappedActivity : mappedActivities) {
			for (String mappedMappedActivity : map2.get(mappedActivity)) {
				if (!map2.get(mappedMappedActivity).contains(mappedActivity)) {
					mappedMappedActivities.add(mappedMappedActivity);
				}
			}
		}
//		System.out.println(""[LogSkeleton] "" + activity + "" "" + mappedMappedActivities);
		map.get(activity).removeAll(mappedMappedActivities);
	}

	private boolean checkSameCounts(LogSkeletonCount model, Set<String> messages, String caseId) {
		boolean ok = true;
		for (Collection<String> sameCount : sameCounts) {
			Set<Integer> counts = new HashSet<Integer>();
			for (String activity : sameCount) {
				counts.add(model.get(activity));
			}
			if (counts.size() != 1) {
				messages.add(""[LogSkeleton] Case "" + caseId + "": Always Together fails for "" + sameCount);
				ok = false;
			}
		}
		return ok;
	}

	private boolean checkTransitionCounts(LogSkeletonCount model, Set<String> messages, String caseId) {
		return countModel.checkTransitionCounts(model, messages, caseId);
	}

	private boolean checkCausalDependencies(XTrace trace, Set<String> messages) {
		String caseId = XConceptExtension.instance().extractName(trace);
		List<String> postset = new ArrayList<String>();
		postset.add(LogSkeletonCount.STARTEVENT);
		for (XEvent event : trace) {
			postset.add(XConceptExtension.instance().extractName(event));
		}
		postset.add(LogSkeletonCount.ENDEVENT);
		List<String> preset = new ArrayList<String>();
		String prevActivity = null;
		while (!postset.isEmpty()) {
			if (prevActivity != null) {
				preset.add(prevActivity);
			}
			String activity = postset.remove(0);
			if (precedences.containsKey(activity) && !preset.containsAll(precedences.get(activity))) {
				Set<String> missing = new HashSet<String>(precedences.get(activity));
				missing.removeAll(preset);
				messages.add(""[LogSkeleton] Case "" + caseId + "": Precedence fails for "" + activity + "", missing are ""
						+ missing);
				return false;
			}
			if (responses.containsKey(activity) && !postset.containsAll(responses.get(activity))) {
				Set<String> missing = new HashSet<String>(responses.get(activity));
				missing.removeAll(postset);
				messages.add(""[LogSkeleton] Case "" + caseId + "": Response fails for "" + activity + "", missing are ""
						+ missing);
				return false;
			}
			Set<String> notPreset = new HashSet<String>(countModel.getActivities());
			notPreset.removeAll(preset);
			if (notPrecedences.containsKey(activity) && !notPreset.containsAll(notPrecedences.get(activity))) {
				Set<String> present = new HashSet<String>(notPrecedences.get(activity));
				present.removeAll(notPreset);
				messages.add(""[LogSkeleton] Case "" + caseId + "": Not Precedence fails for "" + activity + "", present are ""
						+ present);
				return false;
			}
			Set<String> notPostset = new HashSet<String>(countModel.getActivities());
			notPostset.removeAll(postset);
			if (notResponses.containsKey(activity) && !notPostset.containsAll(notResponses.get(activity))) {
				Set<String> present = new HashSet<String>(notResponses.get(activity));
				present.removeAll(notPostset);
				messages.add(""[LogSkeleton] Case "" + caseId + "": Not Response fails for "" + activity + "", present are ""
						+ present);
				return false;
			}
			prevActivity = activity;
		}
		return true;
	}

	public boolean check(XTrace trace, LogSkeletonCount model, Set<String> messages, boolean[] checks) {
		boolean ok = true;
		if (checks[0]) {
			ok = ok && checkSameCounts(model, messages, XConceptExtension.instance().extractName(trace));
			if (!ok) {
				return false;
			}
		}
		if (checks[1]) {
			ok = ok && checkCausalDependencies(trace, messages);
			if (!ok) {
				return false;
			}
		}
		if (checks[2]) {
			ok = ok && checkTransitionCounts(model, messages, XConceptExtension.instance().extractName(trace));
			if (!ok) {
				return false;
			}
		}
		return ok;
	}

	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buf = new StringBuffer();
		List<String> sorted;
		if (includeHTMLTags) {
			buf.append(""<html>"");
		}
		buf.append(""<h1>Causal relations</h1><table>"");
		buf.append(
				""<tr><th>Activity</th><th>Sibling activities</th><th>Count</th><th>Precedence</th><th>Response</th><th>Not co-occurrence</th></tr>"");
		for (String activity : countModel.getActivities()) {
			// Activity
			buf.append(""<tr><td>"" + activity + ""</td>"");
			// Sibling activities and count
			for (Collection<String> siblings : sameCounts) {
				if (siblings.contains(activity)) {
					// Activities
					sorted = new ArrayList<String>(siblings);
					Collections.sort(sorted);
					sorted.remove(activity);
					buf.append(""<td>"" + sorted + ""</td>"");
					// Count
					buf.append(""<td>"" + countModel.get(activity) + ""</td>"");
				}
			}
			// Precedence
			sorted = new ArrayList<String>(precedences.get(activity));
			Collections.sort(sorted);
			buf.append(""<td>"" + sorted + ""</td>"");
			// Response
			sorted = new ArrayList<String>(responses.get(activity));
			Collections.sort(sorted);
			buf.append(""<td>"" + sorted + ""</td>"");
			// Not co-occurrence
			sorted = new ArrayList<String>(countModel.getActivities());
			sorted.removeAll(notCoExistences.get(activity));
			Collections.sort(sorted);
			buf.append(""<td>"" + sorted + ""</td>"");
		}
		buf.append(""</table>"");
		if (includeHTMLTags) {
			buf.append(""</html>"");
		}
		return buf.toString();
	}

	public Dot visualize(LogSkeletonBrowserParameters parameters) {
		Map<String, DotNode> map = new HashMap<String, DotNode>();
		Dot graph = new Dot();
		//		graph.setOption(""concentrate"", ""true"");
		//		graph.setKeepOrderingOfChildren(true);
		// Set312 color scheme, with white as last resort.
		String[] set312Colors = new String[] { ""#8dd3c7"", ""#ffffb3"", ""#bebada"", ""#fb8072"", ""#80b1d3"", ""#fdb462"",
				""#b3de69"", ""#fccde5"", ""#d9d9d9"", ""#bc80bd"", ""#ccebc5"", ""#ffed6f"" };
		//		String[] colors = new String[] { ""#8dd3c7"", ""#ffffb3"", ""#bebada"", ""#fb8072"", ""#80b1d3"", ""#fdb462"", ""#b3de69"",
		//				""#fccde5"", ""#d9d9d9"", ""#bc80bd"", ""#ccebc5"", ""#ffed6f"", ""#8dd3c7:#ffffb3"", ""#bebada:#fb8072"",
		//				""#80b1d3:#fdb462"", ""#b3de69:#fccde5"", ""#d9d9d9:#bc80bd"", ""#ccebc5:#ffed6f"", ""#ffffb3:#bebada"",
		//				""#fb8072:#80b1d3"", ""#fdb462:#b3de69"", ""#fccde5:#d9d9d9"", ""#bc80bd:#ccebc5"", ""#ffed6f:#8dd3c7"", ""white"" };
		String[] colors = new String[100];
		for (int i = 0; i < 99; i++) {
			int m = i / 12;
			int d = i % 12;
			if (m == 0) {
				// Basic color, no gradient.
				colors[i] = set312Colors[i];
			} else {
				// Extended color, gradient.
				colors[i] = set312Colors[d] + "":"" + set312Colors[(d + m) % 12];
			}
		}
		// Fall-back color
		colors[99] = ""white"";

		int colorIndex = 0;
		Map<String, String> colorMap = new HashMap<String, String>();

		Set<String> activities = new HashSet<String>(parameters.getActivities());

		setPrecedenceThreshold(parameters.getPrecedenceThreshold());
		setResponseThreshold(parameters.getResponseThreshold());
		setNotCoExistenceThreshold(parameters.getNotCoExistenceThreshold());

		if (parameters.isUseNeighbors()) {
			for (String fromActivity : countModel.getActivities()) {
				for (String toActivity : countModel.getActivities()) {
					if (parameters.getActivities().contains(fromActivity)
							|| parameters.getActivities().contains(toActivity)) {
						if (parameters.getVisualizers().contains(LogSkeletonBrowser.ALWAYSAFTER)) {
							if (responses.get(fromActivity).contains(toActivity)) {
								activities.add(fromActivity);
								activities.add(toActivity);
							}
						}
						if (parameters.getVisualizers().contains(LogSkeletonBrowser.ALWAYSBEFORE)) {
							if (precedences.get(toActivity).contains(fromActivity)) {
								activities.add(fromActivity);
								activities.add(toActivity);
							}
						}
						if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEVERAFTER)) {
							if (notResponses.get(fromActivity).contains(toActivity)) {
								activities.add(fromActivity);
								activities.add(toActivity);
							}
						}
						if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEVERBEFORE)) {
							if (notPrecedences.get(toActivity).contains(fromActivity)) {
								activities.add(fromActivity);
								activities.add(toActivity);
							}
						}
						//						if (parameters.getVisualizers().contains(LogSkeletonBrowser.OFTENNEXT)) {
						//							if (countModel.get(toActivity, fromActivity) == 0
						//									&& (5 * countModel.get(fromActivity, toActivity) > countModel.get(fromActivity))) {
						//								activities.add(fromActivity);
						//								activities.add(toActivity);
						//							}
						//						}
						//						if (parameters.getVisualizers().contains(LogSkeletonBrowser.OFTENPREVIOUS)) {
						//							if (countModel.get(toActivity, fromActivity) == 0
						//									&& (5 * countModel.get(fromActivity, toActivity) > countModel.get(toActivity))) {
						//								activities.add(fromActivity);
						//								activities.add(toActivity);
						//							}
						//						}
						if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEVERTOGETHER)) {
							if (!fromActivity.equals(toActivity)) {
								if (fromActivity.compareTo(toActivity) >= 0
										&& (!parameters.isUseEquivalenceClass()
												|| fromActivity.equals(getSameCounts(fromActivity).iterator().next()))
										&& (!parameters.isUseEquivalenceClass()
												|| toActivity.equals(getSameCounts(toActivity).iterator().next()))
										&& notCoExistences.get(fromActivity).contains(toActivity)) {
									activities.add(fromActivity);
									activities.add(toActivity);
								}
							}
						}
						//						if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEXTONEWAY)) {
						//							if (countModel.get(fromActivity, toActivity) > 0
						//									&& countModel.get(toActivity, fromActivity) == 0) {
						//								activities.add(fromActivity);
						//								activities.add(toActivity);
						//							}
						//						}
						//						if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEXTBOTHWAYS)) {
						//							if (fromActivity.compareTo(toActivity) <= 0) {
						//								if (countModel.get(fromActivity, toActivity) > 0
						//										&& countModel.get(toActivity, fromActivity) > 0) {
						//									activities.add(fromActivity);
						//									activities.add(toActivity);
						//								}
						//							}
						//						}
					}
				}
			}
		}

		for (String activity : activities) {
			String colorActivity = getSameCounts(activity).iterator().next();
			String activityColor = colorMap.get(colorActivity);
			if (activityColor == null) {
				activityColor = colors[colorIndex];
				colorMap.put(colorActivity, activityColor);
				if (colorIndex < colors.length - 1) {
					colorIndex++;
				}
			}
			String interval = """" + countModel.getMin(activity);
			if (countModel.getMax(activity) > countModel.getMin(activity)) {
				interval += "".."" + countModel.getMax(activity);
			}
			int border = 0;
			if (parameters.getActivities().contains(activity)) {
				border = 1;
			}

			DotNode node = graph.addNode(""<<table align=\""center\"" bgcolor=\"""" + activityColor + ""\"" border=\"""" + border
					+ ""\"" cellborder=\""0\"" cellpadding=\""2\"" columns=\""*\"" style=\""rounded\""><tr><td colspan=\""3\""><font point-size=\""24\""><b>""
					+ encodeHTML(activity) + ""</b></font></td></tr><hr/><tr><td>"" + colorActivity + ""</td><td>""
					+ countModel.get(activity) + ""</td>"" + ""<td>"" + interval + ""</td>"" + ""</tr></table>>"");
			node.setOption(""shape"", ""none"");
			//			DotNode node = graph.addNode(activity + ""\n"" + countModel.get(activity));
			//			node.setLabel(""<"" + encodeHTML(activity) + "">"");
			map.put(activity, node);
		}

		String defaultColor = darker(""#d9d9d9"");
		String almostNeverColor = ""#fdb462"";
		String neverColor = darker(almostNeverColor);
		String almostAlwaysColor = ""#80b1d3"";
		String alwaysColor = darker(almostAlwaysColor);
		String almostAlwaysNotColor = ""#fb8072"";
		String alwaysNotColor = darker(almostAlwaysNotColor);

		for (String fromActivity : activities) {
			for (String toActivity : activities) {
				if (parameters.getActivities().contains(fromActivity)
						|| parameters.getActivities().contains(toActivity)) {
					String tailDecorator = null;
					String headDecorator = null;
					String tailLabel = null;
					String headLabel = null;
					String tailArrow = null;
					String headArrow = null;
					String headColor = null;
					String tailColor = null;
					boolean isAsymmetric = true;
					if (parameters.getVisualizers().contains(LogSkeletonBrowser.ALWAYSAFTER)) {
						if (tailDecorator == null && responses.get(fromActivity).contains(toActivity)) {
							tailDecorator = ""noneinv"";
//							headArrow = ""normal"";
							tailColor = alwaysColor;
							int threshold = responses.get(fromActivity).getMaxThreshold(toActivity);
							if (threshold < 100) {
								tailLabel = ""."" + threshold;
								tailColor = almostAlwaysColor;
							}
							//							System.out.println(""[LogSkeleton] tailLabel = "" + tailLabel);
						}
					}
					if (parameters.getVisualizers().contains(LogSkeletonBrowser.ALWAYSBEFORE)) {
						if (headDecorator == null && precedences.get(toActivity).contains(fromActivity)) {
							headDecorator = ""normal"";
//							headArrow = ""normal"";
							headColor = alwaysColor;
							int threshold = precedences.get(toActivity).getMaxThreshold(fromActivity);
							if (threshold < 100) {
								headLabel = ""."" + threshold;
								headColor = almostAlwaysColor;
							}
							//							System.out.println(""[LogSkeleton] headLabel = "" + headLabel);
						}
					}
					//					if (parameters.getVisualizers().contains(LogSkeletonBrowser.OFTENNEXT)) {
					//						if (tailDecorator == null && countModel.get(toActivity, fromActivity) == 0
					//								&& (5 * countModel.get(fromActivity, toActivity) > countModel.get(fromActivity))) {
					//							tailDecorator = ""odot"";
					//							headArrow = ""normal"";
					//							headLabel = """" + countModel.get(fromActivity, toActivity);
					//						}
					//					}
					//					if (parameters.getVisualizers().contains(LogSkeletonBrowser.OFTENPREVIOUS)) {
					//						if (headDecorator == null && countModel.get(toActivity, fromActivity) == 0
					//								&& (5 * countModel.get(fromActivity, toActivity) > countModel.get(toActivity))) {
					//							headDecorator = ""odot"";
					//							headArrow = ""normal"";
					//							headLabel = """" + countModel.get(fromActivity, toActivity);
					//						}
					//					}
					if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEVERTOGETHER)) {
						if (!fromActivity.equals(toActivity)) {
							if (headDecorator == null && fromActivity.compareTo(toActivity) >= 0
									&& (!parameters.isUseEquivalenceClass()
											|| fromActivity.equals(getSameCounts(fromActivity).iterator().next()))
									&& (!parameters.isUseEquivalenceClass()
											|| toActivity.equals(getSameCounts(toActivity).iterator().next()))
									&& notCoExistences.get(toActivity).contains(fromActivity)) {
								headDecorator = ""nonetee"";
								//								dummy = true;
								isAsymmetric = false;
								headColor = neverColor;
								int threshold = notCoExistences.get(toActivity).getMaxThreshold(fromActivity);
								if (threshold < 100) {
									headLabel = ""."" + threshold;
									headColor = almostNeverColor;
								}
							}
							if (tailDecorator == null && fromActivity.compareTo(toActivity) >= 0
									&& (!parameters.isUseEquivalenceClass()
											|| fromActivity.equals(getSameCounts(fromActivity).iterator().next()))
									&& (!parameters.isUseEquivalenceClass()
											|| toActivity.equals(getSameCounts(toActivity).iterator().next()))
									&& notCoExistences.get(fromActivity).contains(toActivity)) {
								tailDecorator = ""nonetee"";
								//								dummy = true;
								isAsymmetric = false;
								tailColor = neverColor;
								int threshold = notCoExistences.get(fromActivity).getMaxThreshold(toActivity);
								if (threshold < 100) {
									tailLabel = ""."" + threshold;
									tailColor = almostNeverColor;
								}
							}
						}
					}
					if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEVERAFTER)) {
						if (!fromActivity.equals(toActivity) && headDecorator == null
								&& notResponses.get(toActivity).contains(fromActivity) 
								/*&& !notResponses.get(fromActivity).contains(toActivity)*/) {
							headDecorator = ""noneinvtee"";
//							tailArrow = ""normal"";
							headColor = alwaysNotColor;
							int threshold = notResponses.get(toActivity).getMaxThreshold(fromActivity);
							if (threshold < 100) {
								headLabel = ""."" + threshold;
								headColor = almostAlwaysNotColor;
							}
							//							System.out.println(""[LogSkeleton] tailLabel = "" + tailLabel);
						}
					}
					if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEVERBEFORE)) {
						if (!fromActivity.equals(toActivity) && tailDecorator == null
								&& notPrecedences.get(fromActivity).contains(toActivity)
								/*&& !notPrecedences.get(toActivity).contains(fromActivity)*/) {
							tailDecorator = ""teenormal"";
//							tailArrow = ""normal"";
							tailColor = alwaysNotColor;
							int threshold = notPrecedences.get(fromActivity).getMaxThreshold(toActivity);
							if (threshold < 100) {
								tailLabel = ""."" + threshold;
								tailColor = almostAlwaysNotColor;
							}
							//							System.out.println(""[LogSkeleton] tailLabel = "" + tailLabel);
						}
					}
					//					if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEXTONEWAY)) {
					//						if (tailDecorator == null && countModel.get(fromActivity, toActivity) > 0
					//								&& countModel.get(toActivity, fromActivity) == 0) {
					//							tailDecorator = ""odot"";
					//							if (headLabel == null) {
					//								headLabel = """" + countModel.get(fromActivity, toActivity);
					//							}
					//							if (headArrow == null) {
					//								headArrow = ""normal"";
					//							}
					//						}
					//					}
					//					if (parameters.getVisualizers().contains(LogSkeletonBrowser.NEXTBOTHWAYS)) {
					//						if (fromActivity.compareTo(toActivity) <= 0) {
					//							if (tailDecorator == null && countModel.get(fromActivity, toActivity) > 0
					//									&& countModel.get(toActivity, fromActivity) > 0) {
					//								tailDecorator = ""odot"";
					//								if (headLabel == null) {
					//									headLabel = """" + countModel.get(fromActivity, toActivity);
					//								}
					//								if (headArrow == null) {
					//									headArrow = ""normal"";
					//								}
					//							}
					//							if (headDecorator == null && countModel.get(fromActivity, toActivity) > 0
					//									&& countModel.get(toActivity, fromActivity) > 0) {
					//								headDecorator = ""odot"";
					//								if (tailLabel == null) {
					//									tailLabel = """" + countModel.get(toActivity, fromActivity);
					//								}
					//								if (tailArrow == null) {
					//									tailArrow = ""vee"";
					//								}
					//							}
					//						}
					//					}
					if (tailDecorator != null || headDecorator != null || tailArrow != null || headArrow != null) {
						DotEdge arc = graph.addEdge(map.get(fromActivity), map.get(toActivity));
						arc.setOption(""dir"", ""both"");
						if (tailDecorator == null) {
							tailDecorator = """";
						}
						if (tailArrow == null) {
							tailArrow = ""none"";
						}
						if (headDecorator == null) {
							headDecorator = """";
						}
						if (headArrow == null) {
							headArrow = ""none"";
						}
						arc.setOption(""arrowtail"", tailDecorator + tailArrow);
						arc.setOption(""arrowhead"", headDecorator + headArrow);
						if (parameters.isUseFalseConstraints() && !isAsymmetric) {
							arc.setOption(""constraint"", ""false"");
						}
						if (parameters.isUseEdgeColors() && (headColor != null || tailColor != null)) {
							String color = (tailColor == null ? defaultColor : tailColor) + "";0.5:""
									+ (headColor == null ? defaultColor : headColor) + "";0.5"";
							arc.setOption(""color"", color);
						}
						//						arc.setOption(""constraint"", ""true"");
						if (parameters.isUseHeadTailLabels()) {
							if (headLabel != null) {
								arc.setOption(""headlabel"", headLabel);
							}
							if (tailLabel != null) {
								arc.setOption(""taillabel"", tailLabel);
							}
						} else if (headLabel != null || tailLabel != null) {
							String label = """";
							if (tailLabel != null) {
								label += tailLabel;
							}
							label += ""&rarr;"";
							if (headLabel != null) {
								label += headLabel;
							}
							arc.setLabel(label);
						}
					}
				}
			}
		}

		if (parameters.isUseHyperArcs())

		{
			/*
			 * Sort the arcs to get a (more) deterministic result.
			 */
			List<DotEdge> candidateArcs = new ArrayList<DotEdge>(graph.getEdges());
			Collections.sort(candidateArcs, new Comparator<DotEdge>() {

				public int compare(DotEdge o1, DotEdge o2) {
					int c = o1.getSource().getLabel().compareTo(o2.getSource().getLabel());
					if (c == 0) {
						c = o1.getTarget().getLabel().compareTo(o2.getTarget().getLabel());
					}
					return c;
				}

			});

			/*
			 * Iterate over all arcs in the (current!) graph.
			 * 
			 * Note that the graph may change in the process.
			 */
			while (!candidateArcs.isEmpty()) {
				/*
				 * Get the next arc.
				 */
				DotEdge arc = candidateArcs.iterator().next();
				/*
				 * For now, only do this for always-arcs. Includes always-not (not response, not precendence) arcs.
				 */
				if (arc.getOption(""arrowtail"").contains(""inv"") || arc.getOption(""arrowhead"").contains(""inv"")
						|| arc.getOption(""arrowtail"").contains(""inv"") 
						|| arc.getOption(""arrowhead"").contains(""normal"")) {
					/*
					 * Get the cluster for this arc.
					 */
					DotNode sourceNode = arc.getSource();
					DotNode targetNode = arc.getTarget();
					Set<DotNode> sourceNodes = new HashSet<DotNode>();
					sourceNodes.add(sourceNode);
					Set<DotNode> targetNodes = new HashSet<DotNode>();
					targetNodes.add(targetNode);
					boolean changed = true;
					while (changed) {
						changed = false;
						for (DotEdge anotherArc : graph.getEdges()) {
							if (isEqual(arc, anotherArc)) {
								if (sourceNodes.contains(anotherArc.getSource())) {
									changed = changed || targetNodes.add(anotherArc.getTarget());
								}
								if (targetNodes.contains(anotherArc.getTarget())) {
									changed = changed || sourceNodes.add(anotherArc.getSource());
								}
							}
						}
					}

					/*
					 * Get a biggest maximal clique in the cluster.
					 */
					Set<DotEdge> arcs = getMaximalClique(graph, sourceNodes, targetNodes, arc.getOption(""arrowtail""),
							arc.getOption(""arrowhead""), arc.getLabel(), arc, new HashSet<List<Set<DotNode>>>());

					if (arcs != null) {
						/*
						 * A maximal clique was found. Update the sources and
						 * targets to this clique.
						 */
						sourceNodes.clear();
						targetNodes.clear();
						for (DotEdge a : arcs) {
							sourceNodes.add(a.getSource());
							targetNodes.add(a.getTarget());
						}
						//						System.out.println(""[LogSkeleton] "" + sourceNodes + "" -> "" + targetNodes);
						/*
						 * Add a connector node to the graph.
						 */
						DotNode connector = graph.addNode("""");
						connector.setOption(""shape"", ""point"");
						/*
						 * Add arcs from and to the new connector node.
						 */
						for (DotNode node : sourceNodes) {
							DotEdge a = graph.addEdge(node, connector);
							a.setOption(""dir"", ""both"");
							a.setOption(""arrowtail"", arc.getOption(""arrowtail""));
							a.setOption(""arrowhead"", ""none"");
							if (arc.getOption(""taillabel"") != null) {
								a.setOption(""taillabel"", arc.getOption(""taillabel""));
							}
							if (arc.getLabel() != null) {
								String[] labels2 = arc.getLabel().split(""&rarr;"");
								if (labels2.length == 2) {
									System.out.println(""[LogSkeleton] set label1 "" + labels2[0]);
									a.setLabel(labels2[0]);
								} else {
									a.setLabel(arc.getLabel());
								}
							}
							if (arc.getOption(""color"") != null) {
								String[] colors2 = arc.getOption(""color"").split(""[;:]"");
								if (colors2.length == 4) {
									System.out.println(""[LogSkeleton] set color1 "" + colors[0]);
									a.setOption(""color"", colors2[0]);
								} else {
									a.setOption(""color"", arc.getOption(""color""));
								}
							}
							candidateArcs.add(a);
						}
						for (DotNode node : targetNodes) {
							DotEdge a = graph.addEdge(connector, node);
							a.setOption(""dir"", ""both"");
							a.setOption(""arrowtail"", ""none"");
							a.setOption(""arrowhead"", arc.getOption(""arrowhead""));
							if (arc.getOption(""headlabel"") != null) {
								a.setOption(""headlabel"", arc.getOption(""headlabel""));
							}
							if (arc.getLabel() != null) {
								String[] labels2 = arc.getLabel().split(""&rarr;"");
								if (labels2.length == 2) {
									System.out.println(""[LogSkeleton] set label2 "" + labels2[1]);
									a.setLabel(labels2[1]);
								} else {
									a.setLabel(arc.getLabel());
								}
							}
							if (arc.getOption(""color"") != null) {
								String[] colors2 = arc.getOption(""color"").split(""[;:]"");
								if (colors2.length == 4) {
									System.out.println(""[LogSkeleton] set color2 "" + colors[2]);
									a.setOption(""color"", colors2[2]);
								} else {
									a.setOption(""color"", arc.getOption(""color""));
								}
							}
							candidateArcs.add(a);
						}
						/*
						 * Remove the old arcs, they have now been replaced with
						 * the newly added connector node and arcs.
						 */
						for (DotEdge anotherArc : arcs) {
							graph.removeEdge(anotherArc);
						}
						candidateArcs.removeAll(arcs);
						/*
						 * Sort the arcs again, as some have been added.
						 */
						Collections.sort(candidateArcs, new Comparator<DotEdge>() {

							public int compare(DotEdge o1, DotEdge o2) {
								int c = o1.getSource().getLabel().compareTo(o2.getSource().getLabel());
								if (c == 0) {
									c = o1.getTarget().getLabel().compareTo(o2.getTarget().getLabel());
								}
								return c;
							}

						});
					} else {
						/*
						 * No maximal clique was found, leave the arc as-is.
						 */
						candidateArcs.remove(arc);
					}
				} else {
					/*
					 * Not an always-arc, leave the arc as-is.
					 */
					candidateArcs.remove(arc);
				}
			}
		}

		graph.setOption(""labelloc"", ""b"");
		graph.setOption(""nodesep"", ""0.5"");
		//		String label = ""Event Log: "" + (this.label == null ? ""<not specified>"" : this.label) + ""\\l"";
		//		if (!required.isEmpty()) {
		//			label += ""Required Activities Filters: "" + required + ""\\l"";
		//		}
		//		if (!forbidden.isEmpty()) {
		//			label += ""Forbidden Activities Filters: "" + forbidden + ""\\l"";
		//		}
		//		if (!splitters.isEmpty()) {
		//			label += ""Activity Splitters: "" + splitters + ""\\l"";
		//		}
		List<String> selectedActivities = new ArrayList<String>(parameters.getActivities());
		Collections.sort(selectedActivities);
		//		label += ""Show Activities: "" + activities + ""\\l"";
		//		label += ""Show Constraints: "" + parameters.getVisualizers() + ""\\l"";
		String label = ""<table bgcolor=\""gold\"" cellborder=\""0\"" cellpadding=\""0\"" columns=\""3\"" style=\""rounded\"">"";
		label +=

				encodeHeader(""Skeleton Configuration"");
		label += encodeRow(""Event Log"", this.label == null ? ""<not specified>"" : this.label);
		if (!required.isEmpty()) {
			label += encodeRow(""Required Activities Filter"", required.toString());
		}
		if (!forbidden.isEmpty()) {
			label += encodeRow(""Forbidden Activities Filter"", forbidden.toString());
		}
		if (!splitters.isEmpty()) {
			label += encodeRow(""Activity Splitters"", splitters.toString());
		}
		label += encodeRow(""View Activities"", selectedActivities.toString());
		label += encodeRow(""View Constraints"", parameters.getVisualizers().toString());
		if (equivalenceThreshold < 100) {
			label += encodeRow(""Noise Threshold"", """" + (100 - equivalenceThreshold) + ""%"");
		}
		label += ""</table>"";
		graph.setOption(""fontsize"", ""8.0"");
		graph.setOption(""label"", ""<"" + label + "">"");
		//		graph.setOption(""labeljust"", ""l"");
		return graph;
	}

	private String darker(String color) {
		Color darkerColor = Color.decode(color).darker();
		return ""#"" + Integer.toHexString(darkerColor.getRed()) + Integer.toHexString(darkerColor.getGreen())
				+ Integer.toHexString(darkerColor.getBlue());
	}

	private boolean isEqual(DotEdge e1, DotEdge e2) {
		if (!isEqual(e1.getOption(""arrowtail""), e2.getOption(""arrowtail""))) {
			return false;
		}
		if (!isEqual(e1.getOption(""arrowhead""), e2.getOption(""arrowhead""))) {
			return false;
		}
		if (!isEqual(e1.getOption(""headlabel""), e2.getOption(""headlabel""))) {
			return false;
		}
		if (!isEqual(e1.getOption(""taillabel""), e2.getOption(""taillabel""))) {
			return false;
		}
		if (!isEqual(e1.getLabel(), e2.getLabel())) {
			return false;
		}
		return true;
	}

	private boolean isEqual(String s1, String s2) {
		if (s1 == null) {
			return s2 == null;
		}
		return s1.equals(s2);
	}

	private Set<DotEdge> getMaximalClique(Dot graph, Set<DotNode> sourceNodes, Set<DotNode> targetNodes,
			String arrowtail, String arrowhead, String label, DotEdge baseArc, Set<List<Set<DotNode>>> checkedNodes) {
		/*
		 * Make sure a clique is not too small.
		 */
		if (sourceNodes.size() < 2) {
			/*
			 * A single source. Do not look for a maximal clique.
			 */
			return null;
		}
		if (targetNodes.size() < 2) {
			/*
			 * A single target. Do not look for a maximal clique.
			 */
			return null;
		}
		/*
		 * Keep track of which combinations of sources and targets have already
		 * been checked. This prevents checking the same combinations many times
		 * over.
		 */
		List<Set<DotNode>> checked = new ArrayList<Set<DotNode>>();
		checked.add(new HashSet<DotNode>(sourceNodes));
		checked.add(new HashSet<DotNode>(targetNodes));
		checkedNodes.add(checked);
		/*
		 * Collect all matching arcs that go from some source to some target.
		 */
		Set<DotEdge> arcs = new HashSet<DotEdge>();
		for (DotEdge arc : graph.getEdges()) {
			if (isEqual(arc, baseArc)) {
				if (sourceNodes.contains(arc.getSource()) && targetNodes.contains(arc.getTarget())) {
					arcs.add(arc);
				}
			}
		}
		/*
		 * Check whether a maximal clique.
		 */
		if (arcs.size() == sourceNodes.size() * targetNodes.size()) {
			/*
			 * Yes.
			 */
			return arcs;
		}
		/*
		 * No, look for maximal cliques that have one node (source or target)
		 * less.
		 */
		Set<DotEdge> bestArcs = null; // Best solution so far.
		if (sourceNodes.size() > targetNodes.size()) {
			/*
			 * More sources than targets. Removing a source yields a possible
			 * bigger clique than removing a target. So, first try to remove a
			 * source, and only then try to remove a target.
			 */
			if (sourceNodes.size() > 2) {
				/*
				 * Try to find a maximal clique with one source removed. Sort
				 * the source nodes first to get a (more) deterministic result.
				 */
				List<DotNode> sortedSourceNodes = new ArrayList<DotNode>(sourceNodes);
				Collections.sort(sortedSourceNodes, new Comparator<DotNode>() {

					public int compare(DotNode o1, DotNode o2) {
						return o1.getLabel().compareTo(o2.getLabel());
					}

				});
				for (DotNode srcNode : sortedSourceNodes) {
					if (bestArcs == null || (sourceNodes.size() - 1) * targetNodes.size() > bestArcs.size()) {
						/*
						 * May result in a bigger clique than the best found so
						 * far. First, remove the node from the sources.
						 */
						Set<DotNode> nodes = new HashSet<DotNode>(sourceNodes);
						nodes.remove(srcNode);
						/*
						 * Check whether this combination of sources and targets
						 * was checked before.
						 */
						checked = new ArrayList<Set<DotNode>>();
						checked.add(nodes);
						checked.add(targetNodes);
						if (!checkedNodes.contains(checked)) {
							/*
							 * No, it was not. Check now.
							 */
							arcs = getMaximalClique(graph, nodes, targetNodes, arrowtail, arrowhead, label, baseArc,
									checkedNodes);
							if (bestArcs == null || (arcs != null && bestArcs.size() < arcs.size())) {
								/*
								 * Found a bigger maximal clique than the best
								 * found so far. Update.
								 */
								bestArcs = arcs;
							}
						}
					}
				}
			}
			if (targetNodes.size() > 2) {
				List<DotNode> sortedTargetNodes = new ArrayList<DotNode>(targetNodes);
				Collections.sort(sortedTargetNodes, new Comparator<DotNode>() {

					public int compare(DotNode o1, DotNode o2) {
						return o1.getLabel().compareTo(o2.getLabel());
					}

				});
				for (DotNode tgtNode : sortedTargetNodes) {
					if (bestArcs == null || sourceNodes.size() * (targetNodes.size() - 1) > bestArcs.size()) {
						Set<DotNode> nodes = new HashSet<DotNode>(targetNodes);
						nodes.remove(tgtNode);
						checked = new ArrayList<Set<DotNode>>();
						checked.add(sourceNodes);
						checked.add(nodes);
						if (!checkedNodes.contains(checked)) {
							arcs = getMaximalClique(graph, sourceNodes, nodes, arrowtail, arrowhead, label, baseArc,
									checkedNodes);
							if (bestArcs == null || (arcs != null && bestArcs.size() < arcs.size())) {
								bestArcs = arcs;
							}
						}
					}
				}
			}
		} else {
			/*
			 * The other way around.
			 */
			if (targetNodes.size() > 2) {
				List<DotNode> sortedTargetNodes = new ArrayList<DotNode>(targetNodes);
				Collections.sort(sortedTargetNodes, new Comparator<DotNode>() {

					public int compare(DotNode o1, DotNode o2) {
						return o1.getLabel().compareTo(o2.getLabel());
					}

				});
				for (DotNode tgtNode : sortedTargetNodes) {
					if (bestArcs == null || sourceNodes.size() * (targetNodes.size() - 1) > bestArcs.size()) {
						Set<DotNode> nodes = new HashSet<DotNode>(targetNodes);
						nodes.remove(tgtNode);
						checked = new ArrayList<Set<DotNode>>();
						checked.add(sourceNodes);
						checked.add(nodes);
						if (!checkedNodes.contains(checked)) {
							arcs = getMaximalClique(graph, sourceNodes, nodes, arrowtail, arrowhead, label, baseArc,
									checkedNodes);
							if (bestArcs == null || (arcs != null && bestArcs.size() < arcs.size())) {
								bestArcs = arcs;
							}
						}
					}
				}
			}
			if (sourceNodes.size() > 2) {
				List<DotNode> sortedSourceNodes = new ArrayList<DotNode>(sourceNodes);
				Collections.sort(sortedSourceNodes, new Comparator<DotNode>() {

					public int compare(DotNode o1, DotNode o2) {
						return o1.getLabel().compareTo(o2.getLabel());
					}

				});
				for (DotNode srcNode : sortedSourceNodes) {
					if (bestArcs == null || (sourceNodes.size() - 1) * targetNodes.size() > bestArcs.size()) {
						Set<DotNode> nodes = new HashSet<DotNode>(sourceNodes);
						nodes.remove(srcNode);
						checked = new ArrayList<Set<DotNode>>();
						checked.add(nodes);
						checked.add(targetNodes);
						if (!checkedNodes.contains(checked)) {
							arcs = getMaximalClique(graph, nodes, targetNodes, arrowtail, arrowhead, label, baseArc,
									checkedNodes);
							if (bestArcs == null || (arcs != null && bestArcs.size() < arcs.size())) {
								bestArcs = arcs;
							}
						}
					}
				}
			}
		}
		/*
		 * Return the biggest maximal clique found. Equals null if none found.
		 */
		return bestArcs;
	}

	private String encodeHeader(String title) {
		return ""<tr><td colspan=\""3\""><b>"" + encodeHTML(title) + ""</b></td></tr><hr/>"";
	}

	private String encodeRow(String label, String value) {
		return encodeRow(label, value, 0);
	}

	private String encodeRow(String label, String value, int padding) {
		return ""<tr><td align=\""right\""><i>"" + label + ""</i></td><td> : </td><td align=\""left\"">"" + encodeHTML(value)
				+ ""</td></tr>"";
	}

	private String encodeHTML(String s) {
		String s2 = s;
		if (s.length() > 2 && s.startsWith(""["") && s.endsWith(""]"")) {
			s2 = s.substring(1, s.length() - 1);
		}
		return s2.replaceAll(""&"", ""&amp;"").replaceAll(""\\<"", ""&lt;"").replaceAll(""\\>"", ""&gt;"");
	}

	public Dot createGraph(LogSkeletonBrowser visualizer) {
		LogSkeletonBrowserParameters parameters = new LogSkeletonBrowserParameters();
		parameters.getActivities().addAll(countModel.getActivities());
		parameters.getVisualizers().add(visualizer);
		return visualize(parameters);
	}

	public Dot createGraph(Set<LogSkeletonBrowser> visualizers) {
		LogSkeletonBrowserParameters parameters = new LogSkeletonBrowserParameters();
		parameters.getActivities().addAll(countModel.getActivities());
		parameters.getVisualizers().addAll(visualizers);
		return visualize(parameters);
	}

	public Dot createGraph(LogSkeletonBrowserParameters parameters) {
		return visualize(parameters);
	}

	public Collection<String> getActivities() {
		return countModel.getActivities();
	}

	public Set<String> getRequired() {
		return required;
	}

	public void setRequired(Set<String> required) {
		this.required = required;
	}

	public Set<String> getForbidden() {
		return forbidden;
	}

	public void setForbidden(Set<String> forbidden) {
		this.forbidden = forbidden;
	}

	public List<List<String>> getSplitters() {
		return splitters;
	}

	public void setSplitters(List<List<String>> splitters) {
		this.splitters = splitters;
	}

	public String getLabel() {
		return label;
	}

	public void setLabel(String label) {
		this.label = label;
	}

	public void exportToFile(CsvWriter writer) throws IOException {
		writer.write(label);
		writer.endRecord();
		countModel.exportToFile(writer);
		writer.write(""equivalence"");
		for (int noise = 0; noise < 21; noise++) {
			writer.write("""" + sameCountsNoise.get(noise).size());
		}
		for (int noise = 0; noise < 21; noise++) {
			writer.endRecord();
			for (Collection<String> activities : sameCountsNoise.get(noise)) {
				for (String activity : activities) {
					writer.write(activity);
				}
				writer.endRecord();
			}
		}
		writer.write(""precedence"");
		writer.write("""" + precedences.size());
		writer.endRecord();
		for (String activity : precedences.keySet()) {
			writer.write(activity);
			precedences.get(activity).exportToFile(writer);
			writer.endRecord();
		}
		writer.write(""response"");
		writer.write("""" + responses.size());
		writer.endRecord();
		for (String activity : responses.keySet()) {
			writer.write(activity);
			responses.get(activity).exportToFile(writer);
			writer.endRecord();
		}
		writer.write(""not precedence"");
		writer.write("""" + notPrecedences.size());
		writer.endRecord();
		for (String activity : notPrecedences.keySet()) {
			writer.write(activity);
			notPrecedences.get(activity).exportToFile(writer);
			writer.endRecord();
		}
		writer.write(""not response"");
		writer.write("""" + notResponses.size());
		writer.endRecord();
		for (String activity : notResponses.keySet()) {
			writer.write(activity);
			notResponses.get(activity).exportToFile(writer);
			writer.endRecord();
		}
		writer.write(""not co-occurrence"");
		writer.write("""" + notCoExistences.size());
		writer.endRecord();
		for (String activity : notCoExistences.keySet()) {
			writer.write(activity);
			notCoExistences.get(activity).exportToFile(writer);
			writer.endRecord();
		}
		writer.write(""required"");
		writer.write(required.isEmpty() ? ""0"" : ""1"");
		writer.endRecord();
		if (!required.isEmpty()) {
			for (String activity : required) {
				writer.write(activity);
			}
			writer.endRecord();
		}
		writer.write(""forbidden"");
		writer.write(forbidden.isEmpty() ? ""0"" : ""1"");
		writer.endRecord();
		if (!forbidden.isEmpty()) {
			for (String activity : forbidden) {
				writer.write(activity);
			}
			writer.endRecord();
		}
		writer.write(""splitters"");
		writer.write("""" + splitters.size());
		writer.endRecord();
		for (List<String> splitter : splitters) {
			for (String activity : splitter) {
				writer.write(activity);
			}
			writer.endRecord();
		}
		writer.endRecord();
	}

	public void importFromStream(CsvReader reader) throws IOException {
		if (reader.readRecord()) {
			label = reader.get(0);
		}
		sameCountsNoise = new HashMap<Integer, Collection<Collection<String>>>();
		for (int noise = 0; noise < 21; noise++) {
			sameCountsNoise.put(noise, new HashSet<Collection<String>>());
		}
		sameCounts = sameCountsNoise.get(0);
		countModel.importFromStream(reader);
		if (reader.readRecord()) {
			if (reader.get(0).equals(""always together"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						List<String> orderedActivities = new ArrayList<String>();
						for (int column = 0; column < reader.getColumnCount(); column++) {
							orderedActivities.add(reader.get(column));
						}
						Collections.sort(orderedActivities);
						for (int noise = 0; noise < 21; noise++) {
							sameCountsNoise.get(noise).add(orderedActivities);
						}
					}
				}
			} else if (reader.get(0).equals(""equivalence"")) {
				int rows[] = new int[21];
				for (int noise = 0; noise < 21; noise++) {
					rows[noise] = Integer.valueOf(reader.get(noise + 1));
				}
				for (int noise = 0; noise < 21; noise++) {
					for (int row = 0; row < rows[noise]; row++) {
						if (reader.readRecord()) {
							List<String> orderedActivities = new ArrayList<String>();
							for (int column = 0; column < reader.getColumnCount(); column++) {
								orderedActivities.add(reader.get(column));
							}
							Collections.sort(orderedActivities);
							sameCountsNoise.get(noise).add(orderedActivities);
						}
					}
				}
			}
		}
		precedences = new HashMap<String, ThresholdSet>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""always before"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						Set<String> activities = new HashSet<String>();
						for (int column = 1; column < reader.getColumnCount(); column++) {
							activities.add(reader.get(column));
						}
						precedences.put(activity, new ThresholdSet(countModel.getActivities(), precedenceThreshold));
						precedences.get(activity).addAll(activities);
					}
				}
			} else if (reader.get(0).equals(""precedence"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						precedences.put(activity, new ThresholdSet(countModel.getActivities(), precedenceThreshold));
						precedences.get(activity).importFromFile(reader);
					}
				}
			}
		}
		responses = new HashMap<String, ThresholdSet>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""always after"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						Set<String> activities = new HashSet<String>();
						for (int column = 1; column < reader.getColumnCount(); column++) {
							activities.add(reader.get(column));
						}
						responses.put(activity, new ThresholdSet(countModel.getActivities(), responseThreshold));
						responses.get(activity).addAll(activities);
					}
				}
			} else if (reader.get(0).equals(""response"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						responses.put(activity, new ThresholdSet(countModel.getActivities(), responseThreshold));
						responses.get(activity).importFromFile(reader);
					}
				}
			}
		}
		notPrecedences = new HashMap<String, ThresholdSet>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""not precedence"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						notPrecedences.put(activity, new ThresholdSet(countModel.getActivities(), precedenceThreshold));
						notPrecedences.get(activity).importFromFile(reader);
					}
				}
			}
		}
		notResponses = new HashMap<String, ThresholdSet>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""not response"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						notResponses.put(activity, new ThresholdSet(countModel.getActivities(), responseThreshold));
						notResponses.get(activity).importFromFile(reader);
					}
				}
			}
		}
		if (reader.readRecord()) {
			if (reader.get(0).equals(""sometimes before"")) {
				Map<String, Set<String>> anyPresets = new HashMap<String, Set<String>>();
				Map<String, Set<String>> anyPostsets = new HashMap<String, Set<String>>();
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						Set<String> activities = new HashSet<String>();
						for (int column = 1; column < reader.getColumnCount(); column++) {
							activities.add(reader.get(column));
						}
						anyPresets.put(activity, activities);
					}
				}
				if (reader.readRecord()) {
					if (reader.get(0).equals(""sometimes after"")) {
						rows = Integer.valueOf(reader.get(1));
						for (int row = 0; row < rows; row++) {
							if (reader.readRecord()) {
								String activity = reader.get(0);
								Set<String> activities = new HashSet<String>();
								for (int column = 1; column < reader.getColumnCount(); column++) {
									activities.add(reader.get(column));
								}
								anyPostsets.put(activity, activities);
							}
						}
					}
				}
				notCoExistences = new HashMap<String, ThresholdSet>();
				for (String activity : countModel.getActivities()) {
					Set<String> prepostset = new HashSet<String>();
					if (anyPresets.containsKey(activity)) {
						prepostset.addAll(anyPresets.get(activity));
					}
					if (anyPostsets.containsKey(activity)) {
						prepostset.addAll(anyPostsets.get(activity));
					}
					notCoExistences.put(activity,
							new ThresholdSet(countModel.getActivities(), notCoExistenceeThreshold));
					notCoExistences.get(activity).addAll(countModel.getActivities());
					notCoExistences.get(activity).removeAll(prepostset);
				}
			} else if (reader.get(0).equals(""not co-occurrence"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						String activity = reader.get(0);
						notCoExistences.put(activity,
								new ThresholdSet(countModel.getActivities(), notCoExistenceeThreshold));
						notCoExistences.get(activity).importFromFile(reader);
					}
				}
			}
		}
		required = new HashSet<String>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""required"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						for (int column = 0; column < reader.getColumnCount(); column++) {
							required.add(reader.get(column));
						}
					}
				}
			}
		}
		forbidden = new HashSet<String>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""forbidden"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						for (int column = 0; column < reader.getColumnCount(); column++) {
							forbidden.add(reader.get(column));
						}
					}
				}
			}
		}
		splitters = new ArrayList<List<String>>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""splitters"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						List<String> splitter = new ArrayList<String>();
						for (int column = 0; column < reader.getColumnCount(); column++) {
							splitter.add(reader.get(column));
						}
						splitters.add(splitter);
					}
				}
			}
		}
	}

	public Set<String> getAlwaysBefore(String activity) {
		if (precedences.containsKey(activity)) {
			return new HashSet<String>(precedences.get(activity));
		}
		return new HashSet<String>();
	}

	public Set<String> getAlwaysAfter(String activity) {
		if (responses.containsKey(activity)) {
			return new HashSet<String>(responses.get(activity));
		}
		return new HashSet<String>();
	}

	public void setPrecedenceThreshold(int precedenceThreshold) {
		this.precedenceThreshold = precedenceThreshold;
		for (String activity : precedences.keySet()) {
			precedences.get(activity).setThreshold(precedenceThreshold);
		}
		for (String activity : notPrecedences.keySet()) {
			notPrecedences.get(activity).setThreshold(precedenceThreshold);
		}
	}

	public int getResponseThreshold() {
		return responseThreshold;
	}

	public void setResponseThreshold(int responseThreshold) {
		this.responseThreshold = responseThreshold;
		for (String activity : responses.keySet()) {
			responses.get(activity).setThreshold(responseThreshold);
		}
		for (String activity : notResponses.keySet()) {
			notResponses.get(activity).setThreshold(responseThreshold);
		}
	}

	public int getNotCoExistenceThreshold() {
		return notCoExistenceeThreshold;
	}

	public void setNotCoExistenceThreshold(int notCoOccurencethreshold) {
		this.notCoExistenceeThreshold = notCoOccurencethreshold;
		for (String activity : notCoExistences.keySet()) {
			notCoExistences.get(activity).setThreshold(notCoOccurencethreshold);
		}
	}

	public boolean hasManyNotCoExistenceArcs(LogSkeletonBrowserParameters parameters) {
		int nr = 0;
		for (String fromActivity : countModel.getActivities()) {
			for (String toActivity : countModel.getActivities()) {
				if (!fromActivity.equals(toActivity)) {
					if (fromActivity.compareTo(toActivity) >= 0
							&& (!parameters.isUseEquivalenceClass()
									|| fromActivity.equals(getSameCounts(fromActivity).iterator().next()))
							&& (!parameters.isUseEquivalenceClass()
									|| toActivity.equals(getSameCounts(toActivity).iterator().next()))
							&& notCoExistences.get(fromActivity).contains(toActivity)) {
						nr++;
					}
				}
			}
		}
		/*
		 * Return whether there are too many Not Co-Existence constraints to
		 * show by default. THe first visualization should be reasonably fast.
		 * In case of too many Not Co-Existence constraints, this first
		 * visualization takes ages.
		 */
		return nr > 100;
	}

	public int getEquivalenceThreshold() {
		return equivalenceThreshold;
	}

	public void setEquivalenceThreshold(int equivalenceThreshold) {
		this.equivalenceThreshold = equivalenceThreshold;
		sameCounts = sameCountsNoise.get(100 - equivalenceThreshold);
	}
}
"
LogSkeletonCount.java,logskeleton-6.9.91,"package org.processmining.logskeleton.models;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.csvreader.CsvReader;
import com.csvreader.CsvWriter;

public class LogSkeletonCount {

	/*
	 * The names to use for the start and end events.
	 */
	public final static String STARTEVENT = ""|>"";
	public final static String ENDEVENT = ""[]"";

	/*
	 * Counts how many times an activity occurred in the entire log. 
	 * If activityCounts.get(a) == 4, then activity a occurred 4 times in the log.
	 */
	private Map<String, Integer> activityCounts;
	
	/*
	 * Counts the minimal number of times an activity occurs in any trace. 
	 * If activityMinCounts.get(a) == 1, then a occurs at least once in every trace in the log.
	 */
	private Map<String, Integer> activityMinCounts;
	
	/*
	 * Counts the maximal number of times an activity occurs in any trace. 
	 * If activityMinCounts.get(a) == 2, then a occurs at most twice in every trace in the log.
	 */
	private Map<String, Integer> activityMaxCounts;
	
	/*
	 * The directly follows relation. If ab is a list containing first a and then b, and if transitionCounts.get(ab) == 5, 
	 * then a was 5 times directly followed by b in the log. Note that the lists (like ab) have always length 2. 
	 */
	private Map<List<String>, Integer> transitionCounts;

	public LogSkeletonCount() {
		activityCounts = new HashMap<String, Integer>();
		activityMinCounts = new HashMap<String, Integer>();
		activityMaxCounts = new HashMap<String, Integer>();
		transitionCounts = new HashMap<List<String>, Integer>();
	}

	public boolean checkTransitionCounts(LogSkeletonCount model, Set<String> messages, String caseId) {
		for (List<String> transition : model.transitionCounts.keySet()) {
			if (!transitionCounts.keySet().contains(transition)) {
				messages.add(""[LogSkeletonCount] Case "" + caseId + "": Next fails for "" + transition);
				return false;
			}
			if (transitionCounts.get(transition) < model.transitionCounts.get(transition)) {
				messages.add(""[LogSkeletonCount] Case "" + caseId + "": Next fails for "" + transition);
				return false;
			}
		}
		return true;
	}

	public Integer get(String activity) {
		return activityCounts.containsKey(activity) ? activityCounts.get(activity) : 0;
	}

	public Integer getMin(String activity) {
		return activityMinCounts.containsKey(activity) ? activityMinCounts.get(activity) : 0;
	}

	public Integer getMax(String activity) {
		return activityMaxCounts.containsKey(activity) ? activityMaxCounts.get(activity) : 0;
	}

	public Integer get(String fromActivity, String toActivity) {
		List<String> transition = getTransition(fromActivity, toActivity);
		return transitionCounts.containsKey(transition) ? transitionCounts.get(transition) : 0;
	}

	public Collection<String> getTo(String fromActivity) {
		Collection<String> toActivities = new HashSet<String>();
		for (List<String> transition : transitionCounts.keySet()) {
			if (transition.get(0).equals(fromActivity)) {
				toActivities.add(transition.get(1));
			}
		}
		return toActivities;
	}

	public Collection<String> getFrom(String toActivity) {
		Collection<String> fromActivities = new HashSet<String>();
		for (List<String> transition : transitionCounts.keySet()) {
			if (transition.get(1).equals(toActivity)) {
				fromActivities.add(transition.get(0));
			}
		}
		return fromActivities;
	}

	public void add(String activity, Integer number) {
		if (activityCounts.containsKey(activity)) {
			activityCounts.put(activity, activityCounts.get(activity) + number);
		} else {
			activityCounts.put(activity, number);
		}
	}

	public void add(String fromActivity, String toActivity, Integer number) {
		List<String> transition = getTransition(fromActivity, toActivity);
		if (transitionCounts.containsKey(transition)) {
			transitionCounts.put(transition, transitionCounts.get(transition) + number);
		} else {
			transitionCounts.put(transition, number);
		}
	}

	private Map<String, Integer> traceActivities = new HashMap<String, Integer>();

	private void updateMinMax() {
		if (!activityMinCounts.isEmpty()) {
			for (String activity : traceActivities.keySet()) {
				if (!activityMinCounts.containsKey(activity)) {
					activityMinCounts.put(activity, 0);
				}
			}
			for (String activity : activityMinCounts.keySet()) {
				if (!traceActivities.containsKey(activity)) {
					activityMinCounts.put(activity, 0);
				}
			}
		}
		for (String activity : traceActivities.keySet()) {
			if (activityMinCounts.containsKey(activity)) {
				activityMinCounts.put(activity,
						Math.min(activityMinCounts.get(activity), traceActivities.get(activity)));
			} else {
				activityMinCounts.put(activity, traceActivities.get(activity));
			}
			if (activityMaxCounts.containsKey(activity)) {
				activityMaxCounts.put(activity,
						Math.max(activityMaxCounts.get(activity), traceActivities.get(activity)));
			} else {
				activityMaxCounts.put(activity, traceActivities.get(activity));

			}
		}
		traceActivities.clear();
	}

	public void inc(String activity) {
		add(activity, 1);
		if (traceActivities.containsKey(activity)) {
			traceActivities.put(activity, traceActivities.get(activity) + 1);
		} else {
			traceActivities.put(activity, 1);
		}
		if (activity.equals(ENDEVENT)) {
			updateMinMax();
		}
	}

	public void inc(String fromActivity, String toActivity) {
		add(fromActivity, toActivity, 1);
	}

	public Collection<String> getActivities() {
		List<String> ordered = new ArrayList<String>(activityCounts.keySet());
		Collections.sort(ordered);
		return ordered;
	}

	private List<String> getTransition(String fromActivity, String toActivity) {
		List<String> transition = new ArrayList<String>(2);
		transition.add(0, fromActivity);
		transition.add(1, toActivity);
		return transition;
	}

	public void print(String name) {
		//		System.out.println(""[PDC2017CountModel] Activity counts for "" + name);
		for (String activity : activityCounts.keySet()) {
			//			System.out.println(""[LogSkeletonCount] "" + activity + "": "" + activityCounts.get(activity));
		}
		//		System.out.println(""[PC2017CountModel] Transitions counts for "" + name);
		for (List<String> transition : transitionCounts.keySet()) {
			//			System.out.println(""[LogSkeletonCount] "" + transition + "": "" + transitionCounts.get(transition));
		}
	}

	public void exportToFile(CsvWriter writer) throws IOException {
		writer.write(""activity counts"");
		writer.write("""" + activityCounts.keySet().size());
		writer.endRecord();
		for (String activity : activityCounts.keySet()) {
			writer.write(activity);
			writer.write("""" + activityCounts.get(activity));
			writer.write("""" + activityMinCounts.get(activity));
			writer.write("""" + activityMaxCounts.get(activity));
			writer.endRecord();
		}
		writer.write(""transition counts"");
		writer.write("""" + transitionCounts.keySet().size());
		writer.endRecord();
		for (List<String> transitionList : transitionCounts.keySet()) {
			for (String transition : transitionList) {
				writer.write(transition);
			}
			writer.write("""" + transitionCounts.get(transitionList));
			writer.endRecord();
		}
	}

	public void importFromStream(CsvReader reader) throws IOException {
		activityCounts = new HashMap<String, Integer>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""activity counts"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						activityCounts.put(reader.get(0), Integer.valueOf(reader.get(1)));
						activityMinCounts.put(reader.get(0), Integer.valueOf(reader.get(2)));
						activityMaxCounts.put(reader.get(0), Integer.valueOf(reader.get(3)));
					}
				}
			}
		}
		transitionCounts = new HashMap<List<String>, Integer>();
		if (reader.readRecord()) {
			if (reader.get(0).equals(""transition counts"")) {
				int rows = Integer.valueOf(reader.get(1));
				for (int row = 0; row < rows; row++) {
					if (reader.readRecord()) {
						List<String> transitions = new ArrayList<String>();
						for (int column = 0; column < reader.getColumnCount() - 1; column++) {
							transitions.add(reader.get(column));
						}
						transitionCounts.put(transitions, Integer.valueOf(reader.get(reader.getColumnCount() - 1)));
					}
				}
			}
		}
	}
}
"
ThresholdSet.java,logskeleton-6.9.91,"package org.processmining.logskeleton.models;

import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import com.csvreader.CsvReader;
import com.csvreader.CsvWriter;

public class ThresholdSet implements Set<String> {

	private Map<String, Integer> countMap;
	private Map<String, Integer> totalMap;
	private int threshold;
	
	public ThresholdSet(Collection<String> set, int threshold) {
		countMap = new HashMap<String, Integer>();
		totalMap = new HashMap<String, Integer>();
		for (String activity : set) {
			countMap.put(activity, 0);
			totalMap.put(activity, 0);
		}
		this.threshold = threshold; 
	}

	public int size() {
		int size = 0;
		for (String activity : countMap.keySet()) {
			if (contains(activity)) {
				size++;
			}
		}
		return size;
	}
	
	public boolean isEmpty() {
		return size() == 0;
	}
	
	public boolean contains(Object o) {
		return (countMap.get(o) * 100 >= totalMap.get(o) * threshold);
	}

	public Iterator<String> iterator() {
		Set<String> set = new HashSet<String>();
		for (String activity : countMap.keySet()) {
			if (contains(activity)) {
				set.add(activity);
			}
		}
		return set.iterator();
	}
	
	public Object[] toArray() {
		// Not supported
		return null;
	}
	
	public <String> String[] toArray(String[] a) {
		// Not supported
		return null;
	}
	
	public boolean add(String e) {
		// Not supported
		return false;
	}
	
	public boolean remove(Object o) {
		// Not supported
		return false;
	}
	
	public boolean containsAll(Collection<?> c) {
		Set<String> set = new HashSet<String>();
		for (String activity : countMap.keySet()) {
			if (contains(activity)) {
				set.add(activity);
			}
		}
		return set.containsAll(c);
	}
	
	public boolean addAll(Collection<? extends String> c) {
		return retainAll(c);
	}
	
	public boolean retainAll(Collection<?> c) {
		for (String activity : countMap.keySet()) {
			if (c.contains(activity)) {
				countMap.put(activity, countMap.get(activity) + 1);
			}
			totalMap.put(activity, totalMap.get(activity) + 1);
		}
		return true;
	}
	
	public boolean removeAll(Collection<?> c) {
		for (String activity : countMap.keySet()) {
			if (c.contains(activity)) {
				countMap.put(activity, -Math.abs(countMap.get(activity))); 
			}
		}
		return true;
	}
	
	public void clear() {
		// Not supported		
	}

	public void reset() {
		for (String activity : countMap.keySet()) {
			countMap.put(activity, Math.abs(countMap.get(activity)));
		}
	}
	
	public void setThreshold(int threshold) {
		this.threshold = threshold;
	}
	
	public int getThreshold() {
		return threshold;
	}
	
	public int getMaxThreshold(Object o) {
		return countMap.get(o) * 100 / totalMap.get(o);
	}
	
	public void exportToFile(CsvWriter writer) throws IOException {
		writer.write("""" + threshold);
		for (String activity : countMap.keySet()) {
			writer.write("""" + activity);
			writer.write("""" + countMap.get(activity));
			writer.write("""" + totalMap.get(activity));
		}
	}
	
	public void importFromFile(CsvReader reader) throws IOException {
		threshold = Integer.valueOf(reader.get(1));
		for (int column = 2; column + 2 < reader.getColumnCount(); column += 3) {
			String activity = reader.get(column);
			int count = Integer.valueOf(reader.get(column + 1));
			int total = Integer.valueOf(reader.get(column + 2));
			countMap.put(activity, count);
			totalMap.put(activity, total);
		}
	}
}
"
LogSkeletonBrowser.java,logskeleton-6.9.91,"package org.processmining.logskeleton.parameters;

public enum LogSkeletonBrowser {
	
//	ALWAYSTOGETHER(""Always Together""),
	ALWAYSAFTER(""Response""),
	ALWAYSBEFORE(""Precedence""),
	NEVERAFTER(""Not Response""),
	NEVERBEFORE(""Not Precedence""),
	NEVERTOGETHER(""Not Co-Existence"");
//	OFTENNEXT(""Often Next""),
//	OFTENPREVIOUS(""Often Previous""),
//	NEVERTOGETHERSELF(""Never Together (Self)""),
//	SOMETIMESBEFORE(""Sometimes Before""),
//	SOMETIMESAFTER(""Sometimes After""),
//	NEXTONEWAY(""Next (One Way)""),
//	NEXTBOTHWAYS(""Next (Both Ways)"");
	
	private String label;

	private LogSkeletonBrowser(String label) {
		this.label = label;
	}
	
	public String toString() {
		return label;
	}
}
"
LogSkeletonBrowserParameters.java,logskeleton-6.9.91,"package org.processmining.logskeleton.parameters;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class LogSkeletonBrowserParameters {

	private Set<String> activities;
	private List<LogSkeletonBrowser> visualizers;
	private boolean useHyperArcs;
	private boolean useFalseConstraints;
	private boolean useEdgeColors;
	private boolean useEquivalenceClass;
	private boolean useNeighbors;
	private boolean useHeadTailLabels;
	private int precedenceThreshold;
	private int responseThreshold;
	private int notCoExistenceThreshold;

	public LogSkeletonBrowserParameters() {
		activities = new HashSet<String>();
		visualizers = new ArrayList<LogSkeletonBrowser>();
		/* 
		 * By default, do not use hyper arcs as finding the hyper arcs may take considerable time. 
		 */
		setUseHyperArcs(false);
		setUseFalseConstraints(true);
		setUseEdgeColors(true);
		setUseEquivalenceClass(true);
		setUseNeighbors(true);
		setUseHeadTailLabels(true);
		setPrecedenceThreshold(100);
		setResponseThreshold(100);
		setNotCoExistenceThreshold(100);
	}
	
	public Set<String> getActivities() {
		return activities;
	}

	public List<LogSkeletonBrowser> getVisualizers() {
		return visualizers;
	}

	public boolean isUseHyperArcs() {
		return useHyperArcs;
	}

	public void setUseHyperArcs(boolean useHyperArcs) {
		this.useHyperArcs = useHyperArcs;
	}

	public boolean isUseFalseConstraints() {
		return useFalseConstraints;
	}

	public void setUseFalseConstraints(boolean useFalseConstraints) {
		this.useFalseConstraints = useFalseConstraints;
	}

	public boolean isUseNeighbors() {
		return useNeighbors;
	}

	public void setUseNeighbors(boolean useNeighbors) {
		this.useNeighbors = useNeighbors;
	}

	public boolean isUseEdgeColors() {
		return useEdgeColors;
	}

	public void setUseEdgeColors(boolean useEdgeColors) {
		this.useEdgeColors = useEdgeColors;
	}

	public boolean isUseEquivalenceClass() {
		return useEquivalenceClass;
	}

	public void setUseEquivalenceClass(boolean useEquivalenceClass) {
		this.useEquivalenceClass = useEquivalenceClass;
	}

	public int getPrecedenceThreshold() {
		return precedenceThreshold;
	}

	public void setPrecedenceThreshold(int threshold) {
		this.precedenceThreshold = threshold;
	}

	public int getResponseThreshold() {
		return responseThreshold;
	}

	public void setResponseThreshold(int threshold) {
		this.responseThreshold = threshold;
	}

	public int getNotCoExistenceThreshold() {
		return notCoExistenceThreshold;
	}

	public void setNotCoExistenceThreshold(int threshold) {
		this.notCoExistenceThreshold = threshold;
	}

	public boolean isUseHeadTailLabels() {
		return useHeadTailLabels;
	}

	public void setUseHeadTailLabels(boolean useHeadTailLabels) {
		this.useHeadTailLabels = useHeadTailLabels;
	}
}
"
SplitterParameters.java,logskeleton-6.9.91,"package org.processmining.logskeleton.parameters;

import java.util.HashSet;
import java.util.Set;

public class SplitterParameters {

	private Set<String> milestoneActivities;
	private String recurrentActivity;
	
	public SplitterParameters() {
		milestoneActivities = new HashSet<String>();
	}
	public Set<String> getMilestoneActivities() {
		return milestoneActivities;
	}
	
	public String getDuplicateActivity() {
		return recurrentActivity;
	}
	
	public void setDuplicateActivity(String duplicateActivity) {
		this.recurrentActivity = duplicateActivity;
	}
}
"
PDC2016TestDialog.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2016.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JComponent;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.logskeleton.pdc2016.parameters.PDC2016TestParameters;
import org.processmining.pdc2016.algorithms.PDC2016Set;

public class PDC2016TestDialog extends JComponent {

	/**
	 * 
	 */
	private static final long serialVersionUID = -4347149448035402690L;
	
	public PDC2016TestDialog(final PDC2016TestParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL, TableLayoutConstants.FILL },
				{ TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));
		setOpaque(false);

		DefaultListModel<PDC2016Set> setListModel = new DefaultListModel<PDC2016Set>();
		int[] selectedIndices = new int[parameters.getSets().size()];
		int i = 0;
		int j = 0;
		List<PDC2016Set> sortedSets = new ArrayList<PDC2016Set>();
		sortedSets.addAll(parameters.getAllSets());
		Collections.sort(sortedSets, new Comparator<PDC2016Set>() {
			public int compare(PDC2016Set set1, PDC2016Set set2) {
				return set1.toString().compareTo(set2.toString());
			}
		});
		for (PDC2016Set set : sortedSets) {
			setListModel.addElement(set);
			if (parameters.getSets().contains(set)) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<PDC2016Set> setList = new ProMList<PDC2016Set>(""Select log set(s)"", setListModel);
		setList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		setList.setSelectedIndices(selectedIndices);
		setList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<PDC2016Set> selectedSets = setList.getSelectedValuesList();
				parameters.setSets(new HashSet<PDC2016Set>(selectedSets));
			}
		});
		setList.setPreferredSize(new Dimension(100, 100));
		add(setList, ""0, 0"");

		DefaultListModel<Integer> nrListModel = new DefaultListModel<Integer>();
		selectedIndices = new int[parameters.getAllNrs().size()];
		i = 0;
		j = 0;
		for (int nr : parameters.getAllNrs()) {
			nrListModel.addElement(nr);
			if (parameters.getNrs().contains(nr)) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<Integer> nrList = new ProMList<Integer>(""Select log number(s)"", nrListModel);
		nrList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		nrList.setSelectedIndices(selectedIndices);
		nrList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<Integer> selectedNrs = nrList.getSelectedValuesList();
				parameters.setNrs(new HashSet<Integer>(selectedNrs));
			}
		});
		nrList.setPreferredSize(new Dimension(100, 100));
		add(nrList, ""1, 0"");
		
	}
}
"
PDC2016TestModel.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2016.models;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.HTMLToString;
import org.processmining.logskeleton.pdc2016.parameters.PDC2016TestParameters;
import org.processmining.pdc2016.algorithms.PDC2016Set;

public class PDC2016TestModel implements HTMLToString {

	private List<Integer> numbers;
	private List<XLog> cal1Logs;
	private List<XLog> cal2Logs;
	private List<XLog> testLogs;
	private PDC2016TestParameters parameters;

	public PDC2016TestModel(PDC2016TestParameters parameters) {
		numbers = new ArrayList<Integer>();
		cal1Logs = new ArrayList<XLog>();
		cal2Logs = new ArrayList<XLog>();
		testLogs = new ArrayList<XLog>();
		this.parameters = parameters;
	}

	public void add(int i, XLog cal1Log, XLog cal2Log, XLog testLog) {
		numbers.add(i);
		if (cal1Log != null) {
			cal1Logs.add(cal1Log);
		}
		if (cal2Log != null) {
			cal2Logs.add(cal2Log);
		}
		if (testLog != null) {
			testLogs.add(testLog);
		}
	}

	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buf = new StringBuffer();
		if (includeHTMLTags) {
			buf.append(""<html>"");
		}
		List<XLog> logs;
		for (int l = 0; l < 3; l++) {
			if (l == 0 && cal1Logs.isEmpty()) {
				continue;
			}
			if (l == 1 && cal2Logs.isEmpty()) {
				continue;
			}
			if (l == 2 && testLogs.isEmpty()) {
				continue;
			}
			if (l == 0) {
				buf.append(""<h1>""+ PDC2016Set.CAL1 + ""?</h1>"");
				logs = cal1Logs;
			} else if (l == 1) {
				buf.append(""<h1>""+ PDC2016Set.CAL2 + ""?</h1>"");
				logs = cal2Logs;
			} else {
				buf.append(""<h1>""+ PDC2016Set.TEST + ""?</h1>"");
				logs = testLogs;
			}
			buf.append(""<table><tr><th></th>"");
			for (int n = 1; n < 21; n++) {
				buf.append(""<th>trace_"" + n + ""</th>"");
			}
			buf.append(""<th>#True</th>"");
			buf.append(""</tr>"");
			for (int i = 0; i < numbers.size(); i++) {
				Set<String> acceptedTraces = new HashSet<String>();
				for (XTrace trace : logs.get(i)) {
					acceptedTraces.add(XConceptExtension.instance().extractName(trace));
				}
				buf.append(""<tr><td>model_"" + numbers.get(i) + ""</td>"");
				for (int n = 1; n < 21; n++) {
					buf.append(""<td>"" + (acceptedTraces.contains("""" + n) ? ""TRUE"" : ""FALSE"") + ""</td>"");
				}
				buf.append(""<td>"" + logs.get(i).size() + ""</td>"");
				buf.append(""</tr>"");
			}
			buf.append(""</table>"");
		}
		if (includeHTMLTags) {
			buf.append(""</html>"");
		}
		return buf.toString();
	}

}
"
PDC2016TestParameters.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2016.parameters;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.processmining.pdc2016.algorithms.PDC2016Set;

public class PDC2016TestParameters {

	private Set<PDC2016Set> sets;
	private Set<PDC2016Set> allSets;
	private Set<Integer> nrs;
	private Set<Integer> allNrs;

	public PDC2016TestParameters() {

		sets = new HashSet<PDC2016Set>();
		allSets = new HashSet<PDC2016Set>();
		sets.addAll(Arrays.asList(PDC2016Set.values()));
		allSets.addAll(Arrays.asList(PDC2016Set.values()));
		sets.remove(PDC2016Set.TRAIN);
		allSets.remove(PDC2016Set.TRAIN);
		
		nrs = new HashSet<Integer>();
		allNrs = new HashSet<Integer>();
		for(int i = 1; i < 11; i++) {
			nrs.add(i);
			allNrs.add(i);
		}

	}

	public Set<PDC2016Set> getSets() {
		return sets;
	}

	public void setSets(Set<PDC2016Set> sets) {
		this.sets = sets;
	}

	public Set<PDC2016Set> getAllSets() {
		return allSets;
	}

	public void setAllSets(Set<PDC2016Set> allSets) {
		this.allSets = allSets;
	}

	public Set<Integer> getNrs() {
		return nrs;
	}

	public void setNrs(Set<Integer> nrs) {
		this.nrs = nrs;
	}

	public Set<Integer> getAllNrs() {
		return allNrs;
	}

	public void setAllNrs(Set<Integer> allNrs) {
		this.allNrs = allNrs;
	}
}
"
PDC2016TestPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2016.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogPreprocessorAlgorithm;
import org.processmining.logskeleton.algorithms.LogSkeletonClassifierAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.pdc2016.dialogs.PDC2016TestDialog;
import org.processmining.logskeleton.pdc2016.models.PDC2016TestModel;
import org.processmining.logskeleton.pdc2016.parameters.PDC2016TestParameters;
import org.processmining.pdc2016.algorithms.PDC2016LogAlgorithm;
import org.processmining.pdc2016.algorithms.PDC2016Set;
import org.processmining.pdc2016.parameters.PDC2016Parameters;

@Plugin(name = ""PDC 2016 Test"", parameterLabels = {}, returnLabels = { ""Results"" }, returnTypes = { PDC2016TestModel.class })
public class PDC2016TestPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = {})
	public static PDC2016TestModel run(final UIPluginContext context) {
		PDC2016TestParameters testParameters = new PDC2016TestParameters();
		PDC2016TestDialog testDialog = new PDC2016TestDialog(testParameters);
		InteractionResult result = context.showWizard(""Select test parameters"", true, true, testDialog);
		if (result != InteractionResult.FINISHED) {
			context.getFutureResult(0).cancel(true);
			return null;
		}
		PDC2016TestModel testModel = new PDC2016TestModel(testParameters);
		PDC2016Parameters parameters = new PDC2016Parameters();
		PDC2016LogAlgorithm logAlgorithm = new PDC2016LogAlgorithm();
		
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		try {
			for (int i : testParameters.getNrs()) {
				parameters.setNr(i);
				parameters.setSet(PDC2016Set.TRAIN);
				XLog trainingLog = logAlgorithm.apply(context, parameters);
				parameters.setSet(PDC2016Set.CAL1);
				XLog testLogMay = testParameters.getSets().contains(PDC2016Set.CAL1) ? logAlgorithm.apply(context, parameters) : null;
				parameters.setSet(PDC2016Set.CAL2);
				XLog testLogJune = testParameters.getSets().contains(PDC2016Set.CAL2) ? logAlgorithm.apply(context, parameters) : null;
				parameters.setSet(PDC2016Set.TEST);
				XLog testLogFinal = testParameters.getSets().contains(PDC2016Set.TEST) ? logAlgorithm.apply(context, parameters) : null;

				LogSkeletonClassifierAlgorithm classifierAlgorithm = new LogSkeletonClassifierAlgorithm();

				XLog classifiedTestLogCal1 = null;
				XLog classifiedTestLogCal2 = null;
				XLog classifiedTestLogTest = null;

				// Classify the logs
				if (testParameters.getSets().contains(PDC2016Set.CAL1)) {
					System.out.println(""[PDC2016TestPlugin] Classify PDC2016 "" + PDC2016Set.CAL1 + "" number "" + i);
					classifiedTestLogCal1 = classifierAlgorithm.apply(context, trainingLog, testLogMay, classifier, 
							new LogPreprocessorAlgorithm());
					context.getProvidedObjectManager().createProvidedObject(""PDC2016 "" + PDC2016Set.CAL1 + "" number "" + i,
							classifiedTestLogCal1, XLog.class, context);
				}
				if (testParameters.getSets().contains(PDC2016Set.CAL2)) {
					System.out.println(""[PDC2016TestPlugin] Classify PDC2016 "" + PDC2016Set.CAL2 + "" number "" + i);
					classifiedTestLogCal2 = classifierAlgorithm.apply(context, trainingLog, testLogJune, classifier, 
							new LogPreprocessorAlgorithm());
					context.getProvidedObjectManager().createProvidedObject(""PDC2016 "" + PDC2016Set.CAL2 + "" number "" + i,
							classifiedTestLogCal2, XLog.class, context);
				}
				if (testParameters.getSets().contains(PDC2016Set.TEST)) {
					System.out.println(""[PDC2016TestPlugin] Classify PDC2016 "" + PDC2016Set.TEST + "" number "" + i);
					classifiedTestLogTest = classifierAlgorithm.apply(context, trainingLog, testLogFinal, classifier, 
							new LogPreprocessorAlgorithm());
					context.getProvidedObjectManager().createProvidedObject(""PDC2016 "" + PDC2016Set.TEST + "" number "" + i,
							classifiedTestLogTest, XLog.class, context);
				}
				testModel.add(i, classifiedTestLogCal1, classifiedTestLogCal2, classifiedTestLogTest);
			}
			return testModel;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

}
"
PDC2017LogPreprocessorAlgorithm.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.algorithms;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.logskeleton.algorithms.LogPreprocessorAlgorithm;
import org.processmining.logskeleton.models.ClassificationProblem;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log10FilterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log10SplitterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log1FilterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log2FilterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log2SplitterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log4SplitterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log5FilterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log5SplitterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log7SplitterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log9FilterPlugin;
import org.processmining.logskeleton.pdc2017.plugins.PDC2017Log9SplitterPlugin;

public class PDC2017LogPreprocessorAlgorithm extends LogPreprocessorAlgorithm {

	private boolean useFilters;
	private boolean useExtenders;
	private boolean useSplitters;
	
	public PDC2017LogPreprocessorAlgorithm(boolean useFilters, boolean useExtenders, boolean useSplitters) {
		this.useFilters = useFilters;
		this.useExtenders = useExtenders;
		this.useSplitters = useSplitters;
	}
	
	public PDC2017LogPreprocessorAlgorithm() {
		this.useFilters = true;
		this.useExtenders = true;
		this.useSplitters = true;
	}
	
	public ClassificationProblem preprocess(PluginContext context, ClassificationProblem problem) {

		String name = XConceptExtension.instance().extractName(problem.getTrainingLog());

		if (useFilters) {
			/*
			 * Filter out the assumed noise.
			 */
			System.out.println(""====== Filter "" + name + "" ======"");
			if (name.equals(""log1"")) {
				problem.setTrainingLog((new PDC2017Log1FilterPlugin()).run(context, problem.getTrainingLog()));
			} else if (name.equals(""log2"")) {
				problem.setTrainingLog((new PDC2017Log2FilterPlugin()).run(context, problem.getTrainingLog()));
			} else if (name.equals(""log5"")) {
				problem.setTrainingLog((new PDC2017Log5FilterPlugin()).run(context, problem.getTrainingLog()));
			} else if (name.equals(""log9"")) {
				problem.setTrainingLog((new PDC2017Log9FilterPlugin()).run(context, problem.getTrainingLog()));
			} else if (name.equals(""log10"")) {
				problem.setTrainingLog((new PDC2017Log10FilterPlugin()).run(context, problem.getTrainingLog()));
			}
		}

		if (useExtenders) {
			/*
			 * Extend log with assumed false negatives from test log. Assumption
			 * is here that the test log is not that complete :-(.
			 */
			if (name.equals(""log1"")) {
				addTrace(
						problem.getTrainingLog(),
						new ArrayList<String>(Arrays.asList(""g"", ""w"", ""p"", ""c"", ""v"", ""m"", ""b"", ""u"", ""t"", ""s"", ""f"", ""r"",
								""l"", ""k"", ""j"")));
			} else if (name.equals(""log6"")) {
				addTrace(problem.getTrainingLog(), new ArrayList<String>(Arrays.asList(""d"", ""n"", ""a"", ""f"", ""k"")));
				addTrace(problem.getTrainingLog(),
						new ArrayList<String>(Arrays.asList(""c"", ""t"", ""q"", ""c"", ""a"", ""t"", ""r"")));
			}
		}

		if (useSplitters) {
			/*
			 * Split the assumed reoccurring activities.
			 */
			System.out.println(""====== Split "" + name + "" ======"");
			if (name.equals(""log2"")) {
				PDC2017Log2SplitterPlugin splitter = new PDC2017Log2SplitterPlugin();
				problem.setTrainingLog(splitter.run(context, problem.getTrainingLog()));
				problem.setTestLog(splitter.run(context, problem.getTestLog()));
			} else if (name.equals(""log4"")) {
				PDC2017Log4SplitterPlugin splitter = new PDC2017Log4SplitterPlugin();
				problem.setTrainingLog(splitter.run(context, problem.getTrainingLog()));
				problem.setTestLog(splitter.run(context, problem.getTestLog()));
			} else if (name.equals(""log5"")) {
				PDC2017Log5SplitterPlugin splitter = new PDC2017Log5SplitterPlugin();
				problem.setTrainingLog(splitter.run(context, problem.getTrainingLog()));
				problem.setTestLog(splitter.run(context, problem.getTestLog()));
			} else if (name.equals(""log7"")) {
				PDC2017Log7SplitterPlugin splitter = new PDC2017Log7SplitterPlugin();
				problem.setTrainingLog(splitter.run(context, problem.getTrainingLog()));
				problem.setTestLog(splitter.run(context, problem.getTestLog()));
			} else if (name.equals(""log9"")) {
				PDC2017Log9SplitterPlugin splitter = new PDC2017Log9SplitterPlugin();
				problem.setTrainingLog(splitter.run(context, problem.getTrainingLog()));
				problem.setTestLog(splitter.run(context, problem.getTestLog()));
			} else if (name.equals(""log10"")) {
				PDC2017Log10SplitterPlugin splitter = new PDC2017Log10SplitterPlugin();
				problem.setTrainingLog(splitter.run(context, problem.getTrainingLog()));
				problem.setTestLog(splitter.run(context, problem.getTestLog()));
			}
		}

		return problem;
	}

	public String toString() {
		if (useFilters && useExtenders && useSplitters) {
			return ""PDC 2017"";
		}
		List<String> selected = new ArrayList<String>();
		if (useFilters) {
			selected.add(""Filter"");
		}
		if (useExtenders) {
			selected.add(""Extend"");
		}
		if (useSplitters) {
			selected.add(""Split"");
		}
		return ""PDC 2017 "" + selected;
	}

	private static void addTrace(XLog log, List<String> activities) {
		XFactory factory = XFactoryRegistry.instance().currentDefault();
		XTrace trace = factory.createTrace();
		for (String activity : activities) {
			XEvent event = factory.createEvent();
			XConceptExtension.instance().assignName(event, activity);
			trace.add(event);
		}
		log.add(trace);
	}

}
"
PDC2017TestDialog.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JComponent;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.logskeleton.algorithms.LogPreprocessorAlgorithm;
import org.processmining.logskeleton.pdc2017.parameters.PDC2017TestParameters;
import org.processmining.pdc2017.algorithms.PDC2017Set;

public class PDC2017TestDialog extends JComponent {

	/**
	 * 
	 */
	private static final long serialVersionUID = 378756044807568628L;
	
	public PDC2017TestDialog(final PDC2017TestParameters parameters) {
		double size[][] = { { TableLayoutConstants.FILL, TableLayoutConstants.FILL, TableLayoutConstants.FILL },
				{ TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));
		setOpaque(false);

		DefaultListModel<PDC2017Set> setListModel = new DefaultListModel<PDC2017Set>();
		int[] selectedIndices = new int[parameters.getSets().size()];
		int i = 0;
		int j = 0;
		List<PDC2017Set> sortedSets = new ArrayList<PDC2017Set>();
		sortedSets.addAll(parameters.getAllSets());
		Collections.sort(sortedSets, new Comparator<PDC2017Set>() {
			public int compare(PDC2017Set set1, PDC2017Set set2) {
				return set1.toString().compareTo(set2.toString());
			}
		});
		for (PDC2017Set set : sortedSets) {
			setListModel.addElement(set);
			if (parameters.getSets().contains(set)) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<PDC2017Set> setList = new ProMList<PDC2017Set>(""Select log set(s)"", setListModel);
		setList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		setList.setSelectedIndices(selectedIndices);
		setList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<PDC2017Set> selectedSets = setList.getSelectedValuesList();
				parameters.setSets(new HashSet<PDC2017Set>(selectedSets));
			}
		});
		setList.setPreferredSize(new Dimension(100, 100));
		add(setList, ""0, 0"");

		DefaultListModel<Integer> nrListModel = new DefaultListModel<Integer>();
		selectedIndices = new int[parameters.getAllNrs().size()];
		i = 0;
		j = 0;
		for (int nr : parameters.getAllNrs()) {
			nrListModel.addElement(nr);
			if (parameters.getNrs().contains(nr)) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<Integer> nrList = new ProMList<Integer>(""Select log number(s)"", nrListModel);
		nrList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		nrList.setSelectedIndices(selectedIndices);
		nrList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<Integer> selectedNrs = nrList.getSelectedValuesList();
				parameters.setNrs(new HashSet<Integer>(selectedNrs));
			}
		});
		nrList.setPreferredSize(new Dimension(100, 100));
		add(nrList, ""1, 0"");
		
		DefaultListModel<LogPreprocessorAlgorithm> preprocessors = new DefaultListModel<LogPreprocessorAlgorithm>();
		selectedIndices = new int[1];
		i = 0;
		j = 0;
		List<LogPreprocessorAlgorithm> sortedPreprocessors = new ArrayList<LogPreprocessorAlgorithm>();
		sortedPreprocessors.addAll(parameters.getAllPreprocessors());
		Collections.sort(sortedPreprocessors, new Comparator<LogPreprocessorAlgorithm>() {
			public int compare(LogPreprocessorAlgorithm prep1, LogPreprocessorAlgorithm prep2) {
				return prep1.toString().compareTo(prep2.toString());
			}
		});
		for (LogPreprocessorAlgorithm preprocessor : sortedPreprocessors) {
			preprocessors.addElement(preprocessor);
			if (parameters.getPreprocessor().equals(preprocessor)) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<LogPreprocessorAlgorithm> preprocessorList = new ProMList<LogPreprocessorAlgorithm>(""Select preprocessor"", preprocessors);
		preprocessorList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		preprocessorList.setSelectedIndices(selectedIndices);
		preprocessorList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<LogPreprocessorAlgorithm> selectedPreprocessors = preprocessorList.getSelectedValuesList();
				if (selectedPreprocessors.size() == 1) {
					parameters.setPreprocessor(selectedPreprocessors.iterator().next());
				}
			}
		});
		preprocessorList.setPreferredSize(new Dimension(100, 100));
		add(preprocessorList, ""2, 0"");

	}
}
"
PDC2017TestModel.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.models;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.HTMLToString;
import org.processmining.logskeleton.pdc2017.parameters.PDC2017TestParameters;
import org.processmining.pdc2017.algorithms.PDC2017Set;

public class PDC2017TestModel implements HTMLToString {

	private List<Integer> numbers;
	private List<XLog> cal1Logs;
	private List<XLog> cal2Logs;
	private List<XLog> testLogs;
	private PDC2017TestParameters parameters;

	public PDC2017TestModel(PDC2017TestParameters parameters) {
		numbers = new ArrayList<Integer>();
		cal1Logs = new ArrayList<XLog>();
		cal2Logs = new ArrayList<XLog>();
		testLogs = new ArrayList<XLog>();
		this.parameters = parameters;
	}

	public void add(int i, XLog cal1Log, XLog cal2Log, XLog testLog) {
		numbers.add(i);
		if (cal1Log != null) {
			cal1Logs.add(cal1Log);
		}
		if (cal2Log != null) {
			cal2Logs.add(cal2Log);
		}
		if (testLog != null) {
			testLogs.add(testLog);
		}
	}

	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buf = new StringBuffer();
		if (includeHTMLTags) {
			buf.append(""<html>"");
		}
		List<XLog> logs;
		for (int l = 0; l < 3; l++) {
			if (l == 0 && cal1Logs.isEmpty()) {
				continue;
			}
			if (l == 1 && cal2Logs.isEmpty()) {
				continue;
			}
			if (l == 2 && testLogs.isEmpty()) {
				continue;
			}
			if (l == 0) {
				buf.append(""<h1>""+ PDC2017Set.CAL1 + ""? using "" + parameters.getPreprocessor() + ""</h1>"");
				logs = cal1Logs;
			} else if (l == 1) {
				buf.append(""<h1>""+ PDC2017Set.CAL2 + ""? using "" + parameters.getPreprocessor() + ""</h1>"");
				logs = cal2Logs;
			} else {
				buf.append(""<h1>""+ PDC2017Set.TEST + ""? using "" + parameters.getPreprocessor() + ""</h1>"");
				logs = testLogs;
			}
			buf.append(""<table><tr><th></th>"");
			for (int n = 1; n < 21; n++) {
				buf.append(""<th>trace_"" + n + ""</th>"");
			}
			buf.append(""<th>#True</th>"");
			buf.append(""</tr>"");
			for (int i = 0; i < numbers.size(); i++) {
				Set<String> acceptedTraces = new HashSet<String>();
				for (XTrace trace : logs.get(i)) {
					acceptedTraces.add(XConceptExtension.instance().extractName(trace));
				}
				buf.append(""<tr><td>model_"" + numbers.get(i) + ""</td>"");
				for (int n = 1; n < 21; n++) {
					buf.append(""<td>"" + (acceptedTraces.contains("""" + n) ? ""TRUE"" : ""FALSE"") + ""</td>"");
				}
				buf.append(""<td>"" + logs.get(i).size() + ""</td>"");
				buf.append(""</tr>"");
			}
			buf.append(""</table>"");
		}
		if (includeHTMLTags) {
			buf.append(""</html>"");
		}
		return buf.toString();
	}

}
"
PDC2017TestParameters.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.parameters;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.processmining.logskeleton.algorithms.LogPreprocessorAlgorithm;
import org.processmining.logskeleton.pdc2017.algorithms.PDC2017LogPreprocessorAlgorithm;
import org.processmining.pdc2017.algorithms.PDC2017Set;

public class PDC2017TestParameters {

	private Set<PDC2017Set> sets;
	private Set<PDC2017Set> allSets;
	private LogPreprocessorAlgorithm preprocessor;
	private Set<LogPreprocessorAlgorithm> allPreprocessors;
	private Set<Integer> nrs;
	private Set<Integer> allNrs;

	public PDC2017TestParameters() {

		sets = new HashSet<PDC2017Set>();
		allSets = new HashSet<PDC2017Set>();
		sets.addAll(Arrays.asList(PDC2017Set.values()));
		allSets.addAll(Arrays.asList(PDC2017Set.values()));
		sets.remove(PDC2017Set.TRAIN);
		allSets.remove(PDC2017Set.TRAIN);
		
		nrs = new HashSet<Integer>();
		allNrs = new HashSet<Integer>();
		for(int i = 1; i < 11; i++) {
			nrs.add(i);
			allNrs.add(i);
		}

		preprocessor = new PDC2017LogPreprocessorAlgorithm();
		allPreprocessors = new HashSet<LogPreprocessorAlgorithm>();
		allPreprocessors.add(new LogPreprocessorAlgorithm());
		allPreprocessors.add(preprocessor);
		allPreprocessors.add(new PDC2017LogPreprocessorAlgorithm(false, false, true));
		allPreprocessors.add(new PDC2017LogPreprocessorAlgorithm(true, false, false));
		allPreprocessors.add(new PDC2017LogPreprocessorAlgorithm(true, false, true));
		allPreprocessors.add(new PDC2017LogPreprocessorAlgorithm(false, true, false));
		allPreprocessors.add(new PDC2017LogPreprocessorAlgorithm(false, true, true));
		allPreprocessors.add(new PDC2017LogPreprocessorAlgorithm(true, true, false));
	}

	public Set<PDC2017Set> getSets() {
		return sets;
	}

	public void setSets(Set<PDC2017Set> sets) {
		this.sets = sets;
	}

	public LogPreprocessorAlgorithm getPreprocessor() {
		return preprocessor;
	}

	public void setPreprocessor(LogPreprocessorAlgorithm preprocessor) {
		this.preprocessor = preprocessor;
	}

	public Set<PDC2017Set> getAllSets() {
		return allSets;
	}

	public void setAllSets(Set<PDC2017Set> allSets) {
		this.allSets = allSets;
	}

	public Set<LogPreprocessorAlgorithm> getAllPreprocessors() {
		return allPreprocessors;
	}

	public void setAllPreprocessors(Set<LogPreprocessorAlgorithm> allPreprocessors) {
		this.allPreprocessors = allPreprocessors;
	}

	public Set<Integer> getNrs() {
		return nrs;
	}

	public void setNrs(Set<Integer> nrs) {
		this.nrs = nrs;
	}

	public Set<Integer> getAllNrs() {
		return allNrs;
	}

	public void setAllNrs(Set<Integer> allNrs) {
		this.allNrs = allNrs;
	}

}
"
PDC2017Log10FilterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2017 Log 10 Filter"", parameterLabels = { ""Event Log 10"" }, returnLabels = { ""Filtered Log 10"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log10FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: d=1"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""d"") != 1) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2017Log10SplitterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2017 Log 10 Splitter"", parameterLabels = { ""Event Log 10"" }, returnLabels = { ""Split Log 10"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log10SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split o over j
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""j"");
		parameters.setDuplicateActivity(""o"");
		XLog filteredLog = apply(log, classifier, parameters);
		// Split i over j
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""j"");
		parameters.setDuplicateActivity(""i"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split q over q
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""q"");
		parameters.setDuplicateActivity(""q"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split j over j
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""j"");
		parameters.setDuplicateActivity(""j"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split g over q.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""q.1"");
		parameters.setDuplicateActivity(""g"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o.1 over o.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""o.1"");
		parameters.setDuplicateActivity(""o.1"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split q.1 over q.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""q.1"");
		parameters.setDuplicateActivity(""q.1"");
		filteredLog = apply(filteredLog, classifier, parameters);
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | split: [o, j], [i, j], [q, q], [j, j], [g, q.1], [o.1, o.1], [q.1, q.1]"");
		return filteredLog;
	}

}
"
PDC2017Log1FilterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2017 Log 1 Filter"", parameterLabels = { ""Event Log 1"" }, returnLabels = { ""Filtered Log 1"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log1FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: f=j, f+d=1, b=l, c=s, d=o, d=h"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""f"") != count.get(""j"")) {
				continue;
			}
			if (count.get(""f"") + count.get(""d"") != 1) {
				continue;
			}
			if (count.get(""b"") != count.get(""l"")) {
				continue;
			}
			if (count.get(""c"") != count.get(""s"")) {
				continue;
			}
			if (count.get(""d"") != count.get(""o"") || count.get(""d"") != count.get(""h"")) {
				continue;
			}
			//			if (count.get(""d"") != count.get(""o"")) {
			//				continue;
			//			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2017Log2FilterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2017 Log 2 Filter"", parameterLabels = { ""Event Log 2"" }, returnLabels = { ""Filtered Log 2"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log2FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: k=1, d=1, b=i+e"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""k"") != 1 || count.get(""d"") != 1) {
				continue;
			}
			if (count.get(""b"") != count.get(""i"") + count.get(""e"")) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2017Log2SplitterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2017 Log 2 Splitter"", parameterLabels = { ""Event Log 2"" }, returnLabels = { ""Split Log 2"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log2SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XLog filteredLog = log;
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split a over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""a"");
		parameters.setDuplicateActivity(""a"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split s over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""s"");
		parameters.setDuplicateActivity(""s"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Done
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | split: [a, a], [s, s]"");
		return filteredLog;
	}
}
"
PDC2017Log4SplitterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2017 Log 4 Splitter"", parameterLabels = { ""Event Log 4"" }, returnLabels = { ""Split Log 4"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log4SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split t over l
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""l"");
		parameters.setDuplicateActivity(""t"");
		XLog filteredLog = apply(log, classifier, parameters);
		// Split r over b
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""b"");
		parameters.setDuplicateActivity(""r"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split m over b
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""b"");
		parameters.setDuplicateActivity(""m"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Done
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | split: [t, l], [r, b], [m, b]"");
		return filteredLog;
	}

}
"
PDC2017Log5FilterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2017 Log 5 Filter"", parameterLabels = { ""Event Log 5"" }, returnLabels = { ""Filtered Log 5"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log5FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: f=1"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""f"") != 1) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2017Log5SplitterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2017 Log 5 Splitter"", parameterLabels = { ""Event Log 5"" }, returnLabels = { ""Split Log 5"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log5SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XLog filteredLog = log;
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split a over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""a"");
		parameters.setDuplicateActivity(""a"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split i over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""i"");
		parameters.setDuplicateActivity(""i"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split g over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""g"");
		parameters.setDuplicateActivity(""g"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split i.1 over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""i.1"");
		parameters.setDuplicateActivity(""i.1"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split g over itself
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""g.1"");
		parameters.setDuplicateActivity(""g.1"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Done
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | split: [a, a], [i, i], [g, g], [i.1, i,1], [g.1, g.1]"");
		return filteredLog;
	}
}
"
PDC2017Log7SplitterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2017 Log 7 Splitter"", parameterLabels = { ""Event Log 7""}, returnLabels = { ""Split Log 7"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log7SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split n over f
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""f"");
		parameters.setDuplicateActivity(""n"");
		XLog filteredLog = apply(log, classifier, parameters);
		// Split h over i
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""i"");
		parameters.setDuplicateActivity(""h"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split c over i
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""i"");
		parameters.setDuplicateActivity(""c"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split h.0 over c.0
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""c.0"");
//		parameters.getMilestoneActivities().add(""h.0"");
		parameters.setDuplicateActivity(""h.0"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split p over e
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""e"");
		parameters.setDuplicateActivity(""p"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split c.0 over h.0.0
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""h.0.0"");
		parameters.setDuplicateActivity(""c.0"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Done, except for b...
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | split: [n, f], [h, i], [c,i], [h.0, c.0], [p, e], [c.0, h.0.0], 7B"");
		return apply7B(filteredLog, classifier);
	}

}
"
PDC2017Log9FilterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2017 Log 9 Filter"", parameterLabels = { ""Event Log 9""}, returnLabels = { ""Filtered Log 9"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log9FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | filter: c+f=1, c+l=1"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());
		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""c"") + count.get(""f"") != 1) {
				continue;
			} else if (count.get(""c"") + count.get(""l"") != 1) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2017Log9SplitterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2017 Log 9 Splitter"", parameterLabels = { ""Event Log 9""}, returnLabels = { ""Split Log 9"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017Log9SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split t over v
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""v"");
		parameters.setDuplicateActivity(""t"");
		XLog filteredLog = apply(log, classifier, parameters);
		// Split ad over k
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""k"");
		parameters.setDuplicateActivity(""ad"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split ad.0 over ad.0
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""ad.0"");
		parameters.setDuplicateActivity(""ad.0"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split k over b
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""b"");
		parameters.setDuplicateActivity(""k"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split z over ad.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""ad.1"");
		parameters.setDuplicateActivity(""z"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split h over z.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""z.1"");
		parameters.setDuplicateActivity(""h"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split p over b
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""b"");
		parameters.setDuplicateActivity(""p"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o over o
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""o"");
		parameters.setDuplicateActivity(""o"");
		filteredLog = apply(filteredLog, classifier, parameters);
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | split: [t, v], [ad, k], [ad.0, ad.0], [k, b], [z, ad.1], [h, z.1], [p, b], [o, o]"");
		return filteredLog;
	}

}
"
PDC2017TestPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2017.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogPreprocessorAlgorithm;
import org.processmining.logskeleton.algorithms.LogSkeletonClassifierAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.pdc2017.dialogs.PDC2017TestDialog;
import org.processmining.logskeleton.pdc2017.models.PDC2017TestModel;
import org.processmining.logskeleton.pdc2017.parameters.PDC2017TestParameters;
import org.processmining.pdc2017.algorithms.PDC2017LogAlgorithm;
import org.processmining.pdc2017.algorithms.PDC2017Set;
import org.processmining.pdc2017.parameters.PDC2017Parameters;

@Plugin(name = ""PDC 2017 Test"", parameterLabels = {}, returnLabels = { ""Results"" }, returnTypes = { PDC2017TestModel.class })
public class PDC2017TestPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = {})
	public static PDC2017TestModel run(final UIPluginContext context) {
		PDC2017TestParameters testParameters = new PDC2017TestParameters();
		PDC2017TestDialog testDialog = new PDC2017TestDialog(testParameters);
		InteractionResult result = context.showWizard(""Select test parameters"", true, true, testDialog);
		if (result != InteractionResult.FINISHED) {
			context.getFutureResult(0).cancel(true);
			return null;
		}
		PDC2017TestModel testModel = new PDC2017TestModel(testParameters);
		PDC2017Parameters parameters = new PDC2017Parameters();
		PDC2017LogAlgorithm logAlgorithm = new PDC2017LogAlgorithm();

		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		try {
			for (int i : testParameters.getNrs()) {
				parameters.setNr(i);
				parameters.setSet(PDC2017Set.TRAIN);
				XLog trainingLog = logAlgorithm.apply(context, parameters);
				parameters.setSet(PDC2017Set.CAL1);
				XLog testLogMay = testParameters.getSets().contains(PDC2017Set.CAL1) ? logAlgorithm.apply(context,
						parameters) : null;
				parameters.setSet(PDC2017Set.CAL2);
				XLog testLogJune = testParameters.getSets().contains(PDC2017Set.CAL2) ? logAlgorithm.apply(context,
						parameters) : null;
				parameters.setSet(PDC2017Set.TEST);
				XLog testLogFinal = testParameters.getSets().contains(PDC2017Set.TEST) ? logAlgorithm.apply(context,
						parameters) : null;

				LogSkeletonClassifierAlgorithm classifierAlgorithm = new LogSkeletonClassifierAlgorithm();
				LogPreprocessorAlgorithm preprocessor = testParameters.getPreprocessor();

				XLog classifiedTestLogCal1 = null;
				XLog classifiedTestLogCal2 = null;
				XLog classifiedTestLogTest = null;

				// Classify the logs
				if (testParameters.getSets().contains(PDC2017Set.CAL1)) {
					System.out.println(""[PDC2017TestPlugin] Classify PDC2017 "" + PDC2017Set.CAL1 + "" number "" + i);
					classifiedTestLogCal1 = classifierAlgorithm.apply(context, trainingLog, testLogMay, classifier, preprocessor);
					context.getProvidedObjectManager().createProvidedObject(""PDC2017 "" + PDC2017Set.CAL1 + "" number "" + i,
							classifiedTestLogCal1, XLog.class, context);
				}
				if (testParameters.getSets().contains(PDC2017Set.CAL2)) {
					System.out.println(""[PDC2017TestPlugin] Classify PDC2017 "" + PDC2017Set.CAL2 + "" number "" + i);
					classifiedTestLogCal2 = classifierAlgorithm.apply(context, trainingLog, testLogJune, classifier, preprocessor);
					context.getProvidedObjectManager().createProvidedObject(""PDC2017 "" + PDC2017Set.CAL2 + "" number "" + i,
							classifiedTestLogCal2, XLog.class, context);
				}
				if (testParameters.getSets().contains(PDC2017Set.TEST)) {
					System.out.println(""[PDC2017TestPlugin] Classify PDC2017 "" + PDC2017Set.TEST + "" number "" + i);
					classifiedTestLogTest = classifierAlgorithm.apply(context, trainingLog, testLogFinal, classifier, preprocessor);
					context.getProvidedObjectManager().createProvidedObject(""PDC2017 "" + PDC2017Set.TEST + "" number "" + i,
							classifiedTestLogTest, XLog.class, context);
				}
				testModel.add(i, classifiedTestLogCal1, classifiedTestLogCal2, classifiedTestLogTest);
			}
			return testModel;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

}
"
PDC2019Log1FilterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2019.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2019 Log 1 Filter"", parameterLabels = { ""Event Log 1"" }, returnLabels = { ""Filtered Log 1"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2019 Plug-in"")
public class PDC2019Log1FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: ai=o, ai+x+f=1, an+aj=1, ab+n+ah=an, ac+ak=1, ag=1, ad+ap+m=v"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""ai"") != count.get(""o"")) {
				continue;
			}
			if (count.get(""ai"") + count.get(""x"") + count.get(""f"") != 1) {
				continue;
			}
			if (count.get(""an"") + count.get(""aj"") != 1) {
				continue;
			}
			if (count.get(""ab"") + count.get(""n"") + count.get(""ah"") != count.get(""an"")) {
				continue;
			}
			if (count.get(""ac"") + count.get(""ak"") != 1) {
				continue;
			}
			if (count.get(""ag"") != 1) {
				continue;
			}
			if (count.get(""ad"") + count.get(""ap"") + count.get(""m"") != count.get(""v"")) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2019Log2FilterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2019.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2019 Log 2 Filter"", parameterLabels = { ""Event Log 1"" }, returnLabels = { ""Filtered Log 2"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2019 Plug-in"")
public class PDC2019Log2FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: ai=1"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""ai"") != 1) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2019Log3FilterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2019.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2019 Log 3 Filter"", parameterLabels = { ""Event Log 1"" }, returnLabels = { ""Filtered Log 3"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2019 Plug-in"")
public class PDC2019Log3FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: ..."");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""al"") != count.get(""l"")) {
				continue;
			}
			if (count.get(""ap"") != count.get(""j"")) {
				continue;
			}
			if (count.get(""ad"") != count.get(""i"")) {
				continue;
			}
			if (count.get(""b"") != count.get(""u"")) {
				continue;
			}
			if (count.get(""aq"") != count.get(""ar"")) {
				continue;
			}
			if (count.get(""e"") != count.get(""t"")) {
				continue;
			}
			if (count.get(""d"") != count.get(""o"")) {
				continue;
			}
			if (count.get(""w"") != count.get(""ag"")) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2019Log4CheckerPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2019.plugins;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.pdc2019.algorithms.PDC2019LogAlgorithm;
import org.processmining.pdc2019.algorithms.PDC2019Set;
import org.processmining.pdc2019.parameters.PDC2019Parameters;

@Plugin(name = ""PDC 2019 Log 4 Checker"", parameterLabels = {}, returnLabels = { ""Checked Log 4"" }, returnTypes = {
		XLog.class }, userAccessible = true, help = ""PDC 2019 Plug-in"")
public class PDC2019Log4CheckerPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = {})
	public XLog run(PluginContext context) {
		try {
			PDC2019LogAlgorithm algorithm = new PDC2019LogAlgorithm();
			PDC2019Parameters parameters = new PDC2019Parameters();
			parameters.setSet(PDC2019Set.TRAIN);
			parameters.setNr(4);
			Map<List<String>, Long> traceCounts = new HashMap<List<String>, Long>();
			XLog log = algorithm.apply(context, parameters);
			for (XTrace trace : log) {
				List<String> activities = new ArrayList<String>();
				for (XEvent event : trace) {
					activities.add(XConceptExtension.instance().extractName(event));
				}
				long count = 1 + (traceCounts.containsKey(activities) ? traceCounts.get(activities) : 0);
				traceCounts.put(activities, count);
			}
			parameters.setSet(PDC2019Set.CAL2);
			log = algorithm.apply(context, parameters);
			XLog newLog = XFactoryRegistry.instance().currentDefault()
					.createLog((XAttributeMap) log.getAttributes().clone());
			for (XTrace trace : log) {
				XTrace newTrace = XFactoryRegistry.instance().currentDefault()
						.createTrace((XAttributeMap) trace.getAttributes().clone());
				List<String> activities = new ArrayList<String>();
				for (XEvent event : trace) {
					XEvent newEvent = XFactoryRegistry.instance().currentDefault()
							.createEvent((XAttributeMap) event.getAttributes().clone());
					newTrace.add(newEvent);
					activities.add(XConceptExtension.instance().extractName(event));
				}
				newTrace.getAttributes().put(""count"", XFactoryRegistry.instance().currentDefault()
						.createAttributeDiscrete(""count"", traceCounts.containsKey(activities) ? traceCounts.get(activities) : -1, null));
				for (List<String> key : traceCounts.keySet()) {
					if (key.size() >= activities.size()) {
						boolean isPrefix = true;
						for (int i = 0; i < activities.size(); i++) {
							if (!key.get(i).equals(activities.get(i))) {
								isPrefix = false;
							}
						}
						if (isPrefix) {
							newTrace.getAttributes().put(""prefix"", XFactoryRegistry.instance().currentDefault()
									.createAttributeLiteral(""prefix"", activities.toString(), null));
						}
					}
				}
				newLog.add(newTrace);
			}
			return newLog;
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

}
"
PDC2019Log4FilterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2019.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeletonCount;

@Plugin(name = ""PDC 2019 Log 4 Filter"", parameterLabels = { ""Event Log 4"" }, returnLabels = { ""Filtered Log 4"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2019 Plug-in"")
public class PDC2019Log4FilterPlugin {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		LogSkeletonBuilderAlgorithm skeletonBuilder = new LogSkeletonBuilderAlgorithm();
		XLog filteredLog = XFactoryRegistry.instance().currentDefault()
				.createLog((XAttributeMap) log.getAttributes().clone());
		XConceptExtension.instance().assignName(filteredLog,
				XConceptExtension.instance().extractName(log) + "" | filter: 2019-4"");
		XLog traceLog = XFactoryRegistry.instance().currentDefault().createLog((XAttributeMap) log.getAttributes().clone());
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		for (XTrace trace : log) {
			traceLog.clear();
			traceLog.add(trace);
			LogSkeletonCount count = skeletonBuilder.count(traceLog, classifier);
			if (count.get(""al"") != count.get(""at"") + count.get(""n"")) {
				continue;
			}
			if (count.get(""al"") + count.get(""e.1"") + count.get(""as.1"") + count.get(""d"") + count.get(""u"") + count.get(""t.1"") + count.get(""ad.1"") != 1) {
				continue;
			}
			filteredLog.add(trace);
		}
		return filteredLog;
	}
}
"
PDC2019Log4SplitterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2019.plugins;

import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;

@Plugin(name = ""PDC 2019 Log 4 Splitter"", parameterLabels = { ""Event Log 4""}, returnLabels = { ""Split Log 4"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2019Log4SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		XLog filteredLog = apply20194(log);
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | split: 2019-4"");
		return filteredLog;
	}

}
"
PDC2019Log9SplitterPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.pdc2019.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.classification.XEventNameClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.parameters.SplitterParameters;

@Plugin(name = ""PDC 2019 Log 9 Splitter"", parameterLabels = { ""Event Log 9""}, returnLabels = { ""Split Log 9"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2019Log9SplitterPlugin extends SplitterAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public XLog run(PluginContext context, XLog log) {
		SplitterParameters parameters = new SplitterParameters();
		XEventClassifier classifier = new LogSkeletonClassifier(new XEventNameClassifier());

		// Split t over v
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""s"");
		parameters.setDuplicateActivity(""s"");
		XLog filteredLog = apply(log, classifier, parameters);
		// Split ad over k
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""o"");
		parameters.setDuplicateActivity(""w"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split ad.0 over ad.0
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""o"");
		parameters.setDuplicateActivity(""al"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split k over b
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""ai"");
		parameters.setDuplicateActivity(""ai"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split z over ad.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""ai.1"");
		parameters.setDuplicateActivity(""z"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split h over z.1
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""z.0"");
		parameters.setDuplicateActivity(""d"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split p over b
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""q"");
		parameters.setDuplicateActivity(""q"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o over o
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""ai.1"");
		parameters.setDuplicateActivity(""ai.1"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o over o
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""aj"");
		parameters.setDuplicateActivity(""aj"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o over o
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""ac"");
		parameters.setDuplicateActivity(""ac"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o over o
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""n"");
		parameters.setDuplicateActivity(""n"");
		filteredLog = apply(filteredLog, classifier, parameters);
		// Split o over o
		parameters.getMilestoneActivities().clear();
		parameters.getMilestoneActivities().add(""z.1"");
		parameters.setDuplicateActivity(""c"");
		filteredLog = apply(filteredLog, classifier, parameters);
		XConceptExtension.instance().assignName(
				filteredLog,
				XConceptExtension.instance().extractName(log)
						+ "" | split: ..."");
		return filteredLog;
	}

}
"
LogPartitionerPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.log.models.EventLogArray;
import org.processmining.logskeleton.algorithms.LogPartitionerAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;

@Plugin(name = ""Partition Log on Activity Sets"", icon = ""prom_duck_300.png"", url = ""http://www.win.tue.nl/~hverbeek"", parameterLabels = {
		""Event log"" }, returnLabels = { ""Event Log Array"" }, returnTypes = {
				EventLogArray.class }, userAccessible = true, help = ""Filter Event Log on Log Skeleton"")
public class LogPartitionerPlugin extends LogPartitionerAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public EventLogArray run(PluginContext context, XLog log) {
		return run(context, log, new LogSkeletonClassifier());
	}

	public EventLogArray run(PluginContext context, XLog log, XEventClassifier classifier) {
		EventLogArray logs = apply(log, classifier);
		for (int i = 0; i < logs.getSize(); i++) {
			context.getProvidedObjectManager().createProvidedObject(
					XConceptExtension.instance().extractName(logs.getLog(i)), logs.getLog(i), XLog.class, context);
		}
		return logs;
	}

}
"
LogSkeletonBrowserPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.plugins;

import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.logskeleton.models.LogSkeleton;
import org.processmining.logskeleton.parameters.LogSkeletonBrowser;
import org.processmining.logskeleton.parameters.LogSkeletonBrowserParameters;
import org.processmining.plugins.graphviz.visualisation.DotPanel;

import com.fluxicon.slickerbox.components.NiceSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.components.SlickerButton;
import com.fluxicon.slickerbox.factory.SlickerFactory;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

@Plugin(name = ""Log Skeleton Browser"", parameterLabels = { ""Log Skeleton"" }, returnLabels = {
		""Log Skeleton Browser"" }, returnTypes = {
				JComponent.class }, userAccessible = true, help = ""Log Skeleton Browser"")
@Visualizer
public class LogSkeletonBrowserPlugin {

	private LogSkeleton model;
	private LogSkeletonBrowserParameters parameters = new LogSkeletonBrowserParameters();
	private JComponent leftDotPanel = null;
	private JComponent rightDotPanel = null;
	private JPanel mainPanel = null;

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public JComponent run(UIPluginContext context, final LogSkeleton model) {

		this.model = model;

		mainPanel = new JPanel();
		double size[][] = { { TableLayoutConstants.FILL, 250 }, { TableLayoutConstants.FILL, TableLayoutConstants.FILL,
				TableLayoutConstants.FILL, 30, 30, 30, 30, 30, 30, 30, 30 } };
		mainPanel.setLayout(new TableLayout(size));
		mainPanel.setOpaque(false);

		DefaultListModel<String> activities = new DefaultListModel<String>();
		int[] selectedIndices = new int[model.getActivities().size()];
		int i = 0;
		for (String activity : model.getActivities()) {
			activities.addElement(activity);
			selectedIndices[i] = i;
			i++;
		}
		final ProMList<String> activityList = new ProMList<String>(""View Activities"", activities);
		activityList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		activityList.setSelectedIndices(selectedIndices);
		parameters.getActivities().addAll(model.getActivities());
		activityList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selectedActivities = activityList.getSelectedValuesList();
				if (!selectedActivities.equals(parameters.getActivities())) {
					System.out.println(""[LogSkeletonBrowserPlugin] Selected nodes = "" + selectedActivities);
					parameters.getActivities().clear();
					parameters.getActivities().addAll(selectedActivities);
					updateRight();
				}
			}
		});
		activityList.setPreferredSize(new Dimension(100, 100));
		mainPanel.add(activityList, ""1, 0, 1, 1"");

		boolean doNotUseNotCoExistence = model.hasManyNotCoExistenceArcs(parameters);

		List<LogSkeletonBrowser> list = Arrays.asList(LogSkeletonBrowser.values());
		DefaultListModel<LogSkeletonBrowser> visualizers = new DefaultListModel<LogSkeletonBrowser>();
		for (LogSkeletonBrowser visualizer : list) {
			visualizers.addElement(visualizer);
		}
		final ProMList<LogSkeletonBrowser> visualizerList = new ProMList<LogSkeletonBrowser>(""View Constraints"",
				visualizers);
		visualizerList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		List<LogSkeletonBrowser> selectedVisualizers = new ArrayList<LogSkeletonBrowser>();
		selectedIndices = new int[doNotUseNotCoExistence ? 4 : 5];
		//		selectedVisualizers.add(LogSkeletonBrowser.ALWAYSTOGETHER);
		//		selectedIndices[0] = list.indexOf(LogSkeletonBrowser.ALWAYSTOGETHER);
		selectedVisualizers.add(LogSkeletonBrowser.ALWAYSBEFORE);
		selectedIndices[0] = list.indexOf(LogSkeletonBrowser.ALWAYSBEFORE);
		selectedVisualizers.add(LogSkeletonBrowser.ALWAYSAFTER);
		selectedIndices[1] = list.indexOf(LogSkeletonBrowser.ALWAYSAFTER);
		selectedVisualizers.add(LogSkeletonBrowser.NEVERBEFORE);
		selectedIndices[2] = list.indexOf(LogSkeletonBrowser.NEVERBEFORE);
		selectedVisualizers.add(LogSkeletonBrowser.NEVERAFTER);
		selectedIndices[3] = list.indexOf(LogSkeletonBrowser.NEVERAFTER);
		if (!doNotUseNotCoExistence) {
			/*
			 * Only include in the first visualization if not too many Not Co-Existence constraints.
			 */
			selectedVisualizers.add(LogSkeletonBrowser.NEVERTOGETHER);
			selectedIndices[4] = list.indexOf(LogSkeletonBrowser.NEVERTOGETHER);
		}
		visualizerList.setSelectedIndices(selectedIndices);
		parameters.getVisualizers().addAll(selectedVisualizers);
		visualizerList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<LogSkeletonBrowser> selectedVisualizers = visualizerList.getSelectedValuesList();
				if (!selectedVisualizers.equals(parameters.getVisualizers())) {
					System.out.println(""[LogSkeletonBrowserPlugin] Selected edges = "" + selectedVisualizers);
					parameters.getVisualizers().clear();
					parameters.getVisualizers().addAll(selectedVisualizers);
					updateRight();
				}
			}
		});
		visualizerList.setPreferredSize(new Dimension(100, 100));
		mainPanel.add(visualizerList, ""1, 2"");

		final JCheckBox checkBox = SlickerFactory.instance().createCheckBox(""Use Hyper Arcs (may be slow...)"", false);
		checkBox.setSelected(parameters.isUseHyperArcs());
		checkBox.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setUseHyperArcs(checkBox.isSelected());
				updateRight();
			}

		});
		checkBox.setOpaque(false);
		checkBox.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(checkBox, ""1, 4"");

		final JCheckBox checkBoxFalseConstraints = SlickerFactory.instance().createCheckBox(""Use False Constraints"",
				false);
		checkBoxFalseConstraints.setSelected(parameters.isUseFalseConstraints());
		checkBoxFalseConstraints.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setUseFalseConstraints(checkBoxFalseConstraints.isSelected());
				updateRight();
			}

		});
		checkBoxFalseConstraints.setOpaque(false);
		checkBoxFalseConstraints.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(checkBoxFalseConstraints, ""1, 5"");

		final JCheckBox checkBoxEdgeColors = SlickerFactory.instance().createCheckBox(""Use Edge Colors"", false);
		checkBoxEdgeColors.setSelected(parameters.isUseEdgeColors());
		checkBoxEdgeColors.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setUseEdgeColors(checkBoxEdgeColors.isSelected());
				updateRight();
			}

		});
		checkBoxEdgeColors.setOpaque(false);
		checkBoxEdgeColors.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(checkBoxEdgeColors, ""1, 6"");

		final JCheckBox checkBoxEquivalenceClass = SlickerFactory.instance().createCheckBox(""Use Equivalence Class"",
				false);
		checkBoxEquivalenceClass.setSelected(parameters.isUseEquivalenceClass());
		checkBoxEquivalenceClass.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setUseEquivalenceClass(checkBoxEquivalenceClass.isSelected());
				updateRight();
			}

		});
		checkBoxEquivalenceClass.setOpaque(false);
		checkBoxEquivalenceClass.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(checkBoxEquivalenceClass, ""1, 7"");

		final JCheckBox checkBoxLabels = SlickerFactory.instance().createCheckBox(""Use Head/Tail Labels"", false);
		checkBoxLabels.setSelected(parameters.isUseHeadTailLabels());
		checkBoxLabels.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setUseHeadTailLabels(checkBoxLabels.isSelected());
				updateRight();
			}

		});
		checkBoxLabels.setOpaque(false);
		checkBoxLabels.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(checkBoxLabels, ""1, 8"");

		final JCheckBox checkBoxNeighbors = SlickerFactory.instance().createCheckBox(""Show Neighbors"", false);
		checkBoxNeighbors.setSelected(parameters.isUseNeighbors());
		checkBoxNeighbors.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				parameters.setUseNeighbors(checkBoxNeighbors.isSelected());
				updateRight();
			}

		});
		checkBoxNeighbors.setOpaque(false);
		checkBoxNeighbors.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(checkBoxNeighbors, ""1, 9"");

		final NiceSlider noiseLevelSlider = SlickerFactory.instance().createNiceIntegerSlider(""Noise Level in %"",
				0, 20, 100 - parameters.getPrecedenceThreshold(), Orientation.HORIZONTAL);
		noiseLevelSlider.addChangeListener(new ChangeListener() {

			public void stateChanged(ChangeEvent e) {
				int value = 100 - noiseLevelSlider.getSlider().getValue();
				model.setEquivalenceThreshold(value);
				parameters.setPrecedenceThreshold(value);
				parameters.setResponseThreshold(value);
				model.setPrecedenceThreshold(value);
				model.setResponseThreshold(value);
				parameters.setNotCoExistenceThreshold(value);
				model.setNotCoExistenceThreshold(value);
				model.cleanPrePost();
				updateRight();
			}
		});
		noiseLevelSlider.setPreferredSize(new Dimension(100, 30));
		mainPanel.add(noiseLevelSlider, ""1, 3"");

//		final NiceSlider notCoExistenceThresholdSlider = SlickerFactory.instance().createNiceIntegerSlider(
//				""NCE Threshold"", 80, 100, parameters.getPrecedenceThreshold(), Orientation.HORIZONTAL);
//		notCoExistenceThresholdSlider.addChangeListener(new ChangeListener() {
//
//			public void stateChanged(ChangeEvent e) {
//				parameters.setNotCoExistenceThreshold(notCoExistenceThresholdSlider.getSlider().getValue());
//				model.setNotCoExistenceThreshold(notCoExistenceThresholdSlider.getSlider().getValue());
//				updateRight();
//			}
//		});
//		notCoExistenceThresholdSlider.setPreferredSize(new Dimension(100, 30));
//		mainPanel.add(notCoExistenceThresholdSlider, ""1, 10"");
//
		final SlickerButton button = new SlickerButton(""View Log Skeleton in New Window"");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				updateLeft();
			}

		});
		mainPanel.add(button, ""1, 10"");

		//		updateLeft();
		updateRight();
		return mainPanel;
	}

	private void updateLeft() {
		//		if (leftDotPanel != null) {
		//			mainPanel.remove(leftDotPanel);
		//		}
		model.setPrecedenceThreshold(parameters.getPrecedenceThreshold());
		model.setResponseThreshold(parameters.getResponseThreshold());
		model.setNotCoExistenceThreshold(parameters.getNotCoExistenceThreshold());
		leftDotPanel = new DotPanel(model.createGraph(parameters));
		//		mainPanel.add(leftDotPanel, ""0, 0, 0, 3"");
		//		mainPanel.validate();
		//		mainPanel.repaint();
		JFrame frame = new JFrame();
		frame.add(leftDotPanel);
		frame.setTitle(""Log Skeleton Viewer on "" + model.getLabel());
		frame.setSize(1024, 768);
		frame.setVisible(true);
	}

	private void updateRight() {
		if (rightDotPanel != null) {
			mainPanel.remove(rightDotPanel);
		}
		rightDotPanel = new DotPanel(model.visualize(parameters));
		mainPanel.add(rightDotPanel, ""0, 0, 0, 10"");
		mainPanel.validate();
		mainPanel.repaint();

	}
}"
LogSkeletonBuilderPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeleton;

@Plugin(name = ""Build Log Skeleton from Event Log"", icon = ""prom_duck_300.png"", url = ""http://www.win.tue.nl/~hverbeek"", parameterLabels = { ""Event log""}, returnLabels = { ""Log Skeleton"" }, returnTypes = { LogSkeleton.class }, userAccessible = true, help = ""Create Log Skeleton from Event Log"")
public class LogSkeletonBuilderPlugin extends LogSkeletonBuilderAlgorithm  {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public LogSkeleton run(PluginContext context, XLog log) {
		return apply(log, new LogSkeletonClassifier());
	}

	public LogSkeleton run(PluginContext context, XLog log, XEventClassifier classifier) {
		return apply(log, classifier);
	}
}
"
LogSkeletonCheckerPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.plugins;

import java.util.HashSet;
import java.util.Set;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogSkeletonCheckerAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeleton;

@Plugin(name = ""Filter Event Log on Log Skeleton"", icon = ""prom_duck_300.png"", url = ""http://www.win.tue.nl/~hverbeek"", parameterLabels = { ""Log Skeleton"", ""Event log""}, returnLabels = { ""Filtered Event Log"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""Filter Event Log on Log Skeleton"")
public class LogSkeletonCheckerPlugin extends LogSkeletonCheckerAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0, 1 })
	public XLog run(PluginContext context, LogSkeleton model, XLog log) {
		return run(context, model, log, new LogSkeletonClassifier());
	}

	public XLog run(PluginContext context, LogSkeleton model, XLog log, XEventClassifier classifier) {
		boolean[] checks = new boolean[] { true, true, true };
		return run(context, model, log, classifier, new HashSet<String>(), checks);
	}

	public XLog run(PluginContext context, LogSkeleton model, XLog log, Set<String> messages, boolean[] checks) {
		XEventClassifier classifier = new LogSkeletonClassifier();
		return run(context, model, log, classifier, messages, checks);
	}

	public XLog run(PluginContext context, LogSkeleton model, XLog log, XEventClassifier classifier, Set<String> messages, boolean[] checks) {
		return apply(model, log, classifier, messages, checks);
	}
}
"
LogSkeletonClassifierPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.plugins;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.algorithms.LogPreprocessorAlgorithm;
import org.processmining.logskeleton.algorithms.LogSkeletonClassifierAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;

@Plugin(name = ""Classify Test Log using Log Skeleton"", icon = ""prom_duck_300.png"", url = ""http://www.win.tue.nl/~hverbeek"", parameterLabels = { ""Training Event log"", ""Test Event Log""}, returnLabels = { ""Classified Event Log"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""Filter Event Log on Log Skeleton"")
public class LogSkeletonClassifierPlugin extends LogSkeletonClassifierAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0, 1 })
	public XLog run(PluginContext context, XLog trainingLog, XLog testLog) {
		return run(context, trainingLog, testLog, new LogSkeletonClassifier());
	}

	public XLog run(PluginContext context, XLog trainingLog, XLog testLog, XEventClassifier classifier) {
		return apply(context, trainingLog, testLog, classifier, new LogPreprocessorAlgorithm());
	}

}
"
LogSkeletonExportPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.plugins;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.logskeleton.models.LogSkeleton;

import com.csvreader.CsvWriter;

@Plugin(name = ""Export Log Skeleton"", returnLabels = {}, returnTypes = {}, parameterLabels = {
		""Log Skeleton"", ""File"" }, userAccessible = true)
@UIExportPlugin(description = ""Log Skeleton"", extension = ""lsk"")
public class LogSkeletonExportPlugin {
	
	@PluginVariant(variantLabel = ""Export Log Skeleton"", requiredParameterLabels = { 0, 1 })
	public void export(PluginContext context, LogSkeleton logSkeleton, File file) throws IOException {
		Writer fileWriter = new FileWriter(file);
		CsvWriter csvWriter = new CsvWriter(fileWriter, ',');
		logSkeleton.exportToFile(csvWriter);
		csvWriter.close();
	}
}
"
LogSkeletonFilterBrowserPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.plugins;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.swing.DefaultListModel;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.SwingConstants;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.extension.std.XConceptExtension;
import org.deckfour.xes.factory.XFactoryRegistry;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.framework.util.ui.widgets.WidgetColors;
import org.processmining.logskeleton.algorithms.LogSkeletonBuilderAlgorithm;
import org.processmining.logskeleton.algorithms.SplitterAlgorithm;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;
import org.processmining.logskeleton.models.LogSkeleton;
import org.processmining.logskeleton.parameters.SplitterParameters;

import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.components.SlickerButton;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

@Plugin(name = ""Log Skeleton Filter and Browser"", parameterLabels = { ""Event Log"" }, returnLabels = { ""Log Skeleton Filter and Browser"" }, returnTypes = { JComponent.class }, userAccessible = true, help = ""Log Skeleton Filter and Browser"")
@Visualizer
public class LogSkeletonFilterBrowserPlugin {

	private UIPluginContext context;
	private XLog log;
	private JComponent rightPanel = null;
	private JPanel mainPanel = null;
	private List<List<String>> splitters;
	private Set<String> positiveFilters;
	private Set<String> negativeFilters;
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public JComponent run(UIPluginContext context, XLog log) {
		return run(context, log, new LogSkeletonClassifier());
	}
	
	public JComponent run(UIPluginContext context, XLog log, XEventClassifier classifier) {
		this.context = context;
		this.log = log;
		
		mainPanel = new JPanel();
		double size[][] = { { 250, TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		mainPanel.setLayout(new TableLayout(size));
		mainPanel.setOpaque(false);

		splitters = new ArrayList<List<String>>();
		positiveFilters = new HashSet<String>();
		negativeFilters = new HashSet<String>();

		mainPanel.add(getControlPanel(classifier), ""0, 0"");

		update(classifier);

		provideInfo(log, classifier);
		
		return mainPanel;
	}

	private void provideInfo(XLog log, XEventClassifier classifier) {
		Map<Set<String>, Double> scores = new HashMap<Set<String>, Double>();
		double maxScore = 0;
		for (XTrace trace : log) {
			Set<String> score = new HashSet<String>();
			for (XEvent event : trace) {
				score.add(classifier.getClassIdentity(event));
			}
			if (!scores.containsKey(score)) {
				scores.put(score, 1.0 / (trace.size() + 1));
			} else {
				scores.put(score, scores.get(score) + (1.0 / (trace.size() + 1)));
			}
			if (scores.get(score) > maxScore) {
				maxScore = scores.get(score);
			}
		}
		for (Set<String> count : scores.keySet()) {
			if (scores.get(count) == maxScore) {
				System.out.println(""[LogSkeletonFilterBrowserPlugin] "" + maxScore + "": "" + count);
			}
		}
	}
	
	private void update(XEventClassifier classifier) {
		SplitterAlgorithm splitterAlgorithm = new SplitterAlgorithm();
		SplitterParameters splitterParameters = new SplitterParameters();
		XLog filteredLog = log;

		if (!positiveFilters.isEmpty() || !negativeFilters.isEmpty()) {
			filteredLog = filter(filteredLog, classifier, positiveFilters, negativeFilters);
		}
		for (List<String> splitter : splitters) {
			splitterParameters.setDuplicateActivity(splitter.get(0));
			splitterParameters.getMilestoneActivities().clear();
			for (int i = 1; i < splitter.size(); i++) {
				splitterParameters.getMilestoneActivities().add(splitter.get(i));
			}
			filteredLog = splitterAlgorithm.apply(filteredLog, classifier, splitterParameters);
		}
		LogSkeletonBuilderAlgorithm discoveryAlgorithm = new LogSkeletonBuilderAlgorithm();
		context.getProvidedObjectManager().createProvidedObject(XConceptExtension.instance().extractName(filteredLog) + "" Split"", filteredLog, XLog.class, context);
		LogSkeleton model = discoveryAlgorithm.apply(filteredLog, classifier);
		model.setRequired(positiveFilters);
		model.setForbidden(negativeFilters);
		model.setSplitters(splitters);
		LogSkeletonBrowserPlugin visualizerPlugin = new LogSkeletonBrowserPlugin();
		if (rightPanel != null) {
			mainPanel.remove(rightPanel);
		}
		rightPanel = visualizerPlugin.run(context, model);
		mainPanel.add(rightPanel, ""1, 0"");
		mainPanel.validate();
		mainPanel.repaint();
	}

	private XLog filter(XLog log, XEventClassifier classifier, Set<String> positiveFilters, Set<String> negativeFilters) {
		XLog filteredLog = XFactoryRegistry.instance().currentDefault().createLog(log.getAttributes());
		XLog discardedLog = XFactoryRegistry.instance().currentDefault().createLog(log.getAttributes());
		for (XTrace trace : log) {
			boolean ok = true;
			Set<String> toMatch = new HashSet<String>(positiveFilters);
			for (XEvent event : trace) {
				String activity = classifier.getClassIdentity(event);
				if (negativeFilters.contains(activity)) {
					ok = false;
					;
				}
				toMatch.remove(activity);
			}
			if (ok && toMatch.isEmpty()) {
				filteredLog.add(trace);
			} else {
				discardedLog.add(trace);
			}
		}
		context.getProvidedObjectManager().createProvidedObject(XConceptExtension.instance().extractName(filteredLog) + "" In"", filteredLog, XLog.class, context);
		context.getProvidedObjectManager().createProvidedObject(XConceptExtension.instance().extractName(discardedLog) + "" Out"", discardedLog, XLog.class, context);
		return filteredLog;
	}

	private List<String> getActivities(XLog log, XEventClassifier classifier) {
		Set<String> activities = new HashSet<String>();
		for (XTrace trace : log) {
			for (XEvent event : trace) {
				String activity = classifier.getClassIdentity(event);
				activities.add(activity);
			}
		}
		List<String> activityList = new ArrayList<String>(activities);
		Collections.sort(activityList);
		return activityList;
	}

	private JComponent getControlPanel(final XEventClassifier classifier) {
		JPanel controlPanel = new JPanel();
		List<String> activities = getActivities(log, classifier);
		double size[][] = { { TableLayoutConstants.FILL },
				{ TableLayoutConstants.FILL, TableLayoutConstants.FILL, TableLayoutConstants.FILL, 30 } };
		controlPanel.setLayout(new TableLayout(size));
		controlPanel.setOpaque(false);
		controlPanel.setBackground(WidgetColors.COLOR_LIST_BG);
		controlPanel.setForeground(WidgetColors.COLOR_LIST_FG);

		DefaultListModel<String> requiredActivityModel = new DefaultListModel<String>();
		for (String activity : activities) {
			requiredActivityModel.addElement(activity);
		}
		final ProMList<String> requiredActivityList = new ProMList<String>(""Required Activities Filter"", requiredActivityModel);
		requiredActivityList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		requiredActivityList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selectedActivities = requiredActivityList.getSelectedValuesList();
				positiveFilters.clear();
				positiveFilters.addAll(selectedActivities);
			}
		});
		requiredActivityList.setPreferredSize(new Dimension(100, 100));
		controlPanel.add(requiredActivityList, ""0, 0"");

		DefaultListModel<String> forbiddenActivityModel = new DefaultListModel<String>();
		for (String activity : activities) {
			forbiddenActivityModel.addElement(activity);
		}
		final ProMList<String> forbiddenActivityList = new ProMList<String>(""Forbidden Activities Filter"",
				forbiddenActivityModel);
		forbiddenActivityList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		forbiddenActivityList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<String> selectedActivities = forbiddenActivityList.getSelectedValuesList();
				negativeFilters.clear();
				negativeFilters.addAll(selectedActivities);
			}
		});
		forbiddenActivityList.setPreferredSize(new Dimension(100, 100));
		controlPanel.add(forbiddenActivityList, ""0, 1"");

		RoundedPanel splitterPanel = new RoundedPanel(10, 5, 0);
		splitterPanel.setPreferredSize(new Dimension(100, 100));
		double splitterSize[][] = {
				{ TableLayoutConstants.FILL, TableLayoutConstants.FILL },
				{ 30, TableLayoutConstants.FILL, TableLayoutConstants.FILL,
						TableLayoutConstants.FILL, TableLayoutConstants.FILL, TableLayoutConstants.FILL,
						TableLayoutConstants.FILL, TableLayoutConstants.FILL, TableLayoutConstants.FILL,
						TableLayoutConstants.FILL, TableLayoutConstants.FILL } };
		splitterPanel.setLayout(new TableLayout(splitterSize));
		splitterPanel.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		splitterPanel.setForeground(WidgetColors.COLOR_LIST_FG);

		splitterPanel.setOpaque(false);
		JLabel splitterLabel = new JLabel(""Activity Splitters"");
		splitterLabel.setOpaque(false);
		splitterLabel.setForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		splitterLabel.setFont(splitterLabel.getFont().deriveFont(13f));
		splitterLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		splitterLabel.setHorizontalAlignment(SwingConstants.CENTER);
		splitterLabel.setHorizontalTextPosition(SwingConstants.CENTER);

		splitterPanel.add(splitterLabel, ""0, 0, 1, 0"");
		final ProMTextField inputs[][] = new ProMTextField[2][10];
		for (int row = 0; row < 10; row++) {
			for (int col = 0; col < 2; col++) {
				inputs[col][row] = new ProMTextField("""", (col == 0 ? ""Split Activity "" : ""Over Activity "") + (1 + col + 2*row));
				splitterPanel.add(inputs[col][row], """" + col + "", "" + (row + 1));
			}
		}
		controlPanel.add(splitterPanel, ""0, 2"");

		final SlickerButton button = new SlickerButton(""Apply Settings"");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				splitters = new ArrayList<List<String>>();
				for (int row = 0; row < 10; row++) {
					List<String> filter = new ArrayList<String>();
					for (int col = 0; col < 2; col++) {
						filter.add(inputs[col][row].getText());
					}
					if (!filter.get(0).isEmpty() && !filter.get(1).isEmpty()) {
						System.out.println(""[LogSkeletonFilterBrowserPlugin] Filter added: "" + filter);
						splitters.add(filter);
					}
				}
				update(classifier);
			}

		});
		controlPanel.add(button, ""0, 3"");

		return controlPanel;
	}

}
"
LogSkeletonImportPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.plugins;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;

import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;

import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.framework.abstractplugins.AbstractImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.logskeleton.models.LogSkeleton;

import com.csvreader.CsvReader;

@Plugin(name = ""Import Log Skeleton"", parameterLabels = { ""Filename"" }, returnLabels = { ""Log Skeleton"" }, returnTypes = { LogSkeleton.class })
@UIImportPlugin(description = ""Log Skeleton files"", extensions = { ""lsk"" })
public class LogSkeletonImportPlugin extends AbstractImportPlugin {

	protected FileFilter getFileFilter() {
		return new FileNameExtensionFilter(""Log Skeleton files"", ""lsk"");
	}

	protected Object importFromStream(PluginContext context, InputStream input, String filename, long fileSizeInBytes)
			throws Exception {
		Reader streamReader = new InputStreamReader(input);
		CsvReader csvReader = new CsvReader(streamReader);
		LogSkeleton logSkeleton = new LogSkeleton();
		logSkeleton.importFromStream(csvReader);
		return logSkeleton;
	}
	
}
"
LogSkeletonVisualizerPlugin.java,logskeleton-6.9.91,"package org.processmining.logskeleton.plugins;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JComponent;
import javax.swing.JPanel;

import org.deckfour.xes.classification.XEventAttributeClassifier;
import org.deckfour.xes.classification.XEventClassifier;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.ui.widgets.ProMTextField;
import org.processmining.logskeleton.classifiers.LogSkeletonClassifier;

import com.fluxicon.slickerbox.components.SlickerButton;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

@Plugin(name = ""Log Skeleton Visualizer"", parameterLabels = { ""Event Log"" }, returnLabels = { ""Log Skeleton Visualizer"" }, returnTypes = { JComponent.class }, userAccessible = true, help = ""Log Skeleton Visualizer"")
@Visualizer
public class LogSkeletonVisualizerPlugin {

	private UIPluginContext context;
	private XLog log;
	private XEventClassifier classifier;
	private JComponent mainPanel;
	private JComponent bottomPanel = null;
	
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { 0 })
	public JComponent run(UIPluginContext context, XLog log) {
		this.context = context;
		this.log = log;
		
		mainPanel = new JPanel();
		double size[][] = { { TableLayoutConstants.FILL }, { 30, TableLayoutConstants.FILL } };
		mainPanel.setLayout(new TableLayout(size));
		mainPanel.setOpaque(false);

		classifier = new LogSkeletonClassifier();

		mainPanel.add(getControlPanel(), ""0, 0"");

		update();

		return mainPanel;
	}
	
	private void update() {
		LogSkeletonFilterBrowserPlugin filterBrowser = new LogSkeletonFilterBrowserPlugin();
		if (bottomPanel != null) {
			mainPanel.remove(bottomPanel);
		}
		bottomPanel = filterBrowser.run(context, log, classifier);
		mainPanel.add(bottomPanel, ""0, 1"");
		mainPanel.validate();
		mainPanel.repaint();
	}
	
	private JComponent getControlPanel() {
		JPanel controlPanel = new JPanel();
		double size[][] = { { 250, TableLayoutConstants.FILL }, { TableLayoutConstants.FILL } };
		controlPanel.setLayout(new TableLayout(size));
		controlPanel.setOpaque(false);
		
		String[] keys = classifier.getDefiningAttributeKeys();
		String text = """";
		String sep = """";
		for (int i = 0; i < keys.length; i++) {
			text += sep + keys[i];
			sep = "" "";
		}
		final ProMTextField input = new ProMTextField(text);
		controlPanel.add(input, ""1, 0"");

		final SlickerButton button = new SlickerButton(""Apply Classifier"");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				String keys[] = input.getText().split("" "");
				classifier = new LogSkeletonClassifier(new XEventAttributeClassifier(""classifier"", keys));
				update();
			}

		});
		controlPanel.add(button, ""0, 0"");

		return controlPanel;
	}
}
"
PDC2016LogAlgorithm.java,pdc2016-6.9.18,"package org.processmining.pdc2016.algorithms;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.abstractplugins.ImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.pdc2016.parameters.PDC2016Parameters;
import org.processmining.plugins.log.OpenLogFilePlugin;

public class PDC2016LogAlgorithm {

	private static ImportPlugin logImporter = new OpenLogFilePlugin();

	private Map<String, XLog> loadedLogs;

	public PDC2016LogAlgorithm() {
		loadedLogs = new HashMap<String, XLog>();
	}

	public XLog apply(PluginContext context, PDC2016Parameters parameters) throws Exception {
		String fileName = parameters.getSet().getFileName(parameters.getNr());
		if (!loadedLogs.containsKey(fileName)) {
			System.out.println(""[PDC2016LogAlgorithm] Loading log from file "" + ""pdc2016logs/"" + fileName + "".xes"");
			InputStream logFile = ClassLoader.getSystemClassLoader().getResourceAsStream(
					""pdc2016logs/"" + fileName + "".xes"");
			File tmpFile = File.createTempFile(""tmp"" + fileName, "".xes"");
			BufferedReader br = new BufferedReader(new InputStreamReader(logFile));
			String line = br.readLine();

			PrintStream out = new PrintStream(tmpFile);
			while (line != null) {
				out.println(line);
				line = br.readLine();
			}
			out.flush();
			out.close();
			loadedLogs.put(fileName, (XLog) logImporter.importFile(context, tmpFile.getAbsolutePath()));
		}
		return loadedLogs.get(fileName);
	}
}
"
PDC2016Set.java,pdc2016-6.9.18,"package org.processmining.pdc2016.algorithms;

public enum PDC2016Set {

	TRAIN(""Training log"", ""training_log_""),
	CAL1(""Calibration log 1"", ""test_log_april_""),
	CAL2(""Calibration log 2"", ""test_log_may_""),
	TEST(""Test log"", ""test_log_june_"");
	
	private String prefix;
	private String label;
	
	private PDC2016Set(String label, String prefix) {
		this.label = label;
		this.prefix = prefix;
	}
	
	public String getFileName(int nr) {
		return prefix + nr;
	}
	
	public String toString() {
		return label;
	}
}
"
PDC2016Dialog.java,pdc2016-6.9.18,"package org.processmining.pdc2016.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.pdc2016.algorithms.PDC2016Set;
import org.processmining.pdc2016.parameters.PDC2016Parameters;

public class PDC2016Dialog extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -6814149869848660395L;

	public PDC2016Dialog(final PDC2016Parameters parameters) {
		
		double size[][] = { { TableLayoutConstants.FILL, TableLayoutConstants.FILL },
				{ TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));
		setOpaque(false);

		DefaultListModel<PDC2016Set> setListModel = new DefaultListModel<PDC2016Set>();
		int[] selectedIndices = new int[1];
		int i = 0;
		int j = 0;
		List<PDC2016Set> sortedSets = new ArrayList<PDC2016Set>();
		sortedSets.addAll(Arrays.asList(PDC2016Set.values()));
		Collections.sort(sortedSets, new Comparator<PDC2016Set>() {
			public int compare(PDC2016Set set1, PDC2016Set set2) {
				return set1.toString().compareTo(set2.toString());
			}
		});
		for (PDC2016Set set : sortedSets) {
			setListModel.addElement(set);
			if (parameters.getSet() == set) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<PDC2016Set> setList = new ProMList<PDC2016Set>(""Select log collection"", setListModel);
		setList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		setList.setSelectedIndices(selectedIndices);
		setList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<PDC2016Set> selectedSet = setList.getSelectedValuesList();
				parameters.setSet(selectedSet.iterator().next());
			}
		});
		setList.setPreferredSize(new Dimension(100, 100));
		add(setList, ""0, 0"");

		DefaultListModel<Integer> nrListModel = new DefaultListModel<Integer>();
		selectedIndices = new int[10];
		i = 0;
		j = 0;
		for (int nr = 1; nr < 11; nr++) {
			nrListModel.addElement(nr);
			if (parameters.getNr() == nr) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<Integer> nrList = new ProMList<Integer>(""Select log number"", nrListModel);
		nrList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		nrList.setSelectedIndices(selectedIndices);
		nrList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<Integer> selectedNr = nrList.getSelectedValuesList();
				parameters.setNr(selectedNr.iterator().next());
			}
		});
		nrList.setPreferredSize(new Dimension(100, 100));
		add(nrList, ""1, 0"");
	}
}
"
PDC2016Parameters.java,pdc2016-6.9.18,"package org.processmining.pdc2016.parameters;

import org.processmining.pdc2016.algorithms.PDC2016Set;

public class PDC2016Parameters {

	private PDC2016Set set;
	private int nr;

	public PDC2016Parameters() {
		set = PDC2016Set.TRAIN;
		nr = 1;
	}
	
	public PDC2016Set getSet() {
		return set;
	}

	public void setSet(PDC2016Set set) {
		this.set = set;
	}

	public int getNr() {
		return nr;
	}

	public void setNr(int nr) {
		this.nr = nr;
	}
}
"
PDC2016LogPlugin.java,pdc2016-6.9.18,"package org.processmining.pdc2016.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.pdc2016.algorithms.PDC2016LogAlgorithm;
import org.processmining.pdc2016.dialogs.PDC2016Dialog;
import org.processmining.pdc2016.parameters.PDC2016Parameters;

@Plugin(name = ""Create PDC 2016 Log"", parameterLabels = {}, returnLabels = { ""PDC 2016 Log"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2016 Plug-in"")
public class PDC2016LogPlugin extends PDC2016LogAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { })
	public XLog run(UIPluginContext context) throws Exception {
		PDC2016Parameters parameters = new PDC2016Parameters();
		PDC2016Dialog dialog = new PDC2016Dialog(parameters);
		InteractionResult result = context.showWizard(""Select log to create"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			context.getFutureResult(0).cancel(true);
			return null;
		}
		return apply(context, parameters);
	}
}

"
PDC2017LogAlgorithm.java,pdc2017-6.9.22,"package org.processmining.pdc2017.algorithms;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.abstractplugins.ImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.pdc2017.parameters.PDC2017Parameters;
import org.processmining.plugins.log.OpenLogFilePlugin;

public class PDC2017LogAlgorithm {

	private static ImportPlugin logImporter = new OpenLogFilePlugin();

	private Map<String, XLog> loadedLogs;

	public PDC2017LogAlgorithm() {
		loadedLogs = new HashMap<String, XLog>();
	}

	public XLog apply(PluginContext context, PDC2017Parameters parameters) throws Exception {
		String fileName = parameters.getSet().getFileName(parameters.getNr());
		if (!loadedLogs.containsKey(fileName)) {
			System.out.println(""[PDC2017LogAlgorithm] Loading log from file "" + ""pdc2017logs/"" + fileName + "".xes"");
			InputStream logFile = ClassLoader.getSystemClassLoader().getResourceAsStream(
					""pdc2017logs/"" + fileName + "".xes"");
			File tmpFile = File.createTempFile(""tmp"" + fileName, "".xes"");
			BufferedReader br = new BufferedReader(new InputStreamReader(logFile));
			String line = br.readLine();

			PrintStream out = new PrintStream(tmpFile);
			while (line != null) {
				out.println(line);
				line = br.readLine();
			}
			out.flush();
			out.close();
			loadedLogs.put(fileName, (XLog) logImporter.importFile(context, tmpFile.getAbsolutePath()));
		}
		return loadedLogs.get(fileName);
	}
}
"
PDC2017Set.java,pdc2017-6.9.22,"package org.processmining.pdc2017.algorithms;

public enum PDC2017Set {

	TRAIN(""Training log"", ""log""),
	CAL1(""Calibration log 1"", ""test_log_may_""),
	CAL2(""Calibration log 2"", ""test_log_june_""),
	TEST(""Test log"", ""test_log_july_"");
	
	private String prefix;
	private String label;
	
	private PDC2017Set(String label, String prefix) {
		this.label = label;
		this.prefix = prefix;
	}
	
	public String getFileName(int nr) {
		return prefix + nr;
	}
	
	public String toString() {
		return label;
	}
}
"
PDC2017Dialog.java,pdc2017-6.9.22,"package org.processmining.pdc2017.dialogs;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JComponent;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.pdc2017.algorithms.PDC2017Set;
import org.processmining.pdc2017.parameters.PDC2017Parameters;

public class PDC2017Dialog extends JComponent {

	/**
	 * 
	 */
	private static final long serialVersionUID = 7895709177834365821L;
	
	public PDC2017Dialog(final PDC2017Parameters parameters) {
		
		double size[][] = { { TableLayoutConstants.FILL, TableLayoutConstants.FILL },
				{ TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));
		setOpaque(false);

		DefaultListModel<PDC2017Set> setListModel = new DefaultListModel<PDC2017Set>();
		int[] selectedIndices = new int[1];
		int i = 0;
		int j = 0;
		List<PDC2017Set> sortedSets = new ArrayList<PDC2017Set>();
		sortedSets.addAll(Arrays.asList(PDC2017Set.values()));
		Collections.sort(sortedSets, new Comparator<PDC2017Set>() {
			public int compare(PDC2017Set set1, PDC2017Set set2) {
				return set1.toString().compareTo(set2.toString());
			}
		});
		for (PDC2017Set set : sortedSets) {
			setListModel.addElement(set);
			if (parameters.getSet() == set) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<PDC2017Set> setList = new ProMList<PDC2017Set>(""Select log collection"", setListModel);
		setList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		setList.setSelectedIndices(selectedIndices);
		setList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<PDC2017Set> selectedSet = setList.getSelectedValuesList();
				parameters.setSet(selectedSet.iterator().next());
			}
		});
		setList.setPreferredSize(new Dimension(100, 100));
		add(setList, ""0, 0"");

		DefaultListModel<Integer> nrListModel = new DefaultListModel<Integer>();
		selectedIndices = new int[10];
		i = 0;
		j = 0;
		for (int nr = 1; nr < 11; nr++) {
			nrListModel.addElement(nr);
			if (parameters.getNr() == nr) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<Integer> nrList = new ProMList<Integer>(""Select log number"", nrListModel);
		nrList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		nrList.setSelectedIndices(selectedIndices);
		nrList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<Integer> selectedNr = nrList.getSelectedValuesList();
				parameters.setNr(selectedNr.iterator().next());
			}
		});
		nrList.setPreferredSize(new Dimension(100, 100));
		add(nrList, ""1, 0"");
	}
}
"
PDC2017Parameters.java,pdc2017-6.9.22,"package org.processmining.pdc2017.parameters;

import org.processmining.pdc2017.algorithms.PDC2017Set;

public class PDC2017Parameters {

	private PDC2017Set set;
	private int nr;

	public PDC2017Parameters() {
		set = PDC2017Set.TRAIN;
		nr = 1;
	}
	
	public PDC2017Set getSet() {
		return set;
	}

	public void setSet(PDC2017Set set) {
		this.set = set;
	}

	public int getNr() {
		return nr;
	}

	public void setNr(int nr) {
		this.nr = nr;
	}
}
"
PDC2017LogPlugin.java,pdc2017-6.9.22,"package org.processmining.pdc2017.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.pdc2017.algorithms.PDC2017LogAlgorithm;
import org.processmining.pdc2017.dialogs.PDC2017Dialog;
import org.processmining.pdc2017.parameters.PDC2017Parameters;

@Plugin(name = ""Create PDC 2017 Log"", parameterLabels = {}, returnLabels = { ""PDC 2017 Log"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2017LogPlugin extends PDC2017LogAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { })
	public XLog run(UIPluginContext context) throws Exception {
		PDC2017Parameters parameters = new PDC2017Parameters();
		PDC2017Dialog dialog = new PDC2017Dialog(parameters);
		InteractionResult result = context.showWizard(""Select log to create"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			context.getFutureResult(0).cancel(true);
			return null;
		}
		return apply(context, parameters);
	}
}

"
PDC2019LogAlgorithm.java,pdc2019-6.9.19,"package org.processmining.pdc2019.algorithms;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;

import org.deckfour.xes.model.XLog;
import org.processmining.framework.abstractplugins.ImportPlugin;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.pdc2019.parameters.PDC2019Parameters;
import org.processmining.plugins.log.OpenLogFilePlugin;

public class PDC2019LogAlgorithm {

	private static ImportPlugin logImporter = new OpenLogFilePlugin();

	private Map<String, XLog> loadedLogs;

	public PDC2019LogAlgorithm() {
		loadedLogs = new HashMap<String, XLog>();
	}

	public XLog apply(PluginContext context, PDC2019Parameters parameters) throws Exception {
		String fileName = parameters.getSet().getFileName(parameters.getNr());
		if (!loadedLogs.containsKey(fileName)) {
			System.out.println(""[PDC2019LogAlgorithm] Loading log from file "" + ""pdc2019logs/"" + fileName + "".xes"");
			InputStream logFile = ClassLoader.getSystemClassLoader().getResourceAsStream(
					""pdc2019logs/"" + fileName + "".xes"");
			File tmpFile = File.createTempFile(""tmp"" + fileName, "".xes"");
			BufferedReader br = new BufferedReader(new InputStreamReader(logFile));
			String line = br.readLine();

			PrintStream out = new PrintStream(tmpFile);
			while (line != null) {
				out.println(line);
				line = br.readLine();
			}
			out.flush();
			out.close();
			loadedLogs.put(fileName, (XLog) logImporter.importFile(context, tmpFile.getAbsolutePath()));
		}
		return loadedLogs.get(fileName);
	}
}
"
PDC2019Set.java,pdc2019-6.9.19,"package org.processmining.pdc2019.algorithms;

public enum PDC2019Set {

	TRAIN(""Training log"", ""log"", ""-training""),
	CAL1(""Calibration log 1"", ""log"", ""-15February""),
	CAL2(""Calibration log 2"", ""log"", ""-15March""),
	TEST(""Test log"", ""log"", ""-May"");
	
	private String prefix;
	private String postfix;
	private String label;
	
	private PDC2019Set(String label, String prefix, String postfix) {
		this.label = label;
		this.prefix = prefix;
		this.postfix = postfix;
	}
	
	public String getFileName(int nr) {
		return prefix + nr + postfix;
	}
	
	public String toString() {
		return label;
	}
}
"
PDC2019Dialog.java,pdc2019-6.9.19,"package org.processmining.pdc2019.dialogs;

import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JComponent;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.ui.widgets.ProMList;
import org.processmining.pdc2019.algorithms.PDC2019Set;
import org.processmining.pdc2019.parameters.PDC2019Parameters;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class PDC2019Dialog extends JComponent {

	/**
	 * 
	 */
	private static final long serialVersionUID = 7895709177834365821L;
	
	public PDC2019Dialog(final PDC2019Parameters parameters) {
		
		double size[][] = { { TableLayoutConstants.FILL, TableLayoutConstants.FILL },
				{ TableLayoutConstants.FILL } };
		setLayout(new TableLayout(size));
		setOpaque(false);

		DefaultListModel<PDC2019Set> setListModel = new DefaultListModel<PDC2019Set>();
		int[] selectedIndices = new int[1];
		int i = 0;
		int j = 0;
		List<PDC2019Set> sortedSets = new ArrayList<PDC2019Set>();
		sortedSets.addAll(Arrays.asList(PDC2019Set.values()));
		Collections.sort(sortedSets, new Comparator<PDC2019Set>() {
			public int compare(PDC2019Set set1, PDC2019Set set2) {
				return set1.toString().compareTo(set2.toString());
			}
		});
		for (PDC2019Set set : sortedSets) {
			setListModel.addElement(set);
			if (parameters.getSet() == set) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<PDC2019Set> setList = new ProMList<PDC2019Set>(""Select log collection"", setListModel);
		setList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		setList.setSelectedIndices(selectedIndices);
		setList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<PDC2019Set> selectedSet = setList.getSelectedValuesList();
				parameters.setSet(selectedSet.iterator().next());
			}
		});
		setList.setPreferredSize(new Dimension(100, 100));
		add(setList, ""0, 0"");

		DefaultListModel<Integer> nrListModel = new DefaultListModel<Integer>();
		selectedIndices = new int[10];
		i = 0;
		j = 0;
		for (int nr = 1; nr < 11; nr++) {
			nrListModel.addElement(nr);
			if (parameters.getNr() == nr) {
				selectedIndices[j++] = i;
			}
			i++;
		}
		final ProMList<Integer> nrList = new ProMList<Integer>(""Select log number"", nrListModel);
		nrList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		nrList.setSelectedIndices(selectedIndices);
		nrList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				List<Integer> selectedNr = nrList.getSelectedValuesList();
				parameters.setNr(selectedNr.iterator().next());
			}
		});
		nrList.setPreferredSize(new Dimension(100, 100));
		add(nrList, ""1, 0"");
	}
}
"
PDC2019Parameters.java,pdc2019-6.9.19,"package org.processmining.pdc2019.parameters;

import org.processmining.pdc2019.algorithms.PDC2019Set;

public class PDC2019Parameters {

	private PDC2019Set set;
	private int nr;

	public PDC2019Parameters() {
		set = PDC2019Set.TRAIN;
		nr = 1;
	}
	
	public PDC2019Set getSet() {
		return set;
	}

	public void setSet(PDC2019Set set) {
		this.set = set;
	}

	public int getNr() {
		return nr;
	}

	public void setNr(int nr) {
		this.nr = nr;
	}
}
"
PDC2019LogPlugin.java,pdc2019-6.9.19,"package org.processmining.pdc2019.plugins;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.xes.model.XLog;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.pdc2019.algorithms.PDC2019LogAlgorithm;
import org.processmining.pdc2019.dialogs.PDC2019Dialog;
import org.processmining.pdc2019.parameters.PDC2019Parameters;

@Plugin(name = ""Create PDC 2019 Log"", parameterLabels = {}, returnLabels = { ""PDC 2019 Log"" }, returnTypes = { XLog.class }, userAccessible = true, help = ""PDC 2017 Plug-in"")
public class PDC2019LogPlugin extends PDC2019LogAlgorithm {

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = { })
	public XLog run(UIPluginContext context) throws Exception {
		PDC2019Parameters parameters = new PDC2019Parameters();
		PDC2019Dialog dialog = new PDC2019Dialog(parameters);
		InteractionResult result = context.showWizard(""Select log to create"", true, true, dialog);
		if (result != InteractionResult.FINISHED) {
			context.getFutureResult(0).cancel(true);
			return null;
		}
		return apply(context, parameters);
	}
}

"
CLI.java,prom-contexts-6.9.56,"package org.processmining.contexts.cli;

import jargs.gnu.CmdLineParser;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.processmining.contexts.scripting.ScriptExecutor;
import org.processmining.contexts.scripting.ScriptExecutor.ScriptExecutionException;
import org.processmining.contexts.scripting.Signature;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.util.AutoHelpCommandLineParser;
import org.processmining.framework.util.CommandLineArgumentList;
import org.processmining.framework.util.Pair;

public class CLI {
	@Plugin(name = ""CLI"", parameterLabels = {}, returnLabels = {}, returnTypes = {}, userAccessible = false)
	@Bootable
	public Object main(CommandLineArgumentList commandlineArguments) throws Throwable {
		//try {
		if (Boot.VERBOSE != Level.NONE) {
			System.out.println(""Starting script execution engine..."");
			System.out.println(commandlineArguments);
		}

		CLIContext globalContext = new CLIContext();
		ScriptExecutor executor = new ScriptExecutor(globalContext.getMainPluginContext());
		Pair<List<String>, List<String>> params = parseCommandLine(commandlineArguments, executor);

		if (params != null) {
			List<String> scripts = params.getFirst();
			List<String> scriptArguments = params.getSecond();
			try {
				executor.bind(""arguments"", scriptArguments);

				for (String script : scripts) {
					executor.execute(script);
				}
			} catch (ScriptExecutionException e) {
				System.err.println(""Error while executing '""+commandlineArguments+""'"");
				System.err.println(e);
				throw e;
			}
		}
		//} catch (Throwable t) {
		//	t.printStackTrace();
		//	System.err.println(t);
			// System.exit(1);
		//}
		/*
		 * try { File f = new File(OsUtil.getProMUserDirectory(),
		 * ""testrepo.xml""); Repository repo = new Repository(f.toURI().toURL());
		 * PackageManager.getInstance().addRepository(repo);
		 * 
		 * PackageManager.getInstance().update();
		 * 
		 * PackageDescriptor toInstall = null; System.out.println(""Enabled:"");
		 * for (PackageDescriptor pack :
		 * PackageManager.getInstance().getEnabledPackages()) {
		 * System.out.println(""  -  "" + pack); }
		 * System.out.println(""Installed:""); for (PackageDescriptor pack :
		 * PackageManager.getInstance().getInstalledPackages()) {
		 * System.out.println(""  -  "" + pack); } System.out.println(""Latest:"");
		 * for (PackageDescriptor pack :
		 * PackageManager.getInstance().getLatestPackages()) {
		 * System.out.println(""  - "" + pack); if
		 * (pack.getName().equals(""holub"")) { toInstall = pack; } }
		 * PackageManager.getInstance().installOrUpdate(toInstall);
		 * PackageManager.getInstance().uninstall(toInstall);
		 * System.out.println(""Done."");
		 * System.out.println(PackageManager.getInstance()); } catch (Exception
		 * e) { e.printStackTrace(); }
		 */
		// System.exit(0);
		return null;
	}

	private Pair<List<String>, List<String>> parseCommandLine(CommandLineArgumentList arguments, ScriptExecutor executor)
			throws IOException {
		AutoHelpCommandLineParser parser = new AutoHelpCommandLineParser(""java "" + this.getClass().getCanonicalName());

		CmdLineParser.Option helpOption = parser.addHelp(parser.addBooleanOption('h', ""help""),
				""Print this help message and exit"");
		CmdLineParser.Option listOption = parser.addHelp(parser.addBooleanOption('l', ""list""),
				""List all available plugins on standard output and exit"");
		CmdLineParser.Option stdinOption = parser.addHelp(parser.addBooleanOption('i', ""stdin""),
				""Read script from standard input"");
		CmdLineParser.Option scriptOption = parser.addHelp(parser.addStringOption('s', ""script""),
				""Execute the script given on the command line"");
		CmdLineParser.Option fileOption = parser.addHelp(parser.addStringOption('f', ""file""),
				""Read script from the given file"");

		try {
			parser.parse(arguments.toStringArray());
		} catch (CmdLineParser.OptionException e) {
			System.err.println(e.getMessage());
			parser.printUsage();
			return null;
		}

		if ((Boolean) parser.getOptionValue(listOption, Boolean.FALSE)) {
			for (Signature plugin : executor.getAvailablePlugins()) {
				System.out.println(plugin.toString(25, 1));
			}
			return null;
		}
		if ((Boolean) parser.getOptionValue(helpOption, Boolean.FALSE)) {
			parser.printUsage();
			return null;
		}

		List<String> scripts = new ArrayList<String>();
		if ((Boolean) parser.getOptionValue(stdinOption, Boolean.FALSE)) {
			scripts.add(readFromStdin());
		}
		for (Object script : parser.getOptionValues(scriptOption)) {
			scripts.add(script.toString());
		}
		for (Object scriptFile : parser.getOptionValues(fileOption)) {
			scripts.add(readFile(scriptFile.toString()));
		}

		return new Pair<List<String>, List<String>>(scripts, new ArrayList<String>(Arrays.asList(parser
				.getRemainingArgs())));
	}

	public static String readFile(String scriptFile) throws IOException {
		InputStream is = new FileInputStream(scriptFile);
		String result = readWholeStream(is);
		is.close();
		return result;
	}

	private static String readFromStdin() throws IOException {
		return readWholeStream(System.in);
	}

	private static String readWholeStream(InputStream is) throws IOException {
		InputStreamReader reader = new InputStreamReader(new BufferedInputStream(is));
		StringBuffer result = new StringBuffer();
		int c;

		while ((c = reader.read()) != -1) {
			result.append((char) c);
		}
		return result.toString();
	}

	public static void main(String[] args) throws Throwable {
	  try {
	    Boot.boot(CLI.class, CLIPluginContext.class, args);
	  } catch (InvocationTargetException e) {
	    throw e.getCause();
	  }
	}
}
"
CLIContext.java,prom-contexts-6.9.56,"package org.processmining.contexts.cli;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.impl.AbstractGlobalContext;

public class CLIContext extends AbstractGlobalContext {

	private final CLIPluginContext mainPluginContext;

	public CLIContext() {
		super();

		mainPluginContext = new CLIPluginContext(this, ""Main Plugin Context"");
	}

	@Override
	protected CLIPluginContext getMainPluginContext() {
		return mainPluginContext;
	}

	@Override
	public Class<? extends PluginContext> getPluginContextType() {
		return CLIPluginContext.class;
	}

}
"
CLIPluginContext.java,prom-contexts-6.9.56,"package org.processmining.contexts.cli;

import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

import org.processmining.framework.plugin.GlobalContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.plugin.impl.AbstractPluginContext;

public class CLIPluginContext extends AbstractPluginContext {

	private final Executor executor;

	public CLIPluginContext(GlobalContext context, String label) {
		super(context, label);
		// This context is NOT a child of another context,
		// hence should behave in an asynchronous way.
		executor = Executors.newCachedThreadPool();
		progress = new CLIProgressBar(this);
	}

	protected CLIPluginContext(CLIPluginContext context, String label) {
		super(context, label);
		progress = new CLIProgressBar(this);
		// This context is a child of another context,
		// hence should behave in a synchronous way.
		if (context/*.getParentContext()*/ == null) {
			// this context is on the first level below the user-initiated
			// plugins
			executor = Executors.newCachedThreadPool();
		} else {
			// all subtasks take the pool of the parent.
			executor = context.getExecutor();
		}
	}

	@Override
	protected synchronized PluginContext createTypedChildContext(String label) {
		return new CLIPluginContext(this, label);
	}

	public Executor getExecutor() {
		return executor;
	}

	@Override
	public Progress getProgress() {
		return progress;
	}

	@Override
	public CLIContext getGlobalContext() {
		return (CLIContext) super.getGlobalContext();
	}

	@Override
	public CLIPluginContext getRootContext() {
		return (CLIPluginContext) super.getRootContext();
	}
}
"
CLIProgressBar.java,prom-contexts-6.9.56,"package org.processmining.contexts.cli;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.impl.ProgressBarImpl;

public class CLIProgressBar extends ProgressBarImpl {

	public CLIProgressBar(PluginContext context) {
		super(context);
	}
}
"
PromTestException.java,prom-contexts-6.9.56,"package org.processmining.contexts.cli;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.util.List;

import junit.framework.AssertionFailedError;

/**
 * Exception that stores all collected failed tests that arised in {@link PromTestFramework}.
 * Call {@link #toString()} for a formatted test report.
 * 
 * @author dfahland
 */
public class PromTestException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = 3476724712772295479L;
	
	/**
	 * Associates a test case to a thrown exception that occurred during
	 * its execution.
	 */
	protected static class WrappedException {
		protected Method test = null;
		protected String testScript = null;
		protected Throwable thrown = null;
		
		public WrappedException(Method test, Throwable thrown) {
			this.test = test;
			this.thrown = thrown;
		}
		
		public WrappedException(String testScript, Throwable thrown) {
			this.testScript = testScript;
			this.thrown = thrown;
		}
	}
	
	/**
	 * Associates a test case to expected and returned results in case the test was not
	 * successful.
	 */
	protected static class ResultMismatch {
		protected Method test = null;
		protected String expected = null;
		protected String result = null;
		
		protected String testScript = null;
		protected AssertionFailedError junitResult = null;
		
		public ResultMismatch(Method test, String expected, String result) {
			this.test = test;
			this.expected = expected;
			this.result = result;
		}
		
		public ResultMismatch(String testScript, AssertionFailedError junitResult) {
			this.testScript = testScript;
			this.junitResult = junitResult;
		}

	}
	
	private List<ResultMismatch> failures;
	private List<WrappedException> errors;
	
	public PromTestException(List<ResultMismatch> failures, List<WrappedException> errors) {
		this.failures = failures;
		this.errors = errors;
	}
	
	public String toString() {
		
		StringBuilder sb = new StringBuilder();

		sb.append(""============================================================\n"");
		sb.append(""Number of failed tests: ""+failures.size()+""\n"");
		sb.append(""============================================================\n"");
		for (ResultMismatch fail : failures) {
			if (fail.test != null)
				sb.append(getTestName(fail.test)+""\n"");
			else
				sb.append(fail.testScript+""\n"");
			
			if (fail.junitResult != null) {
				sb.append(""--- ASSERTION FAILED ---------------------------------------\n"");
				sb.append(fail.junitResult.toString()+""\n"");				
				sb.append(""============================================================\n"");
			} else {
				sb.append(""--- RESULT -------------------------------------------------\n"");
				sb.append(fail.result+""\n"");
				sb.append(""--- EXPECTED -----------------------------------------------\n"");
				sb.append(fail.expected+""\n"");
				sb.append(""============================================================\n"");
			}
		}
		
		sb.append(""============================================================\n"");
		sb.append(""Number of errors: ""+errors.size()+""\n"");
		sb.append(""============================================================\n"");
		for (WrappedException error : errors) {
			if (error.test != null)
				sb.append(getTestName(error.test)+""\n"");
			else
				sb.append(error.testScript+""\n"");
			
			sb.append(""--- EXCEPTION ----------------------------------------------\n"");
			sb.append(error.thrown.toString()+""\n"");
			sb.append(""--- stack trace --------------------------------------------\n"");
		    final StringWriter result = new StringWriter();
		    final PrintWriter printWriter = new PrintWriter(result);
		    error.thrown.printStackTrace(printWriter);
			sb.append(result.toString()+""\n"");
			sb.append(""============================================================\n"");
		}

		return sb.toString();
	}

	private static String getTestName (Method m) {
		return m.getClass().toString()+"".""+m.getName();
	}
}
"
PromTestFramework.java,prom-contexts-6.9.56,"package org.processmining.contexts.cli;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;

import org.processmining.framework.annotations.TestMethod;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.impl.PluginCacheEntry;
import org.processmining.framework.util.CommandLineArgumentList;

public class PromTestFramework {

	@Plugin(name = ""ProMTest"", parameterLabels = {}, returnLabels = {}, returnTypes = {}, userAccessible = false)
	@Bootable
	public Object main(CommandLineArgumentList commandlineArguments) throws Throwable {
		System.out.println(""Entering ProM Test Framework"");
		
		// from where do we read the tests
		String classesToTestDir = null;			// default
		
		if (commandlineArguments.size() != 2)
			throw new Exception(""Error. The ProM Test Framework requires 2 arguments: (1) location of classes that contain tests, (2) location of test files"");
		
		// directory where test cases are stored
		classesToTestDir = commandlineArguments.get(0); 
		// read location where test input files and expected test outputs are stored
		final String testFileRoot = commandlineArguments.get(1);
		
		// scan directory for tests
		getAllTestMethods(classesToTestDir);
		
		// and run tests, collect all failed tests
		List<PromTestException.ResultMismatch> failedTest = new LinkedList<PromTestException.ResultMismatch>();
		List<PromTestException.WrappedException> errorTest = new LinkedList<PromTestException.WrappedException>();
		
		System.out.println(""Running ""+testMethods.size()+"" tests:"");
		for (Method test : testMethods) {
			
			try {
				System.out.println(test);
				
				// run test and get test result
				String result = (String)test.invoke(null);
				// load expected result
				String expected = null;
				if (testResultFromOutputAnnotation(test)) {
					expected = test.getAnnotation(TestMethod.class).output();
				} else if (testResultFromFile(test)) {
					expected = readFile(testFileRoot+""/""+test.getAnnotation(TestMethod.class).filename());
				}
				// compare result and expected
				if (!result.equals(expected)) {
					// test failed, store for reporting
					failedTest.add(
						new PromTestException.ResultMismatch(test, expected, result));
				}
			} catch (Throwable e) {
				// test crashed, store exception for reporting
				errorTest.add(
						new PromTestException.WrappedException(test, e));
			}
		}
		
		if (!failedTest.isEmpty() || ! errorTest.isEmpty()) {
			throw new PromTestException(failedTest, errorTest);
		}
		
    	return null;
	}
	
	private void getAllTestMethods(String lookUpDir) throws Exception {
		
		URL[] defaultURLs;
		
		if (lookUpDir == null) {
			URLClassLoader sysloader = (URLClassLoader) ClassLoader.getSystemClassLoader();
			defaultURLs = sysloader.getURLs();
		} else {
			File f = new File(lookUpDir);
			defaultURLs = new URL[] { f.toURI().toURL()	};
		}
		
		File f = new File(""."" + File.separator + Boot.LIB_FOLDER);
		String libPath = f.getCanonicalPath();

		for (URL url : defaultURLs) {
			if (Boot.VERBOSE == Level.ALL) {
				System.out.println(""Processing url: "" + url);
			}
			if (!(new File(url.toURI()).getCanonicalPath().startsWith(libPath))) {
				if (Boot.VERBOSE == Level.ALL) {
					System.out.println(""Scanning for tests: "" + url);
				}
				register(url);
			} else {
				if (Boot.VERBOSE == Level.ALL) {
					System.out.println(""Skipping: "" + url.getFile() + "" while scanning for tests."");
				}
			}
		}
	}
	
	/**
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginManager#register(java.net.URL)
	 */
	public void register(URL url) {
		if (url.getProtocol().equals(PluginManager.FILE_PROTOCOL)) {
			try {
				File file = new File(url.toURI());

				if (file.isDirectory()) {
					scanDirectory(file);
					return;
				}
				// we ignore: PluginManager.MCR_EXTENSION
				else if (file.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
					scanUrl(url);
				}
			} catch (URISyntaxException e) {
				// fireError(url, e, null);
				System.err.println(e);
			}
		} else {
			// scanUrl(url);
			System.err.println(""Loading tests from ""+url+"" not supported."");
		}
	}
	
	private void scanDirectory(File file) {
		try {
			URL url = file.toURI().toURL();
			URLClassLoader loader = new URLClassLoader(new URL[] { url });

			Queue<File> todo = new LinkedList<File>();
			FileFilter filter = new FileFilter() {
				public boolean accept(File pathname) {
					return pathname.isDirectory() || pathname.getPath().endsWith(PluginManager.CLASS_EXTENSION);
				}
			};

			todo.add(file);
			while (!todo.isEmpty()) {
				File dir = todo.remove();

				for (File f : dir.listFiles(filter)) {
					if (f.isDirectory()) {
						todo.add(f);
					} else {
						if (f.getAbsolutePath().endsWith(PluginManager.CLASS_EXTENSION)) {
							loadClassFromFile(loader, url,
									makeRelativePath(file.getAbsolutePath(), f.getAbsolutePath()));
						}
					}
				}
			}
		} catch (MalformedURLException e) {
			//fireError(null, e, null);
			System.err.println(e);
		}
	}
	
	private void scanUrl(URL url) {
		URLClassLoader loader = new URLClassLoader(new URL[] { url });
		PluginCacheEntry cached = new PluginCacheEntry(url, Boot.VERBOSE);

		if (cached.isInCache()) {
			for (String className : cached.getCachedClassNames()) {
				loadClass(loader, url, className);
			}
		} else {
			try {
				InputStream is = url.openStream();
				JarInputStream jis = new JarInputStream(is);
				JarEntry je;
				List<String> loadedClasses = new ArrayList<String>();

				while ((je = jis.getNextJarEntry()) != null) {
					if (!je.isDirectory() && je.getName().endsWith(PluginManager.CLASS_EXTENSION)) {
						String loadedClass = loadClassFromFile(loader, url, je.getName());
						loadedClasses.add(loadedClass);
					}
				}
				jis.close();
				is.close();

				cached.update(loadedClasses);
			} catch (IOException e) {
				//fireError(url, e, null);
				System.err.println(e);
			}
		}
	}


	private String makeRelativePath(String root, String absolutePath) {
		String relative = absolutePath;

		if (relative.startsWith(root)) {
			relative = relative.substring(root.length());
			if (relative.startsWith(File.separator)) {
				relative = relative.substring(File.separator.length());
			}
		}
		return relative;
	}
	
	private static final char PACKAGE_SEPARATOR = '.';
	private static final char URL_SEPARATOR = '/';
	private static final char INNER_CLASS_MARKER = '$';

	
	private String loadClassFromFile(URLClassLoader loader, URL url, String classFilename) {
		if (classFilename.indexOf(INNER_CLASS_MARKER) >= 0) {
			// we're not going to load inner classes
			return null;
		}
		return loadClass(loader, url, classFilename.substring(0, classFilename.length() - PluginManager.CLASS_EXTENSION.length())
				.replace(URL_SEPARATOR, PACKAGE_SEPARATOR).replace(File.separatorChar, PACKAGE_SEPARATOR));
	}
	

	private final List<Method> testMethods = new LinkedList<Method>();
	
	/**
	 * Returns the name of the class, if it is annotated, or if any of its
	 * methods carries a plugin annotation!
	 * 
	 * @param loader
	 * @param url
	 * @param className
	 * @return
	 */
	private String loadClass(URLClassLoader loader, URL url, String className) {
		boolean isAnnotated = false;

		if ((className == null) || className.trim().equals("""")) {
			return null;
		}

		className = className.trim();
		try {
			Class<?> pluginClass = Class.forName(className, false, loader);
			/*
			// Check if plugin annotation is present
			if (pluginClass.isAnnotationPresent(Plugin.class) && isGoodPlugin(pluginClass)) {
				PluginDescriptorImpl pl = new PluginDescriptorImpl(pluginClass, pluginContextType);
				addPlugin(pl);
			}*/

			for (Method method : pluginClass.getMethods()) {
				
				if (method.isAnnotationPresent(TestMethod.class) && isGoodTest(method)) {
					testMethods.add(method);
				}
			}
		} catch (Throwable t) {
			// fireError(url, t, className);
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""[Framework] ERROR while scanning for testable plugins at: "" + url + "":"");
				System.err.println(""   in file :"" + className);
				System.err.println(""   "" + t.getMessage());
				t.printStackTrace();
			}
		}
		return isAnnotated ? className : null;
	}
	
	private boolean isGoodTest(Method method) {
		
		assert(method.isAnnotationPresent(TestMethod.class));
		
		// check annotations
		if (!testResultFromFile(method) && !testResultFromOutputAnnotation(method)) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""No expected test result specified."");
			}
			return false;
		}

		// check return type: must be String
		if ((method.getModifiers() & Modifier.STATIC) == 0) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""Test must be static."");
			}
			return false;
		}

		// check return type: must be String
		if (!method.getReturnType().equals(String.class)) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""Return result must be java.lang.String"");
			}
			return false;
		}

		// check parameter types: must be empty
		Class<?>[] pars = method.getParameterTypes();
		if (pars != null && pars.length > 0) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""A test must not take any parameters."");
			}
			return false;			
		}
		return true;
	}

	/**
	 * @param method
	 * @return <code>true</code> iff the method is annotated with
	 *         {@link TestMethod#filename()}. Then the result of the test will
	 *         be compared to the contents of a file.
	 */
	private static boolean testResultFromFile(Method method) {
		assert(method.isAnnotationPresent(TestMethod.class));		
		return 
			method.getAnnotation(TestMethod.class).filename() != null
			&& !method.getAnnotation(TestMethod.class).filename().isEmpty();
	}

	/**
	 * @param method
	 * @return <code>true</code> iff the method is annotated with
	 *         {@link TestMethod#output()}. Then the result of the test will
	 *         be compared to the specified string.
	 */
	private static boolean testResultFromOutputAnnotation(Method method) {
		assert(method.isAnnotationPresent(TestMethod.class));
		return
			method.getAnnotation(TestMethod.class).output() != null
			&& !method.getAnnotation(TestMethod.class).output().isEmpty();
	}
	
	private static String readFile(String scriptFile) throws IOException {
		InputStream is = new FileInputStream(scriptFile);
		String result = readWholeStream(is);
		is.close();
		return result;
	}

	private static String readWholeStream(InputStream is) throws IOException {
		InputStreamReader reader = new InputStreamReader(new BufferedInputStream(is));
		StringBuffer result = new StringBuffer();
		int c;

		while ((c = reader.read()) != -1) {
			result.append((char) c);
		}
		return result.toString();
	}
	
	public static void main(String[] args) throws Throwable {
	  try {
	    Boot.boot(PromTestFramework.class, CLIPluginContext.class, args);
	  } catch (InvocationTargetException e) {
	    throw e.getCause();
	  }
	}
}
"
ScriptExecutor.java,prom-contexts-6.9.56,"package org.processmining.contexts.scripting;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.annotations.CLI;
import org.processmining.framework.util.StringUtils;

import bsh.EvalError;
import bsh.Interpreter;
import bsh.TargetError;

/**
 * Script interpretor for ProM. The class provides a wrapper around
 * the Java BSH {@link Interpreter} to initialize all available plugins
 * from the .ProM user directory in an {@link Interpreter}. This
 * interpreter can the be used to interpret Java code at run-time
 * against the plugins, which allows for scripted execution of ProM plugins.
 * 
 * @author dfahland and others
 */
public class ScriptExecutor {

	// the interpreter used to run a script
	private Interpreter interpreter;
	// the plugin context in which the interpreter is executed, it
	// allows to retrieve the available plugins
	private final PluginContext context;

	// set of all method signatures announced by available plugins
	private Set<Signature> availablePlugins;
	// set of all method signatures announced by plugins that could not
	// be loaded for one reason or the other
	private Set<Signature> failedPlugins;

	/**
	 * Meant to provide diagnostic information in case a script fails.
	 */
	public class ScriptExecutionException extends Exception {

		private static final long serialVersionUID = -4777627419215658865L;

		public ScriptExecutionException(EvalError e) {
			super(e);
		}
		
		public ScriptExecutionException(String e) {
			super(e);
		}
	}

	/**
	 * Initialize a new interpreter with all available plugins.
	 * 
	 * @param context
	 * @throws ScriptExecutionException
	 */
	public ScriptExecutor(PluginContext context) throws ScriptExecutionException {
		this.context = context;
		
		availablePlugins = new HashSet<Signature>();
		failedPlugins = new HashSet<Signature>();
		
		init();
	}

	/**
	 * Execute a script in the interpreter.
	 * 
	 * @param script
	 * @throws ScriptExecutionException
	 */
	public void execute(String script) throws Throwable {
		try {
			interpreter.eval(script);
		} catch (EvalError e) {
		  
			// provide more detailed error messages
			if (e instanceof TargetError) {
				TargetError e2 = (TargetError)e;
				
				if (e2.getTarget() instanceof ExecutionException) {
					ExecutionException e3 = (ExecutionException)e2.getTarget();
					
					if (e3.getCause() instanceof FileNotFoundException) {
						System.err.println(""Error. The script tries to access a non-existing file path:\n  ""+
								((FileNotFoundException)e3.getCause()).getMessage());
					}
					
				  throw e3.getCause();
				} else if (e2.getTarget() instanceof java.util.concurrent.CancellationException) {
				  System.err.println(""Script execution was cancelled. Message:\n""+e);
				  throw e2.getTarget();
				} else if (e2.getTarget() instanceof java.lang.AssertionError) {
				  throw e2.getTarget();
				}
			}
			throw new ScriptExecutionException(e);
		}
	}
	
	/**
	 * Iterate over all registered plugins, find their declared methods
	 * and try to create an invocation context for each. Return the list
	 * of plugins that succeeded, and save the list of methods that failed.
	 * 
	 * @return
	 */
	private LinkedList<PluginDescriptor> workingPlugins() {
		LinkedList<PluginDescriptor> workingPlugins = new LinkedList<PluginDescriptor>();

		Set<Signature> foundSignatures = new HashSet<Signature>();
		String nl = System.getProperty(""line.separator"");
		int pluginIndex = 0;

		for (PluginDescriptor plugin : context.getPluginManager().getAllPlugins())
		{
			if (Boot.VERBOSE == Level.ALL) System.out.println(""checking ""+plugin.getName());

			// method signatures of this plugin
			Set<Signature> thisPluginSignatures = new HashSet<Signature>();
			
			try {
				
				StringBuffer init = new StringBuffer();
				Interpreter pluginInterpreter = new Interpreter();
				pluginInterpreter.set(""__main_context"", context);
				
				// the right context type is checked at start by the
				// pluginmanager
				// if
				// (plugin.getContextType().isAssignableFrom(context.getClass()))
				// {
				for (int j = 0; j < plugin.getParameterTypes().size(); j++) {
					Signature signature = getSignature(plugin, j);
					thisPluginSignatures.add(signature);

					if (!foundSignatures.contains(signature)) {
						foundSignatures.add(signature);
						pluginIndex++;

						pluginInterpreter.set(""__plugin_descriptor"" + pluginIndex, plugin);
						pluginInterpreter.set(""__plugin_method_index"" + pluginIndex, j);

						if (signature.getReturnTypes().size() == 1) {
							init.append(Object.class.getCanonicalName());
						} else {
							init.append(Object[].class.getCanonicalName());
						}
						init.append("" "" + signature.getName() + ""("");

						int index = 0;
						for (Class<?> cl : signature.getParameterTypes()) {
							if (index > 0) {
								init.append("", "");
							}
							init.append(cl.getCanonicalName());
							init.append("" p"" + index++);
						}
						init.append("") {"" + nl);
						init.append(""    "" + PluginContext.class.getCanonicalName()
								+ "" context = __main_context.createChildContext(\""Result of "");
						init.append(signature.getName() + ""\"");"" + nl);

						init.append(""    __plugin_descriptor"" + pluginIndex + "".invoke(__plugin_method_index""
								+ pluginIndex + "", context, new "" + (Object[].class.getCanonicalName()) + "" { "");
						for (int i = 0; i < signature.getParameterTypes().size(); i++) {
							if (i > 0) {
								init.append("", "");
							}
							init.append(""p"" + i);
						}
						init.append("" });"" + nl);

						if (signature.getReturnTypes().size() > 1) {
							init.append(""    context.getResult().synchronize();"" + nl);
							init.append(""    "" + Object[].class.getCanonicalName() + "" result = new ""
									+ Object.class.getCanonicalName() + ""[context.getResult().getSize()];"" + nl);
							init
									.append(""    for (int i = 0; i < result.length; i++) { result[i] = context.getResult().getResult(i); }""
											+ nl);
							init.append(""    return result;"" + nl);
						} else {
							init.append(""    return context.getFutureResult(0).get();"" + nl);
						}
						init.append(""}"" + nl);
					}
				}

				//pluginInterpreter.eval(init.toString());
				workingPlugins.addLast(plugin);		// this plugin works, remeber it
			
			} catch (EvalError e) {
				System.err.println(""Failed to load plugin ""+plugin.getName());
				failedPlugins.addAll(thisPluginSignatures);
				
			} catch (NoClassDefFoundError e) {
				System.err.println(""Failed to load plugin ""+plugin.getName());
				System.err.println(""Missing class ""+e.getMessage());
				failedPlugins.addAll(thisPluginSignatures);
			}
			workingPlugins.addLast(plugin);
		}
		return workingPlugins;
	}

	private void init() throws ScriptExecutionException {
		String nl = System.getProperty(""line.separator"");
		int pluginIndex = 0;

		try {
		StringBuffer init = new StringBuffer();
		interpreter = new Interpreter();
		interpreter.set(""__main_context"", context);
		
		System.out.println(""initializing all plugins"");
	
    	for (PluginDescriptor plugin : context.getPluginManager().getAllPlugins()) {
    	// skip scanning for working plugins. question: why does scanning for working plugins
    	// take so much more time?
		//for (PluginDescriptor plugin : workingPlugins()) {
			
			if (Boot.VERBOSE == Level.ALL) System.out.println(""initializing ""+plugin.getName());
			// the right context type is checked at start by the pluginmanager
			// if (plugin.getContextType().isAssignableFrom(context.getClass()))
			// {
			for (int j = 0; j < plugin.getParameterTypes().size(); j++) {
				Signature signature = getSignature(plugin, j);

				if (!availablePlugins.contains(signature)) {
					availablePlugins.add(signature);
					pluginIndex++;

					interpreter.set(""__plugin_descriptor"" + pluginIndex, plugin);
					interpreter.set(""__plugin_method_index"" + pluginIndex, j);

					// The following code generates a piece of Java code which declares a Java method.
					// This Java method is a wrapper for the plugin method we are currently initializing.
					// The name of the new Java method is a transcription of the name that was declared in
					// the @PluginVariant{} annotation of the plugin (or the name of the owning @Plugin class).
					// The body of the wrapper method uses ProM's invocation context and plugin descriptor
					// to correctly call the plugin with the given parameters, it also returns the results
					// after the plugin had been executed.

					// A script can then use the transcribed name of the Java plugin to call the plugin.

					// signature of the wrapper method: return type, name, ...
					if (signature.getReturnTypes().size() == 1) {
						init.append(Object.class.getCanonicalName());
					} else {
						init.append(Object[].class.getCanonicalName());
					}
					init.append("" "" + signature.getName() + ""("");

					// signature of the wrapper method: ... parameters ...
					int index = 0;
					for (Class<?> cl : signature.getParameterTypes()) {
						if (index > 0) {
							init.append("", "");
						}
						init.append(cl.getCanonicalName());
						init.append("" p"" + index++);
					}

					// body of the wrapper method: get execution context and invoke plugin
					init.append("") {"" + nl);
					init.append(""    "" + PluginContext.class.getCanonicalName()
							+ "" context = __main_context.createChildContext(\""Result of "");
					init.append(signature.getName() + ""\"");"" + nl);

					init.append(""    __plugin_descriptor"" + pluginIndex + "".invoke(__plugin_method_index""
							+ pluginIndex + "", context, new "" + (Object[].class.getCanonicalName()) + "" { "");
					for (int i = 0; i < signature.getParameterTypes().size(); i++) {
						if (i > 0) {
							init.append("", "");
						}
						init.append(""p"" + i);
					}
					init.append("" });"" + nl);

					// body of the wrapper method: wait for plugin method to complete and return result
					if (signature.getReturnTypes().size() > 1) {
						init.append(""    context.getResult().synchronize();"" + nl);
						init.append(""    "" + Object[].class.getCanonicalName() + "" result = new ""
								+ Object.class.getCanonicalName() + ""[context.getResult().getSize()];"" + nl);
						init
						.append(""    for (int i = 0; i < result.length; i++) { result[i] = context.getResult().getResult(i); }""
								+ nl);
						init.append(""    return result;"" + nl);
					} else {
						init.append(""    return context.getFutureResult(0).get();"" + nl);
					}
					init.append(""}"" + nl);
					// finished declaring wrapper method 
				}
			} // for each plugin variant
    	} // for each plugin

    	// compile the Java code for all wrapper methods
    	interpreter.eval(init.toString());
				
		} catch (EvalError e) {
			System.err.println(""Failed to load one of the plugins."");
			throw new ScriptExecutionException(e);
		} catch (NoClassDefFoundError e) {
			System.err.println(""Failed to load one of the plugins."");
			throw new ScriptExecutionException(""Missing class ""+e.getMessage());
		}
	}

	private Signature getSignature(PluginDescriptor plugin, int index) {
		String name;

		if (plugin.hasAnnotation(CLI.class)) {
			name = plugin.getAnnotation(CLI.class).functionName();
		} else {
			name = plugin.getName();
		}
		return new Signature(plugin.getReturnTypes(), StringUtils.getJavaIdentifier(name), plugin
				.getParameterTypes(index));
	}

	public void bind(String name, Object value) throws ScriptExecutionException {
		try {
			interpreter.set(name, value);
		} catch (EvalError e) {
			throw new ScriptExecutionException(e);
		}
	}

	public List<Signature> getAvailablePlugins() {
		List<Signature> result = new ArrayList<Signature>(availablePlugins);

		Collections.sort(result, new Comparator<Signature>() {
			public int compare(Signature a, Signature b) {
				return a.getName().compareTo(b.getName());
			}
		});
		return result;
	}
}
"
Signature.java,prom-contexts-6.9.56,"package org.processmining.contexts.scripting;

import java.util.Collections;
import java.util.List;

public class Signature {

	private final String name;
	private final List<Class<?>> parameterTypes;
	private final List<Class<?>> returnTypes;

	Signature(List<Class<?>> returnTypes, String name, List<Class<?>> parameterTypes) {
		this.returnTypes = returnTypes;
		this.name = name;
		this.parameterTypes = parameterTypes;
	}

	public boolean equals(Object o) {
		if (!(o instanceof Signature)) {
			return false;
		}
		Signature other = (Signature) o;
		return name.equals(other.name) && parameterTypes.equals(other.parameterTypes);
	}

	public int hashCode() {
		return name.hashCode();
	}

	public String getName() {
		return name;
	}

	public List<Class<?>> getParameterTypes() {
		return Collections.unmodifiableList(parameterTypes);
	}

	public List<Class<?>> getReturnTypes() {
		return returnTypes;
	}

	public String toString() {
		return toString(1, 1);
	}

	public String toString(int indent1, int indent2) {
		String result = getName() + ""("";

		boolean isFirst = true;
		for (Class<?> param : getParameterTypes()) {
			if (isFirst) {
				isFirst = false;
			} else {
				result += "", "";
			}
			result += param.getSimpleName();
		}
		result += "") -> "";

		if (getReturnTypes().size() > 1) {
			result += ""("";
		}
		isFirst = true;
		for (Class<?> type : getReturnTypes()) {
			if (isFirst) {
				isFirst = false;
			} else {
				result += "", "";
			}
			result += type.getSimpleName();
		}
		if (getReturnTypes().size() > 1) {
			result += "")"";
		}
		return result;
	}
}
"
AllInclassMethodTests.java,prom-contexts-6.9.56,"package org.processmining.contexts.test;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;

import org.processmining.framework.annotations.TestMethod;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.plugin.PluginManager;

/**
 * Utility class to collect all methods annotated with <code>@TestMethod</code>
 * from a given location of compiled Java classes.
 * 
 * @author dfahland
 */
public class AllInclassMethodTests {

	// the list fo all found methods
	private final List<Method> testMethods = new LinkedList<Method>();
	
	/**
	 * @return all found methods
	 */
	public List<Method> getAllTestMethods() {
		return testMethods;
	}
	
	/**
	 * Find all methods with annotation <code>@TestMethod</code> in the given
	 * loop up directory. The classes can be stored inside a JAR file. The list
	 * of found methods can be retrieved with {@link #getAllTestMethods()}.
	 * 
	 * This method can be run several times to scan classes from different
	 * directories.
	 * 
	 * @param lookUpDir
	 */
	public void collectAllTestMethods(String lookUpDir)  {
		
		System.out.println(""Collecting inclass method tests from ""+lookUpDir);

		try {
	
			URL[] defaultURLs;
			
			if (lookUpDir == null) {
				URLClassLoader sysloader = (URLClassLoader) ClassLoader.getSystemClassLoader();
				defaultURLs = sysloader.getURLs();
			} else {
				File f = new File(lookUpDir);
				defaultURLs = new URL[] { f.toURI().toURL()	};
			}
			
			File f = new File(""."" + File.separator + Boot.LIB_FOLDER);
			String libPath = f.getCanonicalPath();
	
			for (URL url : defaultURLs) {
				if (Boot.VERBOSE == Level.ALL) {
					System.out.println(""Processing url: "" + url);
				}
				if (!(new File(url.toURI()).getCanonicalPath().startsWith(libPath))) {
					if (Boot.VERBOSE == Level.ALL) {
						System.out.println(""Scanning for tests: "" + url);
					}
					register(url);
				} else {
					if (Boot.VERBOSE == Level.ALL) {
						System.out.println(""Skipping: "" + url.getFile() + "" while scanning for tests."");
					}
				}
			}
		} catch (MalformedURLException e) {
			System.err.println(lookUpDir+"" gives an invalid URL.\n""+e);
		} catch (URISyntaxException e) {
			System.err.println(lookUpDir+"" gives an invalid URI.\n""+e);
		} catch (IOException e) {
			System.err.println(""Could not read ""+lookUpDir+""\n""+e);
		}
	}
	
	private void register(URL url) {
		if (url.getProtocol().equals(PluginManager.FILE_PROTOCOL)) {
			try {
				File file = new File(url.toURI());

				if (file.isDirectory()) {
					scanDirectory(file);
					return;
				}
				// we ignore: PluginManager.MCR_EXTENSION
				else if (file.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
					scanUrl(url);
				}
			} catch (URISyntaxException e) {
				// fireError(url, e, null);
				System.err.println(e);
			}
		} else {
			// scanUrl(url);
			System.err.println(""Loading tests from ""+url+"" not supported."");
		}
	}
	
	private void scanDirectory(File file) {
		try {
			URL url = file.toURI().toURL();
			URLClassLoader loader = new URLClassLoader(new URL[] { url });

			Queue<File> todo = new LinkedList<File>();
			FileFilter filter = new FileFilter() {
				public boolean accept(File pathname) {
					return pathname.isDirectory() || pathname.getPath().endsWith(PluginManager.CLASS_EXTENSION);
				}
			};

			todo.add(file);
			while (!todo.isEmpty()) {
				File dir = todo.remove();

				for (File f : dir.listFiles(filter)) {
					if (f.isDirectory()) {
						todo.add(f);
					} else {
						if (f.getAbsolutePath().endsWith(PluginManager.CLASS_EXTENSION)) {
							loadClassFromFile(loader, url,
									makeRelativePath(file.getAbsolutePath(), f.getAbsolutePath()));
						}
					}
				}
			}
		} catch (MalformedURLException e) {
			//fireError(null, e, null);
			System.err.println(e);
		}
	}
	
	private void scanUrl(URL url) {
		URLClassLoader loader = new URLClassLoader(new URL[] { url });
		try {
			InputStream is = url.openStream();
			JarInputStream jis = new JarInputStream(is);
			JarEntry je;
			List<String> loadedClasses = new ArrayList<String>();

			while ((je = jis.getNextJarEntry()) != null) {
				if (!je.isDirectory() && je.getName().endsWith(PluginManager.CLASS_EXTENSION)) {
					String loadedClass = loadClassFromFile(loader, url, je.getName());
					loadedClasses.add(loadedClass);
				}
			}
			jis.close();
			is.close();

		} catch (IOException e) {
			//fireError(url, e, null);
			System.err.println(e);
		}
	}


	private String makeRelativePath(String root, String absolutePath) {
		String relative = absolutePath;

		if (relative.startsWith(root)) {
			relative = relative.substring(root.length());
			if (relative.startsWith(File.separator)) {
				relative = relative.substring(File.separator.length());
			}
		}
		return relative;
	}
	
	private static final char PACKAGE_SEPARATOR = '.';
	private static final char URL_SEPARATOR = '/';
	private static final char INNER_CLASS_MARKER = '$';

	
	private String loadClassFromFile(URLClassLoader loader, URL url, String classFilename) {
//		if (classFilename.indexOf(INNER_CLASS_MARKER) >= 0) {
//			// we're not going to load inner classes
//			return null;
//		}
		return loadClass(loader, url, classFilename.substring(0, classFilename.length() - PluginManager.CLASS_EXTENSION.length())
				.replace(URL_SEPARATOR, PACKAGE_SEPARATOR).replace(File.separatorChar, PACKAGE_SEPARATOR));
	}
	

	/**
	 * Returns the name of the class, if it is annotated, or if any of its
	 * methods carries a plugin annotation!
	 * 
	 * @param loader
	 * @param url
	 * @param className
	 * @return
	 */
	private String loadClass(URLClassLoader loader, URL url, String className) {
		boolean isAnnotated = false;

		if ((className == null) || className.trim().equals("""")) {
			return null;
		}

		className = className.trim();
		try {
			Class<?> pluginClass = Class.forName(className, false, loader);
			/*
			// Check if plugin annotation is present
			if (pluginClass.isAnnotationPresent(Plugin.class) && isGoodPlugin(pluginClass)) {
				PluginDescriptorImpl pl = new PluginDescriptorImpl(pluginClass, pluginContextType);
				addPlugin(pl);
			}*/

			for (Method method : pluginClass.getMethods()) {
				
				if (method.isAnnotationPresent(TestMethod.class) && isGoodTest(method)) {
					testMethods.add(method);
				}
			}
		} catch (Throwable t) {
			// fireError(url, t, className);
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""[Framework] ERROR while scanning for tests at: "" + url + "":"");
				System.err.println(""   in file :"" + className);
				System.err.println(""   "" + t.getMessage());
				t.printStackTrace();
			}
		}
		return isAnnotated ? className : null;
	}
	
	private boolean isGoodTest(Method method) {
		
		assert(method.isAnnotationPresent(TestMethod.class));
		
		// check annotations
		if (!testExpectedFromFile(method) && !testExpectedFromOutputAnnotation(method)) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""No expected test result specified."");
			}
			return false;
		}

		// check return type: must be String
		if ((method.getModifiers() & Modifier.STATIC) == 0) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""Test must be static."");
			}
			return false;
		}

		// check return type: must be String
		if (!method.getReturnType().equals(String.class)) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""Return result must be java.lang.String"");
			}
			return false;
		}

		// check parameter types: must be empty
		Class<?>[] pars = method.getParameterTypes();
		if (pars != null && pars.length > 0) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Test "" + method.toString() + "" could not be loaded. ""
						+ ""A test must not take any parameters."");
			}
			return false;			
		}
		return true;
	}

	/**
	 * @param method
	 * @return <code>true</code> iff the method is annotated with
	 *         {@link TestMethod#filename()}. Then the result of the test will
	 *         be compared to the contents of a file.
	 */
	public static boolean testExpectedFromFile(Method method) {
		assert(method.isAnnotationPresent(TestMethod.class));		
		return 
			method.getAnnotation(TestMethod.class).filename() != null
			&& !method.getAnnotation(TestMethod.class).filename().isEmpty();
	}

	/**
	 * @param method
	 * @return <code>true</code> iff the method is annotated with
	 *         {@link TestMethod#output()}. Then the result of the test will
	 *         be compared to the specified string.
	 */
	public static boolean testExpectedFromOutputAnnotation(Method method) {
		assert(method.isAnnotationPresent(TestMethod.class));
		return
			method.getAnnotation(TestMethod.class).output() != null
			&& !method.getAnnotation(TestMethod.class).output().isEmpty();
	}
	
	/**
	 * @param method
	 * @return <code>true</code> iff the method is annotated with
	 *         <code>{@link TestMethod#returnSystemOut()} == true</code>.
	 *         Then the return result of the method will be everything the
	 *         method wrote to {@link System#out}.
	 */
	public static boolean testResultFromSystemOut(Method method) {
		assert(method.isAnnotationPresent(TestMethod.class));
		return
			method.getAnnotation(TestMethod.class).returnSystemOut() == true;
	}
	
	public static String getTestName (Method m) {
		return m.getClass().toString()+"".""+m.getName();
	}
	
	@TestMethod(output=""correct output"")
	public static String test_basicOutputTest() {
		return ""correct output"";
	}
	
	@TestMethod(filename=""testresult_AllInclassMethodTests_basicFileTest.txt"")
	public static String test_basicFileTest() {
		return ""correct output (filetest)"";
	}

	@TestMethod(filename=""testresult_AllInclassMethodTests_basicFileTest.txt"", output=""correct output"")
	public static String test_dualTest() {
		return ""correct output"";
	}
	
	@TestMethod(filename=""testresult_AllInclassMethodTests_basicFileTest.txt"", returnSystemOut=true)
	public static String test_basicFileTest_OutputStream() {
		System.out.print(""correct output"");
		System.out.print("" (filetest)"");
		return null;
	}
}
"
AllStandardScriptTests.java,prom-contexts-6.9.56,"package org.processmining.contexts.test;

import java.io.File;
import java.util.LinkedList;
import java.util.List;

/**
 * Utility class to collect all test scripts annotated in a given directory.
 * 
 * @author dfahland
 */
public class AllStandardScriptTests {
	
	public static final String TESTSCRIPT_FILE_EXTENSION = ""txt"";

	/**
	 * @param lookUpDir
	 * @return all test script files in the given directory
	 */
	public static List<String> getAllTestScripts(String lookUpDir) {
		
		System.out.println(""Collecting scripted tests from ""+lookUpDir);
		
		List<String> testScriptFiles = new LinkedList<String>();
		
		File dir = new File(lookUpDir);
		if (dir.isDirectory()) {
			for (String file : dir.list()) {
				if (file.endsWith(TESTSCRIPT_FILE_EXTENSION)) {
					testScriptFiles.add(file);
				}
			}
		} else if (lookUpDir.endsWith(TESTSCRIPT_FILE_EXTENSION)) {
			testScriptFiles.add(lookUpDir);
		}
		
		return testScriptFiles;
	}

}
"
FactoryRunner.java,prom-contexts-6.9.56,"/****************************************************************************
 * Copyright (c) 2011. All rights reserved. Ted Young.
 * Original source code published at
 * http://tedyoung.me/2011/01/22/junit-runtime-tests-overview/
 * 
 * Code adapted for ProM by Dirk Fahland.
 ****************************************************************************/
package org.processmining.contexts.test.factory;

import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.TestClass;

/**
 * A helper method that can be used to modify how JUnit executes a test suite.
 * Add annotation <code>@RunWith(FactoryRunner.class)</code> to the JUnit test
 * to hook this helper to the JUnit test suite. When executing the test suite
 * with JUnit, all methods of the test suite that are annotated with {@link TestFactory}
 * will be executed before all other tests. Each of these methods dynamically
 * adds a number of JUnit tests to the test suite.
 * 
 * @author Ted Young
 */
public class FactoryRunner extends BlockJUnit4ClassRunner {
	protected LinkedList<FrameworkMethod> tests = new LinkedList<FrameworkMethod>();

	public FactoryRunner(Class<?> clazz) throws InitializationError {
		super(clazz);
		try {
			computeTests();
		}
		catch (Exception e) {
			throw new InitializationError(e);
		}
	}

	protected void computeTests() throws Exception {
		tests.addAll(super.computeTestMethods());
		tests.addAll(computeFactoryTests());
		
		// This is called here to ensure the test class constructor is called at least
		// once during testing.  If a test class has only TestFactories, than the 
		// test class will never be instantiated by JUnit.
		createTest();
	}
	
	protected Collection<? extends FrameworkMethod> computeFactoryTests() throws Exception {
		List<FrameworkFactoryTest> tests = new LinkedList<FrameworkFactoryTest>();

		// Final all methods in our test class marked with @TestFactory.
		for (FrameworkMethod method: getTestClass().getAnnotatedMethods(TestFactory.class)) {
			// Make sure the TestFactory method is static
			if (!Modifier.isStatic(method.getMethod().getModifiers()))
				throw new InitializationError(""TestFactory "" + method + "" must be static."");

			// Execute the method (statically)
			Object instances = method.getMethod().invoke(getTestClass().getJavaClass());

			// Did the factory return an array?  If so, make it a list.
			if (instances.getClass().isArray())
				instances = Arrays.asList((Object[]) instances);

			// Did the factory return a scalar object?  If so, put it in a list.
			if (!(instances instanceof Iterable<?>))
				instances = Collections.singletonList(instances);

			// For each object returned by the factory.
			for (Object instance: (Iterable<?>) instances) {
				// Find any methods marked with @FactoryTest.
				for (FrameworkMethod m: new TestClass(instance.getClass()).getAnnotatedMethods(FactoryTest.class))
					tests.add(new FrameworkFactoryTest(m.getMethod(), instance, method.getName()));
			}
		}

		return tests;
	}
	
	/**
	 * {@inheritDoc}
	 * @see org.junit.runners.BlockJUnit4ClassRunner#computeTestMethods()
	 */
	@Override
	protected List<FrameworkMethod> computeTestMethods() {
		return tests;
	}
	
	/**
	 * This method overrides the original method <code>validateInstanceMethods(...)</code>
	 * of {@link BlockJUnit4ClassRunner} to avoid a crash of the JUnit test suite caused
	 * by adding {@link FactoryTest}s to the test suite before pre-defined tests are loaded.
	 * 
	 * The original method is marked <code>@Deprecated</code>. 
	 * TODO: Remove this overriding method once the original is removed from the JUnit framework. 
	 */
	@Override
	@SuppressWarnings(""deprecation"")
	protected void validateInstanceMethods(List<Throwable> errors) {
		validatePublicVoidNoArgMethods(After.class, false, errors);
		validatePublicVoidNoArgMethods(Before.class, false, errors);
		validateTestMethods(errors);
	}
}



"
FactoryTest.java,prom-contexts-6.9.56,"/****************************************************************************
 * Copyright (c) 2011. All rights reserved. Ted Young.
 * Original source code published at
 * http://tedyoung.me/2011/01/22/junit-runtime-tests-overview/
 * 
 * Code adapted for ProM by Dirk Fahland.
 ****************************************************************************/

package org.processmining.contexts.test.factory;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * This annotation declares a Java method as 'Test Factory Method'
 * which will be turned into a JUnit test for each object that is
 * registered at the {@link TestFactory}.
 *  
 * @author Ted Young
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface FactoryTest {
}
"
FrameworkFactoryTest.java,prom-contexts-6.9.56,"/****************************************************************************
 * Copyright (c) 2011. All rights reserved. Ted Young.
 * Original source code published at
 * http://tedyoung.me/2011/01/22/junit-runtime-tests-overview/
 * 
 * Code adapted for ProM by Dirk Fahland.
 ****************************************************************************/

package org.processmining.contexts.test.factory;

import java.lang.reflect.Method;

import org.junit.runners.model.FrameworkMethod;

/**
 * Encapsulates a test method to be invoked by the JUnit framework. This particular
 * class encapsulates test methods that are added dynamically to a JUnit test suite
 * during execution and provides additional information for these methods. 
 *  
 * @author Ted Young, Dirk Fahland
 */
class FrameworkFactoryTest extends FrameworkMethod {
	private Object target;
	private String name;

	public FrameworkFactoryTest(Method method, Object target, String name) {
		super(method);
		this.target = target;
		this.name = name;
	}

	@Override
	public Object invokeExplosively(Object target, Object... params) throws Throwable {
		// Executes the test method on the supplied target (returned by the TestFactory)
		// and not the instance generated by FrameworkMethod.
		return super.invokeExplosively(this.target, params);
	}

	@Override
	public String getName() {
		return String.format(""%s=%s.%s[%s]"", name, target.getClass().getSimpleName(), getMethod().getName(), target.toString());
	}
}
"
TestFactory.java,prom-contexts-6.9.56,"/****************************************************************************
 * Copyright (c) 2011. All rights reserved. Ted Young.
 * Original source code published at
 * http://tedyoung.me/2011/01/22/junit-runtime-tests-overview/
 * 
 * Code adapted for ProM by Dirk Fahland.
 ****************************************************************************/
package org.processmining.contexts.test.factory;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.List;

/**
 * This annotation can be added to a method in a JUnit test class. When
 * executing the JUnit test suite, a {@link FactoryRunner} that is hooked
 * to the JUnit Test will use the annotated method to generate and add
 * new JUnit to the test suite. The annotated Method has to return a 
 * {@link List} of Objects that have member methods that are annotated
 * with {@link FactoryTest}.
 *  
 * @author Ted Young
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface TestFactory {
}
"
InclassMethodTest.java,prom-contexts-6.9.56,"

package org.processmining.contexts.test;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Method;

import junit.framework.Assert;
import junit.framework.AssertionFailedError;

import org.processmining.contexts.test.factory.FactoryTest;
import org.processmining.framework.annotations.TestMethod;

/**
 * Encapsulate a method (annotated with {@link TestMethod}) in a 
 * JUnit test. 
 * 
 * @author Dirk Fahland
 */
public class InclassMethodTest {
	
	private Method test;
	private String testFileRoot;

	/**
	 * Encapsulate the given method (annotated with {@link TestMethod}) in a 
	 * JUnit test. When executed, the test may access files stored at
	 * <code>testFileRoot</code>. 
	 * 
	 * @param method
	 * @param testFileRoot
	 */
	public InclassMethodTest(Method method, String testFileRoot) {
		this.test = method;
		this.testFileRoot = testFileRoot;
	}
	
	/**
	 * Invokes the method annotated with {@link TestMethod} and compares the
	 * result with an expected value. Comparison is done using
	 * {@link Assert#assertEquals(String, String, String)}
	 * 
	 * @throws Throwable
	 */
	@FactoryTest
	public void test() throws Throwable {
		
		System.out.println(""--- TESTCASE: ""+this.test+"" -----------------------"");
		System.err.println(""--- TESTCASE: ""+this.test+"" -----------------------"");
		
		System.out.flush();
		// depending on the test, we redirect System.out to a new output stream
		// which we then compare against the expected result
		PrintStream oldSystemOut = System.out;
		OutputStream resultOutStream = new ByteArrayOutputStream();
		PrintStream tempSystemOut = new PrintStream(resultOutStream);
		
		if (AllInclassMethodTests.testResultFromSystemOut(test)) {
			// write System.out temporarily into the resultOutStream 
			System.setOut(tempSystemOut);
		}
		
		// run test and get test result
		String result = """";
		
		try {
			result = (String)test.invoke(null);
		} catch (java.lang.reflect.InvocationTargetException e) {
			// if a user used JUnit Assertion statements in the routine, then the failed
			// assertions are wrappted in InvocationTargetExceptions, unwrap and rethrow
			if (e.getCause() instanceof AssertionFailedError) {
				throw e.getCause();
			}
		}
		
		if (AllInclassMethodTests.testResultFromSystemOut(test)) {
			// get test result from resultOutStream and restore old output system out
			result = resultOutStream.toString();
			tempSystemOut.close();
			System.setOut(oldSystemOut);
		}
		
		// load expected result
		String expected = null;
		if (AllInclassMethodTests.testExpectedFromOutputAnnotation(test)) {
			expected = test.getAnnotation(TestMethod.class).output();
		} else if (AllInclassMethodTests.testExpectedFromFile(test)) {
			expected = readFile(testFileRoot+""/""+test.getAnnotation(TestMethod.class).filename());
		}
		
		expected = expected.replace(""\r"", """");
		result = result.replace(""\r"", """");
		
		Assert.assertEquals(getTestName(test), expected, result);
	}

	/**
	 * @param scriptFileName
	 * @return contents of the file at the given scriptFileName
	 * @throws IOException
	 */
	private static String readFile(String scriptFileName) throws IOException {
		InputStream is = new FileInputStream(scriptFileName);
		String result = readWholeStream(is);
		is.close();
		return result;
	}

	/**
	 * Read an input stream into a string.
	 * 
	 * @param is
	 * @return contents of the input stream
	 * @throws IOException
	 */
	private static String readWholeStream(InputStream is) throws IOException {
		InputStreamReader reader = new InputStreamReader(new BufferedInputStream(is));
		StringBuffer result = new StringBuffer();
		int c;

		while ((c = reader.read()) != -1) {
			result.append((char) c);
		}
		return result.toString();
	}

	/**
	 * @param m
	 * @return qualified Java name pointing to the location of the test in the Java class
	 */
	private static String getTestName (Method m) {
		return m.getDeclaringClass().toString()+"".""+m.getName();
	}
	
	/*
	 * (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	public String toString() {
		return getTestName(test);
	}
}
"
PromTest.java,prom-contexts-6.9.56,"package org.processmining.contexts.test;

import java.lang.reflect.Method;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;

import junit.framework.TestCase;

import org.junit.runner.RunWith;
import org.processmining.contexts.test.factory.FactoryRunner;
import org.processmining.contexts.test.factory.TestFactory;
import org.processmining.framework.annotations.TestMethod;

/**
 * The base class for unit tests in ProM. A class the extends this class is a JUnit
 * test suite that gets automatically enriched with two kinds of tests.
 * 
 * 1) Inclass Method Tests: these are tests generated from all methods in the plugin
 *    code that are annotated with {@link TestMethod} and the corresponding attributes.
 *    Tests are generated from all classes stored in {@value #defaultClassFileLocations}.
 *    
 * 2) Automated test scripts: these are tests that run a sequence of scripted tests
 *    that are stored in a specified location: {@link #defaultTestScriptDir}.
 *    
 * The tests may access files/compare results to files stored in {@link #defaultTestDir}.
 * 
 * @author Dirk Fahland
 */
@RunWith(value=FactoryRunner.class)
public class PromTest extends TestCase {
	
	/**
	 * Default location of test files that is used if the system property
	 * <code>test.testFileRoot</code> is not set. Overwrite this value if
	 * necessary. Default value {@value #defaultTestDir}.
	 */
	public static final String defaultTestDir = ""./tests/testfiles"";
	
	/**
	 * Default location of test script files inside {@link #defaultTestDir}
	 * that is used if the system property <code>test.testScriptRoot</code>
	 * is not set. By default, this location is {@value #defaultTestScriptDir}.
	 * Overwrite this value if necessary.
	 */
	public static final String defaultTestScriptDir = ""autoscripts"";
	
	/**
	 * Default location of class files that contain methods which are annotated
	 * with {@link TestMethod} and which shall be run in the JUnit test. Overwrite
	 * this value if necessary. Default value {@value #defaultTestDir}.
	 */
	public static final String defaultClassFileLocations = ""./bin"";
	
	@TestFactory
	public static Collection<? extends Object> testScripts() {

		String testFileRoot = System.getProperty(""test.testFileRoot"", defaultTestDir);
	    String testScriptRoot = System.getProperty(""test.testScriptRoot"", testFileRoot+""/""+defaultTestScriptDir);
	    
		List<String> testScripts = AllStandardScriptTests.getAllTestScripts(testScriptRoot);
		List<StandardScriptTest> tests = new LinkedList<StandardScriptTest>();
		for (String scriptFile : testScripts) {
			System.out.println("" found ""+testScriptRoot+""/""+scriptFile);
			tests.add(new StandardScriptTest(testScriptRoot+""/""+scriptFile));	
		}
		
		return tests;
	}
	
	@TestFactory
	public static Collection<? extends Object> inlineTests() {

		String testFileRoot = System.getProperty(""test.testFileRoot"", defaultTestDir);
		String lookUpDirString = System.getProperty(""test.inclassTestsAt"", defaultClassFileLocations);
		
		LinkedList<String> lookUpDirs = new LinkedList<String>();
		int comma;
		while ((comma = lookUpDirString.indexOf("","")) >= 0) {
			String dir = lookUpDirString.substring(0, comma);
			lookUpDirs.add(dir);
			lookUpDirString = lookUpDirString.substring(comma+1);
		}
		lookUpDirs.add(lookUpDirString);
		
		AllInclassMethodTests testCollector = new AllInclassMethodTests();
		for (String classFileLocation : lookUpDirs)
			testCollector.collectAllTestMethods(classFileLocation);
		
		List<Method> testMethods = testCollector.getAllTestMethods();
		List<InclassMethodTest> tests = new LinkedList<InclassMethodTest>();
		for (Method m : testMethods) {
			System.out.println("" found ""+AllInclassMethodTests.getTestName(m));
			tests.add(new InclassMethodTest(m, testFileRoot));	
		}

		return tests;
	}
}
"
StandardScriptTest.java,prom-contexts-6.9.56,"package org.processmining.contexts.test;

import org.processmining.contexts.cli.CLI;
import org.processmining.contexts.test.factory.FactoryTest;

public class StandardScriptTest {
	
	private String testScript;
	
	public StandardScriptTest(String testScript) {
		this.testScript = testScript;
	}

	@FactoryTest
	public void test() throws Throwable {

		System.out.println(""--- TESTCASE: ""+testScript+"" -----------------------"");
		System.err.println(""--- TESTCASE: ""+testScript+"" -----------------------"");

		String args[] = new String[] {""-f"", testScript};
		CLI.main(args);
	}
	
	/*
	 * (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	public String toString() {
		return testScript;
	}
}
"
UIExportPlugin.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE })
public @interface UIExportPlugin {
	public String description();

	public String extension();

	public String pack() default """";
}
"
UIImportPlugin.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation is used in the interface
 * org.processmining.contexts.uitopia.specialplugins.ImportPlugin to signal the
 * framework that this is an import plugin.
 * 
 * @author bfvdonge
 * 
 */

@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE })
public @interface UIImportPlugin {
	public String description();

	public String[] extensions();
	
	public String pack() default """";
}
"
UITopiaVariant.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
public @interface UITopiaVariant {

	public final static String USEPLUGIN = ""Use Plugin Name"";
	public final static String USEVARIANT = ""Use Variant Name"";

	public final static String EHV = ""Eindhoven University of Technology"";

	String uiLabel() default USEPLUGIN;

	String uiHelp() default USEPLUGIN;

	String affiliation();

	String email();

	String author();

	String website() default ""http://www.processmining.org"";

	String pack() default """";
}
"
Visualizer.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE, ElementType.METHOD })
public @interface Visualizer {

	public final static String USEPLUGINNAME = ""Use Plugin Name"";

	/**
	 * Returns the name of the visualizer.
	 * 
	 * @return A short string (< 20 characters)
	 */
	public String name() default USEPLUGINNAME;

	public String pack() default """";
}
"
ProgressOverlayDialog.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.hub.overlay;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;

import org.deckfour.uitopia.ui.components.ImageLozengeButton;
import org.deckfour.uitopia.ui.main.MainView;
import org.deckfour.uitopia.ui.overlay.AbstractOverlayDialog;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.plugin.events.ProgressEventListener;

import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.components.SlickerProgressBar;

public class ProgressOverlayDialog extends AbstractOverlayDialog implements ProgressEventListener {

	public static interface CancellationListener {
		public void cancel();
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 2065412432371789921L;
	protected static Color colorBgUp = new Color(80, 80, 80);
	protected static Color colorBgDown = new Color(40, 40, 40);
	protected static Color colorBgInner = new Color(200, 200, 200, 120);
	protected static Color colorFg = new Color(40, 40, 40);

	private final SlickerProgressBar progress;
	private final JLabel title;
	private final JLabel label;
	private final ImageLozengeButton cancelButton;

	public ProgressOverlayDialog(MainView mainView, final UIPluginContext context, String aTitle) {
		this(mainView, aTitle, new CancellationListener() {

			public void cancel() {
				context.getProgress().cancel();
			}

		});
		context.getProgressEventListeners().add(this);
	}

	public ProgressOverlayDialog(MainView mainView, String aTitle, final CancellationListener cancellationListener) {
		super(aTitle);

		setOpaque(false);
		setLayout(new BorderLayout());
		setBorder(BorderFactory.createEmptyBorder(30, 30, 30, 30));

		setLayout(new BoxLayout(this, BoxLayout.X_AXIS));

		RoundedPanel innerPanel = new RoundedPanel(20, 0, 0);
		innerPanel.setAlignmentX(Component.CENTER_ALIGNMENT);
		innerPanel.setBackground(colorBgInner);
		innerPanel.setMinimumSize(new Dimension(300, 120));
		innerPanel.setMaximumSize(new Dimension(600, 130));
		innerPanel.setPreferredSize(new Dimension(500, 130));
		innerPanel.setLayout(new BoxLayout(innerPanel, BoxLayout.Y_AXIS));
		innerPanel.setBorder(BorderFactory.createEmptyBorder(5, 20, 5, 20));

		progress = new SlickerProgressBar();
		progress.setOpaque(false);
		progress.setIndeterminate(true);

		title = new JLabel(aTitle);
		title.setAlignmentX(Component.LEFT_ALIGNMENT);
		title.setOpaque(false);
		title.setFont(title.getFont().deriveFont(16.0f));

		label = new JLabel("""");
		label.setFont(label.getFont().deriveFont(12.0f));
		label.setAlignmentX(Component.LEFT_ALIGNMENT);
		label.setOpaque(false);

		cancelButton = new ImageLozengeButton(ImageLoader.load(""cancel_white_30x30.png""), ""Cancel"",
				new Color(90, 0, 0), new Color(160, 0, 0), 4);
		cancelButton.setLabelColor(Color.white);
		cancelButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				cancellationListener.cancel();
				cancelButton.setEnabled(false);
			}
		});

		JPanel buttonPanel = new JPanel();
		buttonPanel.setOpaque(false);
		buttonPanel.setBorder(BorderFactory.createEmptyBorder());
		buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));
		buttonPanel.add(Box.createHorizontalGlue());
		buttonPanel.add(progress);
		buttonPanel.add(Box.createHorizontalStrut(10));
		buttonPanel.add(cancelButton);
		buttonPanel.add(Box.createHorizontalGlue());

		innerPanel.add(Box.createVerticalGlue());
		innerPanel.add(alignLeft(title));
		innerPanel.add(Box.createVerticalStrut(10));
		innerPanel.add(buttonPanel);
		innerPanel.add(Box.createVerticalStrut(8));
		innerPanel.add(alignLeft(label));
		innerPanel.add(Box.createVerticalGlue());

		add(Box.createHorizontalGlue());
		add(innerPanel);
		add(Box.createHorizontalGlue());

	}

	protected JPanel alignLeft(JComponent component) {
		JPanel enclosure = new JPanel();
		enclosure.setOpaque(false);
		enclosure.setBorder(BorderFactory.createEmptyBorder());
		enclosure.setLayout(new BoxLayout(enclosure, BoxLayout.X_AXIS));
		enclosure.add(component);
		enclosure.add(Box.createHorizontalGlue());
		return enclosure;
	}

	protected JPanel alignRight(JComponent component) {
		JPanel enclosure = new JPanel();
		enclosure.setOpaque(false);
		enclosure.setBorder(BorderFactory.createEmptyBorder());
		enclosure.setLayout(new BoxLayout(enclosure, BoxLayout.X_AXIS));
		enclosure.add(Box.createHorizontalGlue());
		enclosure.add(component);
		return enclosure;
	}

	public void changeProgress(int p) {
		progress.setValue(p);
	}

	public void changeProgressBounds(int lowBo, int upBo) {
		progress.setMinimum(lowBo);
		progress.setMaximum(upBo);
		progress.setIndeterminate(upBo <= lowBo);
	}

	public void changeProgressCaption(String newCaption) {
		label.setText(newCaption);
		revalidate();
	}

	public void changeProgressIndeterminate(boolean indeterminate) {
		progress.setIndeterminate(indeterminate);
	}

	public int getMaximum() {
		return progress.getMaximum();
	}

	public void setIndeterminate(boolean b) {
		progress.setIndeterminate(b);

	}

}
"
ProMActionManager.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.hub;

import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

import org.deckfour.uitopia.api.hub.ActionManager;
import org.deckfour.uitopia.api.model.ActionType;
import org.deckfour.uitopia.api.model.Parameter;
import org.deckfour.uitopia.api.model.ResourceType;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.contexts.uitopia.model.ProMAction;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginManager.PluginManagerListener;
import org.processmining.framework.plugin.PluginParameterBinding;

public class ProMActionManager implements ActionManager<ProMAction>, PluginManagerListener {

	private final SortedSet<ProMAction> actions = new TreeSet<ProMAction>();
	private final UIContext context;

	private ProMActionManager(UIContext context) {

		this.context = context;
		for (PluginDescriptor plugin : context.getPluginManager().getAllPlugins(true)) {
			addPlugin(plugin);
		}
		context.getPluginManager().addListener(this);
	}

	private void addPlugin(PluginDescriptor plugin) {
		for (int i = 0; i < plugin.getNumberOfMethods(); i++) {
			// See if this is an action
			if (checkPlugin(context, plugin, i)) {
				// Construct an action
				ProMAction action = new ProMAction(context.getResourceManager(), context.getPluginManager(), plugin, i);
				actions.add(action);
			}
		}

	}

	private static ProMActionManager instance = null;

	public static ProMActionManager initialize(UIContext context) {
		if (instance == null) {
			instance = new ProMActionManager(context);
		}
		return instance;
	}

	/**
	 * Returns a list of actions, such that these actions accepts all given
	 * input resources and result in at least on of the output resources.
	 */
	public List<ProMAction> getActions(List<ResourceType> input, List<ResourceType> output) {
		return getActions(input, output, null);
	}

	private Collection<ResourceType> getResourcesTypesFor(List<? extends Parameter> parameters) {
		Collection<ResourceType> types = new HashSet<ResourceType>();
		for (Parameter par : parameters) {
			types.add(par.getType());
		}

		return types;
	}

	public List<ProMAction> getActions(List<ResourceType> parameters, List<ResourceType> requiredOutput, ActionType type) {

		List<ProMAction> enabledActions = new ArrayList<ProMAction>();

		actionLoop: for (ProMAction action : actions) {

			// Check for type match
			if ((type != null) && !action.getType().equals(type)) {
				// types don't match
				continue;
			}

			// Check if all given output types are present in the plugin's output
			Collection<ResourceType> outputs = getResourcesTypesFor(action.getOutput());
			for (ResourceType required : requiredOutput) {
				boolean found = false;
				for (ResourceType output : outputs) {
					found |= required.isAssignableFrom(output);
					if (found) {
						break;
					}
				}
				if (!found) {
					continue actionLoop;
				}
			}

			// Check for enabledness using a pluginparamterbinding
			Class<?>[] types = new Class<?>[parameters.size()];
			int i = 0;
			for (ResourceType r : parameters) {
				types[i++] = r.getTypeClass();
			}
			List<PluginParameterBinding> bindings = PluginParameterBinding.Factory.tryToBind(
					context.getPluginManager(), action.getPlugin(), action.getMethodIndex(), false, false, types);
			bindings.addAll(PluginParameterBinding.Factory.tryToBind(context.getPluginManager(), action.getPlugin(),
					action.getMethodIndex(), true, false, types));

			if (bindings.isEmpty()) {
				continue;
			}

			enabledActions.add(action);
		}

		return enabledActions;
	}

	public List<ProMAction> getActions() {
		return new ArrayList<ProMAction>(actions);
	}

	private boolean checkPlugin(UIContext context, PluginDescriptor plugin, int methodIndex) {
		if (plugin.getAnnotation(Visualizer.class) != null) {
			return false;
		}
		if (plugin.getAnnotation(UIImportPlugin.class) != null) {
			return false;
		}
		if (plugin.getAnnotation(UIExportPlugin.class) != null) {
			return false;
		}
		if (plugin.getAnnotation(UITopiaVariant.class, methodIndex) == null) {
			return false;
		}
		for (int p = 0; p < plugin.getParameterNames().size(); p++) {
			Class<?> type = plugin.getPluginParameterType(methodIndex, p);
			if ((type != null) && !context.getResourceManager().isResourceType(type)) {
				return false;
			}
		}
		return true;
	}

	public void error(URL source, Throwable t, String className) {
		System.err.println(""Error while adding plugin from "" + className);
	}

	public void newPlugin(PluginDescriptor plugin, Collection<Class<?>> newTypes) {
		// First, register the new resource types with the resource manager
		for (Class<?> newType : newTypes) {
			context.getResourceManager().addType(newType);
		}
		// Now add the plugins.
		addPlugin(plugin);

		if (plugin.getAnnotation(Visualizer.class) != null) {
			HashSet<Class<?>> parTypes = new HashSet<Class<?>>();
			for (int i = 0; i < plugin.getNumberOfMethods(); i++) {
				parTypes.addAll(plugin.getParameterTypes(i));
			}
			for (Class<?> parType : parTypes) {
				// this plugin might be a visualizes for any of its parameter types, so
				// notify the viewmanager of this.
				context.getViewManager().registerResourceType(context.getResourceManager().getResourceTypeFor(parType));
			}
		}
		if (plugin.getAnnotation(UIImportPlugin.class) != null) {
			// added an import plugin, signal the resource manager.
			context.getResourceManager().addedImportPlugins();
		}
		//		if (plugin.getAnnotation(UIExportPlugin.class) != null) {
		// Export plugins are built on the fly anyway.
		//		}

	}
}
"
ProMCategoryManager.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.hub;

import java.util.ArrayList;
import java.util.List;

import org.deckfour.uitopia.api.hub.CategoryManager;
import org.deckfour.uitopia.api.model.Category;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.model.ProMCategory;
import org.processmining.framework.plugin.annotations.PluginCategory;

public class ProMCategoryManager implements CategoryManager {

	private static ProMCategoryManager instance = null;
	private List<Category> categories;

	public ProMCategoryManager() {
		categories = new ArrayList<>();

		for (PluginCategory c : PluginCategory.values()) {
			ProMCategory newCat = new ProMCategory(c);
			categories.add(newCat);
		}

	}

	public List<Category> getCategories() {

		return categories;
	}

	public static CategoryManager initialize(UIContext uiContext) {
		if(instance == null){
			instance = new ProMCategoryManager();
		}
		return instance;
	}

}"
ProMResourceManager.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.hub;

import java.awt.EventQueue;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.prefs.Preferences;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;

import org.deckfour.uitopia.api.hub.ResourceManager;
import org.deckfour.uitopia.api.model.Resource;
import org.deckfour.uitopia.api.model.ResourceFilter;
import org.deckfour.uitopia.api.model.ResourceType;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.contexts.uitopia.hub.overlay.ProgressOverlayDialog;
import org.processmining.contexts.uitopia.model.ProMCResource;
import org.processmining.contexts.uitopia.model.ProMPOResource;
import org.processmining.contexts.uitopia.model.ProMResource;
import org.processmining.contexts.uitopia.model.ProMResourceType;
import org.processmining.framework.ProMID;
import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionAnnotation;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionID;
import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.events.ConnectionObjectListener;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.plugin.events.PluginLifeCycleEventListener;
import org.processmining.framework.plugin.events.ProvidedObjectLifeCycleListener;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;
import org.processmining.framework.providedobjects.ProvidedObjectManager;

public class ProMResourceManager extends UpdateSignaller implements ResourceManager<ProMResource<?>>,
		ProvidedObjectLifeCycleListener, PluginLifeCycleEventListener, ConnectionObjectListener {

	private static final String LASTIMPORTFILE = ""last import file location"";

	private static final String LASTEXPORTFILE = ""last export file location"";

	private static final String FAVORITEIMPORT = ""favorite import for type "";

	private static final String FAVORITEEXPORT = ""favorite export for type "";

	private static ProMResourceManager instance = null;

	private final Map<Class<?>, ProMResourceType> resourceClasses = new ConcurrentHashMap<Class<?>, ProMResourceType>();
	private final Map<ProMID, ProMResource<?>> resources = new ConcurrentHashMap<ProMID, ProMResource<?>>();

	private final UIContext context;

	private Map<FileFilter, PluginParameterBinding> importplugins;

	private final ProvidedObjectManager poManager;

	// HV Remember last file imported and exported.
	private File lastImportedFile;
	private File lastExportedFile;

	private Boolean importPluginAdded = true;

	private final Preferences preferences;

	private ConnectionManager connectionManager;

	private ProMResourceManager(UIContext context) {

		this.context = context;
		for (Class<?> type : context.getPluginManager().getKnownObjectTypes()) {
			addType(type);
		}
		for (Class<?> type : context.getPluginManager().getKnownClassesAnnotatedWith(ConnectionAnnotation.class)) {
			addType(type);
		}
		poManager = context.getProvidedObjectManager();
		poManager.getProvidedObjectLifeCylceListeners().add(this);

		connectionManager = context.getConnectionManager();
		connectionManager.getConnectionListeners().add(this);

		// HV No last file imported or exported yet.
		preferences = Preferences.userNodeForPackage(getClass());

		String name = preferences.get(LASTIMPORTFILE, null);
		lastImportedFile = name == null ? null : new File(name);
		while (lastImportedFile != null && !lastImportedFile.exists()) {
			lastImportedFile = lastImportedFile.getParentFile();
		}
		name = preferences.get(LASTEXPORTFILE, null);
		lastExportedFile = name == null ? null : new File(name);
		while (lastExportedFile != null && !lastExportedFile.exists()) {
			lastExportedFile = lastExportedFile.getParentFile();
		}
	}

	public ResourceType addType(Class<?> type) {
		return resourceClasses.put(type, new ProMResourceType(type));
	}

	public static ProMResourceManager initialize(UIContext context) {
		if (instance == null) {
			instance = new ProMResourceManager(context);
		}
		return instance;
	}

	/*
	 * HV: Return a default exporter for known types. Fortunately, this handling
	 * of favorite is all String based, so we do not need to know the actual
	 * types (only their names).
	 */
	private String getDefaultExport(String typeName) {
		// The typeName matches whatever the ProM workspace shows in the second line of an object (basically, this is the class name). 
		// The returned label should match with whatever is in the @UIExportPlugin declaration.
		if (typeName.equals(""XLog"")) {
			return ""XES files"";
		} else if (typeName.equals(""Petrinet"")) {
			return ""PNML files"";
		} else if (typeName.equals(""AcceptingPetriNet"")) {
			return ""Accepting Petri Net"";
		} else if (typeName.equals(""PetriNetWithData"")) {
			// Particularly useful, as this may prevent novice users from using the usual PNML export, which does not export data.
			return ""Data-aware PNML files"";
		}
		return """";
	}

	public Collection<FileFilter> getExportFilters(Resource resource) {
		Collection<FileFilter> exportfilters = new HashSet<FileFilter>();
		Set<PluginParameterBinding> potentialExportPlugins = context.getPluginManager().getPluginsAcceptingInAnyOrder(
				UIPluginContext.class, true, File.class, resource.getType().getTypeClass());

		for (PluginParameterBinding binding : potentialExportPlugins) {
			if (binding.getPlugin().getAnnotation(UIExportPlugin.class) != null) {
				String description = binding.getPlugin().getAnnotation(UIExportPlugin.class).description();
				String extension = binding.getPlugin().getAnnotation(UIExportPlugin.class).extension();
				FileNameExtensionFilter filter = new FileNameExtensionFilter(description, extension);
				exportfilters.add(filter);
			}
		}
		return exportfilters;
	}

	public boolean exportResource(Resource resource) throws IOException {
		assert(resource instanceof ProMResource<?>);

		String lastChosenExportPlugin = preferences.get(FAVORITEEXPORT + resource.getType().getTypeName(), """");
		if (lastChosenExportPlugin.isEmpty()) {
			// HV: No favorite set yet by user. Use reasonable default values for known types.
			lastChosenExportPlugin = getDefaultExport(resource.getType().getTypeName());
		}
		FileFilter lastChosenFilter = null;

		Map<FileFilter, PluginParameterBinding> exportplugins = new TreeMap<FileFilter, PluginParameterBinding>(
				new Comparator<FileFilter>() {

					public int compare(FileFilter f1, FileFilter f2) {
						return f1.getDescription().toLowerCase().compareTo(f2.getDescription().toLowerCase());
					}
				});
		Set<PluginParameterBinding> potentialExportPlugins = context.getPluginManager().getPluginsAcceptingInAnyOrder(
				UIPluginContext.class, true, File.class, resource.getType().getTypeClass());

		for (PluginParameterBinding binding : potentialExportPlugins) {
			if (binding.getPlugin().getAnnotation(UIExportPlugin.class) != null) {
				String description = binding.getPlugin().getAnnotation(UIExportPlugin.class).description();
				String extension = binding.getPlugin().getAnnotation(UIExportPlugin.class).extension();
				FileNameExtensionFilter filter = new FileNameExtensionFilter(description, extension);
				exportplugins.put(filter, binding);
				if (description.equals(lastChosenExportPlugin)) {
					lastChosenFilter = filter;
				}
			}
		}

		// HV Start at location last file was exported.
		JFileChooser fc = (lastExportedFile != null ? new JFileChooser(lastExportedFile) : new JFileChooser());
		for (FileFilter filter : exportplugins.keySet()) {
			fc.addChoosableFileFilter(filter);
		}
		fc.setAcceptAllFileFilterUsed(false);
		if (lastChosenFilter != null) {
			fc.setFileFilter(lastChosenFilter);
		}

		askForFile: while (true) {
			int returnVal = fc.showSaveDialog(context.getUI());

			if ((returnVal == JFileChooser.APPROVE_OPTION) && (fc.getSelectedFile() != null)) {
				File file = fc.getSelectedFile();
				FileNameExtensionFilter selectedFilter = (FileNameExtensionFilter) fc.getFileFilter();
				if (selectedFilter == null) {
					selectedFilter = (FileNameExtensionFilter) exportplugins.keySet().iterator().next();
				}

				String postfix = ""."" + selectedFilter.getExtensions()[0];
				if (!file.getAbsolutePath().endsWith(postfix)) {
					String name = file.getAbsolutePath() + postfix;
					file = new File(name);
				}
				if (!file.createNewFile()) {
					int ow = JOptionPane.showConfirmDialog(context.getUI(),
							""Are you sure you want to overwrite "" + file.getName(), ""Confirm overwrite"",
							JOptionPane.YES_NO_OPTION);
					if (ow == JOptionPane.NO_OPTION) {
						continue askForFile;
					}
				}

				// HV Remember last file exported (and imported if not initialized yet).
				lastExportedFile = file.getParentFile();
				preferences.put(LASTEXPORTFILE, lastExportedFile.getAbsolutePath());
				if (lastImportedFile == null) {
					lastImportedFile = lastExportedFile;
					preferences.put(LASTIMPORTFILE, lastImportedFile.getAbsolutePath());
				}

				PluginParameterBinding binding = exportplugins.get(selectedFilter);

				preferences.put(FAVORITEEXPORT + resource.getType().getTypeName(),
						binding.getPlugin().getAnnotation(UIExportPlugin.class).description());

				UIPluginContext importContext = context.getMainPluginContext()
						.createChildContext(""Saving file with "" + binding.getPlugin().getName());

				PluginExecutionResult result = binding.invoke(importContext, file,
						((ProMResource<?>) resource).getInstance());
				context.getProvidedObjectManager().createProvidedObjects(importContext);

				try {
					result.synchronize();
				} catch (CancellationException e) {
					context.getMainPluginContext().log(""Export of "" + file + "" cancelled."");
					return false;
				} catch (Exception e) {
					JOptionPane.showMessageDialog(context.getUI(),
							""<html>Error with export of "" + file + "":<br>"" + e.getMessage() + ""</html>"",
							""Error while exporting"", JOptionPane.ERROR_MESSAGE);
					return false;
				} finally {
					importContext.getParentContext().deleteChild(importContext);
				}
				return true;
			}

			return false;
		}
	}

	public java.util.List<ProMResource<?>> getAllResources() {
		return new ArrayList<ProMResource<?>>(resources.values());
	}

	public java.util.List<ProMResource<?>> getAllResources(ResourceFilter filter) {
		return filterList(getAllResources(), filter);
	}

	public java.util.List<ResourceType> getAllSupportedResourceTypes() {
		java.util.List<ResourceType> types = new ArrayList<ResourceType>();
		types.addAll(resourceClasses.values());
		return types;
	}

	public java.util.List<ProMResource<?>> getChildrenOf(final Resource parent) {
		return getAllResources(new ResourceFilter() {
			public boolean accept(Resource res) {
				return getParentsOf(res).contains(parent);
			}
		});
	}

	public java.util.List<ProMResource<?>> getChildrenOf(final Resource parent, final ResourceFilter filter) {
		return getAllResources(new ResourceFilter() {
			public boolean accept(Resource res) {
				return filter.accept(res) && getParentsOf(res).contains(parent);
			}
		});
	}

	public java.util.List<ProMResource<?>> getFavoriteResources() {
		return getAllResources(new ResourceFilter() {
			public boolean accept(Resource res) {
				return res.isFavorite();
			}
		});
	}

	public java.util.List<ProMResource<?>> getFavoriteResources(final ResourceFilter filter) {
		return getAllResources(new ResourceFilter() {
			public boolean accept(Resource res) {
				return filter.accept(res) && res.isFavorite();
			}
		});
	}

	public java.util.List<ProMResource<?>> getImportedResources() {
		return getAllResources(new ResourceFilter() {
			public boolean accept(Resource res) {
				return getParentsOf(res).isEmpty();
			}
		});
	}

	public java.util.List<ProMResource<?>> getImportedResources(final ResourceFilter filter) {
		return getAllResources(new ResourceFilter() {
			public boolean accept(Resource res) {
				return filter.accept(res) && getParentsOf(res).isEmpty();
			}
		});
	}

	public java.util.List<ProMResource<?>> getParentsOf(Resource child) {
		return new ArrayList<ProMResource<?>>(((ProMResource<?>) child).getParents());
	}

	public java.util.List<ProMResource<?>> getParentsOf(Resource child, ResourceFilter filter) {
		java.util.List<ProMResource<?>> filtered = new ArrayList<ProMResource<?>>(
				((ProMResource<?>) child).getParents());
		return filterList(filtered, filter);
	}

	/**
	 * Start the import dialog for a resource. Can be called from the EDT or any
	 * other thread. Makes sure that the dialog-part of the actual import is run in the EDT.
	 */
	public boolean importResource() {
		if (EventQueue.isDispatchThread()) {
			/*
			 * Called from the EDT. OK.
			 */
			importResourceInEDT();
		} else {
			/*
			 * Not called from the EDT. Have the EDT take care of it.
			 */
			try {
				SwingUtilities.invokeAndWait(new Runnable() {
					public void run() {
						importResourceInEDT();
					}
				});
			} catch (InvocationTargetException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return true;
	}

	/*
	 * This method should only be called from the EDT thread.
	 */
	private synchronized boolean importResourceInEDT() {
		if (!EventQueue.isDispatchThread()) {
			System.err.println(""Method should only be called from EDT"");
			return false;
		}
		synchronized (importPluginAdded) {
			if (importPluginAdded) {
				buildImportPlugins();
				importPluginAdded = false;
			}
		}
		// HV Start from the location of the last file imported.
		final JFileChooser fc = (lastImportedFile != null ? new JFileChooser(lastImportedFile) : new JFileChooser());
		for (FileFilter filter : importplugins.keySet()) {
			fc.addChoosableFileFilter(filter);
		}
		fc.setAcceptAllFileFilterUsed(true);
		/*
		 * Disable multi-selection, as this allows for the user to select two
		 * files simultaneously that cannot be handled by a single importer. The
		 * user can only use one importer...
		 */
		fc.setMultiSelectionEnabled(true);
		fc.setFileFilter(fc.getAcceptAllFileFilter());

		/*
		 * HV: This method does run in the EDT. 
		 */
		int returnVal = fc.showOpenDialog(context.getUI());

		if (returnVal == JFileChooser.APPROVE_OPTION) {
			/*
			 * As a result of disabling the multi-selection, use a different way
			 * to get the selected file(s).
			 */
			File[] files = fc.getSelectedFiles();
			//			File[] files = new File[]{ fc.getSelectedFile() };

			// XL: parse file one for one
			boolean importedSuccessfully = true;
			for (final File f : files) {
				PluginParameterBinding binding = importplugins.get(fc.getFileFilter());
				importedSuccessfully &= importResourceInEDT(binding, f);
			}
			return importedSuccessfully;

		} else {
			return false;

		}
	}

	/**
	 * Can be called from the EDT or any other thread.
	 */
	public synchronized boolean importResources(File... files) {
		return importResource(null, files);
	}

	/**
	 * Can be called from the EDT or any other thread. Makes sure that the
	 * dialog-par tof the actual import is run in the EDT.
	 */
	public boolean importResource(final PluginParameterBinding binding, final File... files) {
		if (EventQueue.isDispatchThread()) {
			/*
			 * Called from the EDT. OK.
			 */
			importResourceInEDT(binding, files);
		} else {
			/*
			 * Not called from the EDT. Have the EDZT take care of it.
			 */
			try {
				SwingUtilities.invokeAndWait(new Runnable() {
					public void run() {
						importResourceInEDT(binding, files);
					}
				});
			} catch (InvocationTargetException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return true;
	}

	/*
	 * This method should be called from the EDT.
	 */
	private synchronized boolean importResourceInEDT(PluginParameterBinding binding, final File... files) {
		if (!EventQueue.isDispatchThread()) {
			System.err.println(""Method should only be called from EDT"");
			return false;
		}
		synchronized (importPluginAdded) {
			if (importPluginAdded) {
				buildImportPlugins();
				importPluginAdded = false;
			}
		}

		// HV Remember the location of the last file imported (and exported if not initialized yet).
		lastImportedFile = files[0].getParentFile();
		preferences.put(LASTIMPORTFILE, lastImportedFile.getAbsolutePath());
		if (lastExportedFile == null) {
			lastExportedFile = lastImportedFile;
			preferences.put(LASTEXPORTFILE, lastExportedFile.getAbsolutePath());
		}

		if (binding == null) {
			// user chose the ""all files"" option
			Map<String, PluginParameterBinding> bindings = new HashMap<String, PluginParameterBinding>();
			for (FileFilter filter : importplugins.keySet()) {
				// HV: Only show plug-ins that can handle all files, as all files will be imported by it.
				boolean ok = true;
				for (File file : files) {
					if (!filter.accept(file)) {
						ok = false;
					}
				}
				if (ok) {
					bindings.put(filter.getDescription(), importplugins.get(filter));
				}
			}
			if (bindings.size() == 0) {
				// 	TODO: No plugins available based on filetype
				// 	show all plugins
				for (FileFilter filter : importplugins.keySet()) {
					bindings.put(filter.getDescription(), importplugins.get(filter));
				}
			}
			if (bindings.size() == 0) {
				/*
				 * HV: This method does run in the EDT. 
				 */
				JOptionPane.showMessageDialog(context.getUI(), ""No import plugins available"",
								""No input plugins available!"", JOptionPane.ERROR_MESSAGE);
				return false;
			}

			binding = bindings.values().iterator().next();
			if (bindings.size() > 1) {

				String key = FAVORITEIMPORT + extractFileType(files[0].getAbsolutePath());
				final String[] possibilities = bindings.keySet().toArray(new String[0]);
				final String preferredImport = preferences.get(key, possibilities[0]);

				String selected = (String) JOptionPane.showInputDialog(context.getUI(),
									""Available Import Plugins for file "" + files[0].getName() + "":"",
									""Select an import plugin..."", JOptionPane.PLAIN_MESSAGE, null, possibilities,
									preferredImport);

				if (selected == null) {
					return false;
				}

				preferences.put(key, selected);
				binding = bindings.get(selected);
			}
		}
		if (binding == null) {
			// No import was selected.
			return false;
		}

		// HV: Dialog-part is now done, hence we can off-load the actual importing to another thread.
		// This frees the EDT for showing the progress bar while doing the import.
		final PluginParameterBinding finalBinding = binding;
		Runnable importThread = new Runnable() {
			public void run() {
				importResourceNotInEDT(finalBinding, files);
			}
		};
		(new Thread(importThread)).start();
		return true;
	}
	
	private boolean importResourceNotInEDT(final PluginParameterBinding binding, final File... files) {
		if (EventQueue.isDispatchThread()) {
			System.err.println(""Method should never be called from EDT"");
			return false;
		}
		/*
		 * Synchronize on the provided object manager to prevent multiple imports 
		 * talking at the same time to this manager.
		 */
		synchronized(context.getProvidedObjectManager()) {
		for (File f : files) {
			UIPluginContext importContext = context.getMainPluginContext()
					.createChildContext(""Opening file with "" + binding.getPlugin().getName());
			importContext.getPluginLifeCycleEventListeners().add(this);

			ProgressOverlayDialog progress = new ProgressOverlayDialog(context.getController().getMainView(),
					importContext, ""Importing "" + binding.getPlugin().getName());
			context.getController().getMainView().showOverlay(progress);
//			Thread.yield();

			PluginExecutionResult result = binding.invoke(importContext, f);
			context.getProvidedObjectManager().createProvidedObjects(importContext);

			try {
				result.synchronize();
			} catch (CancellationException e) {
				context.getController().getMainView().hideOverlay();
				SwingUtilities.invokeLater(new Runnable() {
					public void run() {
						JOptionPane.showMessageDialog(context.getUI(), ""Import of "" + files + "" cancelled."", ""Import cancelled"",
								JOptionPane.WARNING_MESSAGE);
					}
				});
				context.getMainPluginContext().log(""Import of "" + files + "" cancelled."");
				return false;
			} catch (final Exception e) {
				context.getController().getMainView().hideOverlay();
				SwingUtilities.invokeLater(new Runnable() {
					public void run() {
						JOptionPane.showMessageDialog(context.getUI(),
								""<html>Error with import of "" + files + "":<br>"" + e.getMessage() + ""</html>"", ""Import failed"",
								JOptionPane.ERROR_MESSAGE);
					}
				});
				context.getMainPluginContext().log(""Error with import of "" + files + ""."", MessageLevel.ERROR);
				context.getMainPluginContext().log(e);
				return false;
			} finally {
				importContext.getParentContext().deleteChild(importContext);
			}

			context.getController().getMainView().hideOverlay();
		}
		}
		return true;

	}

	private String extractFileType(String filename) {
		/*
		 * HV: Restrict the length of the extension to 9 characters.
		 */
		int indexName = Math.max(filename.lastIndexOf(File.separatorChar), filename.length() - 10);
		int indexDot = filename.indexOf('.', indexName);
		if (indexDot < 0) {
			// No dot in filename, hence no extension.
			return """";
		}
		return filename.substring(indexDot);
	}

	private void buildImportPlugins() {
		importplugins = new TreeMap<FileFilter, PluginParameterBinding>(new Comparator<FileFilter>() {

			public int compare(FileFilter f1, FileFilter f2) {
				return f1.getDescription().toLowerCase().compareTo(f2.getDescription().toLowerCase());
			}
		});

		Set<PluginParameterBinding> potentialImportPlugins = context.getPluginManager()
				.getPluginsAcceptingOrdered(UIPluginContext.class, true, File.class);

		for (PluginParameterBinding binding : potentialImportPlugins) {
			if (binding.getPlugin().hasAnnotation(UIImportPlugin.class)) {
				FileNameExtensionFilter filter = new FileNameExtensionFilter(
						binding.getPlugin().getAnnotation(UIImportPlugin.class).description(),
						binding.getPlugin().getAnnotation(UIImportPlugin.class).extensions());
				importplugins.put(filter, binding);
			}
		}

	}

	public ResourceType getResourceTypeFor(Class<?> type) {
		return resourceClasses.get(type);
	}

	public boolean isResourceType(Class<?> type) {
		return resourceClasses.keySet().contains(type);
	}

	private java.util.List<ProMResource<?>> filterList(java.util.List<ProMResource<?>> filtered,
			ResourceFilter filter) {
		synchronized (filtered) {
			Iterator<ProMResource<?>> it = filtered.iterator();
			while (it.hasNext()) {
				if (!filter.accept(it.next())) {
					it.remove();
				}
			}
		}
		return filtered;
	}

	public java.util.List<ResourceType> getResourceTypes(java.util.List<? extends Resource> res) {
		ArrayList<ResourceType> types = new ArrayList<ResourceType>(res.size());
		for (Resource r : res) {
			types.add(r.getType());
		}
		return types;
	}

	public void providedObjectCreated(ProvidedObjectID objectID, PluginContext context) {
		// Ignore. Only respond when a future of an object is ready.
	}

	public void providedObjectDeleted(ProvidedObjectID id) {
		if (resources.remove(id) != null) {
			signalUpdate();
		}
	}

	public void providedObjectFutureReady(ProvidedObjectID id) {
		Class<?> type;
		try {
			type = context.getProvidedObjectManager().getProvidedObjectType(id);
		} catch (ProvidedObjectDeletedException e) {
			// If the object has been deleted, try the next one
			return;
		}
		ResourceType resType = getResourceTypeFor(type);
		if (resType != null) {
			ProMResource<?> res;
			try {
				res = context.getResourceManager()
						.getResourceForInstance(context.getProvidedObjectManager().getProvidedObjectObject(id, true));
				if (res == null) {
					res = new ProMPOResource(context, null, resType, id,
							Collections.<Collection<ProMPOResource>>emptyList());
					addResource(id, res);
				}
			} catch (ProvidedObjectDeletedException e) {
				// If the object has been deleted, try the next one
				return;
			}
		}
	}

	public void providedObjectNameChanged(ProvidedObjectID id) {
		// Ignore. Access to the object is provided using late-binding, hence
		// the last version of the label is always returned by the resource
		if (resources.containsKey(id)) {
			signalUpdate();
		}
	}

	public void providedObjectObjectChanged(ProvidedObjectID id) {
		// Ignore. Access to the object is provided using late-binding, hence
		// the last version of the object is always returned by the resource
		if (resources.containsKey(id)) {
			signalUpdate();
		}
	}

	@SuppressWarnings(""unchecked"")
	public <R extends ProMResource<?>> R addResource(ProvidedObjectID id, R res) {
		if (resources.containsKey(id)) {
			return (R) resources.get(id);
		} else {
			resources.put(id, res);
			signalUpdate();
			return res;
		}
	}

	public ProMResource<?> getResourceForInstance(Object o) {
		for (ProMResource<?> resource : getAllResources()) {
			if (resource.getInstance() == o) {
				return resource;
			}
		}
		return null;
	}

	//********************************************************************
	// PluginLifeCycle.
	//

	public void pluginCancelled(PluginContext context) {
		// TODO Auto-generated method stub

	}

	public void pluginCompleted(PluginContext pluginContext) {
		PluginExecutionResult result = pluginContext.getResult();
		for (int i = 0; i < result.getSize(); i++) {
			ProvidedObjectID id = result.getProvidedObjectID(i);
			Class<?> type;
			try {
				type = context.getProvidedObjectManager().getProvidedObjectType(id);
			} catch (ProvidedObjectDeletedException e) {
				// If the object has been deleted, try the next one
				continue;
			}
			ResourceType resType = getResourceTypeFor(type);
			if (resType != null) {
				ProMResource<?> res = new ProMPOResource(context, null, resType, id,
						Collections.<Collection<ProMPOResource>>emptyList());
				res = addResource(id, res);
				if (i + 1 == result.getPlugin().getMostSignificantResult()) {
					res.setFavorite(true);
				}
			}
		}
	}

	public void pluginCreated(PluginContext context) {
		// gracefully ignore
	}

	public void pluginDeleted(PluginContext context) {
		// gracefully ignore
	}

	public void pluginFutureCreated(PluginContext context) {
		// gracefully ignore
	}

	public void pluginResumed(PluginContext context) {
		// gracefully ignore
	}

	public void pluginStarted(PluginContext context) {
		// gracefully ignore
	}

	public void pluginSuspended(PluginContext context) {
		// gracefully ignore
	}

	public void pluginTerminatedWithError(PluginContext context, Throwable t) {
		// gracefully ignore
	}

	public void addedImportPlugins() {
		synchronized (importPluginAdded) {
			importPluginAdded = true;
		}
	}

	//********************************************************************
	// ConnectionListener.
	//

	public void connectionCreated(ConnectionID id) {
		if (!resources.containsKey(id)) {
			Connection conn;
			try {
				conn = connectionManager.getConnection(id);
				if (!conn.isRemoved()) {
					// TODO
					java.util.List<Collection<ProMPOResource>> values = new ArrayList<Collection<ProMPOResource>>();
					for (Object o : conn.getObjects().baseSet()) {
						ProMResource<?> r = context.getResourceManager().getResourceForInstance(o);
						if (r != null) {
							assert(r instanceof ProMPOResource);
							Collection<ProMPOResource> c = new LinkedList<ProMPOResource>();
							c.add((ProMPOResource) r);
							values.add(c);
						}
					}

					ProMCResource res = new ProMCResource(context, null, getResourceTypeFor(conn.getClass()), id,
							values);
					resources.put(id, res);
					signalUpdate();
				}
			} catch (ConnectionCannotBeObtained e) {
				// do nothing
			}
		}
	}

	public void connectionDeleted(ConnectionID id) {
		resources.remove(id);
		// No need to alert serializer, the connection will not be serialized if it has
		// been removed/destroyed.
	}

	public void connectionUpdated(ConnectionID id) {
		assert(resources.containsKey(id));
		// No need to alert the serializer, the connections is not serialized yet, it will
		// be on exit, not earlier.
		signalUpdate();
	}

}
"
ProMTaskManager.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.hub;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.deckfour.uitopia.api.event.TaskListener;
import org.deckfour.uitopia.api.hub.TaskManager;
import org.deckfour.uitopia.api.model.Action;
import org.deckfour.uitopia.api.model.Resource;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.model.ProMAction;
import org.processmining.contexts.uitopia.model.ProMPOResource;
import org.processmining.contexts.uitopia.model.ProMTask;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginContextID;
import org.processmining.framework.plugin.events.PluginLifeCycleEventListener;

public class ProMTaskManager implements TaskManager<ProMTask, ProMPOResource>, PluginLifeCycleEventListener {

	private final Set<ProMTask> tasks = new HashSet<ProMTask>();
	private final Set<ProMTask> activeTasks = new HashSet<ProMTask>();
	private final UIContext context;

	private final Map<PluginContextID, ProMTask> context2task = new HashMap<PluginContextID, ProMTask>();

	private ProMTaskManager(UIContext context) {
		this.context = context;
	}

	private static ProMTaskManager instance = null;

	public static ProMTaskManager initialize(UIContext context) {
		if (instance == null) {
			instance = new ProMTaskManager(context);
		}
		return instance;
	}

	public ProMTask execute(Action action, java.util.List<Collection<? extends Resource>> parameterValues,
			TaskListener listener) throws Exception {

		assert (action instanceof ProMAction);
		java.util.List<Collection<ProMPOResource>> list = new ArrayList<Collection<ProMPOResource>>();
		for (Collection<? extends Resource> v : parameterValues) {
			Collection<ProMPOResource> l = new ArrayList<ProMPOResource>();
			for (Resource r : v) {
				if (!(r instanceof ProMPOResource)) {
					throw new Exception(""Cannot instantiate plugins on Connections"");
				}
				l.add((ProMPOResource) r);
			}
			list.add(l);
		}

		UIPluginContext pluginContext = context.getMainPluginContext().createChildContext(action.getName());

		pluginContext.getPluginLifeCycleEventListeners().add(this);

		ProMTask task;
		synchronized (context2task) {
			task = new ProMTask(context, (ProMAction) action, list, pluginContext, listener);
			context2task.put(pluginContext.getID(), task);
		}
		return task;
	}

	public java.util.List<ProMTask> getActiveTasks() {
		return new ArrayList<ProMTask>(activeTasks);
	}

	public java.util.List<ProMTask> getAllTasks() {
		return new ArrayList<ProMTask>(tasks);
	}

	public void pluginCancelled(PluginContext context) {
		synchronized (context2task) {
			activeTasks.remove(context2task.get(context.getID()));
			context.getParentContext().deleteChild(context);
		}
	}

	public void pluginCompleted(PluginContext context) {
		synchronized (context2task) {
			activeTasks.remove(context2task.get(context.getID()));
			context.getParentContext().deleteChild(context);
		}
	}

	public void pluginCreated(PluginContext context) {
		synchronized (context2task) {
			tasks.add(context2task.get(context.getID()));
		}
	}

	public void pluginDeleted(PluginContext context) {
		synchronized (context2task) {
			activeTasks.remove(context2task.get(context.getID()));
			context.getParentContext().deleteChild(context);
		}
	}

	public void pluginFutureCreated(PluginContext context) {
		// Gracefully ignore
	}

	public void pluginResumed(PluginContext context) {
		synchronized (context2task) {
			activeTasks.add(context2task.get(context.getID()));
		}
	}

	public void pluginStarted(PluginContext context) {
		synchronized (context2task) {
			activeTasks.add(context2task.get(context.getID()));
		}
	}

	public void pluginSuspended(PluginContext context) {
		synchronized (context2task) {
			activeTasks.remove(context2task.get(context.getID()));
		}
	}

	public void pluginTerminatedWithError(PluginContext context, Throwable t) {
		synchronized (context2task) {
			activeTasks.remove(context2task.get(context.getID()));
			context.getParentContext().deleteChild(context);
		}
	}

	public boolean isActionableResource(Resource r) {
		return r instanceof ProMPOResource;
	}
	
	public boolean isActionableResource(java.util.List<Resource> resources) {
		for(Resource r : resources){
			if(!(r instanceof ProMPOResource)){
				return false;
			}
		}
		return true;
	}

	public boolean isAnActionableResource(java.util.List<Resource> resources) {
		for(Resource r : resources){
			if(r instanceof ProMPOResource){
				return true;
			}
		}
		return false;
	}

}
"
ProMViewManager.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.hub;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.swing.JComponent;

import org.deckfour.uitopia.api.hub.ViewManager;
import org.deckfour.uitopia.api.model.Resource;
import org.deckfour.uitopia.api.model.ResourceType;
import org.deckfour.uitopia.api.model.View;
import org.deckfour.uitopia.api.model.ViewType;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.contexts.uitopia.model.ProMViewType;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.ProMCanceller;
import org.processmining.framework.util.Pair;

public class ProMViewManager extends UpdateSignaller implements ViewManager {

	private static ProMViewManager instance = null;
	private final UIContext context;
	private final Map<Class<?>, List<ViewType>> viewClasses = new HashMap<Class<?>, List<ViewType>>();
	private final List<View> views;

	private ProMViewManager(UIContext context) {
		this.context = context;
		views = new ArrayList<View>();

		for (ResourceType type : context.getResourceManager().getAllSupportedResourceTypes()) {
			registerResourceType(type);
		}
	}

	public void registerResourceType(final ResourceType type) {
		viewClasses.put(type.getTypeClass(), new ArrayList<ViewType>(0));
		Set<Pair<Integer, PluginParameterBinding>> visualizers = context.getPluginManager().find(Visualizer.class,
				JComponent.class, UIPluginContext.class, true, false, true, type.getTypeClass());
		Set<Pair<Integer, PluginParameterBinding>> cancellableVisualizers = context.getPluginManager().find(Visualizer.class,
				JComponent.class, UIPluginContext.class, true, false, true, type.getTypeClass(), ProMCanceller.class);
		for (Pair<Integer, PluginParameterBinding> binding : visualizers) {
			viewClasses.get(type.getTypeClass()).add(new ProMViewType(this, type, binding));
		}
		for (Pair<Integer, PluginParameterBinding> binding : cancellableVisualizers) {
			viewClasses.get(type.getTypeClass()).add(new ProMViewType(this, type, binding));
		}
		Collections.sort(viewClasses.get(type.getTypeClass()), new Comparator<ViewType>() {

			public int compare(ViewType o1, ViewType o2) {
				if (o1 == o2 || o1.equals(o2)) {
					return 0;
				}
				boolean isO1ExactMatch = o1.getPrimaryType() == type.getTypeClass();
				boolean isO2ExactMatch = o2.getPrimaryType() == type.getTypeClass();
				if (isO1ExactMatch && !isO2ExactMatch) {
					return -1;
				} else if (!isO1ExactMatch && isO2ExactMatch) {
					return 1;
				} else {
					return 0;	
				} 				
			}
		});
	}

	public static ProMViewManager initialize(UIContext context) {
		if (instance == null) {
			instance = new ProMViewManager(context);
		}
		return instance;
	}

	public List<ViewType> getViewTypes(Resource resource) {
		List<ViewType> result = viewClasses.get(resource.getType().getTypeClass());
		return (result == null ? Collections.<ViewType>emptyList() : result);
	}
	
	public List<ViewType> getViewTypes(List<Resource> resources) {
		List<ViewType> views = new ArrayList<ViewType>();
		for(Resource r : resources){
			views.addAll(getViewTypes(r));
		}
		return views;
	}

	public List<View> getViews() {
		return views;
	}

	public void addView(View view) {
		synchronized (views) {
			views.add(view);
			signalUpdate();
		}
	}

	public void removeView(View view) {
		synchronized (views) {
			views.remove(view);
			view.destroy();
			signalUpdate();
		}
	}

	public UIContext getContext() {
		return context;
	}



}
"
UpdateSignaller.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.hub;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.deckfour.uitopia.api.event.UpdateListener;

public class UpdateSignaller {

	private final List<UpdateListener> listeners = new ArrayList<UpdateListener>();

	public UpdateSignaller() {
		super();
	}

	public void addListener(UpdateListener listener) {
		synchronized (listeners) {
			listeners.add(listener);
			listener.updated();
		}
	}

	public Collection<UpdateListener> getListeners() {
		return Collections.unmodifiableCollection(listeners);
	}

	public void removeAllListeners() {
		synchronized (listeners) {
			listeners.clear();
		}
	}

	public void removeListener(UpdateListener listener) {
		synchronized (listeners) {
			listeners.remove(listener);
		}
	}

	protected void signalUpdate() {
		synchronized (listeners) {
			for (UpdateListener listener : listeners) {
				listener.updated();
			}
		}
	}

}"
AbstractAuthored.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.model;

import java.net.URI;
import java.net.URL;

import org.deckfour.uitopia.api.model.Author;

public class AbstractAuthored {

	public Author getAuthor() {
		// TODO
		return new Author() {

			public String getAffiliation() {
				// TODO Auto-generated method stub
				return ""Eindhoven University of Technology"";
			}

			public String getEmail() {
				// TODO Auto-generated method stub
				return ""foo@bar.com"";
			}

			public String getName() {
				// TODO Auto-generated method stub
				return ""John Doe"";
			}

			public URI getWebsite() {
				// TODO Auto-generated method stub
				try {
					return new URL(""http://www.processmining.org"").toURI();
				} catch (Exception e) {
					return null;
				}
			}

		};
	}
}
"
ProMAction.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.model;

import java.lang.reflect.Array;
import java.net.URI;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import javax.swing.ImageIcon;

import org.deckfour.uitopia.api.model.Action;
import org.deckfour.uitopia.api.model.ActionStatus;
import org.deckfour.uitopia.api.model.ActionType;
import org.deckfour.uitopia.api.model.Author;
import org.deckfour.uitopia.api.model.Category;
import org.deckfour.uitopia.api.model.Parameter;
import org.deckfour.uitopia.api.model.Resource;
import org.deckfour.uitopia.api.model.ResourceType;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.contexts.uitopia.hub.ProMResourceManager;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.util.Cast;

public class ProMAction implements Action, Comparable<ProMAction> {

	private final PluginDescriptor plugin;
	private final int methodIndex;
	private final List<Parameter> inputs;
	private String name;
	private final List<Parameter> outputs;
	private final boolean[] isResource;
	private final int[] resourceIndex;
	private final Author author;
	private final PluginManager pluginManager;
	private final String pack;
	
	private String help;
	private String[] keywords;
	private String[] catergories;

	public ProMAction(ProMResourceManager resourceManager, PluginManager pluginManager, final PluginDescriptor plugin,
			final int methodIndex) {
		this.pluginManager = pluginManager;
		this.plugin = plugin;
		this.methodIndex = methodIndex;

		name = plugin.getAnnotation(UITopiaVariant.class, methodIndex).uiLabel();
		if (name.equals(UITopiaVariant.USEPLUGIN)) {
			name = plugin.getName();
		} else if (name.equals(UITopiaVariant.USEVARIANT)) {
			name = plugin.getMethodLabel(methodIndex);
		}

		help = plugin.getAnnotation(UITopiaVariant.class, methodIndex).uiHelp();
		if (help.equals(UITopiaVariant.USEPLUGIN)) {
			help = plugin.getHelp();
		} else if (help.equals(UITopiaVariant.USEVARIANT)) {
			help = plugin.getMethodHelp(methodIndex);
		}

		catergories = plugin.getCategories();
		keywords = plugin.getKeywords();
		
		pack = plugin.getAnnotation(UITopiaVariant.class, methodIndex).pack();

		author = new Author() {

			public String getAffiliation() {
				return plugin.getAnnotation(UITopiaVariant.class, methodIndex).affiliation();
			}

			public String getEmail() {
				return plugin.getAnnotation(UITopiaVariant.class, methodIndex).email();
			}

			public String getName() {
				return plugin.getAnnotation(UITopiaVariant.class, methodIndex).author();
			}

			public URI getWebsite() {
				URI uri = null;
				try {
					uri = new URL(plugin.getAnnotation(UITopiaVariant.class, methodIndex).website()).toURI();
				} catch (Exception e) {
					try {
						uri = new URL(""http://www.processmining.org"").toURI();
					} catch (Exception e2) {
					}
				}
				return uri;
			}

		};

		isResource = new boolean[plugin.getParameterNames(methodIndex).size()];
		resourceIndex = new int[plugin.getParameterNames(methodIndex).size()];

		inputs = new ArrayList<Parameter>();
		int resIndex = 0;
		for (int i = 0; i < plugin.getParameterNames(methodIndex).size(); i++) {
			Class<?> type = plugin.getParameterTypes(methodIndex).get(i);

			String name = plugin.getParameterNames(methodIndex).get(i);

			boolean isArray = type.isArray();
			if (isArray) {
				type = type.getComponentType();
			}
			ResourceType resType = resourceManager.getResourceTypeFor(type);

			if (resType != null) {
				inputs.add(new ProMParameter(name, i, resType, isArray));
				isResource[i] = true;
				resourceIndex[i] = resIndex++;
			} else {
				isResource[i] = false;
				resourceIndex[i] = -1;
			}
		}

		outputs = new ArrayList<Parameter>();
		for (int i = 0; i < plugin.getReturnNames().size(); i++) {
			Class<?> type = plugin.getReturnTypes().get(i);
			String name = plugin.getReturnNames().get(i);

			boolean isArray = type.isArray();
			if (type.isArray()) {
				type = type.getComponentType();
			}
			ResourceType resType = resourceManager.getResourceTypeFor(type);
			if (resType != null) {
				outputs.add(new ProMParameter(name, i, resType, isArray));
			}
		}

	}

	public boolean handlesCancel() {
		return plugin.handlesCancel();
	}

	public List<Parameter> getInput() {
		return inputs;
	}

	public String getName() {
		return name;
	}

	public String getPackage() {
		return pack;
	}

	public List<Parameter> getOutput() {
		return outputs;
	}

	public <R extends Resource> List<PluginParameterBinding> getBindings(List<Collection<R>> parameterValues,
			boolean executable) {
		Class<?>[] types = new Class<?>[parameterValues.size()];
		for (int i = 0; i < parameterValues.size(); i++) {
			Collection<? extends Resource> resources = parameterValues.get(i);
			if (resources.isEmpty()) {
				types[i] = null;
				continue;
			}
			types[i] = resources.iterator().next().getType().getTypeClass();
			if (resources.size() > 1) {
				types[i] = Array.newInstance(types[i], 0).getClass();
			}
		}

		return PluginParameterBinding.Factory.tryToBind(pluginManager, plugin, methodIndex, executable, false, types);

	}

	public ActionStatus getStatus(List<Collection<? extends Resource>> parameterValues) {

		// This cast is safe, since ProMResource is a final class, i.e. the given collection
		// cannot be based on subtypes. 
		List<Collection<ProMResource<?>>> promParameterValues = Cast
				.<java.util.List<Collection<ProMResource<?>>>>cast(parameterValues);

		List<PluginParameterBinding> bindings = getBindings(promParameterValues, true);

		if (!bindings.isEmpty()) {
			return ActionStatus.EXECUTABLE;
		}

		bindings = getBindings(promParameterValues, false);

		if (!bindings.isEmpty()) {
			return ActionStatus.INCOMPLETE;
		}

		return ActionStatus.INVALID;

	}

	public ActionType getType() {
		if (UIPluginContext.class.isAssignableFrom(plugin.getContextType(methodIndex))) {
			return ActionType.INTERACTIVE;
		} else {
			return ActionType.HEADLESS;
		}
	}

	public PluginDescriptor getPlugin() {
		return plugin;
	}

	public int getMethodIndex() {
		return methodIndex;
	}

	public int compareTo(ProMAction action) {
		int c = getName().compareTo(action.getName());
		if (c == 0) {
			return methodIndex - action.methodIndex;
		}
		return c;
	}

	public int getMostSignificantResultIndex() {
		return plugin.getMostSignificantResult();
	}

	public boolean equals(Object o) {
		return (o instanceof ProMAction ? plugin.equals(((ProMAction) o).plugin)
				&& (methodIndex == ((ProMAction) o).methodIndex) : false);
	}

	public int hashCode() {
		return 37 * plugin.hashCode() + methodIndex;
	}

	public String toString() {
		return getName();
	}

	public Author getAuthor() {
		return author;
	}

	public String getHelp() {
		return help;
	}

	public String[] getCategories() {
		return catergories;
	}

	public String[] getKeywords() {
		return keywords;
	}

	public boolean isOfCategory(Category category) {
		for (String c : catergories) {
			if (category.getName().equals(c)) {
				return true;
			}
		}
		return false;
	}
	
	public ImageIcon getIcon() {
		/*
		 * HV: For the time being, we simply use the icon of the package. 
		 * Later on, we can introduce icons that are specific for a plug-ins.
		 */
		if (plugin.getIcon() != null) {
			return plugin.getIcon();
		}
//		PackageDescriptor pack = plugin.getPackage();
//		if (pack != null) {
//			return PMIconCache.getIcon(pack);
//		}
		/*
		 * No icon.
		 */
		return null;
	}
	
	public URL getURL() {
		/*
		 * HV: For the time being, we simply use the URL of th epackage.
		 * Later on, we can introduce URLs that are specific for plug-ins.
		 */
		if (plugin.getURL() != null) {
			return plugin.getURL();
		}
//		PackageDescriptor pack = plugin.getPackage();
//		if (pack != null) {
//			try {
//				return new URL(pack.getURL());
//			} catch (MalformedURLException e) {
//			}	
//		}
		/*
		 * No URL.
		 */
		return null;
	}
}
"
ProMCategory.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.model;

import org.deckfour.uitopia.api.model.Category;
import org.processmining.framework.plugin.annotations.PluginCategory;

public class ProMCategory implements Category {

	private PluginCategory c;

	public ProMCategory(PluginCategory c){
		this.c = c;
	}
	public String getName() {
		return c.getName();
	}

	public String getDescription() {
		return c.getDescription();
	}

	public String getFilterImage() {
		return c.getImageFilterFilename();
	}
	
}
"
ProMCResource.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.model;

import java.util.Collection;
import java.util.List;

import org.deckfour.uitopia.api.model.Action;
import org.deckfour.uitopia.api.model.ResourceType;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionID;

public class ProMCResource extends ProMResource<ConnectionID> {

	public ProMCResource(UIContext context, Action sourceAction, ResourceType resType, ConnectionID id,
			List<Collection<ProMPOResource>> parameterValues) {
		super(context, sourceAction, resType, id, parameterValues);
		// TODO Auto-generated constructor stub
	}

	public void destroy() {
		isDestroyed = true;
		try {
			for (ProMResource<?> r : context.getResourceManager().getAllResources()) {
				r.parents.remove(this);
			}
			context.getConnectionManager().getConnection(id).remove();
		} catch (ConnectionCannotBeObtained e) {
		}

	}

	public String getName() {
		try {
			return context.getConnectionManager().getConnection(id).getLabel();
		} catch (ConnectionCannotBeObtained e) {
			isDestroyed = true;
			return ""This object is no longer available"";
		}
	}

	public void setName(String name) {
		try {
			context.getConnectionManager().getConnection(id).setLabel(name);
			if (listener != null) {
				listener.changed(this, false);
			}
		} catch (ConnectionCannotBeObtained e) {
			isDestroyed = true;
		}
	}

	/**
	 * Provides access to the object of the type specified by this resource.
	 * 
	 * @return The object carried by this resource.
	 */
	public Connection getInstance() {
		try {
			return context.getConnectionManager().getConnection(id);
		} catch (ConnectionCannotBeObtained e) {
			isDestroyed = true;
			return null;
		}
	}
}
"
ProMParameter.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.model;

import org.deckfour.uitopia.api.model.Parameter;
import org.deckfour.uitopia.api.model.ResourceType;

public class ProMParameter implements Parameter {

	private final ResourceType type;
	private final String name;
	private final int index;
	private final boolean isArray;

	public ProMParameter(String name, int index, ResourceType type, boolean isArray) {
		this.name = name;
		this.index = index;
		this.type = type;
		this.isArray = isArray;
	}

	public boolean isRequired() {
		return true;
	}

	public String getName() {
		return name;
	}

	public ResourceType getType() {
		return type;
	}

	public int getRealParameterIndex() {
		return index;
	}

	public int getMaxCardinality() {
		return isArray ? Parameter.CARDINALITY_INFINITY : 1;
	}

	public int getMinCardinality() {
		return 1;
	}
}
"
ProMPOResource.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.model;

import java.util.Collection;
import java.util.List;

import org.deckfour.uitopia.api.model.Action;
import org.deckfour.uitopia.api.model.ResourceType;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;

public class ProMPOResource extends ProMResource<ProvidedObjectID> {

	public ProMPOResource(UIContext context, Action sourceAction, ResourceType resType, ProvidedObjectID id,
			List<Collection<ProMPOResource>> parameterValues) {
		super(context, sourceAction, resType, id, parameterValues);
	}

	public void destroy() {
		isDestroyed = true;
		try {
			context.getProvidedObjectManager().deleteProvidedObject(id);
			for (ProMResource<?> r : context.getResourceManager().getAllResources()) {
				r.parents.remove(this);
			}
		} catch (ProvidedObjectDeletedException e) {
			// THat's fine
		}
	}

	public String getName() {
		try {
			return context.getProvidedObjectManager().getProvidedObjectLabel(id);
		} catch (ProvidedObjectDeletedException e) {
			return ""This object is no longer available"";
		}
	}

	public void setName(String name) {
		try {
			context.getProvidedObjectManager().relabelProvidedObject(id, name);
			if (listener != null) {
				listener.changed(this, false);
			}
		} catch (ProvidedObjectDeletedException e) {
			// Should not happen, unless destroy has been called
			assert (false);
		}
	}

	/**
	 * Provides access to the object of the type specified by this resource.
	 * 
	 * @return The object carried by this resource.
	 */
	public Object getInstance() {
		try {
			return context.getProvidedObjectManager().getProvidedObjectObject(id, true);
		} catch (ProvidedObjectDeletedException e) {
			return null;
		}
	}

}
"
ProMResource.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.model;

import java.awt.Image;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.deckfour.uitopia.api.model.Action;
import org.deckfour.uitopia.api.model.Resource;
import org.deckfour.uitopia.api.model.ResourceType;
import org.deckfour.uitopia.api.model.View;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.framework.ProMID;

public abstract class ProMResource<I extends ProMID> implements Resource {

	public static interface Listener {
		public void changed(ProMResource<?> resource, boolean fullUpdate);
	}

	protected final ResourceType resType;
	protected boolean favorite = false;
	protected long creationTime;
	protected long lastAccessTime = System.currentTimeMillis();
	protected final I id;
	protected final Set<ProMPOResource> parents;
	protected final UIContext context;
	protected View view = null;
	protected final Action sourceAction;
	protected boolean isDestroyed = false;
	protected Listener listener;

	private static Long currentTime = System.currentTimeMillis();

	public ProMResource(UIContext context, Action sourceAction, ResourceType resType, I id,
			List<Collection<ProMPOResource>> parameterValues) {
		assert resType != null;
		this.sourceAction = sourceAction;
		this.resType = resType;
		this.id = id;
		synchronized (currentTime) {
			currentTime = Math.max(currentTime + 1, System.currentTimeMillis());
			creationTime = currentTime;
		}
		parents = new HashSet<ProMPOResource>();
		this.context = context;

		for (Collection<ProMPOResource> col : parameterValues) {
			parents.addAll(col);
		}

	}

	public void setListener(Listener listener) {
		this.listener = listener;
	}

	public void setParents(Set<ProMPOResource> parents) {
		this.parents.clear();
		this.parents.addAll(parents);
	}

	public Date getCreationTime() {
		return new Date(creationTime);
	}

	public Date getLastAccessTime() {
		return new Date(lastAccessTime);
	}

	public void setCreationTime(long creationTime) {
		this.creationTime = creationTime;
	}

	public void setLastAccessTime(long lastAccessTime) {
		this.lastAccessTime = lastAccessTime;
	}

	public Collection<ProMPOResource> getParents() {
		return Collections.unmodifiableCollection(parents);
	}

	public Image getPreview(int maxWidth, int maxHeight) {
		if (view == null) {
			return resType.getTypeIcon();
		}
		return view.getPreview(maxWidth, maxHeight);
	}

	public void setView(ProMView view) {
		this.view = view;
	}

	public Action getSourceAction() {
		return sourceAction;
	}

	public boolean isFavorite() {
		return favorite;
	}

	public void setFavorite(boolean favorite) {
		this.favorite = favorite;
		if (listener != null) {
			listener.changed(this, false);
		}
	}

	public void updateLastAccessTime() {
		lastAccessTime = System.currentTimeMillis();
	}

	public ResourceType getType() {
		return resType;
	}

	public boolean equals(Object o) {
		if (!(o instanceof ProMResource)) {
			return false;
		}
		ProMResource<?> p = (ProMResource<?>) o;
		return p.id.equals(id);
	}

	public int hashCode() {
		return id.hashCode();
	}

	public String toString() {
		return getName();
	}

	public ProMID getID() {
		return id;
	}

	public boolean isDestroyed() {
		return isDestroyed;
	}

	public abstract Object getInstance();
}
"
ProMResourceType.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.model;

import java.awt.Image;
import java.net.URI;
import java.net.URL;

import org.deckfour.uitopia.api.model.Author;
import org.deckfour.uitopia.api.model.ResourceType;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.framework.annotations.AuthoredType;
import org.processmining.framework.annotations.Icon;

public class ProMResourceType implements ResourceType {

	private final Class<?> type;
	private Author author;
	private Image icon;
	private String name;
	private final static String DEFAULT_ICON = ""resourcetype_model_30x35.png"";

	public ProMResourceType(Class<?> aType) {
		type = aType;

		final ResourceTypeInfo typeInfo = ProMResourceTypeInformation.getInstance().getInfoFor(aType);
		if (typeInfo != null) {
			author = typeInfo;
			name = typeInfo.getTypeName();
			icon = ImageLoader.load(typeInfo.getIcon());

		} else {
			if (type.isAnnotationPresent(AuthoredType.class)) {
				author = new Author() {

					public String getAffiliation() {
						return type.getAnnotation(AuthoredType.class).affiliation();
					}

					public String getEmail() {
						return type.getAnnotation(AuthoredType.class).email();
					}

					public String getName() {
						return type.getAnnotation(AuthoredType.class).author();
					}

					public URI getWebsite() {
						URI uri = null;
						try {
							uri = new URL(type.getAnnotation(AuthoredType.class).website()).toURI();
						} catch (Exception e) {
							try {
								uri = new URL(""http://www.processmining.org"").toURI();
							} catch (Exception e2) {
							}
						}
						return uri;
					}

				};
				name = type.getAnnotation(AuthoredType.class).typeName();
			} else {
				author = new Author() {

					public String getAffiliation() {
						return ""Affiliation unknown"";
					}

					public String getEmail() {
						return ""h.m.w.verbeek@tue.nl"";
					}

					public String getName() {
						return ""Author unknown"";
					}

					public URI getWebsite() {
						URI uri = null;
						try {
							uri = new URL(""http://www.processmining.org"").toURI();
						} catch (Exception e2) {
						}
						return uri;
					}
				};
				name = type.getSimpleName();
			}

			if (type.isAnnotationPresent(Icon.class)) {
				icon = ImageLoader.load(type.getAnnotation(Icon.class).icon());
			}

			/*
			 * HV: No icon found yet. Use default.
			 */
			if (icon == null) {
				if (type.getName().equals(""org.deckfour.xes.model.XLog"")) {
					/*
					 * HV: The framework does not know the XLog interface, and
					 * OpenXES does not know the @Icon annotation. Therefore, we
					 * hardcode the link between an XLog and its icon here.
					 */
					icon = ImageLoader.load(""resourcetype_log_30x35.png"");
				} else {
					icon = ImageLoader.load(DEFAULT_ICON);
				}
			}
		}

	}

	public Author getTypeAuthor() {
		return author;
	}

	public Class<?> getTypeClass() {
		return type;
	}

	public Image getTypeIcon() {
		return icon;
	}

	public String getTypeName() {
		return name;
	}

	public boolean isAssignableFrom(ResourceType type) {
		return getTypeClass().isAssignableFrom(type.getTypeClass());
	}

	public boolean equals(Object o) {
		if (!(o instanceof ResourceType)) {
			return false;
		}
		ResourceType rt = (ResourceType) o;
		return (type.equals(rt.getTypeClass()) && getTypeName().equals(rt.getTypeName()));

	}

	public int hashCode() {
		return type.hashCode() + 37 * getTypeName().hashCode();
	}

}
"
ProMResourceTypeInformation.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.model;

import java.net.URI;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

import org.deckfour.uitopia.api.model.Author;

public class ProMResourceTypeInformation {

	private final static Map<Class<?>, ResourceTypeInfo> typeInfo = new HashMap<Class<?>, ResourceTypeInfo>();
	private static ProMResourceTypeInformation instance;

	private ProMResourceTypeInformation() {
	}

	public final static ProMResourceTypeInformation getInstance() {
		if (instance == null) {
			instance = new ProMResourceTypeInformation();
		}
		return instance;
	}

	public ResourceTypeInfo getInfoFor(Class<?> type) {
		return typeInfo.get(type);
	}
	
	public void setInfoFor(Class<?> type, String typename, String affiliation, String email, String author, String website,
			String icon) {
		typeInfo.put(type, new ResourceTypeInfo(typename, affiliation, email, author, website, icon));
	}
}

class ResourceTypeInfo implements Author {

	public String affiliation;
	public String email;
	public String author;
	public String website;
	public String icon;
	public String typename;

	public ResourceTypeInfo(String typename, String affiliation, String email, String author, String website,
			String icon) {
		this.typename = typename;
		this.affiliation = affiliation;
		this.email = email;
		this.author = author;
		this.website = website;
		this.icon = icon;
	}

	public String getTypeName() {
		return typename;
	}

	public String getAffiliation() {
		return affiliation;
	}

	public String getEmail() {
		return email;
	}

	public String getName() {
		return author;
	}

	public URI getWebsite() {
		URI uri = null;
		try {
			uri = new URL(website).toURI();
		} catch (Exception e2) {
		}
		return uri;
	}

	public String getIcon() {
		return icon;
	}

}
"
ProMTask.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.model;

import java.lang.reflect.Array;
import java.util.Collection;
import java.util.Iterator;

import javax.swing.JComponent;

import org.deckfour.uitopia.api.event.TaskListener;
import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.uitopia.api.model.ResourceType;
import org.deckfour.uitopia.api.model.Task;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginContextID;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.events.Logger;
import org.processmining.framework.plugin.events.PluginLifeCycleEventListener;
import org.processmining.framework.plugin.events.ProgressEventListener;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;

public class ProMTask implements Task<ProMPOResource>, ProgressEventListener, Logger, PluginLifeCycleEventListener {

	private final ProMAction action;
	private PluginExecutionResult result;
	private int lowbo = 0, upbo = 0, progress = 0;
	private final TaskListener listener;
	private final UIContext context;
	private final java.util.List<Collection<ProMPOResource>> parameterValues;
	private final java.util.List<ProvidedObjectID> providedObjectIds;
	private boolean active;
	private final UIPluginContext pluginContext;

	public ProMTask(UIContext context, ProMAction action, java.util.List<Collection<ProMPOResource>> parameterValues,
			UIPluginContext pluginContext, TaskListener listener) {
		this.context = context;
		this.action = action;
		this.parameterValues = parameterValues;
		this.pluginContext = pluginContext;
		this.listener = listener;
		changeProgressIndeterminate(true);

		// In this constructor, the task should set up a context for the plugin
		// carried by the action. All resources of the action should have values,
		// i.e. the action should be executable. 
		//		assert (action.getStatus(parameterValues) == ActionStatus.EXECUTABLE);

		// Then, using the resources attached to the input parameters of the 
		// action, possibly some other input parameters need to be found, for example
		// be scanning for connections. This is up to the implementing classes.
		pluginContext.getProgressEventListeners().add(this);
		pluginContext.getLoggingListeners().add(this);
		pluginContext.getPluginLifeCycleEventListeners().add(this);

		Object[] args = unpackResourceCollections(parameterValues);

		// The plugin should be invoked and this task should attach itself as 
		// a progress listener
		pluginContext.setTask(this);
		synchronized (this) {
			active = true;
			pluginContext.getParentContext().getPluginLifeCycleEventListeners().firePluginCreated(pluginContext);
			result = action.getPlugin().invoke(action.getMethodIndex(), pluginContext, args);
			providedObjectIds = context.getProvidedObjectManager().createProvidedObjects(pluginContext);
		}
	}

	public void destroy() {
		if (result != null) {
			if (pluginContext.getProgress() != null) {
				// We have a progress. Have it take care of the futures and such.
				pluginContext.getProgress().cancel();
			} else {
				// We cancel all futures that might exist in this
				// result. Canceling the first only would also work,
				// but this is potentially faster.
				try {
					for (int i = 0; i < result.getSize(); i++) {
						Object o = result.getResult(i);
						if (o instanceof ProMFuture<?>) {
							result.<ProMFuture<?>>getResult(i).cancel(!action.handlesCancel());
						}
					}
				} catch (NullPointerException _) {
					// Happens when task terminates before we can cancel all children
				}
			}
			for (ProvidedObjectID id : getProvidedObjectIds()) {
				try {
					context.getProvidedObjectManager().deleteProvidedObject(id);
				} catch (ProvidedObjectDeletedException e) {
					//Ignore
				}
			}
			result = null;
		}
		progress = upbo;
		listener.updateProgress(1.0);
	}

	public ProMAction getAction() {
		return action;
	}

	public double getProgress() {
		return (double) progress / (double) (upbo - lowbo);
	}

	public InteractionResult showConfiguration(String title, JComponent configuration) {
		return listener.showConfiguration(title, configuration);
	}

	public InteractionResult showWizard(String title, boolean first, boolean last, JComponent configuration) {
		return listener.showWizard(title, first, last, configuration);
	}

	public java.util.List<Collection<ProMPOResource>> getParameterValues() {
		//		java.util.List<Collection<ProMResource<?>>> list = new ArrayList<Collection<ProMResource<?>>>();
		//		for (Collection<ProMPOResource> v : parameterValues) {
		//			Collection<ProMResource<?>> l = new ArrayList<ProMResource<?>>(v);
		//			list.add(l);
		//		}
		return parameterValues;
	}

	private Object[] unpackResourceCollections(java.util.List<Collection<ProMPOResource>> parameters) {
		Object[] objects = new Object[parameters.size()];

		for (int i = 0; i < parameters.size(); i++) {
			if (action.getInput().get(i).getMaxCardinality() == 1) {
				objects[i] = parameters.get(i).iterator().next().getInstance();
			} else {
				Object[] list = (Object[]) Array.newInstance(action.getInput().get(i).getType().getTypeClass(),
						parameters.get(i).size());
				Iterator<ProMPOResource> it = parameters.get(i).iterator();
				int j = 0;
				while (it.hasNext()) {
					list[j++] = it.next().getInstance();
				}
				objects[i] = list;
			}
		}

		return objects;

	}

	//****************ProgressEventListener Interface************************

	public void changeProgress(int progress) {
		this.progress = progress;
		lowbo = Math.min(lowbo, progress);
		upbo = Math.max(upbo, progress);
		listener.updateProgress(getProgress());
	}

	public void changeProgressBounds(int lowBo, int upBo) {
		lowbo = lowBo;
		upbo = upBo;
		progress = 0;
		listener.updateProgress(Math.max(Math.min(lowBo, progress), upBo));
	}

	public void changeProgressCaption(String newCaption) {
		// Gracefully ignore.
	}

	public void changeProgressIndeterminate(boolean indeterminate) {
		if (indeterminate) {
			lowbo = 0;
			upbo = 1;
			progress = 0;
			listener.updateProgress(0.5);
		}
	}

	//****************Logger Interface************************
	public void log(String message, PluginContextID contextID, MessageLevel messageLevel) {
		switch (messageLevel) {
			case DEBUG :
				listener.debug(message);
				break;
			case NORMAL :
				listener.info(message);
				break;
			case ERROR :
				listener.error(message);
				break;
			case WARNING :
				listener.warning(message);
				break;
			case TEST :
				listener.debug(message);
				break;
		}
	}

	public void log(Throwable t, PluginContextID contextID) {
		listener.error(t.getMessage(), t);
	}

	public void pluginCancelled(PluginContext context) {
		// Gracefully ignore. Only the completed is of interest
		listener.completed();
		active = false;
		result = null;
		changeProgress(upbo);
	}

	public void pluginCompleted(PluginContext pluginContext) {
		ProMPOResource[] setResult = null;
		int sig = action.getMostSignificantResultIndex();
		if (sig < 0) {
			// One of the inputs should be returned as the most significant result
			// find the corresponding parameter for this plugin variant.
			sig = action.getPlugin().getIndexInMethod(action.getMethodIndex(), -sig - 1);

			Collection<ProMPOResource> par = parameterValues.get(sig);
			// Visualize the first resource parameter in the end.
			setResult = par.toArray(new ProMPOResource[0]);
			sig = -1;
		}
		for (int i = 0; i < result.getSize(); i++) {
			ProvidedObjectID id = result.getProvidedObjectID(i);
			Class<?> type;
			try {
				type = context.getProvidedObjectManager().getProvidedObjectType(id);
			} catch (ProvidedObjectDeletedException e) {
				// If the object has been deleted, try the next one
				continue;
			}
			ResourceType resType = context.getResourceManager().getResourceTypeFor(type);
			if (resType != null) {
				ProMPOResource res = new ProMPOResource(context, action, resType, id, parameterValues);
				res = context.getResourceManager().addResource(id, res);

				if (i + 1 == sig) {
					res.setFavorite(true);
					setResult = new ProMPOResource[] { res };
				}
			}
		}
		listener.completed(setResult);
		active = false;
		result = null;
		changeProgress(upbo);
	}

	public void pluginCreated(PluginContext pluginContext) {
		// Gracefully ignore. Only the completed is of interest
	}

	public void pluginDeleted(PluginContext pluginContext) {
		// Gracefully ignore. Only the completed is of interest
	}

	public void pluginFutureCreated(PluginContext pluginContext) {
		// Gracefully ignore. Only the completed is of interest
	}

	public void pluginResumed(PluginContext pluginContext) {
		// Gracefully ignore. Only the completed is of interest
	}

	public void pluginStarted(PluginContext pluginContext) {
		// Gracefully ignore. Only the completed is of interest
	}

	public void pluginSuspended(PluginContext pluginContext) {
		// Gracefully ignore. Only the completed is of interest
	}

	public void pluginTerminatedWithError(PluginContext pluginContext, Throwable t) {
		// Gracefully ignore. Only the completed is of interest
		listener.completed();
		active = false;
		result = null;
		changeProgress(upbo);
	}

	public java.util.List<ProvidedObjectID> getProvidedObjectIds() {
		return providedObjectIds;
	}

	public String toString() {
		return (active ? ""[A]"" : ""[I]"") + action.toString();
	}

}
"
ProMView.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.model;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.HeadlessException;
import java.awt.Image;
import java.awt.RenderingHints;
import java.awt.Transparency;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.concurrent.CancellationException;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JEditorPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;

import org.deckfour.uitopia.api.model.Resource;
import org.deckfour.uitopia.api.model.View;
import org.deckfour.uitopia.api.model.ViewType;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.hub.ProMViewManager;
import org.processmining.contexts.uitopia.hub.overlay.ProgressOverlayDialog;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.ProMCanceller;
import org.processmining.framework.util.Pair;

import com.fluxicon.slickerbox.factory.SlickerFactory;
import com.google.common.base.Throwables;

public class ProMView implements View {

	private final class ProMViewRunnable implements Runnable {

		private JComponent content;
		private ProgressOverlayDialog dialog;

		private String message;
		private String stacktrace;
		private PluginDescriptor descriptor;

		public ProMViewRunnable(JComponent content, ProgressOverlayDialog dialog, String message, String stacktrace,
				PluginDescriptor descriptor) {
			this.content = content;
			this.dialog = dialog;
			this.message = message;
			this.stacktrace = stacktrace;
			this.descriptor = descriptor;
		}

		public void run() {
			component.removeAll();
			if (content != null) {
				try {
					content.repaint();
					component.add(content, BorderLayout.CENTER);
				} catch (Exception e) {
					e.printStackTrace();
					//ignore
					message = e.getMessage();
					stacktrace = Throwables.getStackTraceAsString(e);
				}
			}
			if (component.getComponents().length == 0) {
				component.add(buildErrorComponent(message, stacktrace, descriptor), BorderLayout.CENTER);
			}
			dialog.changeProgress(dialog.getMaximum());
		}

		private JComponent buildErrorComponent(final String message, final String stacktrace,
				final PluginDescriptor plugin) {
			final JPanel errorPanel = new JPanel();
			errorPanel.setLayout(new BoxLayout(errorPanel, BoxLayout.Y_AXIS));
			String userfriendlyMessage = String.format(
					""<html><h1>Unable to produce the requested visualization</h1><h2>Error Message</h2><h3>%s</b></h3></html>"",
					message);
			final JEditorPane messagePanel = new JEditorPane(""text/html"", userfriendlyMessage);
			messagePanel.setEditable(false);
			final JButton debugButton = SlickerFactory.instance().createButton(""Show Debug Information"");
			debugButton.setAlignmentX(JComponent.CENTER_ALIGNMENT);
			debugButton.addActionListener(new ActionListener() {

				public void actionPerformed(ActionEvent e) {
					String debugMessage = String.format(
							""<html><body><h1>Unable to produce the requested visualization</h1>""
									+ ""<h2>Error Message</h2><h3>%s</b></h3>""
									+ ""<h2>Debug Information for Reporting</h2>"" + ""<p><b>Visualizer</b>: %s</p>""
									+ ""<p><b>Stack trace</b>: %s</p>"" + ""</body></html>"",
							message, plugin.getName(),
							stacktrace.replace(System.getProperty(""line.separator""), ""<p>\n""));
					messagePanel.setText(debugMessage);
					messagePanel.setCaretPosition(0);
					debugButton.removeActionListener(this);
					errorPanel.remove(debugButton);
					errorPanel.validate();
				}
			});
			errorPanel.add(new JScrollPane(messagePanel));
			errorPanel.add(debugButton);
			return errorPanel;
		}
	}

	private static final class ProMCancellerImpl implements ProMCanceller {

		private boolean isCancelled = false;

		public boolean isCancelled() {
			return isCancelled;
		}

		public void cancel() {
			isCancelled = true;
		}

	}

	private final JPanel component;
	private final ProMViewManager manager;
	private String name;
	private final ProMResource<?> resource;
	protected static GraphicsConfiguration gc;
	private final ProMViewType type;
	private BufferedImage original;
	private BufferedImage scaledImage;
	private final Pair<Integer, PluginParameterBinding> binding;
	private boolean working = true;
	private final ProMCancellerImpl proMCanceller;

	public ProMView(ProMViewManager manager, ProMViewType type, ProMResource<?> resource, String name,
			Pair<Integer, PluginParameterBinding> binding) {
		this.manager = manager;
		this.type = type;
		this.resource = resource;
		this.binding = binding;
		resource.setView(this);
		this.name = name;
		component = new JPanel(new BorderLayout());
		component.setBorder(BorderFactory.createEmptyBorder());
		component.setOpaque(false);
		original = toBufferedImage(resource.getType().getTypeIcon());
		proMCanceller = new ProMCancellerImpl();
		refresh(0);
	}

	public void destroy() {
		component.removeAll();
		proMCanceller.cancel();
	}

	public String getCustomName() {
		return name;
	}

	public Image getPreview(int maxWidth, int maxHeight) {
		synchronized (original) {

			int originalWidth = original.getWidth();
			int originalHeight = original.getHeight();
			double scaleFactor = (double) maxWidth / (double) originalWidth;
			double scaleY = (double) maxHeight / (double) originalHeight;
			if (scaleY < scaleFactor) {
				scaleFactor = scaleY;
			}

			int scaledWidth = Math.max(1, (int) (originalWidth * scaleFactor));
			int scaledHeight = Math.max(1, (int) (originalHeight * scaleFactor));

			scaledImage = createCompatibleImage(scaledWidth, scaledHeight);
			Graphics2D g2ds = scaledImage.createGraphics();
			g2ds = scaledImage.createGraphics();
			g2ds.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
			g2ds.drawImage(original, 0, 0, scaledWidth, scaledHeight, null);
			g2ds.dispose();
			return scaledImage;
		}

	}

	public Resource getResource() {
		return resource;
	}

	public JComponent getViewComponent() {
		return component;
	}

	public void setCustomName(String name) {
		this.name = name;
	}

	private BufferedImage createCompatibleImage(int width, int height) {
		if (gc == null) {
			gc = component.getGraphicsConfiguration();
			if (gc == null) {
				gc = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice()
						.getDefaultConfiguration();
			}
		}
		return gc.createCompatibleImage(width, height, Transparency.TRANSLUCENT);
	}

	public ViewType getType() {
		return type;
	}

	public void captureNow() {
		// Record a screen-capture of the currenly visible frame
		synchronized (original) {
			Dimension size = component.getSize();
			if (size.width > 0 && size.height > 0) {
				original = createCompatibleImage(size.width, size.height);
				Graphics2D g2d = original.createGraphics();
				component.paint(g2d);
				g2d.dispose();
			}
		}

	}

	// This method returns a buffered image with the contents of an image
	private BufferedImage toBufferedImage(Image image) {
		if (image instanceof BufferedImage) {
			return (BufferedImage) image;
		}

		// This code ensures that all the pixels in the image are loaded
		image = new ImageIcon(image).getImage();

		// Create a buffered image with a format that's compatible with the screen
		BufferedImage bimage = null;
		GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
		try {
			// Determine the type of transparency of the new buffered image
			int transparency = Transparency.OPAQUE;

			// Create the buffered image
			GraphicsDevice gs = ge.getDefaultScreenDevice();
			GraphicsConfiguration gc = gs.getDefaultConfiguration();
			bimage = gc.createCompatibleImage(image.getWidth(null), image.getHeight(null), transparency);
		} catch (HeadlessException e) {
			// The system does not have a screen
		}

		if (bimage == null) {
			// Create a buffered image using the default color model
			int type = BufferedImage.TYPE_INT_RGB;
			bimage = new BufferedImage(image.getWidth(null), image.getHeight(null), type);
		}

		// Copy image to buffered image
		Graphics g = bimage.createGraphics();

		// Paint the image onto the buffered image
		g.drawImage(image, 0, 0, null);
		g.dispose();

		return bimage;
	}

	public void refresh() {
		refresh(0);
	}

	public void refresh(final int millisToPopup) {

		final UIPluginContext context = manager.getContext().getMainPluginContext()
				.createChildContext(""Visualizing: "" + resource.getName());
		context.getParentContext().getPluginLifeCycleEventListeners().firePluginCreated(context);

		final ProgressOverlayDialog dialog = new ProgressOverlayDialog(
				manager.getContext().getController().getMainView(), context,
				""Please wait while updating visualization..."");
		dialog.setIndeterminate(false);

		Thread thread = new Thread(new Runnable() {

			public void run() {
				manager.getContext().getController().getMainView().showOverlay(dialog);
				synchronized (ProMView.this) {
					working = true;
				}

				PluginExecutionResult result = getVisualizationResult(context, proMCanceller);

				String message = ""no message"";
				String stacktrace = ""unavailable"";
				JComponent content = null;
				try {
					context.log(""Starting visualization of "" + resource);
					result.synchronize();
					content = result.getResult(binding.getFirst());

					if (content == null) {
						throw new Exception(""The visualiser for "" + resource.toString()
								+ "" returned null. Please select another visualiser."");
					}
				} catch (CancellationException e) {
					proMCanceller.cancel();
					message = ""The visualiser is cancelled."";
					stacktrace = ""not available"";
				} catch (Exception e) {
					message = e.getMessage();
					stacktrace = Throwables.getStackTraceAsString(e);
				} finally {
					context.getParentContext().deleteChild(context);
					SwingUtilities.invokeLater(
							new ProMViewRunnable(content, dialog, message, stacktrace, result.getPlugin()));
					synchronized (ProMView.this) {
						working = false;
						ProMView.this.notifyAll();
					}
					manager.getContext().getController().getMainView().hideOverlay();
				}

			}

			private PluginExecutionResult getVisualizationResult(final UIPluginContext context,
					ProMCanceller proMCanceller) {
				PluginParameterBinding parameterBinding = binding.getSecond();
				List<Class<?>> parameterTypes = parameterBinding.getPlugin()
						.getParameterTypes(parameterBinding.getMethodIndex());
				if (parameterTypes.size() == 2 && parameterTypes.get(1) == ProMCanceller.class) {
					return parameterBinding.invoke(context, resource.getInstance(), proMCanceller);
				} else {
					return parameterBinding.invoke(context, resource.getInstance());
				}
			}

		});
		thread.start();

	}

	public synchronized boolean isReady() {
		return !working;
	}

}
"
ProMViewType.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.model;

import java.text.MessageFormat;

import org.deckfour.uitopia.api.model.Resource;
import org.deckfour.uitopia.api.model.ResourceType;
import org.deckfour.uitopia.api.model.View;
import org.deckfour.uitopia.api.model.ViewType;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.contexts.uitopia.hub.ProMViewManager;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.util.Pair;

public class ProMViewType extends AbstractAuthored implements ViewType {

	private final ResourceType acceptedType;
	private final Pair<Integer, PluginParameterBinding> binding;
	private final ProMViewManager manager;
	private String name;

	public ProMViewType(ProMViewManager manager, ResourceType acceptedType,
			Pair<Integer, PluginParameterBinding> binding) {
		this.manager = manager;
		this.acceptedType = acceptedType;
		this.binding = binding;
		name = binding.getSecond().getPlugin().getAnnotation(Visualizer.class).name();
		if (name.equals(Visualizer.USEPLUGINNAME)) {
			name = binding.getSecond().getPlugin().getName();
		}
	}

	public View createView(Resource res) throws IllegalArgumentException {
		assert (res instanceof ProMResource);
		ProMResource<?> pr = ((ProMResource<?>) res);
		return new ProMView(manager, this, pr, res.getName(), binding);
	}

	public String getTypeName() {
		if (name.startsWith(""@"") && name.contains("" "")) {
			return name.substring(name.indexOf("" "") + 1);
		}
		return name;
	}

	public ResourceType getViewableType() {
		return acceptedType;
	}

	public String toString() {
		PackageDescriptor packageDesc = binding.getSecond().getPlugin().getPackage();
		if (packageDesc != null) {
			return MessageFormat.format(""{0} ({1})"", getTypeName(), packageDesc.getName());
		} else {
			return MessageFormat.format(""{0}"", getTypeName());
		}		
	}

	public boolean equals(Object o) {
		if (o instanceof ProMViewType) {
			ProMViewType vt = (ProMViewType) o;
			return vt.binding.equals(binding);
		}
		return false;
	}

	public int hashCode() {
		return binding.hashCode();
	}

	public Class<?> getPrimaryType() {
		PluginParameterBinding pluginMethod = binding.getSecond();
		PluginDescriptor plugin = pluginMethod.getPlugin();
		return plugin.getPluginParameterType(pluginMethod.getMethodIndex(), 0);
	}
}
"
PMController.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.prefs.BackingStoreException;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageManager;
import org.processmining.framework.packages.UnknownPackageTypeException;
import org.processmining.framework.packages.impl.CancelledException;

public class PMController {

	private final PMMainView mainView;
	private final PackageManager manager;
	private String query;

	public PMController(Boot.Level verbose) {
		manager = PackageManager.getInstance();
		manager.initialize(verbose);
		try {
			manager.update(false, verbose);
		} catch (CancelledException e) {
			e.printStackTrace();
		} catch (UnknownPackageTypeException e) {
			e.printStackTrace();
		}

		mainView = new PMMainView(this);
	}
	
	public void cleanPackageCache() throws BackingStoreException {
		manager.cleanPackageCache();
	}

	/**
	 * Select a package, select the right tab and return the selected PMPackage
	 * 
	 * @param packageName
	 * @return null if no package with such name exists.
	 */
	public PMPackage selectPackage(String packageName) {
		Set<PackageDescriptor> available = manager.getAvailablePackages();
		for (PackageDescriptor d : available) {
			if (d.getName().equals(packageName)) {
				// package descriptor d is available
				PMPackage pack = new PMPackage(d);
				setStatus(pack, d);
				mainView.showWorkspaceView(pack);
				return pack;
			}
		}
		return null;
	}

	public PMMainView getMainView() {
		return mainView;
	}

	public java.util.List<PMPackage> getToUninstallPackages() {
		Set<PackageDescriptor> descriptors = manager.getAvailablePackages();
		java.util.List<PMPackage> list = new ArrayList<PMPackage>();
		for (PackageDescriptor descriptor : descriptors) {
			PMPackage pack = new PMPackage(descriptor);
			PackageDescriptor installed = manager.findInstalledVersion(descriptor);
			if ((installed != null) && installed.equals(descriptor)) {
				list.add(pack);
				setStatus(pack, descriptor);
			}
		}
		return list;
	}

	public java.util.List<? extends PMPackage> getToUpdatePackages() {
		Set<PackageDescriptor> descriptors = manager.getAvailablePackages();
		java.util.List<PMPackage> list = new ArrayList<PMPackage>();
		for (PackageDescriptor available : descriptors) {
			PMPackage pack = new PMPackage(available);
			PackageDescriptor installed = manager.findInstalledVersion(available);
			if ((installed != null && manager.isAvailable(available)) && //
					installed.getVersion().lessThan(available.getVersion())) {
				list.add(pack);
				setStatus(pack, available);
			}
		}
		return list;
	}

	public java.util.List<? extends PMPackage> getToInstallPackages() {
		Set<PackageDescriptor> descriptors = manager.getAvailablePackages();
		java.util.List<PMPackage> list = new ArrayList<PMPackage>();
		for (PackageDescriptor descriptor : descriptors) {
			PMPackage pack = new PMPackage(descriptor);
			PackageDescriptor installed = manager.findInstalledVersion(descriptor);
			if (installed == null && manager.isAvailable(descriptor)) {
				list.add(pack);
				setStatus(pack, descriptor);
			}
		}
		return list;
	}

	public java.util.List<PMPackage> getParentPackages(PMPackage reference) {
		Set<PackageDescriptor> descriptors = manager.getAvailablePackages();
		java.util.List<PMPackage> list = new ArrayList<PMPackage>();
		for (PackageDescriptor descriptor : descriptors) {
			if (reference.getDependencies().contains(descriptor.getName())) {
				PMPackage pack = new PMPackage(descriptor);
				list.add(pack);
				setStatus(pack, descriptor);
			}
		}
		return list;
	}

	public java.util.List<PMPackage> getChildPackages(PMPackage reference) {
		Set<PackageDescriptor> descriptors = manager.getAvailablePackages();
		java.util.List<PMPackage> list = new ArrayList<PMPackage>();
		for (PackageDescriptor descriptor : descriptors) {
			if (descriptor.getDependencies().contains(reference.getPackageName())) {
				PMPackage pack = new PMPackage(descriptor);
				list.add(pack);
				setStatus(pack, descriptor);
			}
		}
		return list;
	}

	public void setStatus(PMPackage pack, PackageDescriptor descriptor) {
		PackageDescriptor installed = manager.findInstalledVersion(descriptor);
		if (installed != null) {
			if (manager.isAvailable(descriptor) && !installed.equals(descriptor)) {
				pack.setStatus(PMPackage.PMStatus.TOUPDATE);
			} else {
				pack.setStatus(PMPackage.PMStatus.TOUNINSTALL);
			}
		} else {
			if (manager.isAvailable(descriptor)) {
				pack.setStatus(PMPackage.PMStatus.TOINSTALL);
			} else {
				pack.setStatus(PMPackage.PMStatus.DEAD);
			}
		}
	}

	public void update(final PMPackage pack, final PMWorkspaceView view) {
		Thread t = new Thread(new Runnable() {

			public void run() {
				try {
					manager.install(Arrays.asList(new PackageDescriptor[] { pack.getDescriptor() }));
					view.updatePackages();
				} catch (CancelledException e) {
					e.printStackTrace();
				} catch (UnknownPackageTypeException e) {
					e.printStackTrace();
				}
			}

		});
		t.start();
	}

	public void update(final Collection<PMPackage> packs, final PMWorkspaceView view) {
		Thread t = new Thread(new Runnable() {

			public void run() {
				try {
					List<PackageDescriptor> pds = new ArrayList<PackageDescriptor>();
					for (PMPackage p : packs) {
						pds.add(p.getDescriptor());
					}
					manager.install(pds);
					view.updatePackages();
				} catch (CancelledException e) {
					e.printStackTrace();
				} catch (UnknownPackageTypeException e) {
					e.printStackTrace();
				}
			}

		});
		t.start();
	}

	public void remove(final PMPackage pack, final PMWorkspaceView view) {
		Thread t = new Thread(new Runnable() {

			public void run() {
				try {
					manager.uninstall(Arrays.asList(new PackageDescriptor[] { pack.getDescriptor() }));
					view.updatePackages();
				} catch (CancelledException e) {
					e.printStackTrace();
				}
			}

		});
		t.start();
	}

	public void remove(final Collection<PMPackage> packs, final PMWorkspaceView view) {
		Thread t = new Thread(new Runnable() {

			public void run() {
				try {
					List<PackageDescriptor> pds = new ArrayList<PackageDescriptor>();
					for (PMPackage p : packs) {
						pds.add(p.getDescriptor());
					}
					manager.uninstall(pds);
					view.updatePackages();
				} catch (CancelledException e) {
					e.printStackTrace();
				}
			}

		});
		t.start();
	}

	public String getQuery() {
		return query == null ? """" : query;
	}

	public void setQuery(String query) {
		this.query = query;
	}
}
"
PMFrame.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.IOException;

import javax.swing.JFrame;
import javax.swing.WindowConstants;

import org.deckfour.uitopia.ui.conf.ConfigurationSet;
import org.deckfour.uitopia.ui.conf.UIConfiguration;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.util.CommandLineArgumentList;

public class PMFrame extends JFrame {

	private static final long serialVersionUID = 3000058846006966241L;

	private static final String CONF_X = ""window_x"";
	private static final String CONF_Y = ""window_y"";
	private static final String CONF_WIDTH = ""window_width"";
	private static final String CONF_HEIGHT = ""window_height"";

	private final ConfigurationSet conf;

	private final PMController controller;

	public PMFrame() {
		controller = new PMController(Boot.VERBOSE);

		// register closing action..
		setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				exitApplication(true);
			}

			public void windowClosed(WindowEvent e) {
				windowClosing(e);
			}
		});
		addComponentListener(new ComponentAdapter() {
			public void componentMoved(ComponentEvent e) {
				saveWindowState();
			}

			public void componentResized(ComponentEvent e) {
				saveWindowState();
			}
		});
		// restore window position and size
		conf = UIConfiguration.master().getChild(this.getClass().getCanonicalName());
		restoreWindowState();
		// set up window contents
		setLayout(new BorderLayout());
		this.add(controller.getMainView(), BorderLayout.CENTER);
		setTitle(""ProM UITopia Package Manager"");
		// show frame
	}

	protected void saveWindowState() {
		Point p = getLocation();
		conf.setInteger(CONF_X, p.x);
		conf.setInteger(CONF_Y, p.y);
		conf.setInteger(CONF_WIDTH, getWidth());
		conf.setInteger(CONF_HEIGHT, getHeight());
	}

	protected void restoreWindowState() {
		int x = conf.getInteger(CONF_X, 10);
		int y = conf.getInteger(CONF_Y, 10);
		int width = conf.getInteger(CONF_WIDTH, 1024);
		int height = conf.getInteger(CONF_HEIGHT, 750);
		x = Math.max(0, x);
		y = Math.max(0, y);
		width = Math.min(width, Toolkit.getDefaultToolkit().getScreenSize().width);
		height = Math.min(height, Toolkit.getDefaultToolkit().getScreenSize().height);
		this.setLocation(x, y);
		this.setSize(width, height);
	}

	protected void exitApplication(boolean askUser) {
		saveConfig();
		System.exit(0);
	}

	public void saveConfig() {
		try {
			UIConfiguration.save();
		} catch (IOException e) {
			System.err.println(""ERROR: Could not save UITopia configuration!"");
			e.printStackTrace();
		}
	}

	@Bootable
	public Object main(CommandLineArgumentList args) {
		return this;
	}

	public static void main(String[] args) throws Exception {
		PMFrame frame = (PMFrame) Boot.boot(PMFrame.class, args);
		frame.setIconImage(ImageLoader.load(""prom_icon_32x32.png""));
		frame.setVisible(true);
	}

	public PMController getController() {
		return controller;
	}
}
"
PMIconCache.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.Image;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

import javax.swing.ImageIcon;

import org.processmining.framework.packages.PackageDescriptor;

public class PMIconCache {

	/*
	 * Cache the retrieved icons. Prevents unnecessary access over the network.
	 */
	private static Map<String, ImageIcon> iconMap = new HashMap<String, ImageIcon>();
	private static Map<String, ImageIcon> iconPreviewMap = new HashMap<String, ImageIcon>();

	public static ImageIcon getIcon(PackageDescriptor pack) {
		synchronized (iconMap) {
			/*
			 * Check whether icon already in cache
			 */
			if (iconMap.containsKey(pack.getLogoURL())) {
				/*
				 * Yes, it is. Return cached icon.
				 */
				return iconMap.get(pack.getLogoURL());
			}
			/*
			 * No, it is not. Retrieve icon and put in cache.
			 */
			System.out.println(""[PMIconCache] Retrieving icon for URL "" + pack.getLogoURL());
			ImageIcon icon = null;
			try {
				URL logoURL = new URL(pack.getLogoURL());
				icon = new ImageIcon(logoURL);
			} catch (MalformedURLException e) {
				System.err.println(""[PMIconCache] Retrieving icon for URL "" + pack.getLogoURL() + "" failed: ""
						+ e.getMessage());
			}
			iconMap.put(pack.getLogoURL(), icon);
			return icon;
		}
	}

	public static ImageIcon getIcon(PMPackage pack) throws MalformedURLException {
		return getIcon(pack.getDescriptor());
	}

	public static ImageIcon getIconPreview(PackageDescriptor pack) {
		synchronized (iconPreviewMap) {
			/*
			 * Check whether icon preview already in cache
			 */
			ImageIcon icon = iconPreviewMap.get(pack.getLogoURL());
			if (icon != null) {
				/*
				 * Yes, it is. Return cached icon preview.
				 */
				return icon;
			}
			/*
			 * No, it is not. Get icon preview and put in cache.
			 */
			Image image = getPreview(getIcon(pack), 150, 150);
			if (image != null) {
				icon = new ImageIcon(image);
				iconPreviewMap.put(pack.getLogoURL(), icon);
			}
			return icon;
		}
	}

	public static ImageIcon getIconPreview(PMPackage pack) {
		return getIconPreview(pack.getDescriptor());
	}

	public static Image getPreview(ImageIcon icon, int w, int h) {
		if (icon != null) {
			Image img = icon.getImage();
			int width = icon.getIconWidth();
			int height = icon.getIconHeight();
			float xScale = w / (float) width;
			float yScale = h / (float) height;
			float scale = (xScale < yScale ? xScale : yScale);
			return img.getScaledInstance((int) (width * scale), (int) (height * scale), Image.SCALE_SMOOTH);
		}
		return null;
	}
}
"
PMListener.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.zip.ZipException;

import javax.xml.parsers.ParserConfigurationException;

import org.deckfour.uitopia.ui.main.Overlayable;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageManager;
import org.processmining.framework.packages.UnknownPackageException;
import org.processmining.framework.packages.events.PackageManagerListener;
import org.processmining.framework.packages.impl.CancelledException;
import org.xml.sax.SAXException;

public class PMListener implements PackageManagerListener {

	private final Overlayable overlayable;

	public PMListener(Overlayable overlayable) {
		this.overlayable = overlayable;

	}

	private PMOverlay pmOverlay;

	public synchronized void exception(Throwable t) {
		if (t instanceof IOException) {
			exception(""I/O Exception: "" + t, true);
		} else if (t instanceof SAXException) {
			exception(""SAX Exception: "" + t, true);
		} else if (t instanceof ParserConfigurationException) {
			exception(""Parser Configuration Exception: "" + t, true);
		} else if (t instanceof UnknownPackageException) {
			exception(""Unknown Package Exception: "" + t, true);
		} else if (t instanceof MalformedURLException) {
			exception(""Malformed URL Exception: "" + t, true);
		} else if (t instanceof FileNotFoundException) {
			exception(""File Not Found Exception: "" + t, true);
		} else if (t instanceof CancelledException) {
			exception(""Cancelled Exception: "" + t, true);
		} else if (t instanceof SecurityException) {
			exception(""Security Exception: "" + t, true);
		} else if (t instanceof ZipException) {
			exception(""ZIP Exception: "" + t, true);
		} else {
			exception(t.getMessage());
		}
	}

	public synchronized void exception(String exception) {
		exception(exception, false);
	}

	private void exception(String exception, boolean hasPrefix) {
		pmOverlay.addText((hasPrefix ? """" : ""Error: "") + exception);	
	}
	
	public synchronized void startDownload(String packageName, URL url, PackageDescriptor pack) {
		pmOverlay.setPackage(pack);
		pmOverlay.addText(""Downloading: "" + packageName);
	}

	public synchronized void startInstall(String packageName, File folder, PackageDescriptor pack) {
		pmOverlay.setPackage(pack);
		pmOverlay.addText(""Installing: "" + packageName);
	}

	public synchronized void sessionComplete(boolean error) {
		PackageManager.getInstance().setCanceller(null);
		pmOverlay.finishedInstall(error);
		pmOverlay.getResultBlocking();
	}

	public synchronized void sessionStart() {
		pmOverlay = new PMOverlay(overlayable);
		PackageManager.getInstance().setCanceller(pmOverlay);
		pmOverlay.addText(""Started package manager session"");
		overlayable.showOverlay(pmOverlay);

	}

	public synchronized void finishedInstall(String packageName, File folder, PackageDescriptor pack) {
		pmOverlay.addText(""Succesfully installed: "" + packageName);
	}
}
"
PMMainView.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Color;

import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

import org.deckfour.uitopia.ui.conf.ConfigurationSet;
import org.deckfour.uitopia.ui.conf.UIConfiguration;
import org.deckfour.uitopia.ui.main.MainViewport;
import org.deckfour.uitopia.ui.main.Overlayable;
import org.deckfour.uitopia.ui.main.Viewable;
import org.deckfour.uitopia.ui.overlay.OverlayEnclosure;
import org.deckfour.uitopia.ui.overlay.TwoButtonOverlayDialog;
import org.processmining.framework.packages.PackageManager;

public class PMMainView extends JPanel implements Overlayable {

	private static final long serialVersionUID = -3555712585055859714L;

	public enum View {

		WORKSPACE();

		private Viewable viewable;

		public Viewable getViewable() {
			return viewable;
		}

		public void setViewable(Viewable viewable) {
			this.viewable = viewable;
		}

	}

	private final PMController controller;

	private final ConfigurationSet conf;
	//	private MainToolbar toolbar;
	private final MainViewport viewport;

	private View activeView;
	private final PMWorkspaceView workspaceView;

	private OverlayEnclosure overlay;
	private final PMListener listener;

	public PMMainView(PMController controller) {
		this.controller = controller;
		setOpaque(false);
		setBorder(BorderFactory.createEmptyBorder());
		setLayout(new BorderLayout());
		viewport = new MainViewport();
		//		toolbar = new MainToolbar(this);
		//		this.add(toolbar, BorderLayout.NORTH);
		this.add(viewport, BorderLayout.CENTER);
		JPanel blankView = new JPanel();
		blankView.setBackground(new Color(50, 50, 50));
		show(blankView);
		workspaceView = new PMWorkspaceView(controller);
		View.WORKSPACE.setViewable(workspaceView);
		conf = UIConfiguration.master().getChild(this.getClass().getCanonicalName());
		activeView = View.valueOf(conf.get(""activeView"", ""WORKSPACE""));
		showView(activeView);

		listener = new PMListener(this);
		PackageManager.getInstance().addListener(listener);
	}

	public PMController controller() {
		return controller;
	}

	public PMWorkspaceView getWorkspaceView() {
		return workspaceView;
	}

	public void showWorkspaceView() {
		if (!activeView.equals(View.WORKSPACE)) {
			showView(View.WORKSPACE);
		}
	}

	public void showWorkspaceView(PMPackage selected) {
		workspaceView.showPackage(selected);
		showWorkspaceView();
	}

	protected void showView(View view) {
		if (activeView.getViewable() != view.getViewable()) {
			activeView.getViewable().viewFocusLost();
		}
		if (view.equals(View.WORKSPACE)) {
			show(workspaceView);
		}
		conf.set(""activeView"", view.name());
		if (activeView.getViewable() != view.getViewable()) {
			view.getViewable().viewFocusGained();
		}
		activeView = view;
		//		toolbar.activateTab(view);
	}

	public void show(JComponent view) {
		viewport.setView(view);
	}

	public void showOverlay(JComponent overlay) {
		final OverlayEnclosure enclosure = new OverlayEnclosure(overlay, 1024, 768);
		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				//				toolbar.setEnabled(false);
				viewport.showOverlay(enclosure);
			}
		});
		this.overlay = enclosure;
	}

	public boolean showOverlayDialog(TwoButtonOverlayDialog dialog) {
		//		dialog.setMainView(this);
		//		showOverlay(dialog);
		//		return dialog.getResultBlocking();
		return true;
	}

	public void hideOverlay() {
		//		toolbar.setEnabled(true);
		viewport.hideOverlay();
	}

	public boolean hideOverlay(JComponent overlay) {
		if ((this.overlay != null) && (this.overlay.getEnclosed() == overlay)) {
			hideOverlay();
			return true;
		} else {
			return false;
		}
	}

}
"
PMMemoryView.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;

import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import org.deckfour.uitopia.ui.components.ImageLozengeButton;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.util.OsUtil;

import com.fluxicon.slickerbox.components.RoundedPanel;

public class PMMemoryView extends RoundedPanel implements ActionListener {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2483996283422006055L;

	/*
	 * Get whether we are running in 64 bit mode, this allows allocating more
	 * than 1300 MB of memory.
	 */
	private static boolean is64bit = OsUtil.is64Bit();
	/*
	 * Get the available memory.
	 */
	private static long mem = OsUtil.getPhysicalMemory() / (1024 * 1024);

	/*
	 * Start with using 1 GB of memory.
	 */
	private static MemoryOption selectedMem = MemoryOption.XMX1G;
	private static MemoryOption oldSelectedMem = MemoryOption.XMX1G;

	private PMController controller;

	private enum MemoryOption implements ActionListener {
		XMX1G(""1G"", true), // 1 GB
		XMX1300M(""1300M"", true), // 1300 MB, about the limit in 32 bit mode
		XMX2G(""2G"", is64bit && mem >= 2 * 1024), // 2 GB
		XMX3G(""3G"", is64bit && mem >= 3 * 1024), // 3 GB
		XMX4G(""4G"", is64bit && mem >= 4 * 1024), // 4 GB
		XMX6G(""6G"", is64bit && mem >= 6 * 1024), // 6 GB
		XMX8G(""8G"", is64bit && mem >= 8 * 1024), // 8 GB
		XMX12G(""12G"", is64bit && mem >= 12 * 1024), // 12 GB
		XMX16G(""16G"", is64bit && mem >= 16 * 1024); // 16 GB

		/*
		 * Text to be added to ""-Xmx""
		 */
		private String size;
		/*
		 * Whether this memory option is available on this computer.
		 */
		private boolean isAvailable;
		/*
		 * Button to show when this option is selected.
		 */
		private ImageLozengeButton selected;
		/*
		 * Button to show when this option is not selected.
		 */
		private ImageLozengeButton notSelected;

		/*
		 * Creates a memory option.
		 */
		private MemoryOption(String size, boolean isAllowed) {
			this.size = size;
			this.isAvailable = isAllowed;
		}

		/*
		 * Returns the string to add to ""-Xmx"".
		 */
		public String toString() {
			return size;
		}

		/*
		 * Returns the string to put on the buttons.
		 */
		public String toDisplay() {
			return size.replace(""G"", "" GB"").replace(""M"", "" MB"");
		}

		/*
		 * Returns whether this option is available.
		 */
		public boolean isAvailable() {
			return isAvailable;
		}

		/*
		 * Returns the current shown button.
		 */
		public JButton getButton(boolean isSelected) {
			return isSelected ? selected : notSelected;
		}

		/*
		 * Initialize this memory option. Creates the buttons, sets the tool
		 * tip, and the action listener.
		 */
		public void init(ActionListener actionListener) {
			selected = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""), toDisplay());
			selected.setEnabled(false);
			notSelected = new ImageLozengeButton(ImageLoader.load(""action_30x30_black.png""), toDisplay());
			notSelected.setToolTipText(""Use "" + toDisplay() + "" of memory when running ProM"");
			notSelected.addActionListener(actionListener);
		}

		/*
		 * Act on a button being selected.
		 * 
		 * @see
		 * java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent
		 * )
		 */
		public void actionPerformed(ActionEvent e) {
			/*
			 * Check whether my button was selected.
			 */
			if (e.getSource() == notSelected) {
				/*
				 * Yes, it was. Set my memory size.
				 */
				selectedMem = this;
			}
		}
	};

	/*
	 * Creates the memory view panel.
	 */
	public PMMemoryView(PMController controller) {
		super(20, 5, 0);
		this.controller = controller;
		setBackground(new Color(160, 160, 160));
		setLayout(new BorderLayout());
		try {
			/*
			 * Try to read the current memory option from file, and set the
			 * default accordingly.
			 */
			String version = Boot.PROM_VERSION.replaceAll(""\\."", """");
			FileReader reader = new FileReader(""ProM"" + version + "".l4j.ini"");
			char[] a = new char[10];
			reader.read(a);
			reader.close();
			String b = String.valueOf(a);
			for (MemoryOption size : MemoryOption.values()) {
				if (b.startsWith(""-Xmx"" + size)) {
					/*
					 * Found a match. Set this option as default.
					 */
					selectedMem = size;
					continue;
				}
			}
		} catch (FileNotFoundException e) {
		} catch (IOException e) {
		}
		setupUI();
		update();
	}

	/*
	 * Sets up the buttons.
	 */
	private void setupUI() {
		/*
		 * Initialize all buttons.
		 */
		for (MemoryOption size : MemoryOption.values()) {
			size.init(this);
		}
	}

	/*
	 * A button was pressed. Check every option, and then update.
	 */
	public void actionPerformed(ActionEvent e) {
		for (MemoryOption size : MemoryOption.values()) {
			/*
			 * Check whether the button belongs to this option.
			 */
			size.actionPerformed(e);
		}
		update();
	}

	/*
	 * Update the memory view.
	 */
	private void update() {
		updateFiles();
		double layoutSize[][] = { { TableLayoutConstants.FILL, TableLayoutConstants.FILL, TableLayoutConstants.FILL, TableLayoutConstants.FILL }, { 30, TableLayoutConstants.FILL } };
		setLayout(new TableLayout(layoutSize));
		
		/*
		 * Create new buttonPanel.
		 */
		JPanel buttonPanel = new RoundedPanel(20, 5, 0);
		buttonPanel.setBackground(new Color(80, 80, 80));
		buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));

		for (MemoryOption size : MemoryOption.values()) {
			/*
			 * Only add button if available.
			 */
			if (size.isAvailable()) {
				/*
				 * Use selected button if selected, not-selected button
				 * otherwise.
				 */
				buttonPanel.add(size.getButton(selectedMem == size));
			}
		}
		/*
		 * Refresh with new button panel.
		 */
		removeAll();
		add(new JLabel(""Manage memory setting""), ""0, 0, 1, 0"");
		add(buttonPanel, ""0, 1, 1, 1"");

		JPanel gaButtonPanel = new RoundedPanel(20, 5, 0);
		gaButtonPanel.setBackground(new Color(80, 80, 80));
		gaButtonPanel.setLayout(new BoxLayout(gaButtonPanel, BoxLayout.X_AXIS));

		final ImageLozengeButton enableGAButton = new ImageLozengeButton(ImageLoader.load(""action_30x30_black.png""), ""Enable"");
		final ImageLozengeButton disableGAButton = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""), ""Disable"");
		if (Preferences.userNodeForPackage(Boot.class).get(Boot.TRACKING_BY_GA_ALLOWED, ""false"").equals(""true"")) {
			enableGAButton.setEnabled(false);
			disableGAButton.setEnabled(true);
		} else {
			enableGAButton.setEnabled(true);
			disableGAButton.setEnabled(false);
		}
		enableGAButton.setToolTipText(""Select this button to enable tracking with GA"");
		disableGAButton.setToolTipText(""Select this button to disable tracking with GA"");
		enableGAButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				Preferences.userNodeForPackage(Boot.class).put(Boot.TRACKING_BY_GA_ALLOWED, ""true"");
				enableGAButton.setEnabled(false);
				disableGAButton.setEnabled(true);
			}			
		});
		disableGAButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				Preferences.userNodeForPackage(Boot.class).put(Boot.TRACKING_BY_GA_ALLOWED, ""false"");
				enableGAButton.setEnabled(true);
				disableGAButton.setEnabled(false);
			}			
		});
		gaButtonPanel.add(enableGAButton);
		gaButtonPanel.add(disableGAButton);
		add(new JLabel(""Manage Google Analytics (GA) setting""), ""2, 0"");
		add(gaButtonPanel, ""2, 1"");
		
		JPanel cacheButtonPanel = new RoundedPanel(20, 5, 0);
		cacheButtonPanel.setBackground(new Color(80, 80, 80));
		cacheButtonPanel.setLayout(new BoxLayout(cacheButtonPanel, BoxLayout.X_AXIS));

		ImageLozengeButton cleanCacheButton = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
				""Clear"", new Color(140, 140, 140), new Color(40, 140, 40), 2);
		cleanCacheButton.setToolTipText(PMTooltips.REMOVEBUTTON);
		cleanCacheButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				cleanCache();
			}
		});

		cacheButtonPanel.add(cleanCacheButton);
		add(new JLabel(""Manage Plugin Cache""), ""3, 0"");
		add(cacheButtonPanel, ""3, 1"");

		revalidate();
	}

	protected void cleanCache() {
		try {
			controller.cleanPackageCache();
		} catch (BackingStoreException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/*
	 * Updates the necessary files with the new memory option.
	 */
	private void updateFiles() {
		if (oldSelectedMem == selectedMem) {
			return;
		}
		String version = Boot.PROM_VERSION.replaceAll(""\\."", """");
		if (OsUtil.isRunningWindows()) {
			/*
			 * Windows. Need to update ini file and bat file.
			 */
			if (!updateIniFile() || !updateBatFile()) {
				/*
				 * Something failed. Possibly, the PM was not run in
				 * Administrator mode.
				 */
				JOptionPane
						.showMessageDialog(
								null,
								""Unable to set memory limit (-Xmx""
										+ selectedMem
										+ "") in ProM""
										+ version
										+ "".l4j.ini and/or ProM""
										+ version
										+ "".bat file.\nPlease run the Package Manager as administrator, or set the memory limit manually."");
				selectedMem = oldSelectedMem;
				return;
			}
		} else if (OsUtil.isRunningLinux() || OsUtil.isRunningUnix()) {
			/*
			 * Linux or UNIX. Need to update sh file (and init file for reading
			 * default option next time).
			 */
			if (!updateIniFile() || !updateShFile()) {
				JOptionPane.showMessageDialog(null, ""Unable to set memory limit (-Xmx"" + selectedMem + "") in ProM""
						+ version + "".l4j.ini and/or ProM"" + version
						+ "".sh file.\nPlease set the memory limit manually."");
				selectedMem = oldSelectedMem;
				return;
			}
		}
		/*
		 * No MAC support (yet), sorry.
		 */
		oldSelectedMem = selectedMem;
	}

	private boolean updateFile(String ext) {
		try {
			String version = Boot.PROM_VERSION.replaceAll(""\\."", """");
			Path path = Paths.get(""ProM"" + version + ext);
			Charset charset = StandardCharsets.UTF_8;
			String content = new String(Files.readAllBytes(path), charset);
			String oldMem = ""-Xmx"" + oldSelectedMem;
			String newMem = ""-Xmx"" + selectedMem;
			content = content.replaceAll(oldMem, newMem);
			Files.write(path, content.getBytes(charset));
			return true;
		} catch (FileNotFoundException e) {
			return false;
		} catch (UnsupportedEncodingException e) {
			return false;
		} catch (IOException e) {
			return false;
		}
	}

	private boolean updateIniFile() {
		return updateFile("".l4j.ini"");
	}

	private boolean updateBatFile() {
		return updateFile("".bat"");
	}

	private boolean updateShFile() {
		return updateFile("".sh"");
	}

}
"
PMOverlay.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Image;
import java.util.Timer;
import java.util.TimerTask;

import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.ScrollPaneConstants;

import org.deckfour.uitopia.ui.main.Overlayable;
import org.deckfour.uitopia.ui.overlay.TwoButtonOverlayDialog;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageManager;

import com.fluxicon.slickerbox.factory.SlickerDecorator;

public class PMOverlay extends TwoButtonOverlayDialog implements PackageManager.Canceller {

	/**
	 * Timeout in seconds after which dialog disappears
	 */
	private final static int TIMEOUT = 10;

	private static final long serialVersionUID = 4721480656622194553L;
	private final JTextArea log;
	private final JLabel label = new JLabel("""");
	private final JLabel iconLabel = new JLabel("""");
	private boolean cancelled;

	public PMOverlay(Overlayable view) {
		super(view, ""External Packages Required"", ""Cancel"", ""  OK  "", null);

		JPanel mainPanel = new JPanel(new BorderLayout());
		mainPanel.setOpaque(false);
		mainPanel.setLayout(new BorderLayout());
		mainPanel.setBorder(BorderFactory.createEmptyBorder(30, 30, 30, 30));

		label.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
		iconLabel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

		log = new JTextArea();
		log.setOpaque(false);
		log.setBorder(BorderFactory.createEmptyBorder());
		log.setLineWrap(true);
		log.setWrapStyleWord(true);

		JScrollPane scrollpane = new JScrollPane(log);
		scrollpane.setOpaque(false);
		scrollpane.getViewport().setOpaque(false);
		scrollpane.setBorder(BorderFactory.createEmptyBorder());
		scrollpane.setViewportBorder(BorderFactory.createEmptyBorder());
		scrollpane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scrollpane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		SlickerDecorator.instance().decorate(scrollpane.getVerticalScrollBar(), new Color(0, 0, 0, 0),
				new Color(20, 20, 20), new Color(60, 60, 60));
		scrollpane.getVerticalScrollBar().setOpaque(false);

		scrollpane.setPreferredSize(new Dimension(800, 100));
		scrollpane.setMinimumSize(new Dimension(0, 100));
		scrollpane.setSize(new Dimension(800, 100));

		JPanel southPanel = new JPanel(new BorderLayout());
		southPanel.setOpaque(false);
		southPanel.setBorder(BorderFactory.createEmptyBorder());

		//		JCheckBox check = new JCheckBox(
		//				""Automatically install new versions of packages (requires an internet connection (xx))"");
		//		check.setOpaque(false);
		//		check.setSelected(PackageManager.getInstance().doAutoUpdate());
		//		check.addItemListener(new ItemListener() {
		//
		//			public void itemStateChanged(ItemEvent e) {
		//				if (e.getStateChange() == ItemEvent.DESELECTED) {
		//					PackageManager.getInstance().setAutoUpdate(false);
		//				} else if (e.getStateChange() == ItemEvent.SELECTED) {
		//					PackageManager.getInstance().setAutoUpdate(true);
		//				}
		//			}
		//		});

		southPanel.add(scrollpane, BorderLayout.CENTER);
		//		southPanel.add(check, BorderLayout.SOUTH);

		mainPanel.add(label, BorderLayout.CENTER);
		mainPanel.add(southPanel, BorderLayout.SOUTH);
		mainPanel.add(iconLabel, BorderLayout.EAST);

		setPayload(mainPanel);
		cancelled = false;
		getCancelButton().setEnabled(true);
		getOKButton().setEnabled(false);
	}

	public void setPackage(PackageDescriptor pack) {
		label.setText(pack.toHTML());
		ImageIcon icon = PMIconCache.getIcon(pack);
		if (icon != null) {
			Image img = icon.getImage();
			int m = icon.getIconHeight() > icon.getIconWidth() ? 200 : -200;
			iconLabel.setIcon(new ImageIcon(img.getScaledInstance(-m, m, Image.SCALE_SMOOTH)));
		} else {
			iconLabel.setIcon(null);
			return;
		}
	}

	public void addText(String text) {
		log.append(text);
		log.append(""\n"");
		log.setCaretPosition(log.getText().length());
	}

	public void clear() {
		log.setText("""");
	}

	public void finishedInstall(boolean error) {
		getOKButton().setEnabled(true);
		getCancelButton().setEnabled(false);
		if (error) {
			// HV: Do not auto-close on an error, as the error message will get lost.
			// Wait for the user to close the overlay.
			//close(true);

			// Indicate that an error has occurred.
			addText(""An error has occurred. Please select OK to continue."");
			log.setForeground(new Color(90, 0, 0));
		} else {
			final String message = ""Closing in "" + TIMEOUT + "" seconds."";
			log.append(message);
			final Timer t = new Timer();
			t.schedule(new TimerTask() {

				private int remaining = TIMEOUT - 1;
				private int lastlength = message.length();

				public void run() {
					if (remaining == 0) {
						cancel();
						return;
					}
					String s = ""Closing in "" + (remaining--) + "" seconds."";
					int l = log.getText().length();
					log.replaceRange(s, l - lastlength, l);
					lastlength = s.length();
				}

			}, 1000L, 1000L);
			t.schedule(new TimerTask() {

				public void run() {
					close(true);
				}

			}, 1000L * TIMEOUT);
		}

	}

	public boolean isCancelled() {
		return cancelled;
	}

	@Override
	public void close(boolean okayed) {
		if (!okayed) {
			cancelled = true;
		}
		super.close(okayed);
	}

}
"
PMPackage.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.util.Set;

import org.processmining.framework.packages.PackageDescriptor;

public class PMPackage {

	public static enum PMStatus {
		TOUNINSTALL, TOUPDATE, TOINSTALL, DEAD
	};

	private final PackageDescriptor descriptor;
	private boolean isFavorite;
	private PMStatus status;

	public PMPackage(PackageDescriptor descriptor) {
		this.descriptor = descriptor;
		isFavorite = false;
		status = PMStatus.TOINSTALL;
	}

	public PackageDescriptor getDescriptor() {
		return descriptor;
	}

	public PMStatus getStatus() {
		return status;
	}

	public void setStatus(PMStatus status) {
		this.status = status;
	}

	public Set<String> getDependencies() {
		return descriptor.getDependencies();
	}

	public String getPackageName() {
		return descriptor.getName();
	}

	public String getAuthorName() {
		return descriptor.getAuthor();
	}

	public String getDescription() {
		return descriptor.getDescription();
	}

	public String getVersion() {
		return ""Version "" + descriptor.getVersion();
	}

	public String getLicense() {
		return descriptor.getLicense();
	}
	
	public boolean isFavorite() {
		return isFavorite;
	}

	public void setFavorite(boolean f) {
		isFavorite = f;
	}

//	public Image getPreview(int w, int h) {
//		try {
//			ImageIcon icon = PMIconCache.getIcon(this);
//			Image img = icon.getImage();
//			int width = icon.getIconWidth();
//			int height = icon.getIconHeight();
//			float xScale = w / (float) width;
//			float yScale = h / (float) height;
//			float scale = (xScale < yScale ? xScale : yScale);
//			return img.getScaledInstance((int) (width * scale), (int) (height * scale), Image.SCALE_SMOOTH);
//		} catch (MalformedURLException e) {
//		}
//		return null;
//	}
//
	public boolean equals(Object o) {
		if (o instanceof PMPackage) {
			return ((PMPackage) o).descriptor.equals(descriptor);
		} else {
			return false;
		}
	}

	public int hashCode() {
		return descriptor.hashCode();
	}

}
"
PMPackageListBrowser.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.ListSelectionModel;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.deckfour.uitopia.ui.components.ImageLozengeButton;
import org.deckfour.uitopia.ui.components.ImageRadioButton;
import org.deckfour.uitopia.ui.util.ArrangementHelper;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.framework.util.OsUtil;

import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.factory.SlickerDecorator;

public class PMPackageListBrowser extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8111058383691281752L;

	public enum Type {
		TOUNINSTALL, TOUPDATE, TOINSTALL, SELECTION
	}

	private static final int VIEWPORT_WIDTH = 500;

	private final PMController controller;
	private List<? extends PMPackage> packages = new ArrayList<PMPackage>();

	private final Type type;

	private PMPackageListModel listModel;
	private JList<? extends PMPackage> packageList;
	private JComponent viewport;
	private JLabel header;

	private JRadioButton sortByPackageName;
	private JRadioButton sortByAuthorName;

	private PMPackageView pmPackageView = null;

	private boolean is64bit = OsUtil.is64Bit();
	private long mem = OsUtil.getPhysicalMemory() / (1024 * 1024);
	private int selectedMem = (is64bit ? 2 : 1);
	private int oldSelectedMem = 1;

	private RoundedPanel memPanel = new RoundedPanel(100, 0, 0);
	private ImageLozengeButton button1gbSelected = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
			""1 GB"");
	private ImageLozengeButton button2gbSelected = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
			""2 GB"");
	private ImageLozengeButton button4gbSelected = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
			""4 GB"");
	private ImageLozengeButton button8gbSelected = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
			""4 GB"");
	private ImageLozengeButton button16gbSelected = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
			""4 GB"");
	private ImageLozengeButton button1gbNotSelected = new ImageLozengeButton(
			ImageLoader.load(""action_30x30_black.png""), ""1 GB"");
	private ImageLozengeButton button2gbNotSelected = new ImageLozengeButton(
			ImageLoader.load(""action_30x30_black.png""), ""2 GB"");
	private ImageLozengeButton button4gbNotSelected = new ImageLozengeButton(
			ImageLoader.load(""action_30x30_black.png""), ""4 GB"");
	private ImageLozengeButton button8gbNotSelected = new ImageLozengeButton(
			ImageLoader.load(""action_30x30_black.png""), ""8 GB"");
	private ImageLozengeButton button16gbNotSelected = new ImageLozengeButton(
			ImageLoader.load(""action_30x30_black.png""), ""16 GB"");

	public PMPackageListBrowser(PMController controller, Type type) {
		this.controller = controller;
		this.type = type;
		setupUI();
		updateData();
	}

	public boolean isEmpty() {
		return packages.isEmpty();
	}

	public void selectPackage(String name) {
		for (int i = 0; i < listModel.getSize(); i++) {
			if (((PMPackage) listModel.getElementAt(i)).getPackageName().equals(name)) {
				packageList.setSelectedIndex(i);
				packageList.ensureIndexIsVisible(i);
				return;
			}
		}
	}

	public void setSelectionContent(PMPackage reference, boolean showParents) {
		if (showParents) {
			packages = controller.getParentPackages(reference);
		} else {
			packages = controller.getChildPackages(reference);
		}
		String rel = showParents ? ""Parents of "" : ""Children of "";
		header.setText(rel + reference.getPackageName());
	}

	public void showPackage(PMPackage res) {
		if (res == null) {
			packageList.setSelectedIndex(0);
			packageList.ensureIndexIsVisible(0);
			return;
		}
		for (int i = 0; i < listModel.getSize(); i++) {
			if (listModel.getElementAt(i).equals(res)) {
				packageList.setSelectedIndex(i);
				packageList.ensureIndexIsVisible(i);
				break;
			}
		}
	}

	private void setupUI() {
		setOpaque(true);
		setBackground(new Color(180, 180, 180));
		setBorder(BorderFactory.createEmptyBorder());
		JPanel browser = new JPanel();
		browser.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
		browser.setLayout(new BorderLayout());
		browser.setOpaque(true);
		browser.setBackground(new Color(180, 180, 180));
		listModel = new PMPackageListModel(packages);
		packageList = new JList(listModel);
		packageList.setBackground(new Color(160, 160, 160));
		packageList.setCellRenderer(new PMPackageListCellRenderer());
		packageList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		packageList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent e) {
				updateViewport();
			}
		});
		sortByPackageName = new ImageRadioButton(ImageLoader.load(""sortByPackage_27x20_white.png""));
		sortByAuthorName = new ImageRadioButton(ImageLoader.load(""sortByAuthor_27x20_white.png""));
		ButtonGroup sortGroup = new ButtonGroup();
		sortGroup.add(sortByPackageName);
		sortGroup.add(sortByAuthorName);
		sortByPackageName.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				SwingUtilities.invokeLater(new Runnable() {
					public void run() {
						sortList(true);
					}
				});
			}
		});
		sortByPackageName.setToolTipText(PMTooltips.SORTBYPACKAGENAME);
		sortByAuthorName.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				SwingUtilities.invokeLater(new Runnable() {
					public void run() {
						sortList(true);
					}
				});
			}
		});
		sortByAuthorName.setToolTipText(PMTooltips.SORTBYAUTHORNAME);
		sortByPackageName.setSelected(true);
		// assemble header
		header = new JLabel(""No selection to show"");
		header.setOpaque(false);
		header.setFont(header.getFont().deriveFont(16f));
		header.setForeground(new Color(60, 60, 60));
		// assemble sort panel
		JPanel sortPanel = new JPanel();
		sortPanel.setMinimumSize(new Dimension(180, 40));
		sortPanel.setMaximumSize(new Dimension(20000, 40));
		sortPanel.setPreferredSize(new Dimension(200, 40));
		sortPanel.setOpaque(false);
		sortPanel.setBorder(BorderFactory.createEmptyBorder());
		sortPanel.setLayout(new BoxLayout(sortPanel, BoxLayout.X_AXIS));
		JLabel sortLabel = new JLabel(""sort by"");
		sortLabel.setFont(sortLabel.getFont().deriveFont(10f));
		sortLabel.setForeground(new Color(80, 80, 80));
		sortPanel.add(sortLabel);
		sortPanel.add(Box.createHorizontalStrut(10));
		sortPanel.add(sortByPackageName);
		sortPanel.add(Box.createHorizontalStrut(5));
		sortPanel.add(sortByAuthorName);
		sortPanel.add(Box.createHorizontalGlue());
		// assemble list view
		JScrollPane listScrollPane = new JScrollPane(packageList);
		listScrollPane.setBorder(BorderFactory.createEmptyBorder());
		SlickerDecorator.instance().decorate(listScrollPane, new Color(180, 180, 180), new Color(40, 40, 40),
				new Color(100, 100, 100));
		listScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		listScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		listScrollPane.setViewportBorder(BorderFactory.createLineBorder(new Color(100, 100, 100), 2));
		// top panel
		JPanel topPanel = new JPanel();
		topPanel.setMinimumSize(new Dimension(180, 60));
		topPanel.setMaximumSize(new Dimension(20000, 60));
		topPanel.setPreferredSize(new Dimension(200, 60));
		topPanel.setOpaque(false);
		topPanel.setBorder(BorderFactory.createEmptyBorder());
		topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
		// assemble browser view
		if (type.equals(Type.SELECTION)) {
			topPanel.add(ArrangementHelper.pushLeft(header));
			topPanel.add(sortPanel);
			browser.add(topPanel, BorderLayout.NORTH);
		} else {
			browser.add(sortPanel, BorderLayout.NORTH);
		}
		browser.add(listScrollPane, BorderLayout.CENTER);
		// assemble all
		viewport = new JPanel();
		viewport.setOpaque(false);
		viewport.setLayout(new BorderLayout());
		viewport.setBorder(BorderFactory.createEmptyBorder(40, 10, 5, 5));
		viewport.setMinimumSize(new Dimension(VIEWPORT_WIDTH, 10));
		viewport.setMaximumSize(new Dimension(VIEWPORT_WIDTH, 10000));
		viewport.setPreferredSize(new Dimension(VIEWPORT_WIDTH, 400));
		setLayout(new BorderLayout());
		this.add(browser, BorderLayout.CENTER);
		this.add(viewport, BorderLayout.EAST);
	}

	private void sortList(boolean keepSelection) {
		final Object selected = packageList.getSelectedValue();
		if (sortByPackageName.isSelected()) {
			listModel.sortByPackageName();
		} else if (sortByAuthorName.isSelected()) {
			listModel.sortByAuthorName();
		}
		if (keepSelection) {
			for (int i = 0; i < listModel.getSize(); i++) {
				if (listModel.getElementAt(i).equals(selected)) {
					packageList.setSelectedIndex(i);
					packageList.ensureIndexIsVisible(i);
					break;
				}
			}
		}
		revalidate();
		repaint();
	}

	public void updateData() {
		if (type.equals(Type.TOUNINSTALL)) {
			packages = controller.getToUninstallPackages();
		} else if (type.equals(Type.TOUPDATE)) {
			packages = controller.getToUpdatePackages();
		} else if (type.equals(Type.TOINSTALL)) {
			packages = controller.getToInstallPackages();
		}

		// Filter packages to keep only those that match the given query
		String query = controller.getQuery();
		List<PMPackage> filteredPackages = new ArrayList<PMPackage>();
		if (query.isEmpty()) {
			filteredPackages.addAll(packages);
		} else {
			for (PMPackage pack : packages) {
				if (pack.getAuthorName().toLowerCase().matches(query) || pack.getPackageName().toLowerCase().matches(query)
						|| pack.getDescription().toLowerCase().matches(query) || pack.getVersion().toLowerCase().matches(query)
						|| pack.getDescriptor().getOrganisation().toLowerCase().matches(query)
						|| pack.getDescriptor().getAuthor().toLowerCase().matches(query)
						|| pack.getDescriptor().getDescription().toLowerCase().matches(query)
						|| pack.getDescriptor().getMaintainer().toLowerCase().matches(query)
						|| pack.getDescriptor().getLicense().toLowerCase().matches(query)
						|| pack.getDescriptor().getName().toLowerCase().matches(query)
						|| pack.getDescriptor().getKeywords().toLowerCase().matches(query)) {
					filteredPackages.add(pack);
				}
			}
		}
		listModel = new PMPackageListModel(filteredPackages);
		final Object selected = packageList.getSelectedValue();
		int index = packageList.getSelectedIndex();

		packageList.setModel(listModel);
		sortList(false);
		packageList.setSelectedValue(selected, true);
		if (packageList.isSelectionEmpty()) {
			int i = Math.max(0, Math.min(index, filteredPackages.size() - 1));
			packageList.setSelectedIndex(i);
			packageList.ensureIndexIsVisible(i);
		}

	}

	private void updateViewport() {
		viewport.removeAll();
		List<? extends PMPackage> selected = packageList.getSelectedValuesList();
		Collection<PMPackage> selectedPacks = new HashSet<PMPackage>();
		for (int i = 0; i < selected.size(); i++) {
			selectedPacks.add(selected.get(i));
		}
		if (!selectedPacks.isEmpty()) {
			pmPackageView = new PMPackageView(selectedPacks, controller);
			viewport.add(pmPackageView, BorderLayout.CENTER);
		} else {
			viewport.add(new JLabel(""No packages selected""), BorderLayout.CENTER);
		}
		viewport.revalidate();
	}

	public PMPackageView getPackageView() {
		return pmPackageView;
	}
}
"
PMPackageListCellRenderer.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.RenderingHints;

import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JList;
import javax.swing.ListCellRenderer;

import org.deckfour.uitopia.ui.util.ImageLoader;

public class PMPackageListCellRenderer extends JComponent implements ListCellRenderer {

	private static final long serialVersionUID = 413965516084559714L;

	private static final Color COLOR_PASSIVE_TOP = new Color(160, 160, 160);
	private static final Color COLOR_PASSIVE_BOTTOM = new Color(150, 150, 150);
	private static final Color COLOR_PASSIVE_TEXT = new Color(30, 30, 30);
	private static final Color COLOR_ACTIVE_TOP_G = new Color(80, 160, 80);
	private static final Color COLOR_ACTIVE_BOTTOM_G = new Color(40, 120, 40);
	private static final Color COLOR_ACTIVE_TOP_Y = new Color(160, 160, 80);
	private static final Color COLOR_ACTIVE_BOTTOM_Y = new Color(120, 120, 40);
	private static final Color COLOR_ACTIVE_TOP_R = new Color(160, 80, 80);
	private static final Color COLOR_ACTIVE_BOTTOM_R = new Color(120, 40, 40);
	private static final Color COLOR_ACTIVE_TEXT = new Color(0, 0, 0);
	private static final Color COLOR_DEAD_TOP = new Color(80, 80, 80);
	private static final Color COLOR_DEAD_BOTTOM = new Color(40, 40, 40);
	private static final Color COLOR_DEAD_TEXT = new Color(160, 160, 160);
	private static final Color COLOR_TRANSPARENT = new Color(0, 0, 0, 0);

	private static final Image favoriteIcon = ImageLoader.load(""favorite_30x30.png"");

	private static final int HEIGHT = 60;

	private PMPackage pack;
	private boolean selected;

	private boolean paintArrow = true;

	public PMPackageListCellRenderer() {
		this(true);
	}

	public PMPackageListCellRenderer(boolean paintArrow) {
		this.paintArrow = paintArrow;
		setOpaque(true);
		setBorder(BorderFactory.createEmptyBorder());
		setMinimumSize(new Dimension(100, HEIGHT));
		setMaximumSize(new Dimension(1000, HEIGHT));
		setPreferredSize(new Dimension(250, HEIGHT));
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
	 */
	@Override
	protected void paintComponent(Graphics g) {
		int height = getHeight();
		int width = getWidth();
		Graphics2D g2d = (Graphics2D) g.create();
		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		// paint background
		if (selected) {
			switch (pack.getStatus()) {
				case TOUNINSTALL :
					g2d.setPaint(new GradientPaint(0, 0, COLOR_ACTIVE_TOP_G, 0, height, COLOR_ACTIVE_BOTTOM_G));
					break;
				case TOUPDATE :
					g2d.setPaint(new GradientPaint(0, 0, COLOR_ACTIVE_TOP_Y, 0, height, COLOR_ACTIVE_BOTTOM_Y));
					break;
				case TOINSTALL :
					g2d.setPaint(new GradientPaint(0, 0, COLOR_ACTIVE_TOP_R, 0, height, COLOR_ACTIVE_BOTTOM_R));
					break;
				case DEAD :
					g2d.setPaint(new GradientPaint(0, 0, COLOR_DEAD_TOP, 0, height, COLOR_DEAD_BOTTOM));
					break;
			}
		} else {
			switch (pack.getStatus()) {
				case DEAD :
					g2d.setPaint(new GradientPaint(0, 0, COLOR_DEAD_TOP, 0, height, COLOR_DEAD_BOTTOM));
					break;
				default :
					g2d.setPaint(new GradientPaint(0, 0, COLOR_PASSIVE_TOP, 0, height, COLOR_PASSIVE_BOTTOM));
					break;
			}
		}
		g2d.fillRect(0, 0, width, height);
		// paint icon
		//		Image icon = pack.getPreview(10, 10);
		//		int iconX = 10;
		//		int iconY = (height - icon.getHeight(null)) / 2;
		//		g2d.drawImage(icon, iconX, iconY, null);
		// paint text
		if (selected) {
			switch (pack.getStatus()) {
				case DEAD :
					g2d.setPaint(new GradientPaint(width - 20, 0, COLOR_DEAD_TEXT, width, 0, COLOR_TRANSPARENT));
					break;
				default :
					g2d.setPaint(new GradientPaint(width - 20, 0, COLOR_ACTIVE_TEXT, width, 0, COLOR_TRANSPARENT));
					break;
			}
		} else {
			switch (pack.getStatus()) {
				case DEAD :
					g2d.setPaint(new GradientPaint(width - 20, 0, COLOR_DEAD_TEXT, width, 0, COLOR_TRANSPARENT));
					break;
				default :
					g2d.setPaint(new GradientPaint(width - 20, 0, COLOR_PASSIVE_TEXT, width, 0, COLOR_TRANSPARENT));
					break;
			}
		}
		g2d.setFont(g2d.getFont().deriveFont(13f));
		int textX = 20; // + icon.getWidth(null);
		int textY = HEIGHT / 2;
		g2d.drawString(pack.getPackageName(), textX, textY - 6);
		g2d.setFont(g2d.getFont().deriveFont(10f));
		g2d.drawString(pack.getAuthorName(), textX, textY + 10);
		g2d.drawString(pack.getVersion(), textX, textY + 22);
		if (pack.isFavorite()) {
			int fwidth = favoriteIcon.getWidth(null);
			int fheight = favoriteIcon.getHeight(null);
			if (!selected) {
				g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.6f));
			} else {
				g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.8f));
			}
			int posX = width - fwidth - 20;
			if (paintArrow) {
				posX -= 20;
			}
			g2d.drawImage(favoriteIcon, posX, (height - fheight) / 2, null);
		}
		if (selected && paintArrow) {
			g2d.setColor(new Color(10, 10, 10, 200));
			int yMid = height / 2;
			int x[] = { width - 30, width - 10, width - 30, width - 28 };
			int y[] = { yMid - 10, yMid, yMid + 10, yMid };
			g2d.fillPolygon(x, y, 4);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * javax.swing.ListCellRenderer#getListCellRendererComponent(javax.swing
	 * .JList, java.lang.Object, int, boolean, boolean)
	 */
	public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected,
			boolean cellHasFocus) {
		pack = (PMPackage) value;
		selected = isSelected;
		return this;
	}
}
"
PMPackageListModel.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import javax.swing.AbstractListModel;

public class PMPackageListModel extends AbstractListModel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 4483191311607087069L;

	private static final Comparator<PMPackage> COMP_PACKAGE_NAME = new Comparator<PMPackage>() {
		public int compare(PMPackage r1, PMPackage r2) {
			return r1.getPackageName().compareTo(r2.getPackageName());
		}
	};

	private static final Comparator<PMPackage> COMP_AUTHOR_NAME = new Comparator<PMPackage>() {
		public int compare(PMPackage r1, PMPackage r2) {
			return r1.getAuthorName().compareTo(r2.getAuthorName());
		}
	};

	private final List<? extends PMPackage> fullList;
	private List<? extends PMPackage> filteredList;
	private boolean filterFavorites;
	private Comparator<PMPackage> comparator;

	public PMPackageListModel(List<? extends PMPackage> packages) {
		fullList = packages;
		filteredList = new ArrayList<PMPackage>(packages);
		filterFavorites = false;
		comparator = PMPackageListModel.COMP_PACKAGE_NAME;
	}

	public void sortByPackageName() {
		comparator = PMPackageListModel.COMP_PACKAGE_NAME;
		updateList();
	}

	public void sortByAuthorName() {
		comparator = PMPackageListModel.COMP_AUTHOR_NAME;
		updateList();
	}

	public void setFilterFavorites(boolean isFiltered) {
		filterFavorites = isFiltered;
		updateList();
	}

	private void updateList() {
		filteredList = new ArrayList<PMPackage>(fullList);
		if (filterFavorites) {
			ArrayList<PMPackage> filtered = new ArrayList<PMPackage>();
			for (PMPackage r : filteredList) {
				if (r.isFavorite()) {
					filtered.add(r);
				}
			}
			filteredList = filtered;
		}
		Collections.sort(filteredList, comparator);
		fireContentsChanged(this, 0, getSize() - 1);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.ListModel#getElementAt(int)
	 */
	public Object getElementAt(int index) {
		return filteredList.get(index);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.ListModel#getSize()
	 */
	public int getSize() {
		return filteredList.size();
	}
}
"
PMPackageView.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Desktop;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Collection;
import java.util.HashSet;

import javax.swing.AbstractButton;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;

import org.deckfour.uitopia.ui.components.ImageLozengeButton;
import org.deckfour.uitopia.ui.util.ArrangementHelper;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.contexts.uitopia.packagemanager.PMPackage.PMStatus;

import com.fluxicon.slickerbox.components.RoundedPanel;

public class PMPackageView extends RoundedPanel {

	private static final long serialVersionUID = 8110954844773778705L;

	private final Collection<PMPackage> packs;
	private final PMPackage pack;
	private final PMController controller;

	//	private AbstractButton actionButton;
	private AbstractButton installButton;
	private AbstractButton updateButton;
	private AbstractButton removeButton;
	private AbstractButton parentButton;
	private AbstractButton childrenButton;

	public PMPackageView(PMPackage pack, PMController controller) {
		super(20, 5, 15);
		this.packs = new HashSet<PMPackage>();
		this.packs.add(pack);
		this.pack = pack;
		this.controller = controller;
		setupUI();
	}

	public PMPackageView(Collection<PMPackage> packs, PMController controller) {
		super(20, 5, 15);
		this.packs = packs;
		this.pack = (packs.isEmpty() ? null : packs.iterator().next());
		this.controller = controller;
		setupUI();
	}

	private void setupUI() {
		setBackground(new Color(160, 160, 160));
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		if (packs.size() == 1) {
			// assemble info panel
			JPanel infoPanel = new JPanel();
			infoPanel.setMaximumSize(new Dimension(500, 180));
			infoPanel.setOpaque(false);
			infoPanel.setLayout(new BorderLayout());
			//			Image icon = pack.getPreview(150, 150);
			JLabel preview = null;
			//			if (icon != null) {
			ImageIcon icon = PMIconCache.getIconPreview(pack);
			if (icon != null) {
				preview = new JLabel(icon);
				//				preview.setSize(150, 150);
				preview.setOpaque(false);
			}
			JPanel detailsPanel = new JPanel();
			detailsPanel.setOpaque(false);
			detailsPanel.setBorder(BorderFactory.createEmptyBorder(0, 20, 15, 0));
			detailsPanel.setLayout(new BoxLayout(detailsPanel, BoxLayout.Y_AXIS));
			detailsPanel.add(styleLabel(pack.getPackageName(), new Color(10, 10, 10), 18));
			detailsPanel.add(Box.createVerticalStrut(3));
			detailsPanel.add(styleLabel(pack.getAuthorName(), new Color(30, 30, 30), 14));
			detailsPanel.add(Box.createVerticalStrut(12));
			detailsPanel.add(styleLabel(pack.getVersion(), new Color(60, 60, 60), 12));
			detailsPanel.add(Box.createVerticalStrut(5));
			detailsPanel.add(styleLinkedLabel(""<html><i>License: "" + pack.getLicense() + ""</i></html>"",
					getLink2License(pack.getLicense()), new Color(60, 60, 60), 12));
			detailsPanel.add(Box.createVerticalStrut(5));
			String text = ""<html><i>"";
			if (pack.getDescription() == null) {
				text += ""No description"";
			} else {
				text += ""Description: "" + pack.getDescription();
			}
			text += ""</i></html>"";
			detailsPanel.add(styleLabel(text, new Color(60, 60, 60), 12));
			detailsPanel.add(Box.createVerticalGlue());
			if (preview != null) {
				infoPanel.add(preview, BorderLayout.WEST);
			}
			infoPanel.add(detailsPanel, BorderLayout.CENTER);
			this.add(infoPanel);
			this.add(Box.createVerticalStrut(25));
		}

		// assemble actions panel
		RoundedPanel actionsPanel = new RoundedPanel(50, 0, 0);
		actionsPanel.setBackground(new Color(80, 80, 80));
		actionsPanel.setLayout(new BoxLayout(actionsPanel, BoxLayout.X_AXIS));
		actionsPanel.setBorder(BorderFactory.createEmptyBorder());
		installButton = new ImageLozengeButton(ImageLoader.load(""action_30x30_black.png""), ""Install"", new Color(140,
				140, 140), new Color(140, 40, 40), 2);
		installButton.setToolTipText(PMTooltips.INSTALLBUTTON);
		installButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				installPacks();
			}
		});
		updateButton = new ImageLozengeButton(ImageLoader.load(""action_30x30_black.png""), ""Update "", new Color(140,
				140, 140), new Color(40, 140, 40), 2);
		updateButton.setToolTipText(PMTooltips.UPDATEBUTTON);
		updateButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				updatePacks();
			}
		});
		removeButton = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""), ""Remove "", new Color(140,
				140, 140), new Color(40, 140, 40), 2);
		removeButton.setToolTipText(PMTooltips.REMOVEBUTTON);
		removeButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				removePacks();
			}
		});
		boolean showInstall = false;
		boolean showUpdate = false;
		boolean showRemove = false;
		for (PMPackage p : packs) {
			switch (p.getStatus()) {
				case TOINSTALL :
					showInstall = true;
					break;
				case TOUPDATE :
					showUpdate = true;
					break;
				case TOUNINSTALL :
					showRemove = true;
					break;
				default :
			}
		}
		int width = 10;
		if (showInstall) {
			actionsPanel.add(Box.createHorizontalGlue());
			actionsPanel.add(installButton);
			width += 110;
		}
		if (showUpdate) {
			actionsPanel.add(Box.createHorizontalGlue());
			actionsPanel.add(updateButton);
			width += 110;
		}
		if (showRemove) {
			actionsPanel.add(Box.createHorizontalGlue());
			actionsPanel.add(removeButton);
			width += 110;
		}
		if (!showInstall && !showUpdate && !showRemove) {
			actionsPanel.add(Box.createHorizontalGlue());
			actionsPanel.add(styleLabel(""No actions available"", new Color(160, 160, 160), 12));
			width += 110;
		}
		actionsPanel.setMinimumSize(new Dimension(width, 50));
		actionsPanel.setMaximumSize(new Dimension(width, 50));
		actionsPanel.setPreferredSize(new Dimension(width, 50));
		//		switch (pack.getStatus()) {
		//			case TOUNINSTALL :
		//				actionButton = new ImageLozengeButton(ImageLoader.load(""remove_30x30_black.png""),
		//						""Remove              "", new Color(140, 140, 140), new Color(140, 40, 40), 2);
		//				actionButton.setToolTipText(PMTooltips.REMOVEBUTTON);
		//				break;
		//			case TOUPDATE :
		//				actionButton = new ImageLozengeButton(ImageLoader.load(""action_30x30_black.png""),
		//						""Update              "", new Color(140, 140, 140), new Color(40, 140, 40), 2);
		//				actionButton.setToolTipText(PMTooltips.UPDATEBUTTON);
		//				break;
		//			default :
		//				actionButton = new ImageLozengeButton(ImageLoader.load(""action_30x30_black.png""),
		//						""Install             "", new Color(140, 140, 140), new Color(40, 140, 40), 2);
		//				actionButton.setToolTipText(PMTooltips.INSTALLBUTTON);
		//				break;
		//		}
		//		actionButton.addActionListener(new ActionListener() {
		//			public void actionPerformed(ActionEvent e) {
		//				action();
		//			}
		//		});
		//		actionsPanel.add(Box.createHorizontalGlue());
		//		actionsPanel.add(actionButton);
		actionsPanel.add(Box.createHorizontalGlue());
		this.add(ArrangementHelper.pushLeft(actionsPanel));
		this.add(Box.createVerticalStrut(25));

		if (packs.size() == 1) {
			// assemble family panel
			RoundedPanel familyPanel = new RoundedPanel(50, 0, 0) {
				private static final long serialVersionUID = 6739005088069438989L;

				@Override
				protected void paintComponent(Graphics g) {
					super.paintComponent(g);
					// add fancy arrowhead
					int yMid = getHeight() / 2;
					int x[] = { 15, 45, 42, 45 };
					int y[] = { yMid, yMid - 15, yMid, yMid + 15 };
					g.setColor(new Color(120, 120, 120));
					g.fillPolygon(x, y, 4);
				}
			};
			familyPanel.setBackground(new Color(80, 80, 80));
			familyPanel.setLayout(new BoxLayout(familyPanel, BoxLayout.Y_AXIS));
			familyPanel.setMinimumSize(new Dimension(220, 100));
			familyPanel.setMaximumSize(new Dimension(220, 100));
			familyPanel.setPreferredSize(new Dimension(220, 100));
			familyPanel.setBorder(BorderFactory.createEmptyBorder(5, 55, 5, 15));
			parentButton = new ImageLozengeButton(ImageLoader.load(""parent_30x30_black.png""), ""Show parents"");
			parentButton.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					showParents();
				}
			});
			parentButton.setToolTipText(PMTooltips.PARENTBUTTON);
			childrenButton = new ImageLozengeButton(ImageLoader.load(""children_30x30_black.png""), ""Show children"");
			childrenButton.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					showChildren();
				}
			});
			childrenButton.setToolTipText(PMTooltips.CHILDRENBUTTON);
			familyPanel.add(Box.createVerticalGlue());
			familyPanel.add(parentButton);
			familyPanel.add(Box.createVerticalStrut(5));
			familyPanel.add(childrenButton);
			familyPanel.add(Box.createVerticalGlue());
			this.add(ArrangementHelper.pushLeft(familyPanel));
			this.add(Box.createVerticalGlue());
		}
	}

	/**
	 * Returns true if the package was installed or updated, false otherwise.
	 * 
	 * @return
	 */
	//	public boolean action() {
	//		if (pack.getStatus() == PMStatus.TOUNINSTALL) {
	//			controller.remove(pack, controller.getMainView().getWorkspaceView());
	//			return false;
	//		} else {
	//			// (pack.getStatus() == PMStatus.TOUPDATE)  ||
	//			// (pack.getStatus() == PMStatus.TOINSTALL)
	//			controller.update(pack, controller.getMainView().getWorkspaceView());
	//			return true;
	//		}
	//	}

	public boolean installPacks() {
		boolean allDone = true;
		Collection<PMPackage> pp = new HashSet<PMPackage>();
		for (PMPackage p : packs) {
			if (pack.getStatus() == PMStatus.TOINSTALL) {
				pp.add(p);
			} else {
				allDone = false;
			}
		}
		if (!pp.isEmpty()) {
			controller.update(pp, controller.getMainView().getWorkspaceView());
			return allDone;
		}
		return false;
	}

	public boolean updatePacks() {
		boolean allDone = true;
		Collection<PMPackage> pp = new HashSet<PMPackage>();
		for (PMPackage p : packs) {
			if (pack.getStatus() == PMStatus.TOUPDATE) {
				pp.add(p);
			} else {
				allDone = false;
			}
		}
		if (!pp.isEmpty()) {
			controller.update(pp, controller.getMainView().getWorkspaceView());
			return allDone;
		}
		return false;
	}

	public boolean removePacks() {
		boolean allDone = true;
		Collection<PMPackage> pp = new HashSet<PMPackage>();
		for (PMPackage p : packs) {
			if (pack.getStatus() != PMStatus.TOINSTALL) {
				pp.add(p);
			} else {
				allDone = false;
			}
		}
		if (!pp.isEmpty()) {
			controller.remove(pp, controller.getMainView().getWorkspaceView());
			return allDone;
		}
		return false;
	}

	private void showParents() {
		controller.getMainView().getWorkspaceView().showParentsOf(pack);
	}

	private void showChildren() {
		controller.getMainView().getWorkspaceView().showChildrenOf(pack);
	}

	private JLabel styleLabel(String text, Color color, float size) {
		JLabel label = new JLabel(text);
		label.setOpaque(false);
		label.setForeground(color);
		label.setFont(label.getFont().deriveFont(size));
		return label;
	}

	private JLabel styleLinkedLabel(String text, final String link, Color color, float size) {
		JLabel label = styleLabel(text, color, size);
		if (link != null) {
			label.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
			label.addMouseListener(new MouseAdapter() {
				public void mouseClicked(MouseEvent e) {
					if (e.getClickCount() > 0) {
						if (Desktop.isDesktopSupported()) {
							Desktop desktop = Desktop.getDesktop();
							try {
								URI uri = new URI(link);
								desktop.browse(uri);
							} catch (IOException ex) {
								ex.printStackTrace();
							} catch (URISyntaxException ex) {
								ex.printStackTrace();
							}
						}
					}
				}
			});
		}
		return label;
	}

	private String getLink2License(String license) {
		if (license.equals(""LGPL"") || license.equals(""L-GPL"") || license.equals(""Lesser GPL"")) {
			return ""http://www.gnu.org/licenses/lgpl.html"";
		}
		if (license.equals(""ProM""))	{
			return ""http://www.promtools.org/doku.php?id=license"";
		}
		if (license.equals(""Apache 2.0"")) {
			return ""http://www.apache.org/licenses/LICENSE-2.0.html"";
		}
		if (license.equals(""Apache"")) {
			return ""http://www.apache.org/licenses/LICENSE-1.0"";
		}
		if (license.equals(""Apache 1.1"")) {
			return ""http://www.apache.org/licenses/LICENSE-1.1"";
		}
		if (license.equals(""BSD 3-Clause"")) {
			return ""http://opensource.org/licenses/BSD-3-Clause"";
		}
		if (license.equals(""BSD"")) {
			return ""https://opensource.org/licenses/BSD-2-Clause"";
		}
		if (license.equals(""CPL"")) {
			return ""https://opensource.org/licenses/cpl1.0.php"";
		}
		if (license.equals(""Daikon-specific license"")) {
			return ""http://plse.cs.washington.edu/daikon/download/doc/daikon.html#License"";
		}
		if (license.equals(""dev.java.net \""Other\"" License"")) {
			return ""https://tablelayout.dev.java.net/servlets/LicenseDetails?licenseID=18"";
		}
		if (license.equals(""EPL 1.0"") || license.equals(""EPL"")) {
			return ""http://www.eclipse.org/legal/epl-v10.html"";
		}
		if (license.equals(""GPL"")) {
			return ""http://www.gnu.org/licenses/gpl.html"";
		}
		if (license.equals(""GPL v2"")) {
			return ""http://www.gnu.org/licenses/gpl-2.0.html"";
		}
		if (license.equals(""AGPL"") || license.equals(""A-GPL"") || license.equals(""Affero GPL"")) {
			return ""https://www.gnu.org/licenses/agpl.html"";
		}
		if (license.equals(""MIT"")) {
			return ""http://www.opensource.org/licenses/mit-license.php"";
		}
		if (license.equals(""Mozilla Public License v1.0"")) {
			return ""https://www-archive.mozilla.org/MPL/MPL-1.0.html"";
		}
		return null;
	}
}
"
PMSearchView.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.BorderFactory;
import javax.swing.JLabel;

import org.deckfour.uitopia.ui.util.ImageLoader;
import org.deckfour.uitopia.ui.util.LinkLabel;
import org.deckfour.uitopia.ui.util.Tooltips;

import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.components.SlickerSearchField;

public class PMSearchView extends RoundedPanel {

	private static final long serialVersionUID = 5079107169836528703L;

	private final PMWorkspaceBrowser pmWorkspaceBrowser;
	private final PMController controller;
	private SlickerSearchField filterSearch;

	public PMSearchView(PMWorkspaceBrowser pmWorkspaceBrowser, PMController controller) {
		super(20, 5, 0);
		this.pmWorkspaceBrowser = pmWorkspaceBrowser;
		this.controller = controller;
		setBackground(new Color(160, 160, 160));
		setLayout(new BorderLayout());
		setupUI();
	}

	private void setupUI() {
		// Filter: Text search
		filterSearch = new SlickerSearchField(50, 40, new Color(140, 140, 140), new Color(80, 80, 80),
				new Color(40, 40, 40), new Color(20, 20, 20));
		filterSearch.requestFocusInWindow();
		filterSearch.setFont(filterSearch.getFont().deriveFont(Font.BOLD, 14.0f));
		filterSearch.addSearchListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				updateFilter();
			}
		});
		filterSearch.setToolTipText(Tooltips.ACTIONFILTERSEARCHFIELD);
		this.add(filterSearch);		
		
		// Add clickable ProM icon.
		Image appIcon = ImageLoader.load(""prom_logo_101x40.png"");
		JLabel logoLabel = new LinkLabel(appIcon, ""http://www.promtools.org"");
		logoLabel.setOpaque(false);
		logoLabel.setBorder(BorderFactory.createEmptyBorder());
		this.add(logoLabel, BorderLayout.WEST);
	}

	private void updateFilter() {
		// construct search reges from search field
		String search = filterSearch.getSearchText().toLowerCase().trim();
		if (search.length() > 0) {
			search.replaceAll(""\\w"", ""(.*)"");
			search = ""(.*)"" + search + ""(.*)"";
		} else {
			search = ""(.*)"";
		}
		// filter list of packages according to search field
		controller.setQuery(search);
		if (!search.isEmpty())
			pmWorkspaceBrowser.update();
	}
}
"
PMTooltips.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

public class PMTooltips {
	public static final String REMOVEBUTTON = ""Remove selected packages"";
	public static final String UPDATEBUTTON = ""Update selected packages"";
	public static final String INSTALLBUTTON = ""Install selected packages"";

	public static final String PARENTBUTTON = ""Show required packages"";
	public static final String CHILDRENBUTTON = ""Show supported packages"";

	public static final String SORTBYPACKAGENAME = ""Sort packages on package name"";
	public static final String SORTBYAUTHORNAME = ""Sort packages on author name"";
}
"
PMWorkspaceBrowser.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JComponent;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.framework.boot.Boot;

import com.fluxicon.slickerbox.components.IconVerticalTabbedPane;

public class PMWorkspaceBrowser extends JPanel {

	private static final long serialVersionUID = -1467890361679445697L;
	private static final Color BG = new Color(180, 180, 180);
	private static final Color FG = new Color(60, 60, 60);

	private IconVerticalTabbedPane tabs;
	private final PMController controller;

	private PMPackageListBrowser browserToUninstall;
	private PMPackageListBrowser browserToUpdate;
	private PMPackageListBrowser browserToInstall;
	private PMPackageListBrowser browserSelection;

	private PMPackage selectionPack;
	private boolean selectionParent;

	private final static String TOUNINSTALL = ""Up to date"";
	private final static String TOPUDATE = ""Out of date"";
	private final static String TOINSTALL = ""Not installed"";
	private final static String SELECTION = ""Selection"";

	public PMWorkspaceBrowser(PMController controller) {
		this.controller = controller;
		setLayout(new BorderLayout());
		setOpaque(false);
		setupUI();
		selectionPack = null;
		selectionParent = true;
		//		PackageManager.getInstance().addListener(
		//				new UpdateListener() {
		//					public void updated() {
		//						updatePackages();
		//					}
		//				});
	}

	public PMPackageListBrowser getSelectedBrowser() {
		return (PMPackageListBrowser) tabs.getSelected();
	}

	public void showPackage(PMPackage pack) {
		if (pack.getStatus() == PMPackage.PMStatus.TOUNINSTALL) {
			tabs.selectTab(TOUNINSTALL);
			browserToUninstall.showPackage(pack);
		} else if (pack.getStatus() == PMPackage.PMStatus.TOUPDATE) {
			tabs.selectTab(TOPUDATE);
			browserToUpdate.showPackage(pack);
		} else {
			tabs.selectTab(TOINSTALL);
			browserToInstall.showPackage(pack);
		}
	}

	public void updatePackages() {
		if (selectionPack != null) {
			browserSelection.setSelectionContent(selectionPack, selectionParent);
		}
		SwingUtilities.invokeLater(new Runnable() {

			public void run() {
				JComponent tab = tabs.getSelected();
				if ((tab != null) && (tab instanceof PMPackageListBrowser)) {
					((PMPackageListBrowser) tab).updateData();
				}
			}
		});
	}

	public void showParentsOf(PMPackage pack) {
		selectionPack = pack;
		selectionParent = true;
		browserSelection.setSelectionContent(selectionPack, selectionParent);
		tabs.selectTab(SELECTION);
	}

	public void showChildrenOf(PMPackage pack) {
		selectionPack = pack;
		selectionParent = false;
		browserSelection.setSelectionContent(selectionPack, selectionParent);
		tabs.selectTab(SELECTION);
	}

	private void setupUI() {
		this.add(new PMSearchView(this, controller), BorderLayout.NORTH);

		browserToUninstall = new PMPackageListBrowser(controller, PMPackageListBrowser.Type.TOUNINSTALL);
		browserToUpdate = new PMPackageListBrowser(controller, PMPackageListBrowser.Type.TOUPDATE);
		browserToInstall = new PMPackageListBrowser(controller, PMPackageListBrowser.Type.TOINSTALL);
		browserSelection = new PMPackageListBrowser(controller, PMPackageListBrowser.Type.SELECTION);

		tabs = new IconVerticalTabbedPane(FG, BG, 100);
		tabs.setPassiveBackground(new Color(140, 140, 140));
		tabs.setMouseOverFadeColor(new Color(90, 90, 90));

		tabs.addTab(TOUNINSTALL, ImageLoader.load(""uptodate_60x60_black.png""), browserToUninstall,
				new ActionListener() {
					public void actionPerformed(ActionEvent e) {
						browserToUninstall.updateData();
					}
				});
		tabs.addTab(TOPUDATE, ImageLoader.load(""outofdate_60x60_black.png""), browserToUpdate, new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				browserToUpdate.updateData();
			}
		});
		tabs.addTab(TOINSTALL, ImageLoader.load(""notinstalled_60x60_black.png""), browserToInstall,
				new ActionListener() {
					public void actionPerformed(ActionEvent e) {
						browserToInstall.updateData();
					}
				});
		tabs.addTab(SELECTION, ImageLoader.load(""selection_60x60_black.png""), browserSelection, new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				browserSelection.updateData();
			}
		});

		/*
		 * Pre-select the tab that is most likely of use to the user
		 */
		PMPackageListBrowser currentBrowser = browserToUninstall;
		if (currentBrowser.isEmpty()) {
			currentBrowser = browserToUpdate;
			if (currentBrowser.isEmpty()) {
				currentBrowser = browserToInstall;
				if (currentBrowser.isEmpty()) {
					/*
					 * No packages at all. User may have no internet conenction.
					 */
					JOptionPane.showMessageDialog(controller.getMainView(),
							""No packages were found. Please check your internet connection."");
				}
			}
		}
		/*
		 * And pre-select the most important package.
		 */
		currentBrowser.selectPackage(Boot.RELEASE_PACKAGE);
		tabs.selectTab(currentBrowser);

		this.add(tabs, BorderLayout.CENTER);
		this.add(new PMMemoryView(controller), BorderLayout.SOUTH);
	}

	public void update() {
		browserToUninstall.updateData();
		browserToUpdate.updateData();
		browserToInstall.updateData();
		browserSelection.updateData();
	}
}
"
PMWorkspaceView.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia.packagemanager;

import java.awt.BorderLayout;

import javax.swing.BorderFactory;
import javax.swing.JPanel;

import org.deckfour.uitopia.ui.components.TiledPanel;
import org.deckfour.uitopia.ui.components.ViewHeaderBar;
import org.deckfour.uitopia.ui.main.Viewable;
import org.deckfour.uitopia.ui.util.ImageLoader;

public class PMWorkspaceView extends JPanel implements Viewable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8491411287370473317L;
	private ViewHeaderBar header;
	private final JPanel contents;
	private final PMWorkspaceBrowser browser;

	public PMWorkspaceView(final PMController controller) {
		setLayout(new BorderLayout());
		setOpaque(true);
		setBorder(BorderFactory.createEmptyBorder());
		contents = new TiledPanel(ImageLoader.load(""tile_wooden.jpg""));
		contents.setBorder(BorderFactory.createEmptyBorder(20, 40, 20, 40));
		contents.setLayout(new BorderLayout());
		browser = new PMWorkspaceBrowser(controller);
		contents.add(browser, BorderLayout.CENTER);
		this.add(contents, BorderLayout.CENTER);
	}

	public ViewHeaderBar getHeader() {
		return header;
	}

	public void showPackage(PMPackage pack) {
		browser.showPackage(pack);
	}

	public void showParentsOf(PMPackage pack) {
		browser.showParentsOf(pack);
	}

	public void showChildrenOf(PMPackage pack) {
		browser.showChildrenOf(pack);
	}

	public void updatePackages() {
		browser.updatePackages();
	}

	public void viewFocusGained() {
	}

	public void viewFocusLost() {
	}

	public PMPackageView getPackageView() {
		return browser.getSelectedBrowser().getPackageView();

	}

	//	public void showFavorites() {
	//		browser.showFavorites();
	//	}
}
"
UI.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia;

import java.io.File;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;

import javax.swing.JLabel;
import javax.swing.JOptionPane;

import org.deckfour.uitopia.ui.UITopiaController;
import org.deckfour.uitopia.ui.main.Overlayable;
import org.deckfour.uitopia.ui.overlay.TwoButtonOverlayDialog;
import org.deckfour.uitopia.ui.util.ImageLoader;
import org.processmining.contexts.uitopia.packagemanager.PMController;
import org.processmining.contexts.uitopia.packagemanager.PMFrame;
import org.processmining.contexts.uitopia.packagemanager.PMMainView;
import org.processmining.contexts.uitopia.packagemanager.PMPackage;
import org.processmining.contexts.uitopia.packagemanager.PMPackage.PMStatus;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageManager;
import org.processmining.framework.packages.events.PackageManagerListener;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.util.CommandLineArgumentList;

public class UI {

	@Plugin(name = ""UITopia"", parameterLabels = {}, returnLabels = {}, returnTypes = {}, userAccessible = false)
	@Bootable
	public Object main(CommandLineArgumentList commandlineArguments) {
		UIContext globalContext;
		globalContext = new UIContext();
		globalContext.initialize();
		final UITopiaController controller = new UITopiaController(globalContext);
		globalContext.setController(controller);
		globalContext.setFrame(controller.getFrame());
		controller.getFrame().setIconImage(ImageLoader.load(""prom_icon_32x32.png""));
		controller.getFrame().setVisible(true);
		controller.getMainView().showWorkspaceView();
		controller.getMainView().getWorkspaceView().showFavorites();

		globalContext.startup();

		for (String cmd : commandlineArguments) {
			File f = new File(cmd);
			if (f.exists() && f.isFile()) {
				globalContext.getResourceManager().importResource(null, f);
			}
		}

		return controller;
	}

	public static void main(String[] args) throws Exception {

		if (Boot.AUTO_UPDATE.equals(""auto"") || Boot.AUTO_UPDATE.equals(""user"") || !Boot.isLatestReleaseInstalled()) {
			Boot.setReleaseInstalled("""", """");
			PMFrame frame = (PMFrame) Boot.boot(PMFrame.class);
			frame.setIconImage(ImageLoader.load(""prom_icon_32x32.png""));
			// Now select the release package
			PMPackage releasePackage = frame.getController().selectPackage(Boot.RELEASE_PACKAGE);
			if (releasePackage == null) {
				Boot.boot(UI.class, UIPluginContext.class, args);
				throw new Exception(""Cannot find release package defined in ProM.ini file: "" + Boot.RELEASE_PACKAGE
						+ "". Continuing to load ProM."");
			}

			if (releasePackage.getStatus() == PMStatus.TOUNINSTALL) {

				int option = JOptionPane.NO_OPTION;

				if (Boot.AUTO_UPDATE.equals(""auto"") || Boot.AUTO_UPDATE.equals(""user"")) {
					/*
					 * HV: Check for packages to install or update.
					 */
					PMController pmController = frame.getController();
					if (Boot.AUTO_UPDATE.equals(""user"")) {
						if (!pmController.getToInstallPackages().isEmpty()) {
							if (!pmController.getToUpdatePackages().isEmpty()) {
								option = JOptionPane.showConfirmDialog(frame,
										""New packages and package updates are available.\nDo you want ProM to install and/or update them now?"",
										""Install and update packages?"", JOptionPane.YES_NO_OPTION);
							} else {
								option = JOptionPane.showConfirmDialog(frame,
										""New packages are available.\nDo you want ProM to install them now?"",
										""Install packages?"", JOptionPane.YES_NO_OPTION);
							}
						} else if (!pmController.getToUpdatePackages().isEmpty()) {
							option = JOptionPane.showConfirmDialog(frame,
									""Package updates are available.\nDo you want ProM to update them now?"",
									""Update packages?"", JOptionPane.YES_NO_OPTION);
						}
					} else { // auto
						option = JOptionPane.YES_OPTION;
					}
					if (option == JOptionPane.YES_OPTION) {
						// Start listening
						UIPackageManagerListener listener = new UIPackageManagerListener(frame, args);
						PackageManager.getInstance().addListener(listener);

						// Show the package manager
						frame.setVisible(true);
						Collection<PMPackage> toUpdate = new ArrayList<PMPackage>();
						toUpdate.addAll(pmController.getToInstallPackages());
						toUpdate.addAll(pmController.getToUpdatePackages());

						frame.getController().update(toUpdate, frame.getController().getMainView().getWorkspaceView());

						// ProM will be started as soon as the package manager finishes.

						synchronized (listener) {
							while (!listener.isDone()) {
								listener.wait();
							}
						}

					}
				}

				if (option == JOptionPane.NO_OPTION) {
					// Package is upToDate and installed.
					// Do not show package manager and start ProM
					Boot.setLatestReleaseInstalled();
					Boot.boot(UI.class, UIPluginContext.class, args);
				}

			} else {

				// Start listening
				UIPackageManagerListener listener = new UIPackageManagerListener(frame, args);
				PackageManager.getInstance().addListener(listener);

				// Show the package manager
				frame.setVisible(true);

				// And install the release package!
				frame.getController().update(releasePackage, frame.getController().getMainView().getWorkspaceView());

				// ProM will be started as soon as the package manager finishes.

				synchronized (listener) {
					while (!listener.isDone()) {
						listener.wait();
					}
				}

			}

			//Boot.setLatestReleaseInstalled();
		} else {
			Boot.boot(UI.class, UIPluginContext.class, args);
		}

	}
}

class FirstTimeOverlay extends TwoButtonOverlayDialog {

	/**
	 * 
	 */
	private static final long serialVersionUID = 494237962617678531L;

	public FirstTimeOverlay(Overlayable mainView) {
		super(mainView, ""Starting ProM"", ""Cancel"", ""  OK  "", //
				new JLabel(""<html>All packages have been installed and/or updated.<BR>""
						+ ""Please wait while starting ProM.<BR><BR>""
						+ ""If this is the first time you run ProM on this computer, please be patient.</html>""));

		getCancelButton().setEnabled(true);
		getOKButton().setEnabled(false);

	}

	@Override
	public void close(boolean okayed) {
		if (!okayed) {
			System.exit(0);
		}
		super.close(okayed);
	}

}

class UIPackageManagerListener implements PackageManagerListener {

	private final String[] args;
	private final PMFrame frame;
	private boolean done = false;

	public UIPackageManagerListener(PMFrame frame, String[] args) {
		this.frame = frame;
		this.args = args;
	}

	public void exception(Throwable t) {
	}

	public void exception(String exception) {
	}

	public void finishedInstall(String packageName, File folder, PackageDescriptor pack) {
	}

	public void sessionComplete(boolean error) {
		synchronized (this) {
			done = true;
			this.notifyAll();
		}
		PackageManager.getInstance().removeListener(this);
		showOverlayAfterInstall();
	}

	public void sessionStart() {
	}

	public void startDownload(String packageName, URL url, PackageDescriptor pack) {
	}

	public void startInstall(String packageName, File folder, PackageDescriptor pack) {
	}

	public boolean isDone() {
		return done;
	}

	private void showOverlayAfterInstall() {
		PMMainView overlayable = frame.getController().getMainView();

		FirstTimeOverlay dialog = new FirstTimeOverlay(overlayable);

		overlayable.showOverlay(dialog);
		frame.saveConfig();

		try {
			Boot.boot(UI.class, UIPluginContext.class, args);
			Boot.setLatestReleaseInstalled();
		} catch (Exception e1) {
			throw new RuntimeException(e1);
		} finally {
			frame.setVisible(false);
		}

	}

}"
UIContext.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia;

import java.util.Date;
import java.util.List;

import org.deckfour.uitopia.api.event.TaskListener;
import org.deckfour.uitopia.api.hub.CategoryManager;
import org.deckfour.uitopia.api.hub.FrameworkHub;
import org.deckfour.uitopia.api.model.Author;
import org.deckfour.uitopia.ui.UITopiaController;
import org.deckfour.uitopia.ui.UITopiaFrame;
import org.processmining.contexts.uitopia.hub.ProMActionManager;
import org.processmining.contexts.uitopia.hub.ProMCategoryManager;
import org.processmining.contexts.uitopia.hub.ProMResourceManager;
import org.processmining.contexts.uitopia.hub.ProMTaskManager;
import org.processmining.contexts.uitopia.hub.ProMViewManager;
import org.processmining.contexts.uitopia.model.ProMAction;
import org.processmining.contexts.uitopia.model.ProMPOResource;
import org.processmining.contexts.uitopia.model.ProMResource;
import org.processmining.contexts.uitopia.model.ProMTask;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.impl.AbstractGlobalContext;

public class UIContext extends AbstractGlobalContext implements
		FrameworkHub<ProMAction, ProMTask, ProMResource<?>, ProMPOResource> {

	private final UIPluginContext mainPluginContext;
	private UITopiaFrame frame;
	private ProMResourceManager resourceManager;
	private ProMActionManager actionManager;
	private ProMTaskManager taskManager;
	private ProMViewManager viewManager;
	private CategoryManager categoryManager;
	private UITopiaController controller;

	public UIContext() {
		super();
		mainPluginContext = new UIPluginContext(this, ""Main Plugin Context"");

	}

	public void initialize() {
		resourceManager = ProMResourceManager.initialize(this);
		taskManager = ProMTaskManager.initialize(this);
		actionManager = ProMActionManager.initialize(this);
		viewManager = ProMViewManager.initialize(this);
		categoryManager = ProMCategoryManager.initialize(this);
	}

	public void setFrame(UITopiaFrame frame) {
		this.frame = frame;
	}

	public CategoryManager getCategoryManager() {
		return categoryManager;
	}

	@Override
	public UIPluginContext getMainPluginContext() {
		return mainPluginContext;
	}

	@Override
	public Class<? extends PluginContext> getPluginContextType() {
		return UIPluginContext.class;
	}

	public List<Author> getFrameworkAuthors() {
		// TODO Auto-generated method stub
		return null;
	}

	public Date getFrameworkReleaseDate() {
		// TODO Auto-generated method stub
		return null;
	}

	public String getFrameworkVersion() {
		// TODO Auto-generated method stub
		return null;
	}

	public ProMResourceManager getResourceManager() {
		return resourceManager;
	}

	public ProMActionManager getActionManager() {
		return actionManager;
	}

	public ProMTaskManager getTaskManager() {
		return taskManager;
	}

	public ProMViewManager getViewManager() {
		return viewManager;
	}

	public void shutdown(TaskListener arg0) {
	}

	public void startup() {
		// Nothing to do (since (de)serialization was abandoned).
	}

	public UITopiaFrame getUI() {
		return frame;
	}

	public UITopiaController getController() {
		return controller;
	}

	public void setController(UITopiaController controller) {
		this.controller = controller;
	}

}
"
UIPluginContext.java,prom-contexts-6.9.56,"package org.processmining.contexts.uitopia;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.IOException;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.Preferences;

import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.deckfour.uitopia.api.model.ActionType;
import org.processmining.contexts.uitopia.model.ProMTask;
import org.processmining.framework.plugin.GlobalContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.plugin.impl.AbstractPluginContext;

public class UIPluginContext extends AbstractPluginContext {

	/*
	 * The field UIPluginContext.PREF is never read locally private static final
	 * String PREF = ""guiplugincontext"";
	 */
	private final Executor executor;
	private ProMTask task;

	UIPluginContext(GlobalContext context, String label) {
		super(context, label);
		// This context is NOT a child of another context,
		// hence should behave in an asynchronous way.
		executor = Executors.newCachedThreadPool();

		//TODO: Setup progressbar
		// progress = new GUIProgressBar(this);

	}

	protected UIPluginContext(UIPluginContext context, String label) {
		super(context, label);

		// TODO: Setup Progress
		// progress = new GUIProgressBar(this);

		// This context is a child of another context,
		// hence should behave in a synchronous way.
		if (context/*.getParentContext()*/ == null) {
			// this context is on the first level below the user-initiated
			// plugins
			executor = Executors.newCachedThreadPool();
		} else {
			// all subtasks take the pool of the parent.
			executor = context.getExecutor();
		}

		setTask(context.task);
	}

	@Override
	protected synchronized PluginContext createTypedChildContext(String label) {
		return new UIPluginContext(this, label);
	}

	public Executor getExecutor() {
		return executor;
	}

	/*
	 * [HV] The method getPreferences() from the type UIPluginContext is never
	 * used locally
	 */
	@SuppressWarnings(""unused"")
	private Preferences getPreferences() {
		return Preferences.userNodeForPackage(UIPluginContext.class);
	}

	/*
	 * [HV] The declared exception IOException is not actually thrown by the
	 * method openFile(FileFilter) from type UIPluginContext
	 */
	@SuppressWarnings(""unused"")
	public File openFile(final FileFilter filter) throws IOException {
		// TODO
		return null;
	}

	/*
	 * [HV] The declared exception IOException is not actually thrown by the
	 * method saveFile(String, String...) from type UIPluginContext
	 */
	@SuppressWarnings(""unused"")
	public File saveFile(String defaultExtension, String... extensions) throws IOException {
		// TODO
		return null;
	}

	/*
	 * [HV] The declared exception IOException is not actually thrown by the
	 * method openFiles(FileFilter) from type UIPluginContext
	 */
	@SuppressWarnings(""unused"")
	public File[] openFiles(FileFilter filter) throws IOException {
		// TODO
		return null;
	}

	public Progress getProgress() {
		return progress;
	}

	public UIContext getGlobalContext() {
		return (UIContext) super.getGlobalContext();
	}

	public UIPluginContext getRootContext() {
		return (UIPluginContext) super.getRootContext();
	}

	public void setTask(ProMTask task) {
		this.task = task;
	}

	/**
	 * Return the task being executed in this PluginContext; useful for registering new resources with this task.
	 * @return the task
	 */
	public ProMTask getTask() {
		return task;
	}

	public InteractionResult showConfiguration(String title, JComponent configuration) {
		if (task == null) {
			return InteractionResult.CANCEL;
		}
		assert (task.getAction().getType() == ActionType.INTERACTIVE);
		return task.showConfiguration(title, configuration);
	}

	public InteractionResult showWizard(String title, boolean first, boolean last, JComponent configuration) {
		if (task == null) {
			return InteractionResult.CANCEL;
		}
		assert (task.getAction().getType() == ActionType.INTERACTIVE);
		return task.showWizard(title, first, last, configuration);
	}

	@Override
	public UIPluginContext createChildContext(String label) {
		return (UIPluginContext) super.createChildContext(label);
	}
}

class FileChooserPropertyListener implements PropertyChangeListener {

	public FileChooserPropertyListener(String ext) {
		this.ext = ext.toLowerCase();
	}

	public String ext;

	public void propertyChange(PropertyChangeEvent evt) {
		if (evt.getPropertyName().equals(JFileChooser.FILE_FILTER_CHANGED_PROPERTY)) {
			ext = ((FileNameExtensionFilter) evt.getNewValue()).getExtensions()[0].toLowerCase();
		}
	}
}
"
HtmlPanel.java,prom-contexts-6.9.56,"package org.processmining.contexts.util;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URISyntaxException;

import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.JEditorPane;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;

import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.util.HTMLToString;

public class HtmlPanel extends javax.swing.JPanel implements HyperlinkListener {

	@Plugin(name = ""Visualize HTML text"", //
	level = PluginLevel.PeerReviewed,
	parameterLabels = { ""HTML text"" }, //
	returnLabels = { ""HTML panel"" }, //
	returnTypes = { HtmlPanel.class }, //
	userAccessible = true, //
	help = ""Visualizes HTML text."", mostSignificantResult = 1)
	@Visualizer
	public static HtmlPanel visualizeHTML(PluginContext context, HTMLToString htmlText) {
		return new HtmlPanel(htmlText.toHTMLString(true));
	}

	/**
	 * Opens hyperlinks in standard browser (see
	 * http://forums.sun.com/thread.jspa?threadID=5403426)
	 */
	public void hyperlinkUpdate(HyperlinkEvent event) {
		if (event.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
			try {
				Desktop.getDesktop().browse(event.getURL().toURI());
			} catch (IOException e) {
			} catch (URISyntaxException e) {
			}
		}
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = -8692121995363561628L;

	/** Creates new form HtmlReport */
	public HtmlPanel(String diagnosis) {
		initComponents(diagnosis);
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate=""collapsed"" desc=""Generated Code"">//GEN-BEGIN:initComponents
	private void initComponents(String diagnosis) {

		jScrollPane1 = new javax.swing.JScrollPane();
		jTextPane1 = new javax.swing.JEditorPane();
		jTextPane1.setEditable(false);
		jTextPane1.addHyperlinkListener(this);

		jTextPane1.setContentType(""text/html"");
		jTextPane1.setText(diagnosis);
		jScrollPane1.setViewportView(jTextPane1);

		GroupLayout layout = new GroupLayout(this);
		setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(Alignment.LEADING).addGroup(
				layout.createSequentialGroup().addContainerGap().addComponent(jScrollPane1, GroupLayout.DEFAULT_SIZE,
						641, Short.MAX_VALUE).addContainerGap()));
		layout.setVerticalGroup(layout.createParallelGroup(Alignment.LEADING).addGroup(
				layout.createSequentialGroup().addContainerGap().addComponent(jScrollPane1, GroupLayout.DEFAULT_SIZE,
						3860, Short.MAX_VALUE).addContainerGap()));
	}// </editor-fold>

	// Variables declaration - do not modify
	private javax.swing.JScrollPane jScrollPane1;
	private JEditorPane jTextPane1;
	// End of variables declaration
}
"
PortLabelCell.java,prom-contexts-6.9.56,"package org.processmining.contexts.util.jgraph;

import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.tree.MutableTreeNode;

import org.jgraph.graph.AttributeMap;
import org.jgraph.graph.DefaultGraphCell;
import org.jgraph.graph.GraphConstants;

public class PortLabelCell extends DefaultGraphCell {

	public PortLabelCell(Object o, Point2D topLeft) {
		super(o);
		if (topLeft == null) {
			topLeft = new Point2D.Double(20, 20);
		}
		GraphConstants.setBounds(getAttributes(), new Rectangle2D.Double(topLeft.getX(), topLeft.getY(), 10, 10));

	}

	public PortLabelCell(Object o, AttributeMap map, MutableTreeNode[] nodes) {
		super(o, map, nodes);
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = -3154130726739617209L;

}"
PortLabelVertexView.java,prom-contexts-6.9.56,"package org.processmining.contexts.util.jgraph;

import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Stroke;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;

import javax.swing.JLabel;
import javax.swing.JPanel;

import org.jgraph.JGraph;
import org.jgraph.graph.CellView;
import org.jgraph.graph.CellViewRenderer;
import org.jgraph.graph.GraphConstants;
import org.jgraph.graph.GraphModel;
import org.jgraph.graph.VertexRenderer;
import org.jgraph.graph.VertexView;

/**
 * 
 */
public class PortLabelVertexView extends VertexView {

	/**
	 * 
	 */
	private static final long serialVersionUID = -4669647479882266935L;

	/**
	 * the renderer for this view
	 */
	protected static WrapperPortLabelRenderer renderer = new WrapperPortLabelRenderer();

	protected CellView[] ports;

	/**
	 * Creates new instance of <code>InstanceView</code>.
	 */
	public PortLabelVertexView() {
		super();
	}

	/**
	 * Creates new instance of <code>InstanceView</code> for the specified graph
	 * cell.
	 * 
	 * @param arg0
	 *            a graph cell to create view for
	 */
	public PortLabelVertexView(Object arg0) {
		super(arg0);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.jgraph.graph.AbstractCellView#getRenderer()
	 */
	public CellViewRenderer getRenderer() {
		return renderer;
	}

	public static class WrapperPortLabelRenderer extends JPanel implements CellViewRenderer {

		/**
		 * 
		 */
		private static final long serialVersionUID = 5603848567918969169L;

		private transient static JLabel label = new JLabel();

		private transient static PortLabelVertexRenderer portLabelRenderer = new PortLabelVertexRenderer();

		/**
		 * Cache the current graph for drawing
		 */
		protected transient JGraph graph = null;

		transient protected Color gradientColor = null;

		/** Cached hasFocus and selected value. */
		transient protected boolean hasFocus, selected, preview;

		/**
		 * Constructs a renderer that may be used to render vertices.
		 */
		public WrapperPortLabelRenderer() {
			super(new BorderLayout());
			this.add(portLabelRenderer, BorderLayout.CENTER);
			this.add(label, BorderLayout.SOUTH);
			label.setOpaque(false);
			setOpaque(false);

		}

		public Component getRendererComponent(JGraph graph, CellView view, boolean sel, boolean focus, boolean preview) {
			portLabelRenderer.getRendererComponent(graph, view, sel, focus, preview);
			label.setText(view.getCell().toString());
			this.graph = graph;
			selected = sel;
			this.preview = preview;
			hasFocus = focus;
			installAttributes(view);
			return this;
		}

		public void paint(Graphics g) {
			if ((gradientColor != null) && !preview) {
				setOpaque(false);
				Graphics2D g2d = (Graphics2D) g;
				g2d.setPaint(new GradientPaint(0, 0, getBackground(), getWidth(), getHeight(), gradientColor, true));
				g2d.fillRect(0, 0, getWidth(), getHeight());
			}
			if (selected) {
				paintSelectionBorder(g);
			}
			super.paint(g);
		}

		protected void paintSelectionBorder(Graphics g) {
			Graphics2D g2 = (Graphics2D) g;
			Stroke previousStroke = g2.getStroke();
			float[] dash = new float[] { 5f, 5f };
			g2.setStroke(new BasicStroke(2, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f));
			g.setColor(Color.RED);
			g.drawRect(0, 0, getWidth() - 1, getHeight() - 1);
			g2.setStroke(previousStroke);
		}

		public Point2D getPerimeterPoint(VertexView view, Point2D source, Point2D p) {
			return portLabelRenderer.getPerimeterPoint(view, source, p);
		}

		protected void installAttributes(CellView view) {
			Map<?, ?> attributes = view.getAllAttributes();
			label.setVerticalAlignment(GraphConstants.getVerticalAlignment(attributes));
			label.setHorizontalAlignment(GraphConstants.getHorizontalAlignment(attributes));
			label.setVerticalTextPosition(GraphConstants.getVerticalTextPosition(attributes));
			label.setHorizontalTextPosition(GraphConstants.getHorizontalTextPosition(attributes));
			label.setFont(GraphConstants.getFont(attributes));
			gradientColor = GraphConstants.getGradientColor(attributes);
		}
	}

	/**
	 * The renderer class for instance view.
	 */
	public static class PortLabelVertexRenderer extends VertexRenderer {

		/**
		 * 
		 */
		private static final long serialVersionUID = -2599058809422643000L;

		protected CellView[] ports = null;

		protected FontMetrics fontMetrics = null;

		public static transient int PORTLABELSPACING = 5;

		public static transient int MINIMUMHORIZONTALSPACING = 15;

		public static transient int MINIMUMVERTICALSPACING = 2;

		/**
		 * The vertical distance added to the label height to make the color
		 * backdrop extend beyond the label text
		 */
		public static transient int COLORHEIGHTBUFFER = 4;

		/**
		 * The maximum width of a label, any label more than this value in width
		 */
		public static transient int MAXLABELWIDTH = 100;

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.awt.Component#paint(java.awt.Graphics)
		 */
		public void paint(Graphics g) {
			selected = false;
			super.paint(g);
			g.setColor(getForeground());
			paintPortLabels(g);
		}

		public Component getRendererComponent(JGraph graph, CellView view, boolean sel, boolean focus, boolean preview) {
			// Do not display the label, the wrapper does this
			setText(null);
			// Finds the ports and install them into the renderer
			Graphics2D g = (Graphics2D) graph.getGraphics();
			if (g != null) {
				fontMetrics = g.getFontMetrics();
				Object cell = view.getCell();
				GraphModel model = graph.getModel();
				int childCount = model.getChildCount(cell);
				List<CellView> result = new ArrayList<CellView>(childCount);
				for (int i = 0; i < childCount; i++) {
					Object child = model.getChild(cell, i);
					if (model.isPort(child)) {
						CellView portView = graph.getGraphLayoutCache().getMapping(child, false);
						if (portView != null) {
							result.add(portView);
						}
					}
				}

				ports = new CellView[result.size()];
				result.toArray(ports);
			}
			Component c = super.getRendererComponent(graph, view, sel, focus, preview);
			// Do not display the label, the wrapper does this
			setText(null);
			return c;
		}

		/**
		 * Install the attributes of specified cell in this renderer instance.
		 * This means, retrieve every published key from the cells hashtable and
		 * set global variables or superclass properties accordingly.
		 * 
		 * @param view
		 *            the cell view to retrieve the attribute values from.
		 */
		protected void installAttributes(CellView view) {
			Map<?, ?> map = view.getAllAttributes();
			setIcon(GraphConstants.getIcon(map));
			setOpaque(GraphConstants.isOpaque(map));
			setBorder(GraphConstants.getBorder(map));
			setVerticalAlignment(GraphConstants.getVerticalAlignment(map));
			setHorizontalAlignment(GraphConstants.getHorizontalAlignment(map));
			bordercolor = GraphConstants.getBorderColor(map);
			borderWidth = Math.max(1, Math.round(GraphConstants.getLineWidth(map)));
			setOpaque(false);
			setFont(GraphConstants.getFont(map));
		}

		/**
		 * Draws a <code>String</code>. Its horizontal position <code>x</code>
		 * is given and its vertical position is centered on given
		 * <code>y</code>.
		 * 
		 * @param g
		 *            a <code>Graphics2D</code> to draw with
		 * @param label
		 *            a <code>String</code> to draw
		 * @param x
		 *            an offset to left edge of the bounding box of vertex
		 * @param y
		 *            an offset to center of the string
		 * @param background
		 *            the background color, if any, behind the text
		 * @param isLeftLabel
		 *            whether or not this label is on the left-hand side of the
		 *            vertex
		 */
		public static void drawPortLabel(Graphics g, String labelValue, double x, double y, Color background,
				boolean isLeftLabel) {
			FontMetrics metrics = g.getFontMetrics();
			StringTokenizer st = new StringTokenizer(labelValue, ""\n"");
			List<String> labels = new ArrayList<String>(st.countTokens());
			while (st.hasMoreTokens()) {
				labels.add(st.nextToken());
			}
			double height = metrics.getStringBounds(labelValue, g).getHeight();
			double i = -.5;
			for (String label : labels) {

				int sw = metrics.stringWidth(label);
				// If string is longer than allowed, concat it, replacing excess
				// with ""...""
				int tries = 0;
				if (sw > MAXLABELWIDTH) {
					int dotLength = metrics.stringWidth(""..."");
					while ((sw > MAXLABELWIDTH) && (tries < 5)) {
						int characters = label.length();
						double stringRatio = (double) (MAXLABELWIDTH - dotLength) / (double) sw;
						int newStringLength = (int) (characters * stringRatio);
						// Shorten string with each try
						newStringLength -= tries;
						if (newStringLength < characters) {
							String newLabel = label.substring(0, newStringLength);
							newLabel += ""..."";
							int newStringWidth = metrics.stringWidth(newLabel);
							if (newStringWidth < MAXLABELWIDTH) {
								label = newLabel;
								sw = newStringWidth;
							}
						}
						tries++;
					}
				}
				int sh = metrics.getHeight();
				int offsetX = 0;
				if (isLeftLabel) {
					offsetX = PORTLABELSPACING;
				} else {
					offsetX = -sw - PORTLABELSPACING;
				}
				g.drawString(label, (int) x + offsetX, (int) ((y + sh / 2) + height * i));
				i += 1.0;
			}
		}

		/**
		 * Paints port labels the view.
		 * 
		 * @param g
		 *            a <code>Graphics2D</code> to draw with
		 */
		public void paintPortLabels(Graphics g) {
			if ((ports != null) && (ports.length > 0)) {
				CellView parentView = ports[0].getParentView();
				Rectangle2D bounds = GraphConstants.getBounds(parentView.getAllAttributes());
				// Get the bounds of the vertex and deduct twice the cell label
				// height plus the vertical buffer distance from it.
				double height = bounds.getHeight();
				Color oldBackground = getBackground();
				for (int i = 0; i < ports.length; i++) {
					String labelValue = ports[i].getCell().toString();
					if (labelValue == null) {
						labelValue = new String();
					}
					Point2D portOffset = GraphConstants.getOffset(ports[i].getAllAttributes());
					Color portBackground = GraphConstants.getBackground(ports[i].getAllAttributes());
					double x = 0;
					double y = 0;
					if (portOffset != null) {
						if (bounds != null) {
							// By x position should be 0 or the width of the
							// vertex
							x = portOffset.getX() * bounds.getWidth() / GraphConstants.PERMILLE;
							// The y position is the proportion of the vertex
							// height available for port label. Remember a bit
							// is reserved either end for the vertex label.
							y = portOffset.getY() * height / GraphConstants.PERMILLE;
							if (portOffset.getX() == 0) {
								drawPortLabel(g, labelValue, x, y, portBackground, true);
							} else if (portOffset.getX() == GraphConstants.PERMILLE) {
								drawPortLabel(g, labelValue, x, y, portBackground, false);
							}
						}
					}
				}
				setBackground(oldBackground);
			}
		}

		public Dimension getPreferredSize() {
			Dimension vertexPreferredSize = super.getPreferredSize();
			if ((ports != null) && (fontMetrics != null)) {
				int heightPerLabel = fontMetrics.getHeight() + MINIMUMVERTICALSPACING;
				double left = 0, right = 0;
				double maxLeft = 0, maxRight = 0;
				for (int i = 0; i < ports.length; i++) {
					String labelValue = ports[i].getCell().toString();
					if (labelValue == null) {
						labelValue = """";
					}
					StringTokenizer st = new StringTokenizer(labelValue, ""\n"");
					List<String> labels = new ArrayList<String>(st.countTokens());
					while (st.hasMoreTokens()) {
						labels.add(st.nextToken());
					}
					Point2D portOffset = GraphConstants.getOffset(ports[i].getAllAttributes());
					if (portOffset != null) {
						for (String label : labels) {
							int sw = fontMetrics.stringWidth(label);
							// Limit the size of labels to MAXLABELWIDTH
							if (sw > MAXLABELWIDTH) {
								sw = MAXLABELWIDTH;
							}
							if (portOffset.getX() == 0) {
								left += heightPerLabel;
								maxLeft = Math.max(maxLeft, sw);
							} else if (portOffset.getX() == GraphConstants.PERMILLE) {
								right += heightPerLabel;
								maxRight = Math.max(maxRight, sw);
							}
						}
					}
				}
				int maxX = 1 + Math.max((int) vertexPreferredSize.getWidth(),
						(2 * MAXLABELWIDTH + MINIMUMHORIZONTALSPACING));//(maxLeft + maxRight + MINIMUMHORIZONTALSPACING));
				return new Dimension(maxX, (int) Math.max(left, right));
			}
			return vertexPreferredSize;
		}
	}
}"
StringVisualizer.java,prom-contexts-6.9.56,"package org.processmining.contexts.util;

import java.awt.Color;

import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;

import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;

import com.fluxicon.slickerbox.factory.SlickerDecorator;

public class StringVisualizer {

	@Visualizer
	@Plugin(name = ""String Visualizer"", parameterLabels = ""String"", returnLabels = ""Label of String"", returnTypes = JComponent.class)
	public static JComponent visualize(PluginContext context, String tovisualize) {
		JScrollPane sp = new JScrollPane();
		sp.setOpaque(false);
		sp.getViewport().setOpaque(false);
		sp.setBorder(BorderFactory.createEmptyBorder());
		sp.setViewportBorder(BorderFactory.createLineBorder(new Color(10, 10, 10), 2));
		sp.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		sp.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		SlickerDecorator.instance().decorate(sp.getVerticalScrollBar(), new Color(0, 0, 0, 0),
				new Color(140, 140, 140), new Color(80, 80, 80));
		sp.getVerticalScrollBar().setOpaque(false);

		JLabel l = new JLabel(tovisualize);
		sp.setViewportView(l);

		return sp;
	}
}
"
ToolTipComboBox.java,prom-contexts-6.9.56,"package org.processmining.contexts.util;

/***********************************************************
 * This software is part of the ProM package * http://www.processmining.org/ * *
 * Copyright (c) 2003-2006 TU/e Eindhoven * and is licensed under the * Common
 * Public License, Version 1.0 * by Eindhoven University of Technology *
 * Department of Information Systems * http://is.tm.tue.nl * *
 **********************************************************/

import java.awt.Component;
import java.util.Vector;

import javax.swing.ComboBoxModel;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JList;
import javax.swing.plaf.basic.BasicComboBoxRenderer;

/**
 * <p>
 * Title:
 * </p>
 * 
 * <p>
 * Description:
 * </p>
 * 
 * <p>
 * Copyright: Copyright (c) 2004
 * </p>
 * 
 * <p>
 * Company:
 * </p>
 * 
 * @author not attributable
 * @version 1.0
 */
public class ToolTipComboBox extends JComboBox {
	/**
	 * 
	 */
	private static final long serialVersionUID = -492241585719051368L;

	/**
	 * Creates a <code>ToolTipComboBox</code> that takes it's items from an
	 * existing <code>ComboBoxModel</code>. Since the <code>ComboBoxModel</code>
	 * is provided, a combo box created using this constructor does not create a
	 * default combo box model and may impact how the insert, remove and add
	 * methods behave.
	 * 
	 * @param aModel
	 *            the <code>ComboBoxModel</code> that provides the displayed
	 *            list of items
	 * @see DefaultComboBoxModel
	 */
	public ToolTipComboBox(ComboBoxModel aModel) {
		super(aModel);
		setRenderer(new ToolTipComboBoxRenderer());
	}

	/**
	 * Creates a <code>ToolTipComboBox</code> that contains the elements in the
	 * specified array. By default the first item in the array (and therefore
	 * the data model) becomes selected.
	 * 
	 * @param items
	 *            an array of objects to insert into the combo box
	 * @see DefaultComboBoxModel
	 */
	public ToolTipComboBox(final Object items[]) {
		super(items);
		setRenderer(new ToolTipComboBoxRenderer());
	}

	/**
	 * Creates a <code>ToolTipComboBox</code> that contains the elements in the
	 * specified Vector. By default the first item in the vector and therefore
	 * the data model) becomes selected.
	 * 
	 * @param items
	 *            an array of vectors to insert into the combo box
	 * @see DefaultComboBoxModel
	 */
	public ToolTipComboBox(Vector<?> items) {
		super(items);
		setRenderer(new ToolTipComboBoxRenderer());
	}

	/**
	 * Creates a <code>ToolTipComboBox</code> with a default data model. The
	 * default data model is an empty list of objects. Use <code>addItem</code>
	 * to add items. By default the first item in the data model becomes
	 * selected.
	 * 
	 * @see DefaultComboBoxModel
	 */
	public ToolTipComboBox() {
		super();
		setRenderer(new ToolTipComboBoxRenderer());
	}
}

class ToolTipComboBoxRenderer extends BasicComboBoxRenderer {
	/**
	 * 
	 */
	private static final long serialVersionUID = 513853339785774728L;

	public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected,
			boolean cellHasFocus) {
		if (isSelected) {
			setBackground(list.getSelectionBackground());
			setForeground(list.getSelectionForeground());
			if (-1 < index) {
				list.setToolTipText(value.toString());
			}
		} else {
			setBackground(list.getBackground());
			setForeground(list.getForeground());
		}
		setFont(list.getFont());
		setText((value == null) ? """" : value.toString());
		return this;
	}
}
"
AbstractImportPlugin.java,prom-framework-6.9.97,"package org.processmining.framework.abstractplugins;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.net.URI;
import java.net.URL;

import javax.swing.filechooser.FileFilter;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.PluginVariant;

/**
 * Note that implementing classes of this baseclass should carry the
 * UIImportPlugin annotation
 * 
 * Subclasses of AbstractImportPlugin should use the @Plugin Annotation as
 * follows:
 * 
 * @Plugin( name = ""{any name}"", parameterLabels={""Filename""}, returnLabels = {
 *          {The right return labels} }, returnTypes = { {The right return
 *          classes} })
 * 
 * 
 * @author bfvdonge
 * 
 */
public abstract class AbstractImportPlugin implements ImportPlugin {

	private File file = null;

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.plugins.abstractplugins.ImportPlugin#getFile()
	 */
	public File getFile() {
		return file;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.plugins.abstractplugins.ImportPlugin#importFile(org
	 * .processmining.framework.plugin.PluginContext, java.lang.String)
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, String filename) throws Exception {
		file = new File(filename);
		return importFromStream(context, new FileInputStream(file), filename, file.length());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.plugins.abstractplugins.ImportPlugin#importFile(org
	 * .processmining.framework.plugin.PluginContext, java.net.URI)
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, URI uri) throws Exception {
		return importFromStream(context, uri.toURL().openStream(), uri.toString(), 0);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.plugins.abstractplugins.ImportPlugin#importFile(org
	 * .processmining.framework.plugin.PluginContext, java.net.URL)
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, URL url) throws Exception {
		file = new File(url.toURI());
		return importFromStream(context, url.openStream(), url.toString(), 0);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.plugins.abstractplugins.ImportPlugin#importFile(org
	 * .processmining.framework.plugin.PluginContext, java.io.File)
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, File f) throws Exception {
		file = f;
		InputStream stream = getInputStream(f);
		return importFromStream(context, stream, file.getName(), file.length());
	}

	/**
	 * This method returns an inputStream for a file. Note that the default
	 * implementation returns ""new FileInputStream(file);""
	 * 
	 * @param file
	 * @return
	 * @throws FileNotFoundException
	 */
	protected InputStream getInputStream(File file) throws Exception {
		return new FileInputStream(file);
	}

	/**
	 * This method is called by all plugin variants to do the actual importing.
	 * 
	 * @param context
	 * @param input
	 * @param filename
	 * @param fileSizeInBytes
	 * @return
	 * @throws Exception
	 */
	protected abstract Object importFromStream(PluginContext context, InputStream input, String filename,
			long fileSizeInBytes) throws Exception;

}

class ZipFilter extends FileFilter {

	private final FileFilter parent;

	public ZipFilter(FileFilter parent) {
		this.parent = parent;
	}

	public boolean accept(File f) {
		return (f.getAbsolutePath().endsWith("".zip"") || parent.accept(f));
	}

	public String getDescription() {
		return parent.getDescription();
	}

}"
ImportPlugin.java,prom-framework-6.9.97,"package org.processmining.framework.abstractplugins;

import java.io.File;
import java.net.URI;
import java.net.URL;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.PluginVariant;

/**
 * This interface should be implemented by plugins that serve as input plugins.
 * 
 * Such a plugin should have the @Plugin annotation on the class level and does
 * not have to define any variants, as these are defined in the interface.
 * 
 * @author bfvdonge
 * 
 */

public interface ImportPlugin {

	/**
	 * Returns the File object this plugin was instantiated with.
	 * 
	 * @return
	 */
	public File getFile();

	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, String filename) throws Exception;

	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, URI uri) throws Exception;

	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, URL url) throws Exception;

	@PluginVariant(requiredParameterLabels = { 0 })
	public Object importFile(PluginContext context, File f) throws Exception;

}"
AuthoredType.java,prom-framework-6.9.97,"package org.processmining.framework.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE })
public @interface AuthoredType {

	public final static String TUE = ""Eindhoven University of Technology"";

	/**
	 * Specifies the user-readable type for this class
	 * 
	 * @return
	 */
	String typeName();

	/**
	 * Specifies the affiliation of the author
	 * 
	 * @return
	 */
	String affiliation();

	/**
	 * specifies the e-mail address of the author
	 * 
	 * @return
	 */
	String email();

	/**
	 * Specifies the name of the author
	 * 
	 * @return
	 */
	String author();

	/**
	 * Specifies the website of the author (note that this should be URL style,
	 * i.e. with http://)
	 * 
	 * @return
	 */
	String website() default ""http://www.processmining.org"";

}
"
Icon.java,prom-framework-6.9.97,"package org.processmining.framework.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.TYPE })
public @interface Icon {

	/**
	 * Specifies the relative path to the icon to be loaded if this type has to
	 * be represented by an Icon
	 * 
	 * @return
	 */
	public String icon();
}
"
TestMethod.java,prom-framework-6.9.97,"package org.processmining.framework.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * By adding this annotation to a method, the method is flagged as a test method
 * for ProM. A hudson server should, on each commit, find all methods annotated
 * with this annotation and exectute it.
 * 
 * The method should not require parameters and should be declared static. The
 * return type of the method should be: <code>String</code>.
 * 
 * The string returned by this method is compared to either the string defined
 * in the output field, or with the contents of the file indicated by
 * filename().
 * 
 * If both filename and output are specified, then only output is used and the
 * file is ignored.
 * 
 * @author bfvdonge
 * 
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
public @interface TestMethod {

	String filename() default """";

	String output() default """";
	
	boolean returnSystemOut() default false;

}
"
AddJarsForPackageRunnable.java,prom-framework-6.9.97,"package org.processmining.framework.boot;

import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.util.PathHacker;

/**
 * Threaded implementation of the addJarsForPackage method
 * 
 * @author berti
 *
 */
public class AddJarsForPackageRunnable extends Thread {
	PackageDescriptor pack;
	Level verbose;
	PluginManager plugins;
	
	public AddJarsForPackageRunnable(PackageDescriptor pack, Level verbose, PluginManager plugins) {
		this.pack = pack;
		this.verbose = verbose;
		this.plugins = plugins;
	}
	
	/**
	 * Entry point for thread
	 */
	public void run() {
		if (verbose == Level.ALL) {
			System.out.println(""Scanning package: "" + pack);
		}
		File dir = pack.getLocalPackageDirectory();
		if (!dir.exists() || !dir.isDirectory() || !dir.canRead()) {
			if (verbose == Level.ALL) {
				System.out.println(""  Error: package directory does not exist: "" + dir);
			}
			return;
		}
		// First, recusively iterate subfolders, where no scanning for plugins is necessary
		// this ensures all requires libraries are known when scanning for plugins
		for (File f : dir.listFiles()) {
			// Scan for jars. Only jars in the root of the package will be scanned for
			// plugins and other annotations.
			if (f.isDirectory()) {
				Boot.addJarsFromPackageDirectory(f, verbose, plugins);
				try {
					Boot.addURLToClasspath(f.toURI().toURL());
				} catch (MalformedURLException e) {
				}
			}
		}
		
		// Now scan the jar files in the package root folder.
		for (File f : dir.listFiles()) {
			if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
				URL url;
				try {
					url = f.toURI().toURL();
					if (verbose == Level.ALL) {
						System.out.println(""  scanning for plugins: "" + url);
					}
					Boot.addURLToClasspath(url);
					if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
						plugins.register(url, pack);
					}
				} catch (MalformedURLException e) {
					e.printStackTrace();
				}
			}
		}
		
		List<Thread> subthreads = new ArrayList<Thread>();
		PathHacker.addLibraryPathFromDirectory(pack.getLocalPackageDirectory());
		try {
			PathHacker.addJar(pack.getLocalPackageDirectory().toURI().toURL());
			for (File f : pack.getLocalPackageDirectory().listFiles()) {
				if (f.isDirectory()) {
					PathHackerRunnable runnable = new PathHackerRunnable(pack, verbose, plugins, f);
					subthreads.add(runnable);
					subthreads.get(subthreads.size()-1).start();
				}
			}
		} catch (MalformedURLException e) {
			assert (false);
		}
				
		for (Thread t : subthreads) {
			try {
				t.join();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}
"
Boot.java,prom-framework-6.9.97,"package org.processmining.framework.boot;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.prefs.Preferences;

import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageManager;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginQuality;
import org.processmining.framework.plugin.impl.PluginManagerImpl;
import org.processmining.framework.util.CommandLineArgumentList;
import org.processmining.framework.util.OsUtil;
import org.processmining.framework.util.PathHacker;

public class Boot {

	public static enum Level {
		NONE, ERROR, ALL

	}

	public static String PROM_VERSION;
	public static String RELEASE_PACKAGE;
	public static String LIB_FOLDER;
	public static String IMAGES_FOLDER;
	public static String PROM_USER_FOLDER;
	public static String MACRO_FOLDER;
	public static String PACKAGE_FOLDER;
	public static String WORKSPACE_FOLDER;
	public static PluginQuality PLUGIN_QUALITY_THRESHOLD;
	public static PluginLevel PLUGIN_LEVEL_THRESHOLD;
	public static Level VERBOSE;
	public static URL DEFAULT_REPOSITORY;
	public static int OPENXES_SHADOW_SIZE;
	public static int CONNECT_TIMEOUT;
	public static int READ_TIMEOUT;

	public static boolean HIDE_OLD_PACKAGES;
	public static boolean CHECK_PACKAGES;

	public static String AUTO_UPDATE;

	public final static String LAST_RELEASE_AUTOINSTALLED_KEY = ""last_release_autoinstalled"";
	public static final String LAST_RELEASE_PACKAGE_KEY = ""last_release_package_installed"";
	public final static String TRACKING_BY_GA_ALLOWED = ""tracking_by_GA_allowed"";

	/**
	 * Versions of ProM.Lite should have a PROM_VERSION in the ini file that
	 * identifies the specific version. This should be prefixed by the
	 * LITE_PREFIX
	 */
	public static final String LITE_PREFIX = "".Lite"";

	static {

		/*
		 * Preset defaults, just in case something fails down th eroad.
		 */
		PROM_VERSION = """";
		RELEASE_PACKAGE = ""RunnerUpPackages"";
		VERBOSE = Level.NONE;
		LIB_FOLDER = ""lib"";
		IMAGES_FOLDER = ""images"";
		MACRO_FOLDER = ""macros"";
		try {
			DEFAULT_REPOSITORY = new URL(""http://www.promtools.org/prom6/packages/packages.xml"");
		} catch (MalformedURLException e1) {
			e1.printStackTrace();
		}
		PROM_USER_FOLDER = System.getProperty(""user.home"", """") + File.separator + "".ProM"";
		PACKAGE_FOLDER = PROM_USER_FOLDER + File.separator + ""packages"";
		WORKSPACE_FOLDER = PROM_USER_FOLDER + File.separator + ""workspace"";
		HIDE_OLD_PACKAGES = false;
		CHECK_PACKAGES = false;
		PLUGIN_QUALITY_THRESHOLD = PluginQuality.VeryPoor;
		PLUGIN_LEVEL_THRESHOLD = PluginLevel.Local;
		CONNECT_TIMEOUT = 100;
		READ_TIMEOUT = 1000;

		Properties ini = new Properties();
		FileInputStream is;
		try {
			is = new FileInputStream(""ProM.ini"");

			try {
				ini.load(is);
				is.close();

				if (!ini.containsKey(""PROM_VERSION"") || !ini.containsKey(""RELEASE_PACKAGE"")) {
					throw new RuntimeException(""Error while reading ProM.ini file, missing required""
							+ "" keys PROM_VERSION and or RELEASE_PACKAGE . Exiting ProM."");
				}

				PROM_VERSION = ini.getProperty(""PROM_VERSION"");
				if (!PROM_VERSION.contains(""."")) {
					PROM_VERSION = """";
				}

				RELEASE_PACKAGE = ini.getProperty(""RELEASE_PACKAGE"");

				//		OPENXES_SHADOW_SIZE = Integer.parseInt(ini.getProperty(""OPENXES_SHADOW_SIZE"", ""4""));
				//		NikeFS2FileAccessMonitor.instance(OPENXES_SHADOW_SIZE);

				CONNECT_TIMEOUT = Integer.parseInt(ini.getProperty(""CONNECT_TIMEOUT"", ""100""));
				READ_TIMEOUT = Integer.parseInt(ini.getProperty(""READ_TIMEOUT"", ""1000""));

				try {
					VERBOSE = Level.valueOf(ini.getProperty(""VERBOSE"", Level.ALL.name()));
				} catch (IllegalArgumentException e) {
					if (e.getMessage().toLowerCase().endsWith("".true"")) {
						VERBOSE = Level.ALL;
					} else if (e.getMessage().toLowerCase().endsWith("".false"")) {
						VERBOSE = Level.NONE;
					} else {
						throw e;
					}
				}

				LIB_FOLDER = ini.getProperty(""LIB_FOLDER"", ""lib"").replace(""/"", File.separator);
				PathHacker.addLibraryPathFromDirectory(new File(""."" + File.separator + LIB_FOLDER));

				IMAGES_FOLDER = LIB_FOLDER + File.separator
						+ ini.getProperty(""IMAGES_FOLDER"", ""images"").replace(""/"", File.separator);
				PathHacker.addLibraryPathFromDirectory(new File(""."" + File.separator + IMAGES_FOLDER));

				MACRO_FOLDER = LIB_FOLDER + File.separator
						+ ini.getProperty(""MACRO_FOLDER"", ""macros"").replace(""/"", File.separator);
				PathHacker.addLibraryPathFromDirectory(new File(""."" + File.separator + MACRO_FOLDER));

				String defaultRepository = ""http://www.promtools.org/prom6/packages""
						+ PROM_VERSION.replaceAll(""\\."", """") + ""/packages.xml"";
				String repository = getBestRepository(ini.getProperty(""PACKAGE_URL"", defaultRepository).split("" ""),
						defaultRepository);

				try {
					DEFAULT_REPOSITORY = new URL(repository);
				} catch (MalformedURLException e) {
					try {
						DEFAULT_REPOSITORY = new URL(defaultRepository);
					} catch (MalformedURLException e1) {
						assert (false);
					}
				}

				String prom_user_folder = ini.getProperty(""PROM_USER_FOLDER"", """").replace(""/"", File.separator);
				if (prom_user_folder.equals("""")) {
					PROM_USER_FOLDER = System.getProperty(""user.home"", """") + File.separator + "".ProM""
							+ PROM_VERSION.replaceAll(""\\."", """");
				} else {
					PROM_USER_FOLDER = prom_user_folder;
				}

				PACKAGE_FOLDER = PROM_USER_FOLDER + File.separator
						+ ini.getProperty(""PACKAGE_FOLDER"", ""packages"").replace(""/"", File.separator);

				WORKSPACE_FOLDER = PROM_USER_FOLDER + File.separator
						+ ini.getProperty(""WORKSPACE_FOLDER"", ""workspace"").replace(""/"", File.separator);

				HIDE_OLD_PACKAGES = new Boolean(ini.getProperty(""HIDE_OLD_PACKAGES"", ""false""));
				CHECK_PACKAGES = new Boolean(ini.getProperty(""CHECK_PACKAGES"", ""false""));
				AUTO_UPDATE = new String(ini.getProperty(""AUTO_UPDATE"", ""never""));

				PLUGIN_QUALITY_THRESHOLD = PluginQuality.VeryPoor;
				String threshold = ini.getProperty(""PLUGIN_QUALITY_THRESHOLD"", PLUGIN_QUALITY_THRESHOLD.getName());
				for (PluginQuality quality : PluginQuality.values()) {
					if (quality.getName().equals(threshold)) {
						PLUGIN_QUALITY_THRESHOLD = quality;
						break;
					}
				}

				PLUGIN_LEVEL_THRESHOLD = PluginLevel.Local;
				threshold = ini.getProperty(""PLUGIN_LEVEL_THRESHOLD"", PLUGIN_LEVEL_THRESHOLD.getName());
				for (PluginLevel level : PluginLevel.values()) {
					if (level.getName().equals(threshold)) {
						PLUGIN_LEVEL_THRESHOLD = level;
						break;
					}
				}

				if (VERBOSE == Level.ALL) {
					System.out.println(""Plug-in level threshold set to "" + PLUGIN_LEVEL_THRESHOLD.getName());
					System.out.println(""Plug-in quality threshold set to "" + PLUGIN_QUALITY_THRESHOLD.getName());
					System.out.println(""Ini file processed"");
				}
			} catch (IOException e) {
				//					throw new RuntimeException(""Error while reading ProM.ini file. Exiting ProM."", e);
				if (VERBOSE != Level.NONE) {
					System.err.println(""Error while reading ProM.ini file.\n"" + e + ""\nReverting to default settings."");
				}
			}
		} catch (FileNotFoundException e) {
			//				throw new RuntimeException(""ProM.ini file not found. Exiting ProM."", e);
			if (VERBOSE != Level.NONE) {
				System.err.println(""ProM.ini file not found.\n"" + e + ""\nReverting to default settings."");
			}
		}

	}

	/*
	 * Gets the best repository from a list of repositories, where best means
	 * the one that responds fastest. To measure the latter, we read only the
	 * first character from the stream, and measure the wall-clock time this
	 * took. If no repository can be returned, the default repository is
	 * returned.
	 */
	public static String getBestRepository(String[] repositories, String defaultRepository) {
		/*
		 * The best repository so far.
		 */
		String bestRepository = defaultRepository;
		/*
		 * If no repositories are provided, use only the default repository.
		 */
		if (repositories.length == 0) {
			repositories = new String[] { defaultRepository };
		}
		/*
		 * If there is only a single repository, that one has to be the best
		 * one.
		 */
		if (repositories.length == 1) {
			bestRepository = repositories[0];
		} else {
			/*
			 * Multiple repositories. Try to get them to respond, and use the
			 * one that responds the fastest.
			 */
			bestRepository = null;
			long bestTime = 0;
			/*
			 * Have a 'dry run' with i = -1, which actually connects to the
			 * first repository.
			 */
			for (int i = -1; i < repositories.length; i++) {
				try {
					/*
					 * Setup a connection...
					 */
					URL url = new URL(repositories[i < 0 ? 0 : i]);
					URLConnection conn = url.openConnection();
					if (conn instanceof HttpURLConnection) {
						HttpURLConnection httpCon = (HttpURLConnection) conn;
						if (Boot.CONNECT_TIMEOUT > 0) {
							httpCon.setConnectTimeout(Boot.CONNECT_TIMEOUT);
						}
						if (Boot.READ_TIMEOUT > 0) {
							httpCon.setReadTimeout(Boot.READ_TIMEOUT);
						}
					}
					/*
					 * ...and a stream.
					 */
					InputStream stream = conn.getInputStream();
					/*
					 * Try to read some first characters on the stream.
					 */
					long time = -System.nanoTime();
					for (int j = 0; j < 10; j++) {
						stream.read();
					}
					time += System.nanoTime();
					/*
					 * Do not weigh this time too much, to take setup times into account.
					 */
					time /= 1000;
					/*
					 * Try to read some additional characters on the stream.
					 */
					time -= System.nanoTime();
					for (int j = 0; j < 1000; j++) {
						stream.read();
					}
					time += System.nanoTime();
					/*
					 * Stream can now be closed.
					 */
					stream.close();
					/*
					 * If not a dry run, see whether this repository is better.
					 */
					if (i >= 0) {
						System.out.println(""[Boot] Repository "" + repositories[i] + "" took "" + time + "" nanoseconds."");
						/*
						 * Update the best repository and the best time, if
						 * needed.
						 */
						if (bestRepository == null || time < bestTime) {
							bestRepository = repositories[i];
							bestTime = time;
							System.out.println(""[Boot] New best repository "" + repositories[i]);
						}
					}
				} catch (MalformedURLException e) {
					System.err.println(""[Boot] URL error with repository "" + repositories[i < 0 ? 0 : i] + "": "" + e.getMessage());
				} catch (IOException e) {
					System.err.println(""[Boot] I/O error with repository "" + repositories[i < 0 ? 0 : 1] + "": "" + e.getMessage());
				}
			}
			/*
			 * Fail safe: If no repository was found, use the default one.
			 */
			if (bestRepository == null) {
				bestRepository = defaultRepository;
			}
		}
		/*
		 * Return the best repository found.
		 */
		return bestRepository;
	}

	public static boolean isLatestReleaseInstalled() {
		return Preferences.userNodeForPackage(Boot.class).get(LAST_RELEASE_AUTOINSTALLED_KEY, """").equals(PROM_VERSION)
				&& Preferences.userNodeForPackage(Boot.class).get(LAST_RELEASE_PACKAGE_KEY, """").equals(RELEASE_PACKAGE);
	}

	public static void setReleaseInstalled(String version, String releasePackage) {
		Preferences.userNodeForPackage(Boot.class).put(LAST_RELEASE_AUTOINSTALLED_KEY, version);
		Preferences.userNodeForPackage(Boot.class).put(LAST_RELEASE_PACKAGE_KEY, releasePackage);
	}

	public static void setLatestReleaseInstalled() {
		setReleaseInstalled(PROM_VERSION, RELEASE_PACKAGE);
	}

	public static boolean isTrackingByGAAllowed() {
		return Preferences.userNodeForPackage(Boot.class).get(TRACKING_BY_GA_ALLOWED, ""false"").equals(""true"");
	}

	public static void boot(Class<?> bootClass, Class<? extends PluginContext> pluginContextClass, String... args)
			throws Exception {
		long start = System.currentTimeMillis();
		// First instantiate the package manager
		PackageManager packages = PackageManager.getInstance();
		// Then the plugin manager, as it listens to the package manager
		PluginManagerImpl.initialize(pluginContextClass);
		PluginManager plugins = PluginManagerImpl.getInstance();

		OsUtil.setWorkingDirectoryAtStartup();

		long startPackages = System.currentTimeMillis();
		packages.initialize(VERBOSE);
		if (VERBOSE == Level.ALL) {
			System.out.println("">>> Scanning for packages took "" + (System.currentTimeMillis() - startPackages)
					/ 1000.0 + "" seconds"");
		}

		long startPlugins = System.currentTimeMillis();
		URLClassLoader sysloader = (URLClassLoader) ClassLoader.getSystemClassLoader();
		URL[] defaultURLs = sysloader.getURLs();

		//	new URLClassLoader(new URL[] { packages.getPackagesDirectory().toURL() });

		if (VERBOSE == Level.ALL) {
			for (URL def : defaultURLs) {
				System.out.println(""known jar file: "" + def);
			}
			System.out.println(""Loading plugins from packages."");
		}

		/**
		 * (berti) Made ""addJarsForPackage"" method as thread to use parallelism
		 */
		List<Thread> loadingThreadsPackage = new ArrayList<Thread>();
		for (PackageDescriptor pack : packages.getEnabledPackages()) {
			if (VERBOSE == Level.ALL) {
				System.out.println(""Processing Package: "" + pack.getName());
			}
			//addJarsForPackage(pack, VERBOSE, plugins);
			AddJarsForPackageRunnable addJarsForPackage = new AddJarsForPackageRunnable(pack, VERBOSE, plugins);
			loadingThreadsPackage.add(addJarsForPackage);
			loadingThreadsPackage.get(loadingThreadsPackage.size() - 1).start();
		}

		// wait for each thread to finish the job before continuing
		for (Thread t : loadingThreadsPackage) {
			t.join();
		}

		if (VERBOSE == Level.ALL) {
			System.out.println(""Loading from: classpath"");
		}

		File f = new File(""."" + File.separator + LIB_FOLDER);
		String libPath = f.getCanonicalPath();
		addURLToClasspath(f.toURI().toURL());
		for (URL url : defaultURLs) {
			if (VERBOSE == Level.ALL) {
				System.out.println(""Processing url: "" + url);
			}
			if (!(new File(url.toURI()).getCanonicalPath().startsWith(libPath))) {
				if (VERBOSE == Level.ALL) {
					System.out.println(""Scanning for plugins: "" + url);
				}
				plugins.register(url, null);
			} else {
				if (VERBOSE == Level.ALL) {
					System.out.println(""Skipping: "" + url.getFile() + "" while scanning for plugins."");
				}
			}
		}

		//		for (URL url : sysloader.getURLs()) {
		//			System.err.println(""URL = "" + url);
		//		}

		if (VERBOSE == Level.ALL) {
			System.out.println("">>> Scanning for plugins took "" + (System.currentTimeMillis() - startPlugins) / 1000.0
					+ "" seconds"");
		}

		boot(bootClass, args);

		if (VERBOSE == Level.ALL) {
			System.out.println("">>> Total startup took "" + (System.currentTimeMillis() - start) / 1000.0 + "" seconds"");
		}
	}

	/*
	 * (non-Javadoc) * @see
	 * org.processmining.framework.plugin.PluginManager#boot(java.lang.Class,
	 * java.lang.String[])
	 */
	public static Object boot(Class<?> bootClass, String... args) throws Exception {
		Method bootMethod = null;

		for (Method method : bootClass.getMethods()) {
			if (method.isAnnotationPresent(Bootable.class)) {
				if (bootMethod == null) {
					bootMethod = method;
				} else {
					throw new IllegalArgumentException(""Cannot have more than one @Bootable method in a class"");
				}
			}
		}
		if (bootMethod == null) {
			throw new IllegalArgumentException(""No @Bootable annotation found: "" + bootClass.getName());
		}

		CommandLineArgumentList argList = new CommandLineArgumentList();
		for (String arg : args) {
			argList.add(arg);
		}

		return bootMethod.invoke(bootMethod.getDeclaringClass().newInstance(), argList);
	}

	public static void addJarsForPackage(PackageDescriptor pack, Boot.Level verbose, PluginManager plugins) {
		if (verbose == Level.ALL) {
			System.out.println(""Scanning package: "" + pack);
		}
		File dir = pack.getLocalPackageDirectory();
		if (!dir.exists() || !dir.isDirectory() || !dir.canRead()) {
			if (verbose == Level.ALL) {
				System.out.println(""  Error: package directory does not exist: "" + dir);
			}
			return;
		}
		// First, recusively iterate subfolders, where no scanning for plugins is necessary
		// this ensures all requires libraries are known when scanning for plugins
		for (File f : dir.listFiles()) {
			// Scan for jars. Only jars in the root of the package will be scanned for
			// plugins and other annotations.
			if (f.isDirectory()) {
				addJarsFromPackageDirectory(f, verbose, plugins);
				try {
					addURLToClasspath(f.toURI().toURL());
				} catch (MalformedURLException e) {
				}
			}
		}
		// Now scan the jar files in the package root folder.
		for (File f : dir.listFiles()) {
			if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
				URL url;
				try {
					url = f.toURI().toURL();
					if (verbose == Level.ALL) {
						System.out.println(""  scanning for plugins: "" + url);
					}
					addURLToClasspath(url);
					if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
						plugins.register(url, pack);
					}
				} catch (MalformedURLException e) {
					e.printStackTrace();
				}
			}

		}
		PathHacker.addLibraryPathFromDirectory(pack.getLocalPackageDirectory());
		try {
			PathHacker.addJar(pack.getLocalPackageDirectory().toURI().toURL());
			for (File f : pack.getLocalPackageDirectory().listFiles()) {
				if (f.isDirectory()) {
					PathHacker.addJar(f.toURI().toURL());
				}
			}
		} catch (MalformedURLException e) {
			assert (false);
		}

	}

	/**
	 * Scan for jars and add them to the classpath.
	 * 
	 * @param dir
	 *            the folder (or jar file) to scan
	 * @param verbose
	 *            true if output required
	 * @param plugins
	 *            the plugin manager
	 * @param scanClasses
	 *            If true, then all classes are scanned for annotations and for
	 *            plugins. This property recusively propagates to sub-folders.
	 */
	static void addJarsFromPackageDirectory(File dir, Boot.Level verbose, PluginManager plugins) {

		for (File f : dir.listFiles()) {
			if (f.isDirectory()) {
				addJarsFromPackageDirectory(f, verbose, plugins);
			}
		}
		for (File f : dir.listFiles()) {
			if (f.getAbsolutePath().endsWith(PluginManager.JAR_EXTENSION)) {
				try {
					URL url = f.toURI().toURL();
					if (verbose == Level.ALL) {
						System.out.println(""  adding to classpath: "" + url);
					}
					addURLToClasspath(url);
				} catch (MalformedURLException e) {
					e.printStackTrace();

				}
			}
		}
	}

	static void addURLToClasspath(URL url) {
		try {
			URLClassLoader sysloader = (URLClassLoader) ClassLoader.getSystemClassLoader();
			Method method = URLClassLoader.class.getDeclaredMethod(""addURL"", new Class<?>[] { URL.class });

			method.setAccessible(true);
			method.invoke(sysloader, new Object[] { url });
		} catch (Throwable t) {
			t.printStackTrace();
		}
	}
}
"
PathHackerRunnable.java,prom-framework-6.9.97,"package org.processmining.framework.boot;

import java.io.File;
import java.net.MalformedURLException;

import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.util.PathHacker;

/**
 * Threaded executions of PathHacker addJar
 * 
 * @author berti
 *
 */
public class PathHackerRunnable extends Thread {
	PackageDescriptor pack;
	Level verbose;
	PluginManager plugins;
	File f;
	
	public PathHackerRunnable(PackageDescriptor pack, Level verbose, PluginManager plugins, File f) {
		this.pack = pack;
		this.verbose = verbose;
		this.plugins = plugins;
		this.f = f;
	}
	
	/**
	 * Entry point for thread
	 */
	public void run() {
		//System.out.println(""pathHacker ""+f.toURI());
		try {
			PathHacker.addJar(f.toURI().toURL());
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
"
ConnectionDoesntExistMessage.java,prom-framework-6.9.97,"package org.processmining.framework.connections.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
public @interface ConnectionDoesntExistMessage {

	public String message() default """";
}
"
ConnectionObjectFactory.java,prom-framework-6.9.97,"package org.processmining.framework.connections.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation used on plugins to signal that they can construct a Connection on
 * objects.
 * 
 * The type of connection produced is given by the return type of the plugin, of
 * which there should be only 1, which is assignable from Connection.class.
 * 
 * To avoid lifelocks such a plugin should not request any connection on its
 * inputs. If no connection can be made, <code>null</code> should be returned.
 * 
 * @author bfvdonge
 * 
 */
@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.METHOD, ElementType.TYPE })
public @interface ConnectionObjectFactory {

}
"
Connection.java,prom-framework-6.9.97,"package org.processmining.framework.connections;

import java.util.Collection;
import java.util.Set;

import org.processmining.framework.annotations.AuthoredType;
import org.processmining.framework.annotations.Icon;
import org.processmining.framework.util.collection.MultiSet;

/**
 * A connection describes a relation between objects. The connection keeps a
 * number of weak references between the objects in the relation. Each object
 * should have a label describing the role of the object in the relation. These
 * roles are unique
 * 
 * Note that for all implementations of Connection, it is essential to consider
 * memory consumption. Connections are kept in the framework for as long as the
 * isRemoved() method returns false, hence this method should return true at the
 * earliest occasion.
 * 
 * All implementations of this class should carry the following annotations:
 * @KeepInProMCache
 * @ConnectionAnnotation
 * @ConnectionDoesntExistMessage(message = ""Message for case that connection Doesn't Exist"")
 * 
 * @author bfvdonge
 * 
 */
@AuthoredType(typeName = ""Connection"", affiliation = AuthoredType.TUE, author = ""B.F. van Dongen"", email = ""b.f.v.dongen@tue.nl"")
@Icon(icon = ""resourcetype_connection_30x35.png"")
public interface Connection {

	/**
	 * Return the label of the connection
	 * 
	 * @return
	 */
	public String getLabel();

	/**
	 * Return the ID of the connection.
	 * 
	 * @return
	 */
	public ConnectionID getID();

	/**
	 * Return true if all objects given as parameter are contained in the
	 * connection. Multiplicities are taken into account, however order is
	 * abstracted from
	 * 
	 * @param objects
	 *            the objects to check for
	 * @return
	 */
	public boolean containsObjects(Object... objects);

	/**
	 * Return true if all objects given as parameter are contained in the
	 * connection. Multiplicities are taken into account, i.e. each object
	 * should occur as often as it is returned by the iterator of the given
	 * collection however order is abstracted from
	 * 
	 * @param objects
	 *            the objects as a collection
	 * @return
	 */
	public boolean containsObjects(Collection<?> objects);

	/**
	 * Return true if one of the objects connected by this connection no longer
	 * exists, i.e. it is collected by the garbage collector.
	 * 
	 * @return
	 */
	public boolean isRemoved();

	/**
	 * Return all objects contained in this connection, without their labels.
	 * 
	 * By contract, this method should always return the same set of objects
	 * after the connections was created, i.e. connections may only be changed
	 * by changing the contents of the objects, but not by changing the
	 * pointers.
	 * 
	 * @return
	 */
	public MultiSet<Object> getObjects();

	/**
	 * Return the roles of all objects in this connection
	 * 
	 * @return
	 */
	public Set<String> getRoles();

	/**
	 * Return the object with the given role in this connection The type of the
	 * returned object is T. However, no checks have to be performed to see if
	 * the cast can be made. It is up to the calling method to ensure this cast
	 * is safe.
	 * 
	 * @param <T>
	 *            The type of object that should be returned.
	 * @param role
	 *            the role the returned object has to have
	 * @return the object attached to this role (not null).
	 */
	public <T> T getObjectWithRole(String role);

	/**
	 * Removes the connection. After calling this method, isRemoved()returns
	 * true;
	 */
	public void remove();

	/**
	 * sets the label of the connection to the new name
	 * 
	 * @param name
	 */
	public void setLabel(String name);

	/**
	 * This method should be called as soon as the connection is changed, for
	 * example if the label changed, or if the contents of one of the connected
	 * objects changes.
	 * 
	 * By calling this method, the connection manager should be notified.
	 */
	public void updated();

	/**
	 * Sets the manager for the connection. This method is called by the
	 * connection manager as soon as this connection is added to that manager. A
	 * connection should keep a reference to the manager only in a transient
	 * field.
	 * 
	 * @param manager
	 */
	void setManager(ConnectionManager manager);

}
"
ConnectionAnnotation.java,prom-framework-6.9.97,"package org.processmining.framework.connections;

import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * This annotation is used by the framework to scan for all implementations if
 * Connection.
 * 
 * @author bfvdonge
 * 
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
@Inherited
public @interface ConnectionAnnotation {

}
"
ConnectionCannotBeObtained.java,prom-framework-6.9.97,"package org.processmining.framework.connections;

import org.processmining.framework.connections.annotations.ConnectionDoesntExistMessage;

/**
 * Exception thrown by the connectionmanager if a requested connection does not
 * exist.
 * 
 * @author bfvdonge
 * 
 */
public class ConnectionCannotBeObtained extends Exception {

	private final Class<? extends Object> connectionType;

	/**
	 * Constructor with message and cause
	 * 
	 * @param reason
	 *            The reason of throwing this exception
	 * @param ex
	 *            the cause of this exception
	 */
	public ConnectionCannotBeObtained(String reason, ConnectionCannotBeObtained ex) {
		this(reason + "" \n "" + ex.getMessage(), ex.connectionType);
	}

	/**
	 * Constructor with reason, connection type and objects. The message is set
	 * to: ""No known connection of type + connectionType + "" between "" +
	 * Arrays.toString(objects) + "" ["" + reason + ""]"";
	 * 
	 * @param reason
	 *            The reason of throwing this exception
	 * @param connectionType
	 *            The requested connection type
	 * @param objects
	 *            the objects on which a connection was requested
	 */
	public ConnectionCannotBeObtained(String reason, Class<?> connectionType, Object... objects) {
		super(""No connection of type "" + connectionType.getSimpleName() + 
//				"" can be obtained for objects: "" + Arrays.toString(objects) + 
				""\n The reason given is: "" + reason + ""\n ""
				+ getDoesntExistMessage(connectionType))
				;
		this.connectionType = connectionType;
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 224232280740635702L;

	private static String getDoesntExistMessage(Class<?> connectionType) {
		if (connectionType == null) {
			return """";
		}
		String s = """";
		ConnectionDoesntExistMessage message = connectionType.getAnnotation(ConnectionDoesntExistMessage.class);
		if (message != null) {
			s = message.message();
		}
		if ((connectionType != Connection.class) && (connectionType.getSuperclass() != null)
				&& (Connection.class.isAssignableFrom(connectionType.getSuperclass()))) {
			s = getDoesntExistMessage(connectionType.getSuperclass()) + "" \n "" + s;
		}
		for (Class<?> sup : connectionType.getInterfaces()) {
			if (Connection.class.isAssignableFrom(sup)) {
				s = getDoesntExistMessage(connectionType.getSuperclass()) + "" \n "" + s;
			}
		}
		return s;

	}

}
"
ConnectionID.java,prom-framework-6.9.97,"package org.processmining.framework.connections;

import org.processmining.framework.ProMID;

/**
 * ID of a connection. Need not to be persistent over serialization.
 * 
 * @author bfvdonge
 * 
 */
public interface ConnectionID extends ProMID {


}
"
ConnectionManager.java,prom-framework-6.9.97,"package org.processmining.framework.connections;

import java.util.Collection;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.events.ConnectionObjectListener;

public interface ConnectionManager {

	/**
	 * Returns a collection of connections between the objects specified, such
	 * that the type of the connection is assignable from the given
	 * connectionType (unless the parameter equals null).
	 * 
	 * If no connections satisfying these criteria exist and the required type
	 * is specified and no required name is specified, then the global context
	 * searches for all available plugins with a ConnectionObjectFactory
	 * annotation, which can be executed in a child of the given PluginContext
	 * and accept the given objects as input
	 * 
	 * If such plugins exist, the first of these plugins is selected and invoked
	 * on the given objects. The result is obtained from the plugin and a new
	 * connection is registered of the right type. This connection is then
	 * returned.
	 * 
	 * @param <T>
	 *            the type of the requested connection.
	 * @param connectionType
	 *            The type of the object requested. This type can be null, in
	 *            which case all types are considered.
	 * @param context
	 *            The context which requests the connection. If a plugin is
	 *            invoked to create a connection, a child context of this
	 *            context is instantiated
	 * @param objects
	 *            the objects which should be connected by the requested
	 *            connection. There might be more objects involved in the
	 *            connection
	 * @return A collection of connections of the requested type T. If no
	 *         connection exists, an exception is thrown, hence the collection
	 *         is never empty.
	 * @throws ConnectionCannotBeObtained
	 *             if the requested connection does not exist and cannot be
	 *             produced in the given context.
	 */
	<T extends Connection> Collection<T> getConnections(Class<T> connectionType, PluginContext context,
			Object... objects) throws ConnectionCannotBeObtained;

	/**
	 * Returns a connection between the objects specified, such that the type of
	 * the connection is assignable from the given connectionType (unless the
	 * parameter equals null).
	 * 
	 * If no connections satisfying these criteria exist and the required type
	 * is specified and no required name is specified, then the global context
	 * searches for all available plugins with a ConnectionObjectFactory
	 * annotation, which can be executed in a child of the given PluginContext
	 * and accept the given objects as input
	 * 
	 * If such plugins exist, the first of these plugins is selected and invoked
	 * on the given objects. The result is obtained from the plugin and a new
	 * connection is registered of the right type. This connection is then
	 * returned.
	 * 
	 * @param <T>
	 *            the type of the requested connection.
	 * @param connectionType
	 *            The type of the object requested. This type can be null, in
	 *            which case all types are considered.
	 * @param context
	 *            The context which requests the connection. If a plugin is
	 *            invoked to create a connection, a child context of this
	 *            context is instantiated
	 * @param objects
	 *            the objects which should be connected by the requested
	 *            connection. There might be more objects involved in the
	 *            connection
	 * @return A connection of the requested type T. If no connection exists, an
	 *         exception is thrown, hence null is never returned.
	 * @throws ConnectionCannotBeObtained
	 *             if the requested connection does not exist and cannot be
	 *             produced in the given context.
	 */
	<T extends Connection> T getFirstConnection(Class<T> connectionType, PluginContext context, Object... objects)
			throws ConnectionCannotBeObtained;

	/**
	 * Returns the connection with the given ID.
	 * 
	 * @param id
	 *            the connection ID
	 * @return the connection with the given ID
	 */
	Connection getConnection(ConnectionID id) throws ConnectionCannotBeObtained;

	/**
	 * Returns the list of registered connectionObject listeners
	 * 
	 * @return the list of registered connectionObject listeners
	 */
	ConnectionObjectListener.ListenerList getConnectionListeners();

	/**
	 * Returns a collection of connection IDs registered to this global context.
	 * 
	 * @return the ids of the registered connections
	 */
	Collection<ConnectionID> getConnectionIDs();

	/**
	 * Adds the given connection to the framework.
	 * 
	 * @param connection
	 *            The connection to be registered
	 * @return the given parameter connection
	 */
	<T extends Connection> T addConnection(T connection);

	/**
	 * Returns whether connections are enabled. If not, then connecitons will not be added.
	 * @return whether connections are enabled
	 */
	boolean isEnabled();

	/**
	 * Sets whether connections are enabled.
	 * @param isEnabled whether connections should be enabled
	 */
	void setEnabled(boolean isEnabled);

	void clear();
}
"
DynamicConnection.java,prom-framework-6.9.97,"package org.processmining.framework.connections;

/**
 * Tagger interface to indicate that a connection will change after
 * instantiation. Since the actual objects involved in the connection are not
 * allowed to change, these changes should be limited to the contents of the
 * connection itself.
 * 
 * The main use for this interface is in serialization, where DynamicConnections
 * are only serialized when ProM is closed.
 * 
 * @author bfvdonge
 * 
 */
public interface DynamicConnection {

}
"
AbstractConnection.java,prom-framework-6.9.97,"package org.processmining.framework.connections.impl;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionAnnotation;
import org.processmining.framework.connections.ConnectionID;
import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.connections.annotations.ConnectionDoesntExistMessage;
import org.processmining.framework.plugin.annotations.KeepInProMCache;
import org.processmining.framework.util.collection.HashMultiSet;
import org.processmining.framework.util.collection.MultiSet;

/**
 * Note that for all implementations of Connection, it is essential to consider
 * memory consumption. Connections are kept in the framework for as long as the
 * isRemoved() method returns false, hence this method should return true at the
 * earliest occasion.
 * 
 * The AbstractConnection keeps weak references to the objects added through the
 * put methods. As soon as one of these objects is collected by the garbage
 * collector, then this connection becomes removed. Therefore, it is essential
 * that subclasses of the AbstractConnection do not keep pointers to these
 * objects, or at least only keep weak references.
 * 
 * This class is annotated with @ConnectionAnnotation. Therefore, none of the
 * implementing classes have to do so explicitly.
 * 
 * @author bfvdonge
 * 
 */
@KeepInProMCache
@ConnectionAnnotation
@ConnectionDoesntExistMessage(message = ""Connection Doesn't Exist"")
public abstract class AbstractConnection implements Connection {

	private final Map<String, WeakReference<?>> mapping;
	private static final long serialVersionUID = -9049359040527952685L;

	private String label;

	private final ConnectionID id;
	protected transient ConnectionManager manager = null;

	protected AbstractConnection(String label) {
		if (label == null) {
			throw new NullPointerException(""Connection label should not be NULL"");
		}
		this.label = label;
		id = new ConnectionIDImpl();
		mapping = new HashMap<String, WeakReference<?>>();
	}

	public void setManager(ConnectionManager manager) {
		this.manager = manager;
	}

	public String getLabel() {
		return label;
	}

	public boolean containsObjects(Object... objects) {
		return containsObjects(Arrays.asList(objects));
	}

	public boolean containsObjects(Collection<?> objects) {
		Collection<WeakReference<?>> references = new ArrayList<WeakReference<?>>(mapping.values());

		for (Object o : objects) {
			boolean found = false;
			Iterator<WeakReference<?>> it = references.iterator();
			while (!found && it.hasNext()) {
				Object referenced = it.next().get();
				if (o.getClass().isArray() && referenced.getClass().isArray()) {
					// We are dealing with an array type
					if (Arrays.equals((Object[]) o, (Object[]) referenced)) {
						// Found a match for this object.
						found = true;
					}
				} else {
					if (referenced.equals(o)) {
						// Found a match for this object.
						found = true;
					}
				}
				if (found) {
					it.remove();
				}
			}
			if (!found) {
				return false;
			}
		}
		return true;
	}

	public boolean isRemoved() {
//		System.gc(); // By doing this, object are removed earlier from the workspace.
		for (Map.Entry<String, WeakReference<?>> t : mapping.entrySet()) {
			Object o = t.getValue().get();
//			System.out.println(""[AbstractionConnection] isRemoved "" + this.getClass().getName() + ""@"" + t.getKey() + "": "" + o);			
			if (o == null) {
				return true;
			}
		}
		return false;
	}

	public String toString() {
		return ""Connection labelled "" + label + "", connecting "" + super.toString();
	}

	@Override
	public int hashCode() {
		return Objects.hashCode(id);
	}

	public MultiSet<Object> getObjects() {
		MultiSet<Object> result = new HashMultiSet<Object>();
		for (Map.Entry<String, WeakReference<?>> t : mapping.entrySet()) {
			Object o = t.getValue().get();
			if (o != null) {
				result.add(o);
			} else {
				return new HashMultiSet<Object>();
			}
		}
		return result;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null) {
			return false;
		}
		if (!(o instanceof AbstractConnection)) {
			return false;
		}
		AbstractConnection a = (AbstractConnection) o;
		if (id == null) {
			if (a.id != null) {
				return false;
			}
		} else if (!id.equals(a.id)) {
			return false;
		}
		return true;
	}

	public ConnectionID getID() {
		return id;
	}

	@SuppressWarnings(""unchecked"")
	public <T> T getObjectWithRole(String role) {
		assert (get(role) != null);
		return (T) get(role);
	}

	public Set<String> getRoles() {
		return mapping.keySet();
	}

	protected <T> WeakReference<T> put(String role, T o) {
		WeakReference<T> ref = new WeakReference<T>(o);
		mapping.put(role, ref);
		return ref;
	}

	protected void remove(String role) {
		mapping.remove(role);
	}

	protected Object get(String role) {
		return mapping.get(role).get();
	}

	protected Map<String, WeakReference<?>> getMapping() {
		return mapping;
	}

	/**
	 * Removes the connection. After calling this method, isRemoved()returns
	 * true;
	 */
	public void remove() {
		for (Map.Entry<String, WeakReference<?>> t : mapping.entrySet()) {
			t.getValue().clear();
		}
	}

	/**
	 * sets the label of the connection to the new name
	 * 
	 * @param name
	 */
	public void setLabel(String name) {
		if (name == null) {
			throw new NullPointerException(""Connection label should not be NULL"");
		}
		boolean changed = name.equals(label);
		this.label = name;
		if (changed) {
			updated();
		}
	}

	public void updated() {
		if (manager != null) {
			manager.getConnectionListeners().fireConnectionUpdated(id);
		}
	}

	private Object readResolve() {
		manager = null;
		return this;
	}
}
"
AbstractStrongReferencingConnection.java,prom-framework-6.9.97,"package org.processmining.framework.connections.impl;

import java.lang.ref.WeakReference;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;

public abstract class AbstractStrongReferencingConnection extends AbstractConnection {

	// Keep a strong reference to some objects, as these
	// would otherwise fault the connection.
	// When checking for removal, these objects are ignored, i.e. the connection
	// is considered to be removed if any of the weak references has been nullified.
	private final Collection<Object> objectReferences = new HashSet<Object>();

	public AbstractStrongReferencingConnection(String label) {
		super(label);
	}

	protected <T> WeakReference<T> putStrong(String role, T o) {
		objectReferences.add(o);
		return super.put(role, o);
	}

	@Override
	public boolean isRemoved() {
		for (Map.Entry<String, WeakReference<?>> t : getMapping().entrySet()) {
			Object o = t.getValue().get();
			if (objectReferences.contains(o)) {
				// Skip the objects to which Hard links need to be kept.
				continue;
			}
			if (o == null) {
				return true;
			}
		}
		return false;
	}

}"
ConnectionIDImpl.java,prom-framework-6.9.97,"package org.processmining.framework.connections.impl;

import java.util.UUID;

import org.processmining.framework.ProMID;
import org.processmining.framework.connections.ConnectionID;

public class ConnectionIDImpl implements ConnectionID {

	private final UUID id = UUID.randomUUID();

	public String toString() {
		return id.toString();
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof ConnectionIDImpl)) {
			return false;
		} else {
			return ((ConnectionIDImpl) o).id.equals(id);
		}
	}

	public boolean equalsIgnoreType(Object o) {
		return toString().equals(o.toString());
	}

	public int compareTo(ProMID o) {
		return o.getUUID().compareTo(id);
	}

	public UUID getUUID() {
		return id;
	}

}
"
ConnectionManagerImpl.java,prom-framework-6.9.97,"package org.processmining.framework.connections.impl;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionID;
import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.connections.annotations.ConnectionObjectFactory;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.events.ConnectionObjectListener;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.util.Pair;

public class ConnectionManagerImpl implements ConnectionManager {

	private final Map<ConnectionID, Connection> connections = new HashMap<ConnectionID, Connection>();
	private final ConnectionObjectListener.ListenerList connectionListeners = new ConnectionObjectListener.ListenerList();
	private final PluginManager pluginManager;
	private boolean isEnabled = true;

	public ConnectionManagerImpl(PluginManager pluginManager) {
		this.pluginManager = pluginManager;

	}

	/**
	 * Returns the list of registered connectionObject listeners
	 * 
	 * @return the list of registered connectionObject listeners
	 */
	public ConnectionObjectListener.ListenerList getConnectionListeners() {
		return connectionListeners;
	}

	public boolean isEnabled() {
		return isEnabled;
	}

	public void setEnabled(boolean isEnabled) {
		this.isEnabled = isEnabled;
	}

	public void clear() {
		connections.clear();
	}
	
	public <T extends Connection> T addConnection(T connection) {
		if (isEnabled) {
			synchronized (connections) {
				connections.put(connection.getID(), connection);
				connection.setManager(this);
				connectionListeners.fireConnectionCreated(connection.getID());
			}
		}
		return connection;
	}

	public Connection getConnection(ConnectionID id) throws ConnectionCannotBeObtained {
		Connection c = connections.get(id);
		synchronized (connections) {
			if (c == null || c.isRemoved()) {
				connections.remove(c);
				connectionListeners.fireConnectionDeleted(id);
				if (c != null)
					throw new ConnectionCannotBeObtained(""Objects were deleted"", c.getClass());
				else
					throw new ConnectionCannotBeObtained(""Objects were deleted"", Object.class);
			}
			return c;
		}
	}

	public <T extends Connection> T getFirstConnection(Class<T> connectionType, PluginContext context,
			Object... objects) throws ConnectionCannotBeObtained {
		return getConnections(true, connectionType, context, objects).iterator().next();
	}

	public <T extends Connection> Collection<T> getConnections(Class<T> connectionType, PluginContext context,
			Object... objects) throws ConnectionCannotBeObtained {
		return getConnections(false, connectionType, context, objects);
	}

	@SuppressWarnings(""unchecked"")
	private <T extends Connection> Collection<T> getConnections(boolean stopAtFirst, Class<T> connectionType,
			PluginContext context, Object... objects) throws ConnectionCannotBeObtained {
		List<T> available = new ArrayList<T>(1);
		//System.gc();
		synchronized (connections) {
			Iterator<Map.Entry<ConnectionID, Connection>> it = connections.entrySet().iterator();
			while (it.hasNext()) {
				Entry<ConnectionID, Connection> entry = it.next();
				Connection c = entry.getValue();
				if (c.isRemoved()) {
					it.remove();
					connectionListeners.fireConnectionDeleted(c.getID());
					continue;
				}
				if (((connectionType == null) || connectionType.isAssignableFrom(c.getClass()))
						&& c.containsObjects(objects)) {
					context.log(""Connection found: "" + c, MessageLevel.DEBUG);
					available.add((T) c);
					if (stopAtFirst) {
						return available;
					}
				}
			}
		}
		if (!available.isEmpty()) {
			return available;
		}
		if ((connectionType == null) || (objects.length <= 1)) {
			throw new ConnectionCannotBeObtained(""No plugin available to create connection"", connectionType, objects);

		}
		Class<?>[] types = new Class<?>[objects.length];
		for (int i = 0; i < objects.length; i++) {
			types[i] = objects[i].getClass();
		}

		Collection<Pair<Integer, PluginParameterBinding>> plugins = pluginManager.find(ConnectionObjectFactory.class,
				connectionType, context.getClass(), true, false, false, types);
		if (plugins.isEmpty()) {
			throw new ConnectionCannotBeObtained(""No plugin available to create connection"", connectionType, objects);
		}
		PluginContext c2 = context.createChildContext(""Creating connection of Type "" + connectionType);
		Pair<Integer, PluginParameterBinding> pair = plugins.iterator().next();
		PluginParameterBinding binding = pair.getSecond();
		try {

			PluginExecutionResult pluginResult = binding.invoke(c2, objects);
			pluginResult.synchronize();
			T connectionObject = pluginResult.<T>getResult(pair.getFirst());

			if (connectionObject == null) {
				throw new ConnectionCannotBeObtained(""Factory plugin returned null."", connectionType, objects);
			}
			available.add(addConnection(connectionObject));
			context.log(""Added connection: "" + connectionObject, MessageLevel.DEBUG);
			return available;
		} catch (Exception e) {
			throw new ConnectionCannotBeObtained(e.getMessage(), connectionType, objects);
		} finally {
			c2.getParentContext().deleteChild(c2);
		}
	}

	public Collection<ConnectionID> getConnectionIDs() {
		return connections.keySet();
	}

}
"
CommandLineInterface.java,prom-framework-6.9.97,"package org.processmining.framework.packages;

import jargs.gnu.CmdLineParser;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;

import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.util.AutoHelpCommandLineParser;
import org.processmining.framework.util.Pair;

public class CommandLineInterface {

	private final PackageManager manager;

	public CommandLineInterface(PackageManager manager) {
		this.manager = manager;
	}

	public int run(String[] args) {
		AutoHelpCommandLineParser.Command[] commands = { new UpdateCommand(manager),
				new InstallOrRemoveCommand(manager), new ListCommand(manager) };
		AutoHelpCommandLineParser parser = new AutoHelpCommandLineParser(""java ""
				+ PackageManager.class.getCanonicalName(), commands);

		CmdLineParser.Option helpOption = parser.addHelp(parser.addBooleanOption('h', ""help""),
				""Print this help message and exit"");

		try {
			parser.parse(args);
		} catch (CmdLineParser.OptionException e) {
			System.err.println(e.getMessage());
			parser.printUsage();
			return 1;
		}

		if ((parser.getRemainingArgs().length == 0) || (Boolean) parser.getOptionValue(helpOption, Boolean.FALSE)) {
			parser.printUsage();
			return 0;
		}

		int exitcode;
		try {
			manager.initialize(Level.ALL);
			exitcode = parser.runCommand();
		} catch (Throwable e) {
			e.printStackTrace();
			return 1;
		}

		if (exitcode == -1) {
			parser.printUsage();
			return 1;
		}
		return exitcode;
	}

}

class UpdateCommand extends AutoHelpCommandLineParser.Command {

	private final PackageManager manager;

	public UpdateCommand(PackageManager manager) {
		super(""update"", ""Retrieve the latest package definitions from all repositories"");
		this.manager = manager;
	}

	@Override
	public int run(List<String> args) throws Exception {
		System.out.println(""Updating..."");
		manager.update(true, Level.ALL);
		System.out.println(""Done."");
		return 0;
	}

}

class InstallOrRemoveCommand extends AutoHelpCommandLineParser.Command {

	private final PackageManager manager;

	public InstallOrRemoveCommand(PackageManager manager) {
		super(""change"",
				""Install the packages preceded by +, remove packages preceded by x (example: change +packageA:1.0 xpackageB)"");
		this.manager = manager;
	}

	@Override
	public int run(List<String> args) throws Exception {
		List<PackageDescriptor> toInstall = new ArrayList<PackageDescriptor>();
		List<PackageDescriptor> toRemove = new ArrayList<PackageDescriptor>();

		Set<PackageDescriptor> all = new HashSet<PackageDescriptor>(manager.getInstalledPackages());
		all.addAll(manager.getAvailablePackages());
		Map<String, SortedSet<PackageDescriptor>> map = PackageManager.getPackageMap(all);

		for (String packageNameAndAction : args) {
			if ((packageNameAndAction.length() > 1)
					&& ((packageNameAndAction.charAt(0) == 'x') || (packageNameAndAction.charAt(0) == '+'))) {
				Pair<String, PackageVersion> packageName = parse(packageNameAndAction.substring(1));
				boolean install = packageNameAndAction.charAt(0) == '+';
				Set<PackageDescriptor> versions = map.get(packageName.getFirst());
				PackageDescriptor p = null;

				if ((versions != null) && !versions.isEmpty()) {
					if (packageName.getSecond() == null) {
						// take latest version if no version was given
						p = versions.toArray(new PackageDescriptor[0])[versions.size() - 1];
					} else {
						for (PackageDescriptor v : versions) {
							if (v.getVersion().equals(packageName.getSecond())) {
								p = v;
								break;
							}
						}
					}
				}

				if (p == null) {
					System.out.println(""Could not find package "" + packageNameAndAction.substring(1)
							+ "" in the list of available packages, skipping."");
				} else {
					System.out.println(""Selected "" + p + "" for "" + (install ? ""installation"" : ""removal"") + ""..."");
					if (install) {
						toInstall.add(p);
					} else {
						toRemove.add(p);
					}
				}
			} else {
				System.out
						.println(""Invalid package specification (please use + or - to indicate installation or removal), skipping."");
			}
		}

		if (toInstall.isEmpty() && toRemove.isEmpty()) {
			System.out.println(""Nothing to install or remove."");
		} else {
			System.out.println(""Starting installation..."");
			manager.install(toInstall);
			manager.uninstall(toRemove);
			PackageStateReport report = manager.getLatestReport();

			System.out.print(report);
			System.out.println(report.hasErrors() ? ""Installation is NOT performed."" : ""Installation done."");
		}
		return 0;
	}

	private Pair<String, PackageVersion> parse(String name) {
		int hyphen = name.indexOf(':');

		if (hyphen >= 0) {
			return new Pair<String, PackageVersion>(name.substring(0, hyphen), new PackageVersion(
					name.substring(hyphen + 1)));
		} else {
			return new Pair<String, PackageVersion>(name, null);
		}
	}
}

class ListCommand extends AutoHelpCommandLineParser.Command {

	private final PackageManager manager;

	public ListCommand(PackageManager manager) {
		super(""list"", ""List all known packages and their status (A=available,I=installed,B=broken,+=has update)"");
		this.manager = manager;
	}

	@Override
	public int run(List<String> args) throws Exception {
		Set<PackageDescriptor> installed = manager.getInstalledPackages();
		Collection<PackageDescriptor> enabled = manager.getEnabledPackages();

		Set<PackageDescriptor> all = new HashSet<PackageDescriptor>(manager.getInstalledPackages());
		all.addAll(manager.getAvailablePackages());

		for (Map.Entry<String, SortedSet<PackageDescriptor>> item : PackageManager.getPackageMap(all).entrySet()) {
			PackageDescriptor installedPackage = null;
			PackageVersion highestVersion = null;
			boolean isEnabled = false;
			String versions = """";

			for (PackageDescriptor pack : item.getValue()) {
				if (installed.contains(pack)) {
					installedPackage = pack;
				}
				if (enabled.contains(pack)) {
					isEnabled = true;
				}
				if (versions.length() > 0) {
					versions += "", "";
				}
				versions += pack.getVersion();
				highestVersion = pack.getVersion();
			}

			if (installedPackage == null) {
				System.out.println(""A  "" + item.getKey() + "" ["" + versions + ""]"");
			} else if (isEnabled) {
				System.out.println(""I"" + (installedPackage.getVersion().lessThan(highestVersion) ? ""+"" : "" "") + "" ""
						+ installedPackage + "" ["" + versions + ""]"");
			} else {
				System.out.println(""B"" + (installedPackage.getVersion().lessThan(highestVersion) ? ""+"" : "" "") + "" ""
						+ installedPackage + "" ["" + versions + ""]"");
			}
		}
		return 0;
	}
}
"
PackageManagerListener.java,prom-framework-6.9.97,"package org.processmining.framework.packages.events;

import java.io.File;
import java.net.URL;
import java.util.EventListener;

import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.events.ProMEventListenerList;

public interface PackageManagerListener extends EventListener {

	public class ListenerList extends ProMEventListenerList<PackageManagerListener> {
		public void fireSessionStart() {
			for (PackageManagerListener listener : getListeners()) {
				listener.sessionStart();
			}
		}

		public void fireSessionComplete(boolean error) {
			for (PackageManagerListener listener : getListeners()) {
				listener.sessionComplete(error);
			}
		}

		public void fireStartDownload(String packageName, URL url, PackageDescriptor pack) {
			for (PackageManagerListener listener : getListeners()) {
				listener.startDownload(packageName, url, pack);
			}
		}

		public void fireStartInstall(String packageName, File folder, PackageDescriptor pack) {
			for (PackageManagerListener listener : getListeners()) {
				listener.startInstall(packageName, folder, pack);
			}
		}

		public void fireFinishedInstall(String packageName, File folder, PackageDescriptor pack) {
			for (PackageManagerListener listener : getListeners()) {
				listener.finishedInstall(packageName, folder, pack);
			}
		}

		public void fireException(String exception) {
			for (PackageManagerListener listener : getListeners()) {
				listener.exception(exception);
			}
		}

		public void fireException(Throwable t) {
			for (PackageManagerListener listener : getListeners()) {
				listener.exception(t);
			}
		}
	}

	public void sessionStart();

	public void exception(Throwable t);

	public void exception(String exception);

	public void startDownload(String packageName, URL url, PackageDescriptor pack);

	public void startInstall(String packageName, File folder, PackageDescriptor pack);

	public void finishedInstall(String packageName, File folder, PackageDescriptor pack);

	public void sessionComplete(boolean error);

}
"
CancelledException.java,prom-framework-6.9.97,"package org.processmining.framework.packages.impl;

import org.xml.sax.SAXException;

public class CancelledException extends SAXException {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1288614934031744810L;

}
"
PackageConfigPerister.java,prom-framework-6.9.97,"package org.processmining.framework.packages.impl;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.packages.PackageDescriptor.OS;
import org.processmining.framework.packages.PackageManager;
import org.processmining.framework.packages.PackageManager.Canceller;
import org.processmining.framework.packages.PackageSet;
import org.processmining.framework.packages.Repository;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

public class PackageConfigPerister {

	private static final String nl = System.getProperty(""line.separator"");

	private PackageConfigPerister() {
	}

	public static void read(File f, Set<Repository> repositories, PackageSet available, PackageSet installed,
			Canceller canceller) throws ParserConfigurationException, SAXException, IOException {
		InputStream is = new BufferedInputStream(new FileInputStream(f));
		try {
			read(is, repositories, available, installed, canceller);
		} finally {
			is.close();
		}
	}

	public static void read(InputStream is, Set<Repository> repositories, PackageSet available, PackageSet installed,
			Canceller canceller) throws ParserConfigurationException, SAXException, IOException {
		BufferedInputStream bis = new BufferedInputStream(is);
		ConfigHandler handler = new ConfigHandler(repositories, available, installed, canceller);
		SAXParserFactory parserFactory = SAXParserFactory.newInstance();

		parserFactory.setNamespaceAware(false);
		parserFactory.setValidating(false);
		try {
			// Some old JAXP versions may throw the UnsupportedOperation Exception in the next call.
			parserFactory.setSchema(null);
		} catch (UnsupportedOperationException ex) {
			// Ignore.
		}

		SAXParser parser = parserFactory.newSAXParser();
		parser.parse(bis, handler);
		bis.close();
	}

	public static Set<PackageDescriptor> listRepository(InputStream is, Canceller canceller)
			throws ParserConfigurationException, SAXException, IOException {
		Set<Repository> repos = new HashSet<Repository>();
		PackageSet available = new PackageSet();
		PackageSet installed = new PackageSet();

		read(is, repos, available, installed, canceller);
		return available;
	}

	static private class ConfigHandler extends DefaultHandler {

		private static final String PACKAGES = ""packages"";
		private static final String URL_ATTR = ""url"";
		private static final String VERSION_ATTR = ""version"";
		private static final String NAME_ATTR = ""name"";
		private static final String DEPENDENCY = ""dependency"";
		private static final String PACKAGE = ""package"";
		private static final String REPOSITORY = ""repository"";
		private static final String CONFLICT = ""conflict"";
		private static final String DESCRIPTION_ATTR = ""desc"";
		private static final String ORGANISATION_ATTR = ""org"";
		private static final String AUTHOR_ATTR = ""author"";
		private static final String AUTO_ATTR = ""auto"";
		private static final String LICENSE_ATTR = ""license"";
		private static final Object INSTALLED = ""installed-packages"";
		private static final String HAS_PLUGINS_ATTR = ""hasPlugins"";
		private static final String OS_ATTR = ""os"";
		private static final String MAINTAINER_ATTR = ""maintainer"";

		private static final String LOGO_URL_ATTR = ""logo"";
		private static final String KEYWORDS_ATTR = ""keywords"";

		private Repository curRepo = null;
		private String curPackageName = null;
		private String curPackageVersion = null;
		private final List<String> dependencies = new ArrayList<String>();
		private final List<String> conflicts = new ArrayList<String>();
		private String curPackageURL;
		private String curLogoURL;
		private String curPackageDesc;
		private String curPackageOrg;
		private String curPackageAuthor;
		private String curPackageLicense;
		private String curPackageAutoInstalled;
		private String curPackageHasPlugins;
		private boolean insideInstalled = false;

		private final Set<Repository> repositories;
		private final Set<PackageDescriptor> available;
		private final Set<PackageDescriptor> installed;
		private final Canceller canceller;
		private String curPackageOS;
		private String curPackageMaintainer;
		private String curKeywords;
		private URL contextURL;
		
		public ConfigHandler(Set<Repository> repositories, Set<PackageDescriptor> available,
				Set<PackageDescriptor> installed, Canceller canceller) {
			this.available = available;
			this.installed = installed;
			this.repositories = repositories;
			this.canceller = canceller;
			
			/*
			 * Set a context for the URLs. This allows us to use relative URLs in the repositories.
			 */
			String repository = Boot.DEFAULT_REPOSITORY.toString();
			int lastPathSeparator = repository.lastIndexOf(""/"");
			String context = repository.substring(0, lastPathSeparator + 1);
			try {
				this.contextURL = new URL(context);
			} catch (MalformedURLException e) {
				try {
					this.contextURL = new URL(""http://www.promtools.org/prom6/packages/"");
				} catch (MalformedURLException e2) {
					assert(false);
				}
			}
			System.out.println(""[PackageConfigPerister] Context URL set to "" + this.contextURL);
		}

		@Override
		public void startElement(String uri, String local, String qName, Attributes attributes) throws SAXException {
			if ((canceller != null) && canceller.isCancelled()) {
				throw new CancelledException();
			}
			qName = qName.toLowerCase();

			if ((curRepo == null) && (curPackageName == null)) {
				if (qName.equals(INSTALLED)) {
					insideInstalled = true;
				} else if (!insideInstalled && qName.equals(REPOSITORY)) {
					String url = attributes.getValue(URL_ATTR);

					if ((url != null) && (url.trim().length() > 0)) {
						try {
							/*
							 * Use the context for URLs.
							 */
							curRepo = new Repository(new URL(contextURL, url.trim()));
						} catch (MalformedURLException e) {
							System.err.println(""Invalid URL for repository, skipping: "" + url);
						}
					}
				} else if (qName.equals(PACKAGE)) {
					String name = attributes.getValue(NAME_ATTR);
					String version = attributes.getValue(VERSION_ATTR);
					String url = attributes.getValue(URL_ATTR);
					String logo = attributes.getValue(LOGO_URL_ATTR);
					String desc = attributes.getValue(DESCRIPTION_ATTR);
					String org = attributes.getValue(ORGANISATION_ATTR);
					String license = attributes.getValue(LICENSE_ATTR);
					String author = attributes.getValue(AUTHOR_ATTR);
					String auto = attributes.getValue(AUTO_ATTR);
					String hasPlugins = attributes.getValue(HAS_PLUGINS_ATTR);
					String os = attributes.getValue(OS_ATTR);
					String maintainer = attributes.getValue(MAINTAINER_ATTR);
					String keywords = attributes.getValue(KEYWORDS_ATTR);

					if ((name != null) && (name.trim().length() > 0) && //
							(version != null) && (version.trim().length() > 0) && //
							(os != null) && (os.trim().length() > 0) && //
							(url != null) && (url.trim().length() > 0)) {
						curPackageName = name;
						curPackageVersion = version;
						try {
							/*
							 * Use the context for URLs.
							 */
							curPackageURL = new URL(contextURL, url).toString();
						} catch (MalformedURLException e) {
							/*
							 * Use of context not possible. As before.
							 */
							curPackageURL = url;
						}
						curPackageOS = os;
						if (logo != null) {
							try {
								/*
								 * Use the context for logo URLs.
								 */
								curLogoURL = new URL(contextURL, logo).toString();
							} catch (MalformedURLException e) {
								/*
								 * Use of context not possible. As before.
								 */
								curLogoURL = """";
							}
						} else {
							curLogoURL = """";
						}
						curPackageDesc = desc == null ? """" : desc;
						curPackageOrg = org == null ? """" : org;
						curPackageLicense = license == null ? """" : license;
						curPackageAuthor = author == null ? """" : author;
						curPackageMaintainer = maintainer == null ? author : maintainer;
						curPackageAutoInstalled = auto == null ? """" : auto;
						curPackageHasPlugins = hasPlugins == null ? """" : hasPlugins;
						curKeywords = keywords == null ? """" : keywords;
						dependencies.clear();
						conflicts.clear();
					}
				}
			} else if ((curPackageName != null) && qName.equals(DEPENDENCY)) {
				String name = attributes.getValue(NAME_ATTR);

				if ((name != null) && (name.trim().length() > 0)) {
					dependencies.add(name);
				}
			} else if ((curPackageName != null) && qName.equals(CONFLICT)) {
				String name = attributes.getValue(NAME_ATTR);

				if ((name != null) && (name.trim().length() > 0)) {
					conflicts.add(name);
				}
			}
		}

		@Override
		public void endElement(String uri, String local, String qName) throws SAXException {
			if ((canceller != null) && canceller.isCancelled()) {
				throw new CancelledException();
			}
			qName = qName.toLowerCase();

			if (qName.equals(INSTALLED)) {
				insideInstalled = false;
			} else if ((curRepo != null) && qName.equals(REPOSITORY)) {
				repositories.add(curRepo);
				curRepo = null;
			} else if ((curPackageName != null) && qName.equals(PACKAGE)) {
				OS os = OS.fromString(curPackageOS);
				if (os.isUsable()) {
					PackageDescriptor pack = new PackageDescriptor(curPackageName, curPackageVersion, os,
							curPackageDesc, curPackageOrg, curPackageAuthor, curPackageMaintainer, curPackageLicense,
							curPackageURL, curLogoURL,  curKeywords, ""true"".equals(curPackageAutoInstalled), !""false""
									.equals(curPackageHasPlugins), dependencies, conflicts);
					if (insideInstalled) {
						installed.add(pack);
					} else {
						if (Boot.HIDE_OLD_PACKAGES) {
							// Suggested by Massimiliano de Leoni
							PackageDescriptor foundPack = null;
							for (PackageDescriptor availablePack : available) {
								if (availablePack.getName().equals(pack.getName())) {
									foundPack = availablePack;
									break;
								}
							}
							if (foundPack != null) {
								if (foundPack.getVersion().lessThan(pack.getVersion())) {
									available.remove(foundPack);
									available.add(pack);
								} else {
									// Skip, pack is dominated by foundPack.
								}
							} else {
								available.add(pack);
							}
						} else {
							available.add(pack);
						}
					}
				}
				curPackageName = null;
			}
		}
	}

	public static void write(File config, Set<Repository> repositories, Set<PackageDescriptor> available,
			Set<PackageDescriptor> installed) throws IOException {
		Writer writer = new FileWriter(config);

		// TODO properly escape all raw strings

		writer.write(""<?xml version=\""1.0\"" encoding=\""iso-8859-1\""?>"" + nl);
		writer.write(""<"" + ConfigHandler.PACKAGES + "">"" + nl);
		for (Repository repo : repositories) {
			writer.write(""  <"" + ConfigHandler.REPOSITORY + "" "" + ConfigHandler.URL_ATTR + ""=\"""" + repo.getURL() + ""\""""
					+ "" />"" + nl);
		}
		for (PackageDescriptor pack : available) {
			/*
			 * Do not write to local repo if known to be unavailable.
			 */
			if (PackageManager.getInstance().isAvailable(pack)) {
				writePackage(pack, writer);
			}
		}
		writer.write(""  <"" + ConfigHandler.INSTALLED + "">"" + nl);
		for (PackageDescriptor pack : installed) {
			writePackage(pack, writer);
		}
		writer.write(""  </"" + ConfigHandler.INSTALLED + "">"" + nl);

		writer.write(""</"" + ConfigHandler.PACKAGES + "">"" + nl);
		writer.close();
	}

	private static void writePackage(PackageDescriptor pack, Writer writer) throws IOException {
		writer.write(""  <"" + ConfigHandler.PACKAGE + //
				"" "" + ConfigHandler.NAME_ATTR + ""=\"""" + pack.getName() + ""\"""" + //
				"" "" + ConfigHandler.VERSION_ATTR + ""=\"""" + pack.getVersion() + ""\"""" + //
				"" "" + ConfigHandler.OS_ATTR + ""=\"""" + pack.getOS().getName() + ""\"""" + //
				"" "" + ConfigHandler.URL_ATTR + ""=\"""" + pack.getURL() + ""\"""" + //
				"" "" + ConfigHandler.DESCRIPTION_ATTR + ""=\"""" + pack.getDescription() + ""\"""" + //
				"" "" + ConfigHandler.ORGANISATION_ATTR + ""=\"""" + pack.getOrganisation() + ""\"""" + //
				"" "" + ConfigHandler.AUTO_ATTR + ""=\"""" + (pack.getAutoInstalled() ? ""true"" : ""false"") + ""\"""" + //
				"" "" + ConfigHandler.HAS_PLUGINS_ATTR + ""=\"""" + (pack.hasPlugins() ? ""true"" : ""false"") + ""\"""" + //
				"" "" + ConfigHandler.LICENSE_ATTR + ""=\"""" + pack.getLicense() + ""\"""" + //
				"" "" + ConfigHandler.AUTHOR_ATTR + ""=\"""" + pack.getAuthor() + ""\"""" + //
				"" "" + ConfigHandler.MAINTAINER_ATTR + ""=\"""" + pack.getMaintainer() + ""\"""" + //
				"" "" + ConfigHandler.LOGO_URL_ATTR + ""=\"""" + pack.getLogoURL() + ""\"""" + //
				"" "" + ConfigHandler.KEYWORDS_ATTR + ""=\"""" + pack.getKeywords() + ""\"""" + //
				"">"" + nl);
		for (String dep : pack.getDependencies()) {
			writer.write(""    <"" + ConfigHandler.DEPENDENCY + "" "" + ConfigHandler.NAME_ATTR + ""=\"""" + dep + ""\""""
					+ "" />"" + nl);
		}
		for (String confl : pack.getConflicts()) {
			writer.write(""    <"" + ConfigHandler.CONFLICT + "" "" + ConfigHandler.NAME_ATTR + ""=\"""" + confl + ""\""""
					+ "" />"" + nl);
		}
		writer.write(""  </"" + ConfigHandler.PACKAGE + "">"" + nl);
	}
}
"
PackageDescriptor.java,prom-framework-6.9.97,"package org.processmining.framework.packages;

import java.io.File;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.processmining.framework.util.OsUtil;

public class PackageDescriptor implements Comparable<PackageDescriptor> {

	public static enum OS {
		WIN64(""win64"", OsUtil.isRunningWindows() && OsUtil.is64Bit()), //
		WIN32(""win32"", OsUtil.isRunningWindows() && OsUtil.is32Bit()), //
		LIN32(""linux32"", OsUtil.isRunningLinux() && OsUtil.is32Bit()), //
		LIN64(""linux64"", OsUtil.isRunningLinux() && OsUtil.is64Bit()), //
		MAC(""mac"", OsUtil.isRunningMacOsX()), //
		ALL(""all"", true);

		private final String name;
		private final boolean usable;

		private OS(String name, boolean usable) {
			this.name = name;
			this.usable = usable;
		}

		public String getName() {
			return name;
		}

		public static OS fromString(String curPackageOS) {
			for (OS os : OS.values()) {
				if (os.name.equals(curPackageOS)) {
					return os;
				}
			}
			return ALL;
		}

		public boolean isUsable() {
			return usable;
		}
	}

	private final String name;
	private final PackageVersion version;
	private final String description;
	private final String organisation;
	private final String author;
	private final String license;
	private final String url;
	private final boolean autoInstalled;
	private final boolean hasPlugins;
	private final Set<String> dependencies;
	private final Set<String> conflicts;
	private boolean broken;
	private final String logoUrl;
	private final OS os;
	private final String maintainer;
	private final String keywords;

	public PackageDescriptor(String name, String version, OS os, String description, String organisation,
			String author, String maintainer, String license, String url, String logoUrl, String keywords,
			boolean autoInstalled, boolean hasPlugins, List<String> dependencies, List<String> conflicts) {
		this.name = name;
		this.os = os;
		this.maintainer = maintainer;
		this.logoUrl = logoUrl;
		this.autoInstalled = autoInstalled;
		this.hasPlugins = hasPlugins;
		this.version = new PackageVersion(version);
		this.description = description;
		this.organisation = organisation;
		this.author = author;
		this.license = license;
		this.url = url;
		this.keywords = keywords;
		this.dependencies = Collections.unmodifiableSet(new HashSet<String>(dependencies));
		this.conflicts = Collections.unmodifiableSet(new HashSet<String>(conflicts));
		broken = false;
	}

	@Override
	public String toString() {
		return name + ""-"" + version;
	}

	@Override
	public boolean equals(Object other) {
		if (!(other instanceof PackageDescriptor)) {
			return false;
		}
		return name.equals(((PackageDescriptor) other).name) && //
				version.equals(((PackageDescriptor) other).version) && //
				os.equals(((PackageDescriptor) other).os);
	}

	@Override
	public int hashCode() {
		return name.hashCode() * 37 + version.hashCode();
	}

	public String getName() {
		return name;
	}

	public PackageVersion getVersion() {
		return version;
	}

	public String getURL() {
		return url;
	}

	public String getLogoURL() {
		return logoUrl;
	}

	public Set<String> getDependencies() {
		return dependencies;
	}

	public Set<String> getConflicts() {
		return conflicts;
	}

	public File getLocalPackageDirectory() {
		return new File(PackageManager.getInstance().getPackagesDirectory(), makeFilename(name + ""-"" + version));
	}

	private static String makeFilename(String filename) {
		return filename.toLowerCase().replaceAll(""[^a-zA-Z0-9-.]"", ""_"");
	}

	public void setHasBrokenDependencies() {
		broken = true;
	}

	public boolean hasBrokenDependencies() {
		return broken;
	}

	public String getDescription() {
		return description;
	}

	public String getOrganisation() {
		return organisation;
	}

	public String getAuthor() {
		return author;
	}

	public String getLicense() {
		return license;
	}

	public OS getOS() {
		return os;
	}

	public String getMaintainer() {
		return maintainer;
	}

	public String getKeywords() {
		return keywords;
	}

	public boolean getAutoInstalled() {
		return autoInstalled;
	}

	public boolean hasPlugins() {
		return hasPlugins;
	}

	public String toHTML() {
		StringBuffer buffer = new StringBuffer();

		buffer.append(""<HTML><TABLE>"");
		buffer.append(""<TR><TD>Package:</TD><TD>"" + description + ""</TD></TR>"");
		buffer.append(""<TR><TD>Version:</TD><TD>"" + version + ""</TD></TR>"");
		buffer.append(""<TR><TD>Organisation:</TD><TD>"" + organisation + ""</TD></TR>"");
		buffer.append(""<TR><TD>Author(s):</TD><TD>"" + author + ""</TD></TR>"");
		buffer.append(""<TR><TD>Maintained by:</TD><TD>"" + maintainer + ""</TD></TR>"");
		buffer.append(""<TR><TD>License:</TD><TD>"" + license + ""</TD></TR>"");

		buffer.append(""<TR><TD>Dependencies:</TD>"");
		if (dependencies.isEmpty()) {
			buffer.append(""<TD>none</TD></TR>"");
		} else {
			for (Iterator<String> it = dependencies.iterator(); it.hasNext();) {
				buffer.append(""<TD>"" + it.next() + ""</TD></TR>"");
				if (it.hasNext()) {
					buffer.append(""<TR><TD> </TD>"");
				}
			}
		}
		buffer.append(""<TR><TD>Conflicts:</TD>"");
		if (conflicts.isEmpty()) {
			buffer.append(""<TD>none</TD></TR>"");
		} else {
			for (Iterator<String> it = conflicts.iterator(); it.hasNext();) {
				buffer.append(""<TD>"" + it.next() + ""</TD></TR>"");
				if (it.hasNext()) {
					buffer.append(""<TR><TD> </TD>"");
				}
			}
		}

		buffer.append(""</TABLE></HTML>"");

		return buffer.toString();
	}

	public int compareTo(PackageDescriptor pack) {
		if (pack.name.equals(name)) {
			if (version.equals(pack.version)) {
				return os.compareTo(pack.os);
			}
			return -version.compareTo(pack.version);
		}
		return name.compareTo(pack.name);
	}
}
"
PackageManager.java,prom-framework-6.9.97,"package org.processmining.framework.packages;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;

import javax.xml.parsers.ParserConfigurationException;

import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.events.PackageManagerListener;
import org.processmining.framework.packages.impl.CancelledException;
import org.processmining.framework.packages.impl.PackageConfigPerister;
import org.processmining.framework.plugin.impl.PluginCacheEntry;
import org.processmining.framework.plugin.impl.PluginManagerImpl;
import org.processmining.framework.util.OsUtil;
import org.xml.sax.SAXException;

/*
 * Package manager goals: - Packages are completely independent from plugins and
 * are simply a distribution mechanism - Easy to provide a package as a single
 * zip or jar file, with an xml description file - Easy addition of custom
 * repositories - Transparent caching of packages - Transparent use in
 * development - Should be possible to depend on / resolve packages in an Ant
 * script - Should be easy to develop a package in Eclipse - Versions need to be
 * managed and version conflicts need to be resolved - Handles (possibly
 * transitive and circular) dependencies - Cleaning out all files from the
 * package directory of packages which are de-installed
 * 
 * @author peter
 */
public class PackageManager {
	private final static String DO_AUTO_UPDATES = ""do_auto_updates"";
	private static final String LITE_VERSION_INSTALLED = ""lite_version_installed"";

	public static interface Canceller {
		public boolean isCancelled();
	}

	private static final String TEMP_INSTALL_DIR_POSTFIX = ""-temp-install-dir"";
	private static final String CONFIG_XML = ""packages.xml"";

	private static final String nl = System.getProperty(""line.separator"");

	private static final int UNIX_OWNER_EXECUTABLE_BIT = 64;

	private static PackageManager instance = null;
	private final Set<Repository> repositories = new HashSet<Repository>();
	private final PackageSet installed = new PackageSet();
	private final PackageSet available = new PackageSet();

	/*
	 * Maps every package descriptor to whether it is still available. This map
	 * acts as a cache to prevent us from have to access the URL over and over
	 * again.
	 * 
	 * This map is also used by PackageConfigPersiter when writing the packages
	 * to the local repo again. As a result, packages that are known to be
	 * unavailable will not be written back to the local repo.
	 */
	private Map<PackageDescriptor, Boolean> availability;
	
	/**
	 * Checks whether a package is still available. This prevents the user from
	 * installing or updating a package that cannot be installed anymore.
	 * 
	 * @param descriptor
	 *            The descriptor of the package.
	 * @return Whether the URL of the package descriptor can be opened
	 *         successfully.
	 */
	public boolean isAvailable(PackageDescriptor descriptor) {
		if (!Boot.CHECK_PACKAGES) {
			return true;
		}
		/*
		 * First check the cache.
		 */
		if (availability.containsKey(descriptor)) {
			/*
			 * In cache, return cached result.
			 */
			return availability.get(descriptor);
		}
		/*
		 * Not in cache, check whether URL still exists.
		 */
		InputStream is = null;
		try {
			URL url = new URL(descriptor.getURL());
			URLConnection conn = url.openConnection();
			if (conn instanceof HttpURLConnection) {
				HttpURLConnection httpCon = (HttpURLConnection) conn;
				if (Boot.CONNECT_TIMEOUT > 0) {
					httpCon.setConnectTimeout(Boot.CONNECT_TIMEOUT);
				}
				if (Boot.READ_TIMEOUT > 0) {
					httpCon.setReadTimeout(Boot.READ_TIMEOUT);
				}
				//					httpCon.connect();
			}

			is = conn.getInputStream();
		} catch (Exception e) {
			/*
			 * Something's wrong with this URL. Mark it as unavailable.
			 */
			System.err.println(""Package found in local repository, but not in global repository: "" + descriptor);
			availability.put(descriptor, false);
			return false;
		} finally {
			try {
				is.close();
			} catch (Exception e) {
			}
		}
		//		System.out.println(""Package available: ""+ descriptor);
		/*
		 * All fine, still available. Mark it as such.
		 */
		availability.put(descriptor, true);
		return true;
	}

	private PackageManager() {
		availability = new HashMap<PackageDescriptor, Boolean>();
	}

	private final PackageManagerListener.ListenerList listeners = new PackageManagerListener.ListenerList();
	private PackageStateReport report = null;
	private Canceller canceller = null;
	private boolean doAutoUpdate = false;
	private Preferences preferences = Preferences.userNodeForPackage(getClass());

	public static PackageManager getInstance() {
		if (instance == null) {
			instance = new PackageManager();
		}
		return instance;
	}

	public static void main(String[] args) {
		System.exit(new CommandLineInterface(getInstance()).run(args));
	}

	private File getConfigFile() {
		return new File(OsUtil.getProMPackageDirectory(), CONFIG_XML);
	}

	public void addListener(PackageManagerListener listener) {
		listeners.add(listener);
	}

	public void removeListener(PackageManagerListener listener) {
		listeners.remove(listener);
	}

	public File getPackagesDirectory() {
		return new File(Boot.PACKAGE_FOLDER);
	}

	public void initialize(Boot.Level verbose) {

		doAutoUpdate = Boolean.parseBoolean(preferences.get(DO_AUTO_UPDATES, Boolean.FALSE.toString()));

		String liteVersion = preferences.get(LITE_VERSION_INSTALLED, ""UNKNOWN"");
		if (Boot.PROM_VERSION.startsWith(Boot.LITE_PREFIX) && !liteVersion.equals(Boot.PROM_VERSION)) {
			preferences.put(LITE_VERSION_INSTALLED, Boot.PROM_VERSION);
			if (verbose == Level.ALL) {
				System.out.println("">>> New ProM-Lite installation found."");
				System.out.println("">>> Clearing package cache."");
			}
			try {
				cleanPackageCache();
			} catch (BackingStoreException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		getPackagesDirectory().mkdirs();
		File config = getConfigFile();

		if (verbose == Level.ALL) {
			System.out.println("">>> Loading packages from "" + config.getAbsolutePath());
		}

		try {
			writeDefaultConfigIfNeeded(config);

			repositories.clear();
			available.clear();
			installed.clear();
			PackageConfigPerister.read(config, repositories, available, installed, canceller);
			resolveAllConflicts(verbose);

		} catch (Exception e) {
			listeners.fireException(e);
		}
	}

	private void scanRepositories(Boot.Level verbose) throws ParserConfigurationException, SAXException, IOException {

		final Comparator<Repository> comp = new Comparator<Repository>() {

			public int compare(Repository o1, Repository o2) {
				return o1.getURL().toString().compareTo(o2.getURL().toString());
			}
		};

		Set<Repository> read = new TreeSet<Repository>(comp);
		Set<Repository> toRead = new TreeSet<Repository>(comp);
		toRead.addAll(repositories);

		toRead.add(new Repository(Boot.DEFAULT_REPOSITORY));
		while (!toRead.isEmpty()) {
			for (Repository rep : toRead) {
				URL packages = rep.getURL();
				if (verbose == Level.ALL) {
					System.out.println("">>> Loading packages from "" + packages);
				}
				URLConnection conn = packages.openConnection();
				if (conn instanceof HttpURLConnection) {
					HttpURLConnection httpCon = (HttpURLConnection) conn;
					if (Boot.CONNECT_TIMEOUT > 0) {
						httpCon.setConnectTimeout(Boot.CONNECT_TIMEOUT);
					}
					if (Boot.READ_TIMEOUT > 0) {
						httpCon.setReadTimeout(Boot.READ_TIMEOUT);
					}
					//					httpCon.connect();
				}
				long time = -System.currentTimeMillis();
				try {
					PackageConfigPerister.read(conn.getInputStream(), repositories, available, installed, canceller);
					time += System.currentTimeMillis();
					if (Boot.VERBOSE == Level.ALL) {
						System.out.println(""Read package in "" + time + "" milliseconds."");
					}
				} catch (FileNotFoundException e) {
					// did not find the file for some package
					time += System.currentTimeMillis();
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Failed to read package (file not found)."");
					}
				} catch (IOException e) {
					time += System.currentTimeMillis();
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Failed to read package in "" + time + "" milliseconds."");
					}
				}
			}
			read.addAll(toRead);
			toRead.clear();
			toRead.addAll(repositories);
			toRead.removeAll(read);
		}

	}

	private void writeDefaultConfigIfNeeded(File config) throws IOException {
		config.createNewFile();
		if (config.length() == 0) {
			PackageConfigPerister
					.write(config,
							new HashSet<Repository>(Arrays.asList(new Repository[] { new Repository(
									Boot.DEFAULT_REPOSITORY) })), new HashSet<PackageDescriptor>(),
							new HashSet<PackageDescriptor>());
		}
	}

	private void resolveAllConflicts(Boot.Level verbose) throws UnknownPackageException {
		boolean ok;

		do {
			ok = true;

			Map<String, PackageDescriptor> enabled = new HashMap<String, PackageDescriptor>();
			for (PackageDescriptor pack : getEnabledPackages()) {
				enabled.put(pack.getName(), pack);
			}
			for (PackageDescriptor pack : enabled.values()) {
				for (String dep : pack.getDependencies()) {
					PackageDescriptor p = enabled.get(dep);

					if (p == null) {
						pack.setHasBrokenDependencies();
						ok = false;

						if (verbose == Level.ALL) {
							System.out.println(""     deactivating: "" + pack + "" (missing at least "" + dep + "")"");
						}
						break;
					}
				}
				for (String conf : pack.getConflicts()) {
					PackageDescriptor p = enabled.get(conf);

					if (p != null) {
						pack.setHasBrokenDependencies();
						ok = false;

						if (verbose == Level.ALL) {
							System.out
									.println(""     deactivating: "" + pack + "" (conflicts with at least "" + conf + "")"");
						}
						break;
					}
				}
			}
		} while (!ok);
	}

	public String toString() {
		StringBuffer result = new StringBuffer();
		Set<PackageDescriptor> allPackages = new HashSet<PackageDescriptor>();

		for (Repository repo : repositories) {
			result.append(""Repository: "" + repo.getURL() + nl);
		}

		allPackages.addAll(installed);
		allPackages.addAll(available);
		for (PackageDescriptor pack : allPackages) {
			String status;

			if (installed.contains(pack)) {
				if (!pack.hasBrokenDependencies()) {
					status = ""I"";
				} else {
					status = ""M"";
				}
				boolean hasUpgrade = false;
				if (available.contains(pack)) {
					for (PackageDescriptor p : available) {
						if (p.equals(pack)) {
							hasUpgrade = pack.getVersion().lessThan(p.getVersion());
							break;
						}
					}
				}
				status += hasUpgrade ? ""+"" : "" "";
			} else {
				status = ""A "";
			}
			result.append(status + "" "" + pack);
			result.append(nl);
			if (!pack.getDependencies().isEmpty()) {
				result.append(""      (depends on: "" + pack.getDependencies() + "")"" + nl);
			}
			if (!pack.getConflicts().isEmpty()) {
				result.append(""      (conflicts with: "" + pack.getConflicts() + "")"" + nl);
			}
		}
		return result.toString();
	}

	public Set<Repository> getRepositories() {
		return Collections.unmodifiableSet(repositories);
	}

	//	public void addRepository(Repository repository) {
	//		repositories.add(repository);
	//		save();
	//	}

	public void removeRepository(Repository repository) {
		repositories.remove(repository);
		save();
	}

	public Set<PackageDescriptor> getInstalledPackages() {
		return Collections.unmodifiableSet(installed);
	}

	public Set<PackageDescriptor> getAvailablePackages() {
		return Collections.unmodifiableSet(available);
	}

	public Collection<PackageDescriptor> getEnabledPackages() throws UnknownPackageException {
		List<PackageDescriptor> result = new ArrayList<PackageDescriptor>();

		Set<PackageDescriptor> broken = new HashSet<PackageDescriptor>();

		Set<PackageDescriptor> installed = new HashSet<PackageDescriptor>(this.installed);

		/*
		 * During every iteration we should be able to add at least one package
		 * to the result set. Hence, we should need at most as many iterations
		 * as we have packages to add. If after this number if iterations some
		 * packages have not yet been added, there should be a cyclic dependency
		 * somewhere between the remaining packages.
		 * 
		 * Initialize the number of iterations we have still left.
		 */
		int iterationsLeft = installed.size();

		/*
		 * Iterate as long as needed.
		 */
		while (!installed.isEmpty() && iterationsLeft > 0) {
			Set<String> requiredPackages = new HashSet<String>();

			Iterator<PackageDescriptor> it = installed.iterator();
			while (it.hasNext()) {
				PackageDescriptor pack = it.next();
				if (pack.hasBrokenDependencies()) {
					broken.add(pack);
					it.remove();
				} else {

					if (getPackageMap(result).keySet().containsAll(pack.getDependencies())) {
						result.add(pack);
						it.remove();
					} else {
						// remember all packages that have been required
						requiredPackages.addAll(pack.getDependencies());
					}
				}
			}

			// after this iteration check whether we have any chance to resolve
			// the remaining dependencies: if not, throw an exception
			Set<String> listedPackages = new HashSet<String>(getPackageMap(this.installed).keySet());
			requiredPackages.removeAll(listedPackages);
			if (!requiredPackages.isEmpty()) {
				for (String required : requiredPackages) {
					System.out.println(""Cannot find required package: "" + required);
				}
				throw new UnknownPackageException(requiredPackages.toString());
			}
			/*
			 * One less iteration left.
			 */
			iterationsLeft--;
		}

		if (installed.isEmpty()) {
			if (Boot.VERBOSE == Level.ALL) {
				System.out.println("">>> All dependencies have been resolved"");
			}
		} else {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println("">>> The dependencies for the following packages have not been resolved:"");
				for (PackageDescriptor pack : installed) {
					System.err.println("">>>     "" + pack + "" "" + pack.getDependencies());
				}
			}
		}

		return result;
	}

	private void save() {
		try {
			PackageConfigPerister.write(getConfigFile(), repositories, available, installed);
		} catch (IOException e) {
			listeners.fireException(e);
			return;
		}
	}

	public void update(boolean autoInstall, Boot.Level verbose) throws CancelledException, UnknownPackageTypeException {

		try {
			scanRepositories(verbose);
		} catch (Exception e) {
			// continue with known repositories
			e.printStackTrace();
		}
		Map<String, SortedSet<PackageDescriptor>> map = PackageManager.getPackageMap(available);

		Set<PackageDescriptor> packs = new HashSet<PackageDescriptor>();

		// TODO allow clients to monitor progress and report errors

		//		for (Repository repository : repositories) {
		//			if ((canceller != null) && canceller.isCancelled()) {
		//				return;
		//			}
		//			System.out.println(""Updating: "" + repository);
		//			try {
		//				InputStream is = repository.getURL().openStream();
		//
		//				try {
		//					packs.addAll(PackageConfigPerister.listRepository(is, canceller));
		//				} catch (ParserConfigurationException e) {
		//					listeners.fireException(e);
		//					throw new CancelledException();
		//				} catch (CancelledException e) {
		//					throw e;
		//				} catch (SAXException e) {
		//					listeners.fireException(e);
		//					throw new CancelledException();
		//				} finally {
		//					is.close();
		//				}
		//			} catch (IOException e) {
		//				listeners.fireException(e);
		//				throw new CancelledException();
		//			}
		//			System.out.println(""Done updating: "" + repository);
		//		}
		//
		//		available.clear();
		//		available.addAll(packs);

		if (autoInstall) {
			List<PackageDescriptor> toRemove = new ArrayList<PackageDescriptor>();
			List<PackageDescriptor> toInstall = new ArrayList<PackageDescriptor>();
			for (PackageDescriptor pack : packs) {
				PackageDescriptor inst = findInstalledVersion(pack);
				if ((inst != null) && inst.getVersion().lessThan(pack.getVersion())) {
					// package was already installed, but new version is available.
					// old version remains, just in case this is required by some
					// existing plugins.
					System.out.println(""Found new version of installed package: "" + pack.getName());
					toInstall.add(pack);
					toRemove.add(inst);
				} else if ((inst == null) && pack.hasPlugins()) {
					// Install all available packages that carry plugins.
					System.out.println(""Found new package which contains plugins: "" + pack.getName());
					toInstall.add(pack);
					for (String dep : pack.getDependencies()) {
						if (!containsPackage(installed, dep)) {
							SortedSet<PackageDescriptor> packages = map.get(dep);
							if ((packages == null) || packages.isEmpty()) {
								toInstall.remove(pack);
								continue;
							}
							boolean found = false;
							for (PackageDescriptor p : packages) {
								toInstall.add(p);
								found = true;
								break;
							}
							if (!found) {
								toInstall.remove(pack);
							}

						}
					}
				}
			}
			if (!toInstall.isEmpty()) {
				System.out.println(""Installing packages: "" + toInstall.toString());
				install(toInstall);
				uninstall(toRemove);
				// execute does a save, no need to do that twice.
			} else {
				save();
			}
		} else {
			save();
		}
	}

	public PackageDescriptor findInstalledVersion(PackageDescriptor pack) {
		for (PackageDescriptor p : installed) {
			if (p.getName().equals(pack.getName())) {
				return p;
			}
		}
		return null;
	}

	public PackageDescriptor[] findOrInstallPackages(String... packageNames) throws UnknownPackageTypeException,
			UnknownPackageException, CancelledException {

		if (doAutoUpdate) {
			update(false, Level.NONE);
		}

		PackageDescriptor[] result = new PackageDescriptor[packageNames.length];
		List<PackageDescriptor> toInstall = new ArrayList<PackageDescriptor>(result.length);

		// First, consider all available packages
		Map<String, SortedSet<PackageDescriptor>> map = PackageManager.getPackageMap(available);

		// Check for each package if it might be installed
		for (int i = 0; i < packageNames.length; i++) {
			SortedSet<PackageDescriptor> packages = map.get(packageNames[i]);
			if ((packages == null) || packages.isEmpty()) {
				// No package is available with the name: names[i]
				throw new UnknownPackageException(packageNames[i]);
			}

			// Use the first available package for this name.
			// If there are more, they are sorted by 
			// version, latest version first.
			result[i] = packages.first();
			if (!doAutoUpdate) {
				// See if any of the versions is installed. If not,
				// install the latest
				for (PackageDescriptor d : packages) {
					if (installed.contains(d)) {
						result[i] = d;
						break;
					}
				}
			}
			if (!installed.contains(result[i])) {
				toInstall.add(result[i]);
			}

		}
		if (!toInstall.isEmpty()) {
			// Install some packages that were available, but not installed
			install(toInstall);
		}

		return result;
	}

	public void install(List<PackageDescriptor> toInstall) throws UnknownPackageTypeException, CancelledException {
		if ((canceller != null) && canceller.isCancelled()) {
			throw new CancelledException();
		}
		boolean exception = false;
		try {
			listeners.fireSessionStart();
			Set<PackageDescriptor> toAdd = new HashSet<PackageDescriptor>(toInstall);

			Map<String, SortedSet<PackageDescriptor>> map = PackageManager.getPackageMap(available);

			// TODO: rewrite these statements to take care of versions.
			//			// These need to be added
			//			toAdd.removeAll(getInstalledPackages());
			//			// No need to install packages that need to be removed anyway
			//			toAdd.removeAll(toRemove);

			Set<PackageDescriptor> newState = new HashSet<PackageDescriptor>(getInstalledPackages());
			newState.addAll(toAdd);

			checkConsistency(newState);
			boolean error = false;
			do {
				HashSet<String> extra = new HashSet<String>();
				for (Map.Entry<PackageDescriptor, Set<String>> item : report.getMissingDependencies().entrySet()) {
					extra.addAll(item.getValue());
				}
				if (!extra.isEmpty()) {
					for (String s : extra) {
						if (!map.containsKey(s) || map.get(s) == null) {
							// package required that is not available, break.
							error = true;
							System.err.println(""[PackageManager] Package "" + s + "" is not available."");
						} else {
							PackageDescriptor first = map.get(s).first();
							toAdd.add(first);
							newState.add(first);
						}
					}
					checkConsistency(newState);
				}
			} while (!error && !report.getMissingDependencies().isEmpty());

			HashSet<PackageDescriptor> toRemove = new HashSet<PackageDescriptor>();
			while (!error && !report.getPackagesWithMultipleVersions().isEmpty()) {
				// Resolved all dependencies, now check for multiple versions.
				for (Map.Entry<String, SortedSet<PackageDescriptor>> item : report.getPackagesWithMultipleVersions()
						.entrySet()) {
					Iterator<PackageDescriptor> it = item.getValue().iterator();
					it.next();
					while (it.hasNext()) {
						PackageDescriptor p = it.next();
						newState.remove(p);
						toRemove.add(p);
					}
				}
				checkConsistency(newState);
			}

			if (!report.hasErrors()) {
				for (PackageDescriptor pack : toAdd) {
					installPackage(pack);
				}

				installed.clear();
				installed.addAll(newState);

				uninstall(toRemove);

				save();

			}

		} catch (UnknownPackageTypeException e) {
			exception = true;
			throw e;
		} catch (CancelledException e) {
			exception = true;
			throw e;
		} finally {

			// Before propagating the error, make sure to signal the listeners of this error.
			listeners.fireSessionComplete(exception);
		}

	}

	public void uninstall(Collection<PackageDescriptor> toRemove) throws CancelledException {
		if ((canceller != null) && canceller.isCancelled()) {
			throw new CancelledException();
		}

		Set<PackageDescriptor> newState = new HashSet<PackageDescriptor>(getInstalledPackages());
		newState.removeAll(toRemove);

		checkConsistency(newState);
		boolean error = false;
		do {
			// All packages that now have broken dependencies should also be uninstalled
			newState.removeAll(report.getMissingDependencies().keySet());
			checkConsistency(newState);
		} while (!error && !report.getMissingDependencies().isEmpty());

		if (!report.hasErrors()) {

			removePackages(newState);

			installed.clear();
			installed.addAll(newState);

			save();

		}

	}

	public void setCanceller(Canceller canceller) {
		this.canceller = canceller;

	}

	public PackageStateReport getLatestReport() {
		synchronized (report) {
			return report;
		}
	}

	public void checkConsistency() {
		checkConsistency(getInstalledPackages());
	}

	private void checkConsistency(Set<PackageDescriptor> packages) {
		Map<String, SortedSet<PackageDescriptor>> multipleVersions = new HashMap<String, SortedSet<PackageDescriptor>>();
		Map<PackageDescriptor, Set<String>> missing = new HashMap<PackageDescriptor, Set<String>>();
		Map<PackageDescriptor, Set<String>> conflicts = new HashMap<PackageDescriptor, Set<String>>();

		// check whether at most one version of each package is installed
		for (Map.Entry<String, SortedSet<PackageDescriptor>> item : getPackageMap(packages).entrySet()) {
			if (item.getValue().size() > 1) {
				SortedSet<PackageDescriptor> versions = multipleVersions.get(item.getKey());

				if (versions == null) {
					versions = new TreeSet<PackageDescriptor>();
					multipleVersions.put(item.getKey(), versions);
				}
				versions.addAll(item.getValue());
			}
		}

		// check whether all dependencies are satisfied
		for (PackageDescriptor pack : packages) {
			for (String dep : pack.getDependencies()) {
				if (!containsPackage(packages, dep)) {
					Set<String> misses = missing.get(pack);

					if (misses == null) {
						misses = new HashSet<String>();
						missing.put(pack, misses);
					}
					misses.add(dep);
				}
			}
		}

		// check whether all conflicts are satisfied
		for (PackageDescriptor pack : packages) {
			for (String conf : pack.getConflicts()) {
				if (containsPackage(packages, conf)) {
					Set<String> conflictsWith = conflicts.get(pack);

					if (conflictsWith == null) {
						conflictsWith = new HashSet<String>();
						conflicts.put(pack, conflictsWith);
					}
					conflictsWith.add(conf);
				}
			}
		}

		report = new PackageStateReport(multipleVersions, missing, conflicts);
	}

	private boolean containsPackage(Set<PackageDescriptor> packages, String dep) {
		for (PackageDescriptor pack : packages) {
			if (dep.equals(pack.getName())) {
				return true;
			}
		}
		return false;
	}

	public static Map<String, SortedSet<PackageDescriptor>> getPackageMap(Collection<PackageDescriptor> packages) {
		Map<String, SortedSet<PackageDescriptor>> result = new HashMap<String, SortedSet<PackageDescriptor>>();

		for (PackageDescriptor pack : packages) {
			SortedSet<PackageDescriptor> list = result.get(pack.getName());

			if (list == null) {
				list = new TreeSet<PackageDescriptor>();
				result.put(pack.getName(), list);
			}
			list.add(pack);
		}
		return result;
	}

	private void installPackage(PackageDescriptor pack) throws UnknownPackageTypeException, CancelledException {
		File packageDir = pack.getLocalPackageDirectory();
		File tempDir = new File(packageDir.getAbsolutePath() + TEMP_INSTALL_DIR_POSTFIX);
		URL url;
		try {
			url = new URL(pack.getURL());
		} catch (MalformedURLException e) {
			listeners.fireException(e);
			return;
		}

		recursivelyDeleteDir(tempDir);
		recursivelyDeleteDir(packageDir);

		tempDir.mkdirs();
		packageDir.mkdirs();

		if (url.toString().toLowerCase().endsWith("".jar"")) {
			installJar(url, packageDir, pack.getName() + ""-"" + pack.getVersion(), pack);
		} else if (url.toString().toLowerCase().endsWith("".zip"")) {
			installZip(url, tempDir, packageDir, pack.getName() + ""-"" + pack.getVersion(), pack);
		} else {
			throw new UnknownPackageTypeException(pack);
		}
		if (PluginManagerImpl.getInstance() != null) {
			Boot.addJarsForPackage(pack, Level.ALL, PluginManagerImpl.getInstance());
		}
		recursivelyDeleteDir(tempDir);
	}

	private void removePackages(Collection<PackageDescriptor> toKeep) throws CancelledException {
		if ((canceller != null) && canceller.isCancelled()) {
			throw new CancelledException();
		}
		File packageDir = getPackagesDirectory();
		File[] files = packageDir.listFiles();
		Set<File> installations = new HashSet<File>();

		for (PackageDescriptor pack : toKeep) {
			if ((canceller != null) && canceller.isCancelled()) {
				throw new CancelledException();
			}
			installations.add(pack.getLocalPackageDirectory());
		}

		if (files != null) {
			for (File file : files) {
				if (!file.isDirectory()) {
					file.delete();
				} else if (!installations.contains(file)) {
					recursivelyDeleteDir(file);
				}
			}
		}
	}

	/*
	 * private Set<PackageDescriptor>
	 * findReverseDependenciesInInstalled(PackageDescriptor pack) { return
	 * findReverseDependencies(pack, installed); }
	 * 
	 * private Set<PackageDescriptor>
	 * findDependenciesInAvailable(PackageDescriptor pack,
	 * Set<PackageVersionRange> missing) { return findDependencies(pack,
	 * missing, available); }
	 * 
	 * private static Set<PackageDescriptor> findDependencies(PackageDescriptor
	 * pack, Set<PackageVersionRange> missing, Set<PackageDescriptor> packages)
	 * { Set<PackageDescriptor> result = new HashSet<PackageDescriptor>();
	 * Set<PackageVersionRange> todo = new HashSet<PackageVersionRange>();
	 * Set<PackageVersionRange> done = new HashSet<PackageVersionRange>();
	 * 
	 * while (!todo.isEmpty()) { PackageVersionRange dep =
	 * todo.iterator().next(); boolean found = false;
	 * 
	 * todo.remove(dep); done.add(dep);
	 * 
	 * for (PackageDescriptor p : packages) { if (dep.isSatisfiedBy(p)) {
	 * result.add(p); found = true; for (PackageVersionRange r :
	 * p.getDependencies()) { if (!done.contains(r)) { todo.add(r); } } break; }
	 * } if (!found) { missing.add(dep); } } return result; }
	 * 
	 * private static Set<PackageDescriptor>
	 * findReverseDependencies(PackageDescriptor pack, Set<PackageDescriptor>
	 * packages) { Set<PackageDescriptor> result = new
	 * HashSet<PackageDescriptor>();
	 * 
	 * for (PackageDescriptor p : packages) { Set<PackageVersionRange> missing =
	 * new HashSet<PackageVersionRange>(); Set<PackageDescriptor> deps =
	 * findDependencies(p, missing, packages);
	 * 
	 * if (deps.contains(pack)) { result.add(p); } } return result; }
	 */

	private void installZip(URL source, File temp, File unzipTo, String name, PackageDescriptor pack)
			throws CancelledException {
		File sourceZipFile = new File(temp, "".package.zip"");

		// download zip file

		listeners.fireStartDownload(name, source, pack);
		OutputStream out = null;
		try {
			out = new BufferedOutputStream(new FileOutputStream(sourceZipFile));
			copyInputStream(source.openStream(), out);
		} catch (Exception e) {
			listeners.fireException(e);
			throw new CancelledException();
		} finally {
			if (out != null) {
				try {
					out.close();
				} catch (IOException e) {
					throw new CancelledException();
				}
			}

		}

		listeners.fireStartInstall(name, unzipTo, pack);

		try {
			// extract zip file
			ZipFile zipFile = new ZipFile(sourceZipFile);
			Enumeration<?> zipFileEntries = zipFile.getEntries();

			while (zipFileEntries.hasMoreElements()) {
				ZipArchiveEntry entry = (ZipArchiveEntry) zipFileEntries.nextElement();
				File destFile = new File(unzipTo, entry.getName());

				if (entry.isDirectory()) {
					destFile.mkdirs();
				} else {
					destFile.getParentFile().mkdirs();

					OutputStream o = new FileOutputStream(destFile);
					try {
						copyInputStream(zipFile.getInputStream(entry), o);
					} finally {
						o.close();
					}

					//Only for non-windows operating systems: Check if the executable bit was set in the zip-archive,
					//if so, set it on the file system too. (Only checks and sets the owner executable bit.)
					if (!OsUtil.isRunningWindows()
							&& (entry.getUnixMode() & UNIX_OWNER_EXECUTABLE_BIT) == UNIX_OWNER_EXECUTABLE_BIT) {
						destFile.setExecutable(true);
					}
				}

			}
			zipFile.close();
		} catch (Exception e) {
			listeners.fireException(e);
			throw new CancelledException();
		}
		listeners.fireFinishedInstall(name, unzipTo, pack);
	}

	private void installJar(URL source, File dest, String name, PackageDescriptor pack) throws CancelledException {
		InputStream in = null;
		try {
			in = source.openStream();

			OutputStream out = null;
			File outFile = new File(dest, name + "".jar"");
			try {
				out = new FileOutputStream(outFile);
			} catch (FileNotFoundException e) {
				listeners.fireException(e);
				return;
			} finally {
				if (out != null) {
					out.close();
				}
			}
			listeners.fireStartDownload(name, source, pack);
			copyInputStream(in, out);
			listeners.fireStartInstall(name, outFile, pack);

			in.close();
			listeners.fireFinishedInstall(name, outFile, pack);
		} catch (IOException e) {
			listeners.fireException(e);
			throw new CancelledException();
		}
	}

	private void recursivelyDeleteDir(File dir) {
		if (dir.isDirectory()) {
			for (String child : dir.list()) {
				recursivelyDeleteDir(new File(dir, child));
			}
		}
		dir.delete();
	}

	private void copyInputStream(InputStream in, OutputStream out) throws IOException, CancelledException {
		try {
			byte[] buffer = new byte[1024];
			int len;

			while ((len = in.read(buffer)) >= 0) {
				if ((canceller != null) && canceller.isCancelled()) {
					throw new CancelledException();
				}
				out.write(buffer, 0, len);
			}
		} finally {
			try {
				in.close();
			} finally {
				out.close();
			}
		}
	}

	public PackageManagerListener.ListenerList getListeners() {
		return listeners;
	}

	@Deprecated
	public boolean doAutoUpdate() {
		return doAutoUpdate;
	}

	@Deprecated
	public void setAutoUpdate(boolean doAutoUpdate) {
		this.doAutoUpdate = doAutoUpdate;
		this.preferences.put(DO_AUTO_UPDATES, Boolean.toString(doAutoUpdate));

	}

	/**
	 * Cleans the package cache in the registry. This is automatically done for
	 * ProM-Lite the first time when a new version of ProM-Lite is booted.
	 * 
	 * @throws BackingStoreException
	 */
	public void cleanPackageCache() throws BackingStoreException {
		PluginCacheEntry.clearSettingsCache();

	}
}
"
PackageSet.java,prom-framework-6.9.97,"package org.processmining.framework.packages;

import java.util.HashSet;

import org.processmining.framework.packages.PackageDescriptor.OS;

public class PackageSet extends HashSet<PackageDescriptor> {

	private static final long serialVersionUID = -5010658216636461231L;

	public boolean add(PackageDescriptor e) {
		if (e.getOS() == OS.WIN64) {
			// check for removal of Win32 version
			for (PackageDescriptor pack : this) {
				if (pack.getName().equals(e.getName()) && //
						pack.getVersion().equals(e.getVersion()) && //
						pack.getOS() == OS.WIN32) {
					remove(pack);
					break;
				}
			}
		} else {
			if (e.getOS() == OS.WIN32) {
				// Check if Win64 version already in the set
				for (PackageDescriptor pack : this) {
					if (pack.getName().equals(e.getName()) && //
							pack.getVersion().equals(e.getVersion()) && //
							pack.getOS() == OS.WIN64) {
						// win64 version already available. Don't add 32 bit version.
						return false;
					}
				}
			}
		}
		return super.add(e);
	}
}
"
PackageStateReport.java,prom-framework-6.9.97,"package org.processmining.framework.packages;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;

public class PackageStateReport {

	private final Map<PackageDescriptor, Set<String>> missing;
	private final Map<PackageDescriptor, Set<String>> conflicts;
	private final Map<String, SortedSet<PackageDescriptor>> multipleVersions;

	public PackageStateReport(Map<String, SortedSet<PackageDescriptor>> multipleVersions,
			Map<PackageDescriptor, Set<String>> missing, Map<PackageDescriptor, Set<String>> conflicts) {
		this.multipleVersions = multipleVersions;
		this.conflicts = conflicts;
		this.missing = missing;
	}

	public Map<PackageDescriptor, Set<String>> getMissingDependencies() {
		return missing;
	}

	public Map<PackageDescriptor, Set<String>> getConflictingPackages() {
		return conflicts;
	}

	public Map<String, SortedSet<PackageDescriptor>> getPackagesWithMultipleVersions() {
		return multipleVersions;
	}

	public String toString() {
		List<String> lines = new ArrayList<String>();

		for (Map.Entry<String, SortedSet<PackageDescriptor>> item : getPackagesWithMultipleVersions().entrySet()) {
			lines.add(""Package "" + item.getKey() + "" has or will have multiple versions installed:"");
			for (PackageDescriptor p : item.getValue()) {
				lines.add(""  "" + p);
			}
		}
		for (Map.Entry<PackageDescriptor, Set<String>> item : getMissingDependencies().entrySet()) {
			lines.add(""Package "" + item.getKey() + "" depends on packages which are and will not be installed:"");
			for (String dep : item.getValue()) {
				lines.add(""  "" + dep);
			}
		}
		for (Map.Entry<PackageDescriptor, Set<String>> item : getConflictingPackages().entrySet()) {
			lines.add(""Package "" + item.getKey() + "" conflicts with packages which are or will be installed:"");
			for (String confl : item.getValue()) {
				lines.add(""  "" + confl);
			}
		}

		StringBuffer result = new StringBuffer();
		for (String s : lines) {
			result.append(s);
			result.append(System.getProperty(""line.separator""));
		}
		return result.toString();
	}

	public boolean hasErrors() {
		return !getConflictingPackages().isEmpty() || !getMissingDependencies().isEmpty()
				|| !getPackagesWithMultipleVersions().isEmpty();
	}
}
"
PackageVersion.java,prom-framework-6.9.97,"package org.processmining.framework.packages;

import java.util.ArrayList;
import java.util.List;

public class PackageVersion implements Comparable<PackageVersion> {

	private final List<Integer> version;

	public PackageVersion(String version) {
		this.version = parse(version);
	}

	private List<Integer> parse(String v) {
		List<Integer> result = new ArrayList<Integer>();
		String[] components = v.split(""[^0-9]"");

		for (String c : components) {
			if (c.length() > 0) {
				result.add(Integer.parseInt(c));
			}
		}
		return result;
	}

	public boolean equals(Object o) {
		if (!(o instanceof PackageVersion)) {
			return false;
		}
		return version.equals(((PackageVersion) o).version);
	}

	public int hashCode() {
		return version.hashCode();
	}

	public String toString() {
		String result = new String();

		for (Integer i : version) {
			if (result.length() > 0) {
				result += '.';
			}
			result += i;
		}
		return result;
	}

	public boolean lessOrEqual(PackageVersion v) {
		return compareTo(v) <= 0;
	}

	public boolean lessThan(PackageVersion v) {
		return compareTo(v) < 0;
	}

	public int compareTo(PackageVersion v) {
		for (int i = 0; i < version.size(); i++) {
			if (i < v.version.size()) {
				int self = version.get(i);
				int other = v.version.get(i);

				if (self < other) {
					return -1;
				} else if (self > other) {
					return 1;
				}
			} else {
				return 1;
			}
		}
		return version.size() == v.version.size() ? 0 : -1;
	}
}
"
Repository.java,prom-framework-6.9.97,"package org.processmining.framework.packages;

import java.net.URL;

public class Repository {

	private final URL url;

	public Repository(URL url) {
		this.url = url;
	}

	public URL getURL() {
		return url;
	}

	public String toString() {
		return ""Repository("" + getURL().toString() + "")"";
	}

	public boolean equals(Object other) {
		if (!(other instanceof Repository)) {
			return false;
		}
		return ((Repository) other).getURL().equals(url);
	}

	public int hashCode() {
		return url.hashCode();
	}
}
"
UnknownPackageException.java,prom-framework-6.9.97,"package org.processmining.framework.packages;

public class UnknownPackageException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1037754203430229972L;
	private final String name;

	public UnknownPackageException(String name) {
		super(""Unknow package: "" + name);
		this.name = name;
	}

	public String getName() {
		return name;
	}
}
"
UnknownPackageTypeException.java,prom-framework-6.9.97,"package org.processmining.framework.packages;

public class UnknownPackageTypeException extends Exception {

	private static final long serialVersionUID = -7248277354439798414L;
	private final PackageDescriptor pack;

	public UnknownPackageTypeException(PackageDescriptor pack) {
		super(""Unknow package file type: "" + pack.getURL());
		this.pack = pack;
	}

	public PackageDescriptor getPack() {
		return pack;
	}
}
"
Bootable.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Bootable {
}
"
CLI.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface CLI {
	String functionName();
}
"
KeepInProMCache.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation that is used as a base annotation for all classes that need to be
 * kept in cache by the ProM framework. When a class carries this annotation,
 * the ProM PluginManager will scan the class during first boot and store the
 * class in the cache for future reference.
 * 
 * This allows ProM to build a mapping from annotations to annotated classes
 * during boot.
 * 
 * @author bfvdonge
 * 
 */

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Inherited
public @interface KeepInProMCache {

}
"
Plugin.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD, ElementType.TYPE })
public @interface Plugin {

	/**
	 * Returns the name identifying this plugin in a human readable way.
	 * 
	 * @return
	 */
	String name();

	/**
	 * Returns an Array of strings, such that each String is an initial label
	 * for a returned object. Plugins can change this label during execution.
	 * 
	 * The length of the array should be the same as the length of the
	 * returnTypes array.
	 * 
	 * @return
	 */
	String[] returnLabels();

	/**
	 * Returns an Array of Class objects, such that each class object represents
	 * the type of the returned object at that index, i.e. the plugin should
	 * return as many objects as the length of this array, and each object
	 * should be of the type given in this array.
	 * 
	 * @return
	 */
	Class<?>[] returnTypes();

	/**
	 * Returns the labels of the parameters for this plugin.
	 * 
	 * If the Plugin annotation is used on a method, then the number of elements
	 * in this array should correspond to the number of parameters that the
	 * method requires, not counting the first parameter of type PluginContext.
	 * 
	 * If the plugin annotation is used on a class, then each variant should
	 * indicate which subset of parameters it requires. Each parameter should
	 * appear in at least one variant.
	 * 
	 * Note that the types of the parameters are not specified in the
	 * annotation. Instead they are derived from the method definitions that
	 * contain the logic of this plugin. Parameters can be overloaded, i.e. the
	 * same parameter can have multiple types.
	 * 
	 * @return
	 */
	String[] parameterLabels();

	/**
	 * Returns the help / description for this plugin.
	 * 
	 * @return Empty string as default
	 */
	String help() default """";

	/**
	 * Signals the framework to make this plugin user-accessible. If a plugin is
	 * not user-accessible, it does not show up in any UI
	 * 
	 * @return Defaults to true.
	 */
	boolean userAccessible() default true;

	/**
	 * Returns the index + 1 in the result array of the most significant result
	 * for this plugin, i.e. if the first element in the array is the most
	 * significant, then the value of this parameter should be 1.
	 * 
	 * If the plugin does not return anything interesting itself, but considers
	 * one of it's inputs to be the most significant one, then a negative value
	 * should be returned. I.e. if the first parameter is the most significant
	 * result, a value of -1 has to be returned. Note that this parameter should
	 * always be included in all variants
	 * 
	 * @return the index in the result array of the most significant result. If
	 *         no results are returned by this plugin, anything can be returned.
	 *         Defaults to 1
	 * 
	 */
	int mostSignificantResult() default 1;

	/**
	 * Whether this plugin handles cancel itself. If this is true, the plug-in
	 * will not be killed but is allowed to terminate itself by monitoring
	 * isCancelled.
	 * 
	 * @return
	 */
	boolean handlesCancel() default false;

	/**
	 * Categories define the 'type' of functionality the plugin provides.
	 */
	PluginCategory[] categories() default { PluginCategory.Analytics };

	/**
	 * Keywords / tags for the plugin (extra description)
	 */
	String[] keywords() default {};
	
	/**
	 * Indication of quality for plug-in.
	 * @return
	 */
	PluginQuality quality() default PluginQuality.VeryPoor;
	/**
	 * Indication of level for plug-in.
	 * @return
	 */
	PluginLevel level() default PluginLevel.NightlyBuild;
	
	String icon() default """";
	String url() default """";
}
"
PluginCategory.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.annotations;

/**
 * Plugin Category
 * 
 * @author mleemans
 * 
 *         Possible categories specifying the 'type' of functionality the plugin
 *         provides.
 */
public enum PluginCategory {
	Discovery( //
			""Discovery"", //
			""Discovery plugin constructs a model from a given event log"", //
			""action_filter_discovery_20x20.png""), //
	ConformanceChecking( //
			""Conformance Checking"", //
			""Conformance checking plugin check conformance between a given a model and a given event log"", //
			""action_filter_conformance_20x20.png""), //
	Enhancement( //
			""Enhancement"", //
			""Enhancement plugin enhances a given model using a given log"", //
			""action_filter_enhancement_20x20.png""), //
	Filtering( //
			""Filtering"", //
			""Filtering plugin filters or clusters a given log"", //
			""action_filter_filtering_20x20.png""), //
	Analytics( //
			""Analytics"", //
			""Analytic plugin provides additional analysis for a given log"", //
			""action_filter_analytics_20x20.png"");

	private final String name;
	private final String description;
	private final String imageFilterFilename;

	private PluginCategory(String name, String description, String imageFilterFilename) {
		this.name = name;
		this.description = description;
		this.imageFilterFilename = imageFilterFilename;
	}

	public String getName() {
		return name;
	}

	public String getDescription() {
		return description;
	}

	public String getImageFilterFilename() {
		return imageFilterFilename;
	}

}
"
PluginLevel.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.annotations;

public enum PluginLevel {
	Local( //
			""Local"", //
			1), //
	NightlyBuild( //
			""NightlyBuild"", //
			2), //
	Regular( //
			""Regular"", //
			3), //
	PeerReviewed( //
			""PeerReviewed"", //
			4), //
	BulletProof( //
			""BulletProof"", //
			5);

	private final String name;
	private final int value;

	private PluginLevel(String name, int value) {
		this.name = name;
		this.value = value;
	}

	public String getName() {
		return name;
	}

	public int getValue() {
		return value;
	}

}
"
PluginQuality.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.annotations;

public enum PluginQuality {
	VeryPoor( //
			""VeryPoor"", //
			0), //
	Poor( //
			""Poor"", //
			1), //
	Fair( //
			""Fair"", //
			2), //
	Good( //
			""Good"", //
			3), //
	VeryGood( //
			""VeryGood"", //
			4);

	private final String name;
	private final int value;

	private PluginQuality(String name, int value) {
		this.name = name;
		this.value = value;
	}

	public String getName() {
		return name;
	}

	public int getValue() {
		return value;
	}
}
"
PluginVariant.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface PluginVariant {

	/**
	 * Each plugin variant specifies the required parameter labels in this
	 * Array. The array should be at most as long as the parameterLabels array
	 * of the Plugin annotation. Furthermore, all elements of the array should
	 * be indices in the parametersLabels array of the Plugin annotation and the
	 * elements should be ordered.
	 * 
	 * @return
	 */
	int[] requiredParameterLabels();

	/**
	 * This String represents the label of the plugin variant. This label is
	 * used to identify different variants of the same plugin, specifically when
	 * multiple variants accept the same parameters of the same types.
	 */
	String variantLabel() default """";

	/**
	 * Returns the help / description for this plugin variant.
	 * 
	 * @return Empty string as default
	 */
	String help() default """";

}
"
ConnectionObjectListener.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.connections.ConnectionID;

public interface ConnectionObjectListener extends EventListener {

	public class ListenerList extends ProMEventListenerList<ConnectionObjectListener> {
		public void fireConnectionCreated(ConnectionID connectionID) {
			for (ConnectionObjectListener listener : getListeners()) {
				listener.connectionCreated(connectionID);
			}
		}

		public void fireConnectionDeleted(ConnectionID id) {
			for (ConnectionObjectListener listener : getListeners()) {
				listener.connectionDeleted(id);
			}
		}

		public void fireConnectionUpdated(ConnectionID id) {
			for (ConnectionObjectListener listener : getListeners()) {
				listener.connectionUpdated(id);
			}
		}
	}

	/**
	 * This method signals the creation of a connection with the given ID. For
	 * access to the actual connection, the connectionManager should be used.
	 * 
	 * @param connectionID
	 */
	public void connectionCreated(ConnectionID connectionID);

	/**
	 * This method signals the deletion of a connection with the given ID. For
	 * access to the actual connection, the connectionManager should be used.
	 * 
	 * @param connectionID
	 */
	public void connectionDeleted(ConnectionID connectionID);

	/**
	 * This method signals that the connection with the given ID was updated.
	 * For access to the actual connection, the connectionManager should be
	 * used.
	 * 
	 * Be aware, that the actual pointers to the objects connected by the
	 * Connection with the given ID are not changed. Furthermore, it is wise not
	 * to update connections too often.
	 * 
	 * @param connectionID
	 */
	public void connectionUpdated(ConnectionID connectionID);

}
"
FutureListener.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.plugin.ProMFuture;

public interface FutureListener extends EventListener {

	public class ListenerList extends ProMEventListenerList<FutureListener> {
		public void fireFutureReady(ProMFuture<? extends Object> future) {
			for (FutureListener listener : getListeners()) {
				listener.futureReady(future);
			}
		}
	}

	public void futureReady(ProMFuture<? extends Object> future);

}
"
Logger.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.plugin.PluginContextID;

public interface Logger extends EventListener {

	public enum MessageLevel {
		/**
		 * Normal message level, for information during runtime
		 */
		NORMAL("" "", ""Normal""),
		/**
		 * Warning message level, for warning messages during runtime
		 */
		WARNING(""W"", ""Warning""),
		/**
		 * Error message level, for error information during ruintime. Use in
		 * case error can be recovered from, i.e. not in case of exception
		 * handling.
		 */
		ERROR(""E"", ""Error""),
		/**
		 * All TEST messages are omitted in the release version.
		 */
		TEST(""T"", ""Test""),
		/**
		 * All DEBUG messages are omitted in the release version.
		 */
		DEBUG(""D"", ""Debug"");

		private final String shortName;
		private final String longName;

		MessageLevel(String shortName, String longName) {
			this.shortName = shortName;
			this.longName = longName;
		}

		public String getShortName() {
			return shortName;
		}

		public String getLongName() {
			return longName;
		}
	}

	public class ListenerList extends ProMEventListenerList<Logger> {

		public void fireLog(String message, PluginContextID contextID, MessageLevel messageLevel) {
			for (Logger listener : getListeners()) {
				listener.log(message, contextID, messageLevel);
			}
		}

		public void fireLog(Throwable t, PluginContextID contextID) {
			for (Logger listener : getListeners()) {
				listener.log(t, contextID);
			}
		}
	}

	public void log(String message, PluginContextID contextID, MessageLevel messageLevel);

	public void log(Throwable t, PluginContextID contextID);

}
"
NameChangeListener.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

public interface NameChangeListener extends EventListener {

	public class ListenerList extends ProMEventListenerList<NameChangeListener> {
		public void fireNameChanged(String newName) {
			for (NameChangeListener listener : getListeners()) {
				listener.nameChanged(newName);
			}
		}
	}

	public void nameChanged(String newName);
}
"
PluginLifeCycleEventListener.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.plugin.PluginContext;

public interface PluginLifeCycleEventListener extends EventListener {

	/**
	 * This method is invoked on a parent context, if a child context of that
	 * parent is created.
	 * 
	 * @param context
	 *            the new Child context
	 */
	public void pluginCreated(PluginContext context);

	/**
	 * This method is invoked on a context, if it is started
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginStarted(PluginContext context);

	/**
	 * This method is invoked on a context, if it is suspended
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginSuspended(PluginContext context);

	/**
	 * This method is invoked on a context, if it is resumed
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginResumed(PluginContext context);

	/**
	 * This method is invoked on a context, if it is completed
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginCompleted(PluginContext context);

	/**
	 * This method is invoked on a context, if it is cancelled
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginCancelled(PluginContext context);

	/**
	 * This method is invoked on a context, if it throws an exception
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginTerminatedWithError(PluginContext context, Throwable t);

	/**
	 * This method is invoked on a context, if it's future was set.
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginFutureCreated(PluginContext context);

	/**
	 * This method is invoked on a context, if it's deleted from its parent
	 * 
	 * @param context
	 *            the context
	 */
	public void pluginDeleted(PluginContext context);

	public class List extends ProMEventListenerList<PluginLifeCycleEventListener> {
		public void firePluginCreated(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginCreated(context);
			}
		}

		public void firePluginStarted(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginStarted(context);
			}
		}

		public void firePluginSuspended(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginSuspended(context);
			}
		}

		public void firePluginResumed(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginResumed(context);
			}
		}

		public void firePluginCompleted(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginCompleted(context);
			}
		}

		public void firePluginCancelled(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginCancelled(context);
			}
		}

		public void firePluginTerminatedWithError(PluginContext context, Throwable t) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginTerminatedWithError(context, t);
			}
		}

		public void firePluginFutureCreated(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginFutureCreated(context);
			}
		}

		public void firePluginDeleted(PluginContext context) {
			for (PluginLifeCycleEventListener listener : getListeners()) {
				listener.pluginDeleted(context);
			}
		}
	}
}"
ProgressEventListener.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

public interface ProgressEventListener extends EventListener {

	void changeProgressCaption(String newCaption);

	void changeProgress(int progress);

	void changeProgressBounds(int lowBo, int upBo);

	void changeProgressIndeterminate(boolean indeterminate);

	public class ListenerList extends ProMEventListenerList<ProgressEventListener> {
		public void fireProgressCaptionChanged(String newCaption) {
			for (ProgressEventListener listener : getListeners()) {
				listener.changeProgressCaption(newCaption);
			}
		}

		public void fireProgressChanged(int progress) {
			for (ProgressEventListener listener : getListeners()) {
				listener.changeProgress(progress);
			}
		}

		public void fireProgressBoundsChanged(int lowBo, int upBo) {
			for (ProgressEventListener listener : getListeners()) {
				listener.changeProgressBounds(lowBo, upBo);
			}
		}

		public void fireProgressIndeterminateChanged(boolean indeterminate) {
			for (ProgressEventListener listener : getListeners()) {
				listener.changeProgressIndeterminate(indeterminate);
			}
		}
	}
}"
ProMEventListenerList.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.events;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.EventListener;
import java.util.Iterator;
import java.util.List;

public class ProMEventListenerList<T extends EventListener> {

	private final List<WeakReference<T>> listeners = new ArrayList<WeakReference<T>>(2);

	public void add(T listener) {
		synchronized (listeners) {
			listeners.add(new WeakReference<T>(listener));
		}
	}

	public int getListenerCount() {
		return listeners.size();
	}

	protected List<T> getListeners() {
		List<T> result = new ArrayList<T>();
		Iterator<WeakReference<T>> it = listeners.iterator();
		while (it.hasNext()) {
			T object = it.next().get();
			if (object != null) {
				result.add(object);
			} else {
				it.remove();
			}
		}
		return result;
	}

	public void remove(T listener) {
		while (listeners.contains(listener)) {
			listeners.remove(listener);
		}
	}

	public String toString() {
		return listeners.toString();
	}

	public void removeAll() {
		listeners.clear();
	}

}"
ProvidedObjectLifeCycleListener.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.events;

import java.util.EventListener;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.providedobjects.ProvidedObjectID;

public interface ProvidedObjectLifeCycleListener extends EventListener {

	public void providedObjectCreated(ProvidedObjectID objectID, PluginContext context);

	public void providedObjectFutureReady(ProvidedObjectID objectID);

	public void providedObjectNameChanged(ProvidedObjectID objectID);

	public void providedObjectObjectChanged(ProvidedObjectID objectID);

	public void providedObjectDeleted(ProvidedObjectID objectID);

	public class ListenerList extends ProMEventListenerList<ProvidedObjectLifeCycleListener> {
		public void fireProvidedObjectCreated(ProvidedObjectID objectID, PluginContext context) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectCreated(objectID, context);
			}
		}

		public void fireProvidedObjectNameChanged(ProvidedObjectID objectID) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectNameChanged(objectID);
			}
		}

		public void fireProvidedObjectObjectChanged(ProvidedObjectID objectID) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectObjectChanged(objectID);
			}
		}

		public void fireProvidedObjectDeleted(ProvidedObjectID objectID) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectDeleted(objectID);
			}
		}

		public void fireProvidedObjectFutureReady(ProvidedObjectID objectID) {
			for (ProvidedObjectLifeCycleListener listener : getListeners()) {
				listener.providedObjectFutureReady(objectID);
			}
		}
	}
}
"
GlobalContext.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.providedobjects.ProvidedObjectManager;

/**
 * Any implementation should maintain a referencte to a single plugin context.
 * This plugin context is then used create children, in which plugins are
 * executed.
 * 
 * @author bfvdonge
 * 
 */
public interface GlobalContext {

	/**
	 * Returns the plugin manager. The plugin manager can be used to query for
	 * plugins which are registered in ProM.
	 * 
	 * @return the plugin manager
	 */
	PluginManager getPluginManager();

	/**
	 * Returns the providedObject manager. The providedObject manager can be
	 * used to query for providedObjects which are registered in ProM. The
	 * manager should be a ProvidedObjectListener on all PluginInstanceContexts
	 * created by createRootInstanceContext.
	 * 
	 * @return the providedObject manager
	 */
	ProvidedObjectManager getProvidedObjectManager();

	/**
	 * Returns the connection manager. The connection manager can be used to
	 * query for connections which are registered in ProM.
	 * 
	 * @return the connection manager
	 */

	ConnectionManager getConnectionManager();

	/**
	 * The GlobalContext implementation should create IDs for all PluginContexts
	 * instantiated for it.
	 * 
	 * @return
	 */
	PluginContextID createNewPluginContextID();

	/**
	 * This method invokes the specified plugin in a context which is a child of
	 * the main plugin context maintained by this globalContext. No results are
	 * provided to the method calling this method and the plugin is executed
	 * some time in the future, as decided by the implementing class.
	 * 
	 * @param plugin
	 *            The plugin that should be invoked by the framework
	 * @param index
	 *            The index of the plugin method that should be invoked.
	 * @param objects
	 *            The objects to serve as input as accepted by the method at
	 *            index of the plugin
	 */
	void invokePlugin(PluginDescriptor plugin, int index, Object... objects);

	/**
	 * This method invokes the specified binding in a context which is a child
	 * of the main plugin context maintained by this globalContext. No results
	 * are provided to the method calling this method and the plugin is executed
	 * some time in the future, as decided by the implementing class.
	 * 
	 * @param binding
	 *            The binding that should be invoked by the framework
	 * @param objects
	 *            The objects to serve as input as accepted by the given
	 *            binding.
	 */
	void invokeBinding(PluginParameterBinding binding, Object... objects);

	/**
	 * Returns the specific type of the PluginContext. This type is used to
	 * instantiate new contexts in which to invoke plugins.
	 * 
	 * @return the type of PluginContext provided by this global context
	 */
	Class<? extends PluginContext> getPluginContextType();

}
"
AbstractGlobalContext.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.impl;

import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.connections.impl.ConnectionManagerImpl;
import org.processmining.framework.plugin.GlobalContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginContextID;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.events.Logger;
import org.processmining.framework.providedobjects.ProvidedObjectManager;
import org.processmining.framework.providedobjects.impl.ProvidedObjectManagerImpl;

/**
 * Since this context should maintain a link to a single plugin context, and
 * PluginContextImpl is abstract, this context is also abstract.
 * 
 * @author bfvdonge
 * 
 */
public abstract class AbstractGlobalContext implements GlobalContext {

	private final ProvidedObjectManager providedObjectManager = new ProvidedObjectManagerImpl();
	private final ConnectionManager connectionManager = new ConnectionManagerImpl(PluginManagerImpl.getInstance());
	protected final Logger.ListenerList loggingEventListeners = new Logger.ListenerList();

	public PluginManager getPluginManager() {
		return PluginManagerImpl.getInstance();
	}

	public ConnectionManager getConnectionManager() {
		return connectionManager;
	}

	public ProvidedObjectManager getProvidedObjectManager() {
		return providedObjectManager;
	}

	public PluginContextID createNewPluginContextID() {
		return new PluginContextIDImpl();
	}

	public void invokeBinding(PluginParameterBinding binding, Object... objects) {

		PluginContext c2 = getMainPluginContext().createChildContext(binding.getPlugin().getName());

		try {
			// Create a new providedObject, by passing the future to the
			// providedObjectManager;
			getMainPluginContext().getPluginLifeCycleEventListeners().firePluginCreated(c2);
			binding.invoke(c2, objects);
			getProvidedObjectManager().createProvidedObjects(c2);

		} catch (IllegalArgumentException e) {
			getMainPluginContext().log(e);
			return;
		} finally {
			c2.getParentContext().deleteChild(c2);
		}

		// Since the result is still being calculated, we can only
		// use the defaultResultName for the providedObject.

	}

	public void invokePlugin(PluginDescriptor plugin, int index, Object... objects) {
		PluginContext c2 = getMainPluginContext().createChildContext(plugin.getName());

		try {
			// Create a new providedObject, by passing the future to the
			// providedObjectManager;
			getMainPluginContext().getPluginLifeCycleEventListeners().firePluginCreated(c2);
			plugin.invoke(index, c2, objects);
			getProvidedObjectManager().createProvidedObjects(c2);

		} catch (IllegalArgumentException e) {
			getMainPluginContext().log(e);
			return;
		} finally {
			c2.getParentContext().deleteChild(c2);
		}

		// Since the result is still being calculated, we can only
		// use the defaultResultName for the providedObject.

	}

	protected abstract PluginContext getMainPluginContext();

	public abstract Class<? extends PluginContext> getPluginContextType();

}
"
AbstractPluginContext.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.impl;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.plugin.GlobalContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginContextID;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.Progress;
import org.processmining.framework.plugin.RecursiveCallException;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.events.Logger;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.plugin.events.PluginLifeCycleEventListener;
import org.processmining.framework.plugin.events.ProgressEventListener;
import org.processmining.framework.providedobjects.ProvidedObjectManager;
import org.processmining.framework.util.Cast;
import org.processmining.framework.util.Pair;

public abstract class AbstractPluginContext implements PluginContext {

	private final GlobalContext context;
	private final PluginContext parentPluginContext;

	private final PluginLifeCycleEventListener.List lifeCycleEventListeners = new PluginLifeCycleEventListener.List();
	private final ProgressEventListener.ListenerList progressEventListeners = new ProgressEventListener.ListenerList();
	private final Logger.ListenerList loggers = new Logger.ListenerList();

	protected Progress progress;
	private PluginDescriptor descriptor;
	private final java.util.List<PluginContext> childContexts = new ArrayList<PluginContext>(0);
	private PluginExecutionResult futures = null;
	private final PluginContextID id;
	private String label = """";
	private int methodIndex = -1;

	/**
	 * Create a new root plugin instance context.
	 * 
	 * @param context
	 *            the global context in which this instance context is used
	 */
	public AbstractPluginContext(GlobalContext context, String label) {
		assert (context != null);
		this.context = context;
		id = context.createNewPluginContextID();
		this.label = label;
		parentPluginContext = null;
		progress = new ProgressBarImpl(this);
	}

	protected AbstractPluginContext(AbstractPluginContext context, String label) {
		assert (context != null);
		this.context = context.getGlobalContext();
		id = this.context.createNewPluginContextID();
		this.label = label;
		parentPluginContext = context;
		progress = new ProgressBarImpl(this);
	}

	public Pair<PluginDescriptor, Integer> getPluginDescriptor() {
		return new Pair<PluginDescriptor, Integer>(descriptor, methodIndex);
	}

	public GlobalContext getGlobalContext() {
		return context;
	}

	public PluginLifeCycleEventListener.List getPluginLifeCycleEventListeners() {
		return lifeCycleEventListeners;
	}

	public ProgressEventListener.ListenerList getProgressEventListeners() {
		return progressEventListeners;
	}

	public Progress getProgress() {
		return progress;
	}

	public PluginContextID getID() {
		return id;
	}

	public ConnectionManager getConnectionManager() {
		return context.getConnectionManager();
	}

	public String getLabel() {
		return label;
	}

	public boolean hasPluginDescriptorInPath(PluginDescriptor plugin, int methodIndex) {
		return ((methodIndex == this.methodIndex) && (plugin == descriptor))
				|| (getParentContext() == null ? false : getParentContext().hasPluginDescriptorInPath(plugin,
						methodIndex));
	}

	public void setPluginDescriptor(PluginDescriptor descriptor, int methodIndex) throws FieldSetException,
			RecursiveCallException {
		if ((getParentContext() != null) && getParentContext().hasPluginDescriptorInPath(descriptor, methodIndex)) {
			throw new RecursiveCallException(this, descriptor, methodIndex);
		}
		if (this.descriptor == null) {
			this.methodIndex = methodIndex;
			this.descriptor = descriptor;
		} else {
			throw new FieldSetException(""descriptor"",
					""Use getGlobalContext().createInstanceContext() to create a new instance context"");
		}
	}

	public PluginContext createChildContext(String label) {
		PluginContext context = createTypedChildContext(label);
		childContexts.add(context);
		return context;
	}

	public java.util.List<PluginContext> getChildContexts() {
		return Collections.unmodifiableList(childContexts);
	}

	public PluginContext getParentContext() {
		return parentPluginContext;
	}

	protected abstract PluginContext createTypedChildContext(String label);

	/**
	 * This method returns the PluginExecutionResult of the plugin which is
	 * invoked in this context. This future result is set by
	 * PluginManager.invoke() and will not be available (will be null) until the
	 * invoke() method is called.
	 * 
	 * @return The PluginExecutionResult that represents the result of this
	 *         plugin invocation
	 * @throws FieldNotSetException
	 *             If the future is not know to this context
	 */
	public PluginExecutionResult getResult() {
		return futures;
	}

	public ProMFuture<?> getFutureResult(int i) {
		assert (futures != null);
		Object o = futures.getResult(i);
		assert (o instanceof ProMFuture<?>);
		// Note that if this cast cannot be performed,
		// an exception should be thrown. This method should
		// only be called from the body of a plugin
		return futures.<ProMFuture<?>>getResult(i);
	}

	public void setFuture(PluginExecutionResult futureToBe) {
		assert (futures == null);
		futures = futureToBe;
	}

	public boolean equals(Object o) {
		if (o instanceof PluginContext) {
			return ((PluginContext) o).getID().equals(id);
		}
		return false;

	}

	public String toString() {
		return getID() + "": "" + getLabel();
	}

	public boolean isDistantChildOf(PluginContext context) {
		if (getParentContext() == null) {
			return false;
		}
		return getParentContext().getID().equals(context.getID()) || getParentContext().isDistantChildOf(context);
	}

	/**
	 * The provided String is provided to the context for information. It can
	 * for example signal a state change of a plugin. Note that some contexts
	 * can completely ignore this message.
	 * 
	 * @param message
	 *            the message to log
	 * @param level
	 *            the message level
	 */
	public void log(String message, MessageLevel level) {
		loggers.fireLog(message, id, level);
	}

	/**
	 * Same as calling log(message, MessageLevel.NORMAL);
	 * 
	 * @param message
	 *            The message
	 */
	public void log(String message) {
		loggers.fireLog(message, id, MessageLevel.NORMAL);
	}

	/**
	 * The provided Exception is provided to the context. It signals the context
	 * about an error in the plugin, that specifically lead to abnormal
	 * termination. The plugin signaling the exception is no longer executing!
	 * 
	 * @param exception
	 *            the exception thrown
	 */
	public void log(Throwable exception) {
		loggers.fireLog(exception, id);
		System.err.println(""-------- The following exception was logged by the framework: "");
		System.err.println(""         The exception was probalby handled properly. "");
		exception.printStackTrace();
		System.err.println(""--------------------------------------------------------------"");
		
	}

	/**
	 * Returns the plugin manager. The plugin manager can be used to query for
	 * plugins which are registered in ProM.
	 * 
	 * @return the plugin manager
	 */
	public PluginManager getPluginManager() {
		return context.getPluginManager();
	}

	/**
	 * Returns the providedObject manager. The providedObject manager can be
	 * used to query for providedObjects which are registered in ProM. The
	 * manager should be a ProvidedObjectListener on all PluginInstanceContexts
	 * created by createRootInstanceContext.
	 * 
	 * @return the providedObject manager
	 */
	public ProvidedObjectManager getProvidedObjectManager() {
		return context.getProvidedObjectManager();
	}

	/**
	 * The GlobalContext implementation should create IDs for all PluginContexts
	 * instantiated for it.
	 * 
	 * @return
	 */
	public PluginContextID createNewPluginContextID() {
		return context.createNewPluginContextID();
	}

	/**
	 * This method invokes the specified plugin in a context which is a child of
	 * the main plugin context maintained by this globalContext;
	 * 
	 * @param plugin
	 * @param objects
	 *            The objects to serve as input. Note that all elements should
	 *            implement Object, or be a ProMFuture<?>.
	 */
	public void invokePlugin(PluginDescriptor plugin, int index, Object... objects) {
		context.invokePlugin(plugin, index, objects);
	}

	public void invokeBinding(PluginParameterBinding binding, Object... objects) {
		context.invokeBinding(binding, objects);
	}

	public Logger.ListenerList getLoggingListeners() {
		return loggers;
	}

	public PluginContext getRootContext() {
		if (parentPluginContext == null) {
			return this;
		} else {
			return parentPluginContext.getRootContext();
		}
	}

	public boolean deleteChild(PluginContext child) {
		if (childContexts.contains(child)) {
			childContexts.remove(child);
			for (PluginContext context : new ArrayList<PluginContext>(child.getChildContexts())) {
				child.deleteChild(context);
			}
			child.getPluginLifeCycleEventListeners().firePluginDeleted(child);
			return true;
		}
		return false;
	}

	public <T extends Connection> T addConnection(T c) {
		return getConnectionManager().addConnection(c);
	}

	public Class<? extends PluginContext> getPluginContextType() {
		return this.getClass();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.processmining.framework.util.ObjectConstructorInterface#
	 * tryToFindOrConstructAllObjects(java.lang.Class,
	 * org.processmining.framework.plugin.PluginContext, java.lang.Class,
	 * java.lang.String, java.lang.Object)
	 */
	public <T, C extends Connection> Collection<T> tryToFindOrConstructAllObjects(Class<T> type,
			Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained {
		return findOrConstructAllObjects(false, type, null, connectionType, role, input);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.processmining.framework.util.ObjectConstructorInterface#
	 * tryToFindOrConstructFirstObject(java.lang.Class,
	 * org.processmining.framework.plugin.PluginContext, java.lang.Class,
	 * java.lang.String, java.lang.Object)
	 */
	public <T, C extends Connection> T tryToFindOrConstructFirstObject(Class<T> type, Class<C> connectionType,
			String role, Object... input) throws ConnectionCannotBeObtained {
		return findOrConstructAllObjects(true, type, null, connectionType, role, input).iterator().next();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seeorg.processmining.framework.util.ObjectConstructorInterface#
	 * tryToFindOrConstructFirstNamedObject(java.lang.Class, java.lang.String,
	 * org.processmining.framework.plugin.PluginContext, java.lang.Class,
	 * java.lang.String,
	 * 
	 * java.lang.Object)
	 */
	public <T, C extends Connection> T tryToFindOrConstructFirstNamedObject(Class<T> type, String name,
			Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained {
		return findOrConstructAllObjects(true, type, name, connectionType, role, input).iterator().next();
	}

	private <T, C extends Connection> Collection<T> constructAllObjects(boolean stopAtFirst, Class<T> type,
			String name, Object... input) throws CancellationException, InterruptedException, ExecutionException {
		Class<?>[] types;
		if (input != null) {
			types = new Class<?>[input.length];
			for (int i = 0; i < input.length; i++) {
				types[i] = input[i].getClass();
			}
		} else {
			types = new Class<?>[0];
			input = new Object[0];
		}

		// Find available plugins
		Set<Pair<Integer, PluginParameterBinding>> set = getPluginManager().find(Plugin.class, type,
				getPluginContextType(), true, false, false, types);

		if (set.isEmpty()) {
			throw new RuntimeException(""No plugin available to build this type of object: "" + type.toString());
		}

		// Filter on the given name, if given.
		if (name != null) {
			Set<Pair<Integer, PluginParameterBinding>> filteredSet = new HashSet<Pair<Integer, PluginParameterBinding>>();
			for (Pair<Integer, PluginParameterBinding> pair : set) {
				if (name.equals(pair.getSecond().getPlugin().getName())) {
					filteredSet.add(pair);
				}
			}
			set.clear();
			set.addAll(filteredSet);
		}

		if (set.isEmpty()) {
			throw new RuntimeException(""No named plugin available to build this type of object: "" + name + "", ""
					+ type.toString());
		}

		SortedSet<Pair<Integer, PluginParameterBinding>> plugins = new TreeSet<Pair<Integer, PluginParameterBinding>>(
				new Comparator<Pair<Integer, PluginParameterBinding>>() {

					public int compare(Pair<Integer, PluginParameterBinding> arg0,
							Pair<Integer, PluginParameterBinding> arg1) {
						int c = arg0.getSecond().getPlugin().getReturnNames().size()
								- arg1.getSecond().getPlugin().getReturnNames().size();
						if (c == 0) {
							c = arg0.getSecond().compareTo(arg1.getSecond());
						}
						if (c == 0) {
							c = arg0.getFirst() - arg1.getFirst();
						}
						return c;
					}

				});
		plugins.addAll(set);

		Collection<T> result = new ArrayList<T>(stopAtFirst ? 1 : plugins.size());

		// get the first available plugin
		ExecutionException ex = null;
		for (Pair<Integer, PluginParameterBinding> pair : plugins) {
			PluginParameterBinding binding = pair.getSecond();
			// create a context to execute this plugin in
			PluginContext child = createChildContext(""Computing: "" + type.toString());
			getPluginLifeCycleEventListeners().firePluginCreated(child);

			// Invoke the binding
			PluginExecutionResult pluginResult = binding.invoke(child, input);

			// synchronize on the required result and continue
			try {
				pluginResult.synchronize();

				// get all results and pass them to the framework as provided objects
				getProvidedObjectManager().createProvidedObjects(child);
				result.add(pluginResult.<T>getResult(pair.getFirst()));
				if (stopAtFirst) {
					break;
				}
			} catch (ExecutionException e) {
				// Try next plugin if stop at first, otherwise rethrow
				ex = e;
			} finally {
				child.getParentContext().deleteChild(child);
			}
		}
		if (result.isEmpty()) {
			assert (ex != null);
			throw ex;
		}
		return result;
	}

	private <T, C extends Connection> Collection<T> findOrConstructAllObjects(boolean stopAtFirst, Class<T> type,
			String name, Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained {

		Collection<T> accepted = new ArrayList<T>();
		try {
			for (C conn : getConnectionManager().getConnections(connectionType, this, input)) {
				Object object = conn.getObjectWithRole(role);
				if (type.isAssignableFrom(object.getClass())) {
					accepted.add(Cast.<T>cast(object));
				}
			}
		} catch (Exception e) {
			// Don't care, let's try to construct later
		}
		if (!accepted.isEmpty()) {
			return accepted;
		}
		try {
			return constructAllObjects(stopAtFirst, type, name, input);
		} catch (Exception e) {
			throw new ConnectionCannotBeObtained(e.getMessage(), connectionType);
		}
	}

	public void clear() {
		getProvidedObjectManager().clear();
		getConnectionManager().clear();
	}
}"
AbstractPluginDescriptor.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.impl;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import javax.swing.JOptionPane;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.plugin.InSufficientResultException;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.RecursiveCallException;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.util.GoogleAnalyticsUtil;

public abstract class AbstractPluginDescriptor implements PluginDescriptor {

	@SuppressWarnings( { ""unchecked"" })
	private Object[] prepareAndWaitForArgs(PluginContext context, int methodIndex, List<Class<?>> parameterTypes,
			Object... args) throws CancellationException, InterruptedException, ExecutionException, FieldSetException,
			RecursiveCallException {
		Object[] result = new Object[args.length + 1];
		// copy the args to result
		System.arraycopy(args, 0, result, 1, args.length);
		boolean[] done = new boolean[result.length];
		Arrays.fill(done, false);
		boolean timeoutOccurred = false;
		do {
			timeoutOccurred = false;
			for (int i = 1; i < result.length; i++) {
				if (done[i]) {
					continue;
				}
				if (result[i] == null) {
					throw new IllegalArgumentException(""Cannot pass <null> as a parameter to a plugin"");
				}
				if ((result[i] instanceof ProMFuture)) {
					// synchronize on this get() method
					// any exception is forwarded.
					try {
						// try to get the result within 100 millisecond
						result[i] = ((ProMFuture) result[i]).get(100L, TimeUnit.MILLISECONDS);
						done[i] = true;
					} catch (TimeoutException e) {
						// A timeout exception occurred, no big deal,
						// just wait longer
						timeoutOccurred = true;
					}
				}
				if (result[i] instanceof Object[]) {
					// This array can contain a combination of rightly typed
					// objects, or futures on
					// rightly types objects, or futures on other arrays.
					Object[] array = (Object[]) result[i];
					boolean futureLeft = false;
					for (int j = 0; j < array.length; j++) {
						if (array[j] instanceof ProMFuture) {
							try {
								// try to get the result within 1 second
								array[j] = ((ProMFuture) array[j]).get(100L, TimeUnit.MILLISECONDS);
							} catch (TimeoutException e) {
								// A timeout exception occurred, no big deal,
								// just wait longer
								timeoutOccurred = true;
								futureLeft |= true;
							}
						}
					}
					if (!futureLeft) {
						List<Object> list = new ArrayList<Object>();
						for (int j = 0; j < array.length; j++) {
							if (array[j].getClass().isArray()) {
								for (int k = 0; k < ((Object[]) array[j]).length; k++) {
									list.add(((Object[]) array[j])[k]);
								}
							} else {
								list.add(array[j]);
							}
						}

						result[i] = list.toArray((Object[]) Array.newInstance(parameterTypes.get(i - 1)
								.getComponentType(), 0));
						done[i] = true;
					}

				}
			}
			if (timeoutOccurred) {
				// At least one of my input objects is not ready yet
				// try again in 2 seconds.
				Thread.sleep(2000);
			}
		} while (timeoutOccurred);

		context.setPluginDescriptor(this, methodIndex);
		result[0] = context;

		return result;
	}
	

	public PluginExecutionResult invoke(final int methodIndex, final PluginContext context, final Object... args) {

		ProMFuture<?>[] futures = new ProMFuture[Math.max(1, getReturnTypes().size())];

		Class<?> returnType;
		String name;
		final PluginExecutionResultImpl lock;
		if (getReturnTypes().size() == 0) {
			returnType = void.class;
			name = ""nothing"";
			lock = new PluginExecutionResultImpl(new Class<?>[] { returnType }, new String[0], this);
		} else {
			returnType = getReturnTypes().get(0);
			name = getReturnNames().get(0);
			lock = new PluginExecutionResultImpl(getReturnTypes().toArray(new Class<?>[0]), getReturnNames().toArray(
					new String[0]), this);
		}

		futures[0] = new ProMFuture<Object>(returnType, name) {

			@Override
			protected Object doInBackground() throws Exception {
				context.getPluginLifeCycleEventListeners().firePluginStarted(context);
				synchronized (lock) {
					// First, do a get on all Future objects in the args list

					Object[] allArgs = prepareAndWaitForArgs(context, methodIndex, getParameterTypes(methodIndex), args);

					// copy the result back into parameters, i.e. all futures
					// are unwrapped at this point and arrays are correctly typed.
					Object[] parameters = new Object[allArgs.length - 1];
					System.arraycopy(allArgs, 1, parameters, 0, parameters.length);
					lock.setInput(parameters);

					// All objects are available, now any exceptions
					// are forwarded, so start the computation of
					// this plugin
					try {
						if (Boot.isTrackingByGAAllowed()) {
							System.out.println(""[AbstractPluginDescriptor] Using GoogleAnalytics"");
							(new GoogleAnalyticsUtil()).runPluginEvent(getName(), getPackage() != null ? getPackage().getName() : null);
						}
						System.out.println(""Start plug-in "" + getName());
						long time = -System.currentTimeMillis();
						Object[] result = execute(context, methodIndex, allArgs);
						time += System.currentTimeMillis();
						System.out.println(""End plug-in "" + getName() + "", took "" + time + "" milliseconds"");

						if ((result == null) && !getReturnType().equals(void.class)) {
							throw new InSufficientResultException(getName(), lock.getExpectedSize(), 0);
						} else if (result.length < lock.getExpectedSize()) {
							throw new InSufficientResultException(getName(), lock.getExpectedSize(), result.length);
						} else if (result.length > lock.getExpectedSize()) {
							context.log(""Plugin "" + getName() + "" produced "" + result.length + "" results, while ""
									+ lock.getExpectedSize() + "" results were declared. Extra results are ignored."",
									MessageLevel.WARNING);
						}

						lock.setResult(result);
						lock.notifyAll();
						Object object = lock.getObject(0);
						return object;
					} catch (Exception ex) {
						if (ex.getCause() instanceof Exception) {
							ex = (Exception) ex.getCause();
						}
						lock.setException(ex);
						lock.notifyAll();
						//						context.getPluginLifeCycleEventListeners().firePluginTerminatedWithError(context, ex);
						//						context.log(ex);
						throw ex;
					}
				}
			}

			@Override
			protected void done() {
				if (context != null) {
					if (isCancelled()) {
						context.getPluginLifeCycleEventListeners().firePluginCancelled(context);
					} else {
						try {
							get();
							context.getPluginLifeCycleEventListeners().firePluginCompleted(context);
						} catch (Exception e) {
							JOptionPane.showMessageDialog(null, ""Exception happened: ""+e.getMessage());
							context.getPluginLifeCycleEventListeners().firePluginTerminatedWithError(context, e);
							context.log(e);
						}
					}

				}

			}
		};

		for (int i = 1; i < getReturnTypes().size(); i++) {
			final int j = i;
			returnType = getReturnTypes().get(i);
			name = getReturnNames().get(i);

			futures[i] = new ProMFuture<Object>(returnType, name) {
				@Override
				protected Object doInBackground() throws Exception {
					synchronized (lock) {
						while ((lock.getObject(j) instanceof ProMFuture<?>) && (lock.getException() == null)) {
							lock.wait();
						}
						Object object = lock.getObject(j);
						if ((object != null) && (lock.getException() == null)) {
							return object;
						}
						throw (lock.getException());
					}

				}
			};
		}

		lock.setResult(futures);

		context.setFuture(lock);
		context.getPluginLifeCycleEventListeners().firePluginFutureCreated(context);
		assert (context.getParentContext() != null);
		for (int i = 0; i < futures.length; i++) {
			context.getParentContext().getExecutor().execute(futures[i].getRunnable());
		}

		return lock;
	}

	/**
	 * In this method, the pluginDescriptor should do the actual work of
	 * concstructing the result. Note that no objects passed in the allArgs
	 * argument are futures anymore.
	 * 
	 * @param context
	 * @param methodIndex
	 * @param allArgs
	 * @return
	 * @throws Exception
	 */
	protected abstract Object[] execute(PluginContext context, int methodIndex, Object... allArgs) throws Exception;

}
"
DependsOnUnknownException.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.impl;

/**
 * thrown by the constructor of a plugindescritor if it depends on a plugin not
 * yet in the system.
 * 
 * @author bfvdonge
 * 
 */
public class DependsOnUnknownException extends Exception {

	public DependsOnUnknownException(String message) {
		super(message);
	}

	private static final long serialVersionUID = 4219323628021104089L;

}
"
FieldNotSetException.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.impl;

public class FieldNotSetException extends Exception {

	private static final long serialVersionUID = 6942427887070071817L;

	public FieldNotSetException(String fieldName, String message) {
		super(""Field "" + fieldName + "" was not yet set. "" + message);
	}
}
"
FieldSetException.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.impl;

public class FieldSetException extends Exception {

	private static final long serialVersionUID = 1024657629198603241L;

	public FieldSetException(String fieldName, String message) {
		super(""Field "" + fieldName + "" was already set. "" + message);
	}
}
"
PluginCacheEntry.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.impl;

import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.PackageDescriptor;

public class PluginCacheEntry {

	//	private byte[] buffer = new byte[2 * 1024 * 1024];

	private static final String CURRENT_VERSION = ""currentversion"";

	private static final String FILE_PROTOCOL = ""file"";

	private static final Set<String> STANDARD_JRE_DIRS = new HashSet<String>(
			Arrays.asList(new String[] { ""jdk"", ""jre"", }));
	private static final String STANDARD_JRE_LIB_DIR = ""lib"";
	private static final String STANDARD_JRE_EXT_DIR = ""ext"";
	private static final Set<String> STANDARD_JAR_FILES = new HashSet<String>(Arrays.asList(new String[] {
			""resources.jar"", ""rt.jar"", ""jsse.jar"", ""jce.jar"", ""charsets.jar"", ""dnsns.jar"", ""localedata.jar"",
			""qtjava.jar"", ""sunjce_provider.jar"", ""sunmscapi.jar"", ""sunpkcs11.jar"" }));

	private final URL url;
	private boolean inCache;
	private Set<String> classNames;
	private String key;
	private Boot.Level verbose;

	private final PackageDescriptor packageDescriptor;

	private final String jarName;

	private static Preferences PACKAGECACHE = initCache();

	//	private static MessageDigest digest;
	//
	//	static {
	//		try {
	//			digest = MessageDigest.getInstance(""MD5"");
	//		} catch (NoSuchAlgorithmException e) {
	//			// no MD5 available, so we cannot reliably detect whether the JAR is
	//			// cached or not
	//			digest = null;
	//		}
	//	}

	/**
	 * Deprecated. Use the version with the package descriptor for a
	 * significantly faster cache lookup
	 * 
	 * @param url
	 * @param verbose
	 */
	@Deprecated
	public PluginCacheEntry(URL url, Boot.Level verbose) {
		this(url, verbose, null);
	}

	private static Preferences initCache() {
		return Preferences.userNodeForPackage(PluginCacheEntry.class).parent().node(""_plugincache"");
	}

	public PluginCacheEntry(URL url, Boot.Level verbose, PackageDescriptor packageDescriptor) {
		this.url = url;
		this.verbose = verbose;
		this.packageDescriptor = packageDescriptor;
		this.jarName = packageDescriptor == null ? url.toString().substring(url.toString().lastIndexOf('/') + 1)
				.toLowerCase() : packageDescriptor.getName().toLowerCase();
		reset();

		try {
			init();
		} catch (Throwable e) {
			System.err.println(""Error caching JAR file: "" + e.getMessage());
			reset();
		}
	}

	public String getKey() {
		return key;
	}

	private void reset() {
		inCache = false;
		classNames = new HashSet<String>();
		key = null;
	}

	public boolean isInCache() {
		return inCache;
	}

	public Set<String> getCachedClassNames() {
		return classNames;
	}

	public void removeFromCache() {
		if (key != null) {
			getSettings().remove(key);
		}
	}

	private void init() throws URISyntaxException {
		if (!url.getProtocol().equals(FILE_PROTOCOL)) {
			return;
		}

		if (isStandardJar()) {
			inCache = true;
			return;
		}

		if (packageDescriptor == null) {
			//			if (digest == null) {
			//				return;
			//			}
			key = createFileBasedKey(new File(url.toURI()));
			if (key == null) {
				return;
			}
		} else {
			key = createPackageBasedKey();
		}

		String names = getSettings().get(key, null);

		if (names == null) {
			return;
		}

		if (verbose == Level.ALL) {
			System.out.println(""Plugins found in cache. "");
		}

		try {
			int subkeys = Integer.parseInt(names);
			for (int i = 0; i < subkeys; i++) {
				parseKey(key + ""-"" + i);
			}

		} catch (NumberFormatException e) {
			parseKey(key);
		}
		inCache = true;
	}

	private String createPackageBasedKey() {
		assert packageDescriptor != null;
		String key;
		key = packageDescriptor.getName();
		key += "" "";
		key += packageDescriptor.getVersion();
		return key.toLowerCase();
	}

	private String createFileBasedKey(File file) {
		//		InputStream is = null;
		//		try {
		long modified = file.lastModified();

		key = Long.toHexString(modified);

		//			int numRead = 0;
		//
		//			is = url.openStream();
		//			while ((numRead = is.read(buffer)) > 0) {
		//				digest.update(buffer, 0, numRead);
		//			}

		//		} catch (IOException e) {
		//			return null;
		//		} finally {
		//			if (is != null) {
		//				try {
		//					is.close();
		//				} catch (IOException e) {
		//
		//				}
		//			}
		//		}

		//		key = """";
		//		for (byte b : digest.digest()) {
		//			// append the signed byte as an unsigned hex number
		//			key += Integer.toString(0xFF & b, 16);
		//		}

		// No need to put the jarName in the key anymore.
		//		key += "" "" + new File(new URI(url.toString())).getName();
		//		if (key.length() > 80) {
		//			// make sure they is not too long for the preferences API
		//			key = key.substring(0, 80);
		//		}
		return key;
	}

	private void parseKey(String key) {
		String names = getSettings().get(key, null);

		//System.out.println(""  -> FOUND IN CACHE"");
		for (String className : names.split(""/"")) {
			if (className.length() > 0) {
				//System.out.println(""     - "" + className);
				classNames.add(className);
			}
		}
	}

	private boolean isStandardJar() throws URISyntaxException {
		try {
			File file = new File(new URI(url.toString()));
			String filename = file.getName().toLowerCase();

			if (STANDARD_JAR_FILES.contains(filename)) {
				String libDir = file.getParentFile().getName().toLowerCase();
				String jreDir = removeNonAlphaChars(file.getParentFile().getParentFile().getName().toLowerCase());

				if (libDir.equals(STANDARD_JRE_EXT_DIR)) {
					libDir = file.getParentFile().getParentFile().getName().toLowerCase();
					jreDir = removeNonAlphaChars(file.getParentFile().getParentFile().getParentFile().getName()
							.toLowerCase());
				}
				if (libDir.equals(STANDARD_JRE_LIB_DIR)) {
					return STANDARD_JRE_DIRS.contains(jreDir);
				}
			}
		} catch (NullPointerException e) {
			// probably the file doesn't have enough parent paths
		}
		return false;
	}

	private String removeNonAlphaChars(String s) {
		String result = """";

		for (int i = 0; i < s.length(); i++) {
			if (('a' <= s.charAt(i)) && (s.charAt(i) <= 'z')) {
				result += s.substring(i, i + 1);
			}
		}
		return result;
	}

	public void update(List<String> classes) {
		if (key != null) {
			String newKey = key;
			//			if (packageDescriptor == null) {
			//				newKey = createKey();
			//				if (newKey == null) {
			//					return;
			//				}
			//			} else {
			//				newKey = createPackageBasedKey();
			//			}

			if (verbose == Level.ALL) {
				System.out.println(""UPDATING CACHE: "" + key);
			}

			// updating. Remove the previpous version if present and add the new classes

			String previous = getSettings().get(CURRENT_VERSION, null);
			if (previous != null) {
				TreeSet<String> installed = new TreeSet<>(Arrays.asList(previous.split(""/"")));
				Iterator<String> it = installed.iterator();
				if (installed.size() >= 5) {
					// already keeping 5 versions alive. Remove one if
					// current not already present.
					if (!installed.contains(newKey)) {
						String toRemove = it.next();
						getSettings().remove(toRemove);

					}
				}
				previous = newKey;
				while (it.hasNext()) {
					previous += '/';
					previous += it.next();
				}
				getSettings().put(CURRENT_VERSION, previous);

			} else {
				getSettings().put(CURRENT_VERSION, newKey);
			}

			classNames.clear();
			for (String name : classes) {
				if ((name != null) && (name.length() > 0)) {
					classNames.add(name);
				}
			}

			StringBuffer value = new StringBuffer("""");
			for (String name : classNames) {
				if (verbose == Level.ALL) {
					System.out.println(""               : "" + name);
				}
				value.append(name);
				value.append(""/"");
			}

			if (value.length() > Preferences.MAX_VALUE_LENGTH) {
				int subkeys = (value.length() / Preferences.MAX_VALUE_LENGTH) + 1;
				getSettings().put(key, """" + subkeys);
				for (int i = 0; i < subkeys; i++) {
					getSettings().put(
							key + ""-"" + i,
							value.substring(i * Preferences.MAX_VALUE_LENGTH,
									Math.min((i + 1) * Preferences.MAX_VALUE_LENGTH, value.length())));
				}
			} else {

				getSettings().put(key, value.toString());
			}
		}
	}

	/**
	 * If a package descriptor is given, we use that to build the cache. The
	 * version number is increased automatically now with every build/release,
	 * hence we can use that to determine the cache.
	 * 
	 * @return
	 */
	private Preferences getSettings() {

		//		String className = getClass().getName();
		//		int pkgEndIndex = className.lastIndexOf('.');
		//		if (pkgEndIndex < 0) {
		//			className = ""/<unnamed>"";
		//		} else {
		//			String packageName = className.substring(0, pkgEndIndex);
		//			className = ""/"" + packageName.replace('.', '/');
		//		}
		if (packageDescriptor == null) {
			//			return Preferences.userRoot().node(className + ""/_jarfiles/"" + jarName);
			return PACKAGECACHE.node(""_jarfiles/"" + jarName);

		} else {
			return PACKAGECACHE.node(jarName);
			//			return Preferences.userRoot().node(className + '/' + jarName);
		}
	}

	/**
	 * Clear the cache here.
	 * 
	 * @return
	 */
	public static void clearSettingsCache() throws BackingStoreException {
		Preferences node = Preferences.userNodeForPackage(PluginCacheEntry.class);
		node.removeNode();
		node.flush();
		PACKAGECACHE.removeNode();
		PACKAGECACHE.flush();
		PACKAGECACHE = initCache();
	}

}
"
PluginContextIDImpl.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.impl;

import java.util.UUID;

import org.processmining.framework.plugin.PluginContextID;

public class PluginContextIDImpl implements PluginContextID {

	private final UUID id = UUID.randomUUID();

	public String toString() {
		return id.toString();
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof PluginContextIDImpl)) {
			return false;
		} else {
			return ((PluginContextIDImpl) o).id.equals(id);
		}
	}

	public int compareTo(PluginContextID o) {
		if (!(o instanceof PluginContextIDImpl)) {
			// Nasty implementation and not likely to be necessary,
			// as the ProvidedObjectManager should take care of not
			// using different object as ID.
			return PluginContextIDImpl.class.getName().compareTo(o.getClass().getName());
		} else {
			return ((PluginContextIDImpl) o).id.compareTo(id);
		}
	}
}
"
PluginDescriptorIDImpl.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.impl;

import java.lang.reflect.Method;

import org.processmining.framework.plugin.PluginDescriptorID;

public class PluginDescriptorIDImpl implements PluginDescriptorID {

	private final String id;

	public PluginDescriptorIDImpl(Method pluginMethod) {
		String temp = pluginMethod.toGenericString();
		int index = temp.indexOf("" throws "");
		if (index >= 0) {
			temp = temp.substring(0, index);
		}
		id = temp;
	}

	public PluginDescriptorIDImpl(Class<?> pluginClass) {
		id = pluginClass.getName();
	}

//	public PluginDescriptorIDImpl(MacroPluginDescriptorImpl macroPluginDescriptorImpl) {
//		id = macroPluginDescriptorImpl.getFileName();
//	}

	public String toString() {
		return id;
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof PluginDescriptorIDImpl)) {
			return false;
		} else {
			return ((PluginDescriptorIDImpl) o).id.equals(id);
		}
	}

	public int compareTo(PluginDescriptorID o) {
		if (!(o instanceof PluginDescriptorIDImpl)) {
			// Nasty implementation and not likely to be necessary,
			// as the ProvidedObjectManager should take care of not
			// using different object as ID.
			return PluginDescriptorIDImpl.class.getName().compareTo(o.getClass().getName());
		} else {
			return ((PluginDescriptorIDImpl) o).id.compareTo(id);
		}
	}
}
"
PluginDescriptorImpl.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.impl;

import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.imageio.ImageIO;
import javax.swing.ImageIcon;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginDescriptorID;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginCategory;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginQuality;
import org.processmining.framework.plugin.annotations.PluginVariant;

public class PluginDescriptorImpl extends AbstractPluginDescriptor {

	private final AnnotatedElement annotatedElement;
	// This list contains either Class<? extends Object> or
	// Class<? extends Object[]>
	private final PluginDescriptorID id;
	private final List<List<Class<?>>> parameterTypes;
	private List<String> parameterNames;
	private final List<Class<?>> returnTypes;
	private final List<Method> methods;
	private final List<String> returnNames;
	private final String name;
	//	public Class<? extends PluginContext> contextType = null;
	private final Class<?> declaringClass;
	private final PackageDescriptor pack;

	private String help;
	private String[] keywords;
	private PluginCategory[] categories;
	private PluginQuality quality;
	private PluginLevel level;
	private ImageIcon icon;
	private URL url;

	private final static Map<String, ImageIcon> icons = new HashMap<String, ImageIcon>();
	private final static Map<String, URL> urls = new HashMap<String, URL>();

	PluginDescriptorImpl(Method method, PackageDescriptor pack) throws Exception {
		assert (method != null);
		assert (method.isAnnotationPresent(Plugin.class));
		this.pack = pack;
		id = new PluginDescriptorIDImpl(method);
		parameterTypes = new ArrayList<List<Class<?>>>(1);
		ArrayList<Class<?>> list = new ArrayList<Class<?>>(method.getParameterTypes().length - 1);
		parameterTypes.add(list);
		declaringClass = method.getDeclaringClass();

		for (Class<?> par : method.getParameterTypes()) {
			if (!PluginContext.class.isAssignableFrom(par)) {
				list.add(par);
			}
		}
		methods = new ArrayList<Method>(1);
		methods.add(method);

		annotatedElement = method;
		name = method.getAnnotation(Plugin.class).name();
		help = method.getAnnotation(Plugin.class).help();
		keywords = method.getAnnotation(Plugin.class).keywords();
		categories = method.getAnnotation(Plugin.class).categories();
		quality = method.getAnnotation(Plugin.class).quality();
		level = method.getAnnotation(Plugin.class).level();

		String iconString = method.getAnnotation(Plugin.class).icon();
		if (icons.containsKey(iconString)) {
			icon = icons.get(iconString);
		} else {
			icon = iconString.isEmpty() ? null : new ImageIcon(new URL(iconString));
			if (icon != null) {
				System.out.println(""[PluginDescriptorImpl] Found icon at "" + iconString);
			} else {
				System.out.println(""[PluginDescriptorImpl] Found no icon at "" + iconString);
			}
			icons.put(iconString, icon);
		}

		String urlString = method.getAnnotation(Plugin.class).url();
		if (urls.containsKey(urlString)) {
			url = urls.get(urlString);
		} else {
			url = urlString.isEmpty() ? null : new URL(urlString);
			urls.put(urlString, url);
		}

		//		System.out.println(""PluginDescriptorImpl,\"""" + name + ""\"",\"""" + (pack == null ? """" : pack.getName()) + ""\"""");

		parameterNames = Arrays.asList(getAnnotation(Plugin.class).parameterLabels());
		if (parameterNames.size() == 0) {
			parameterNames = new ArrayList<String>(parameterTypes.size());
			for (Class<?> par : list) {
				parameterNames.add(par.getSimpleName());
			}
		}

		returnTypes = Arrays.asList(getAnnotation(Plugin.class).returnTypes());
		assert (getAnnotation(Plugin.class).returnLabels().length == returnTypes.size());
		returnNames = Arrays.asList(getAnnotation(Plugin.class).returnLabels());
	}

	PluginDescriptorImpl(Class<?> type, Class<? extends PluginContext> acceptedContext, PackageDescriptor pack)
			throws Exception {
		assert (type != null);
		assert (type.isAnnotationPresent(Plugin.class));

		this.pack = pack;
		id = new PluginDescriptorIDImpl(type);
		annotatedElement = type;
		declaringClass = type;
		methods = new ArrayList<Method>();

		String[] pls = getAnnotation(Plugin.class).parameterLabels();

		int max = -1;
		for (Method method : type.getMethods()) {
			if (method.isAnnotationPresent(PluginVariant.class)) {
				if (method.getParameterTypes()[0].isAssignableFrom(acceptedContext)) {
					methods.add(method);
				}

				int[] requiredPar = method.getAnnotation(PluginVariant.class).requiredParameterLabels();
				for (int i : requiredPar) {
					if (i > max) {
						max = i;
					}
				}
			}
		}
		max++;

		parameterTypes = new ArrayList<List<Class<?>>>(methods.size());

		for (Method method : methods) {
			int[] requiredPar = method.getAnnotation(PluginVariant.class).requiredParameterLabels();
			ArrayList<Class<?>> list = new ArrayList<Class<?>>(method.getParameterTypes().length - 1);
			for (int i = 0; i < requiredPar.length; i++) {
				list.add(method.getParameterTypes()[i + 1]);
			}
			parameterTypes.add(list);
		}

		name = type.getAnnotation(Plugin.class).name();
		help = type.getAnnotation(Plugin.class).help();
		keywords = type.getAnnotation(Plugin.class).keywords();
		categories = type.getAnnotation(Plugin.class).categories();
		quality = type.getAnnotation(Plugin.class).quality();
		level = type.getAnnotation(Plugin.class).level();
		//		System.out.println(""PluginDescriptorImpl,\"""" + name + ""\"",\"""" + (pack == null ? """" : pack.getName()) + ""\"""");

		String iconString = type.getAnnotation(Plugin.class).icon();
		if (icons.containsKey(iconString)) {
			icon = icons.get(iconString);
		} else {
			/*
			 * Read the icon from a lib/images folder.
			 */
			InputStream url = Thread.currentThread().getContextClassLoader()
					.getResourceAsStream(""images/"" + iconString);
			if (url == null) {
				icon = null;
			} else {
				try {
					icon = new ImageIcon(ImageIO.read(url));
				} catch (IOException e) {
					icon = null;
				}
			}

			//			icon = iconString.isEmpty() ? null : new ImageIcon(new URL(iconString));
			if (icon != null) {
				System.out.println(""[PluginDescriptorImpl] Found icon at "" + iconString);
			} else {
				System.out.println(""[PluginDescriptorImpl] Found no icon at "" + iconString);
			}
			icons.put(iconString, icon);
		}

		String urlString = type.getAnnotation(Plugin.class).url();
		if (urls.containsKey(urlString)) {
			url = urls.get(urlString);
		} else {
			url = urlString.isEmpty() ? null : new URL(urlString);
			urls.put(urlString, url);
		}

		// There are either no parameters, or all parameters are required at least once
		// in all variants, ignoring the specific context.
		//
		if ((pls.length > 0) && (pls.length < max)) {
			String message = ""Plugin "" + name
					+ "" could not be added as a plugin. There is at lease one declared parameter type,""
					+ "" which is not used by any of the plugin's variants."";
			throw new AssertionError(message);
		}

		parameterNames = Arrays.asList(pls);

		returnTypes = Arrays.asList(type.getAnnotation(Plugin.class).returnTypes());
		assert (getAnnotation(Plugin.class).returnLabels().length == returnTypes.size());
		returnNames = Arrays.asList(type.getAnnotation(Plugin.class).returnLabels());
	}

	PluginDescriptorImpl(String className, String name, Class<?>[] parTypes, PackageDescriptor pack) throws Exception {
		this(Class.forName(className).getMethod(name, parTypes), pack);
	}

	public PackageDescriptor getPackage() {
		return pack;
	}

	public int getMostSignificantResult() {
		return getAnnotation(Plugin.class).mostSignificantResult();
	}

	AnnotatedElement getAnnotatedElement() {
		return annotatedElement;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginDescriptor#hasAnnotation(java
	 * .lang.Class)
	 */
	public boolean hasAnnotation(Class<? extends Annotation> annotationClass) {
		return getAnnotatedElement().isAnnotationPresent(annotationClass);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginDescriptor#getAnnotation(java
	 * .lang.Class)
	 */
	public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
		return getAnnotatedElement().getAnnotation(annotationClass);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.framework.plugin.PluginDescriptor#getName()
	 */
	public String getName() {
		return name;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.framework.plugin.PluginDescriptor#hashCode()
	 */
	@Override
	public int hashCode() {
		return id.hashCode();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginDescriptor#equals(java.lang.
	 * Object)
	 */
	@Override
	public boolean equals(Object other) {
		if (!(other instanceof PluginDescriptorImpl)) {
			return false;
		}
		PluginDescriptorImpl otherDesc = (PluginDescriptorImpl) other;
		return id.equals(otherDesc.id);

		// note: this does not compare whether the plugins have been loaded by
		// the same class loader
		// return getMethod().getDeclaringClass().getName().equals(
		// otherDesc.getMethod().getDeclaringClass().getName())
		// && getMethod().getName()
		// .equals(otherDesc.getMethod().getName());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.framework.plugin.PluginDescriptor#toString()
	 */
	@Override
	public String toString() {
		return getName();
	}

	protected Object[] execute(PluginContext context, int methodIndex, Object... allArgs) throws Exception {
		Method method = getMethod(methodIndex);
		if (returnTypes.size() > 1) { // method.getReturnType().isArray())
			// {
			Object[] result;
			if ((method.getModifiers() & Modifier.STATIC) == Modifier.STATIC) {
				result = (Object[]) method.invoke(null, allArgs);
			} else {
				result = (Object[]) method.invoke(declaringClass.newInstance(), allArgs);
			}

			return result;
		} else {
			Object result;
			if ((method.getModifiers() & Modifier.STATIC) == Modifier.STATIC) {
				result = method.invoke(null, allArgs);
			} else {
				result = method.invoke(declaringClass.newInstance(), allArgs);
			}

			return new Object[] { result };
		}
	}

	protected Method findMethod(Object[] allArgs) {
		for (Method m : ((Class<?>) annotatedElement).getMethods()) {
			if (m.isAnnotationPresent(PluginVariant.class)) {
				boolean match = (m.getParameterTypes().length == allArgs.length);
				for (int i = 0; (i < allArgs.length) && match; i++) {
					Class<?> type = m.getParameterTypes()[i];
					if (type.isArray()) {
						if (allArgs[i].getClass().isArray()) {
							for (Object o : (Object[]) allArgs[i]) {
								match &= type.getComponentType().isAssignableFrom(o.getClass());
							}
						} else {
							match = false;
						}
					} else {
						match &= type.isAssignableFrom(allArgs[i].getClass());
					}
				}
				if (match) {
					return m;
				}
			}
		}
		return null;
	}

	/**
	 * returns the labels of the objects returned if this plugin is invoked, in
	 * the order in which they are returned
	 * 
	 * @return
	 */
	public List<Class<? extends Object>> getReturnTypes() {
		return Collections.unmodifiableList(returnTypes);
	}

	public List<Class<?>> getParameterTypes(int methodIndex) {
		return Collections.unmodifiableList(getParameterTypes().get(methodIndex));
	}

	public Class<?> getPluginParameterType(int methodIndex, int parameterIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			for (int j = 0; j < req.length; j++) {
				if (req[j] == parameterIndex) {
					return parameterTypes.get(methodIndex).get(j);
				}
			}
			return null;
		} else {
			return parameterTypes.get(methodIndex).get(parameterIndex);
		}
	}

	public List<List<Class<?>>> getParameterTypes() {
		return Collections.unmodifiableList(parameterTypes);
	}

	public List<String> getParameterNames() {
		return Collections.unmodifiableList(parameterNames);
	}

	public Set<Class<?>> getTypesAtParameterIndex(int index) {
		HashSet<Class<?>> result = new HashSet<Class<?>>();
		for (int j = 0; j < methods.size(); j++) {
			Class<?> name = getPluginParameterType(j, index);
			if (name != null) {
				result.add(name);
			}
		}

		return result;
	}

	/**
	 * Return the number of methods in this plugin.
	 * 
	 * @return
	 */
	public int getNumberOfMethods() {
		return methods.size();
	}

	public List<String> getParameterNames(int methodIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			ArrayList<String> list = new ArrayList<String>();
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			for (int i : req) {
				list.add(parameterNames.get(i));
			}
			return Collections.unmodifiableList(list);
		} else {
			return Collections.unmodifiableList(parameterNames);
		}
	}

	public String getPluginParameterName(int methodIndex, int parameterIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			for (int j = 0; j < req.length; j++) {
				if (req[j] == parameterIndex) {
					return parameterNames.get(parameterIndex);
				}
			}
			return null;
		} else {
			return parameterNames.get(parameterIndex);
		}
	}

	/**
	 * returns the types of the objects returned if this plugin is invoked, in
	 * the order in which they are returned
	 * 
	 * @return
	 */
	public List<String> getReturnNames() {
		return Collections.unmodifiableList(returnNames);
	}

	public PluginDescriptorID getID() {
		return id;
	}

	@SuppressWarnings(""unchecked"")
	public Class<? extends PluginContext> getContextType(int methodIndex) {
		return (Class<? extends PluginContext>) methods.get(methodIndex).getParameterTypes()[0];
	}

	public int compareTo(PluginDescriptor plugin) {
		if (plugin.equals(this)) {
			return 0;
		}

		int c = getName().toLowerCase().compareTo(plugin.getName().toLowerCase());
		if (c == 0) {
			c = id.compareTo(plugin.getID());
		}
		return c;
	}

	Method getMethod(int i) {
		return methods.get(i);
	}

	public int getIndexInParameterNames(int methodIndex, int methodParameterIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			return req[methodParameterIndex];
		} else {
			return methodParameterIndex;
		}
	}

	public int getIndexInMethod(int methodIndex, int parameterIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)) {
			int[] req = methods.get(methodIndex).getAnnotation(PluginVariant.class).requiredParameterLabels();
			for (int i = 0; i < req.length; i++) {
				if (req[i] == parameterIndex) {
					return i;
				}
			}
			return -1;
		} else {
			return parameterIndex;
		}
	}

	public String getMethodLabel(int methodIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)
				&& !methods.get(methodIndex).getAnnotation(PluginVariant.class).variantLabel().equals("""")) {
			return methods.get(methodIndex).getAnnotation(PluginVariant.class).variantLabel();
		} else {
			return name;
		}
	}

	public boolean isUserAccessible() {
		return getAnnotation(Plugin.class).userAccessible();
	}

	public boolean handlesCancel() {
		return getAnnotation(Plugin.class).handlesCancel();
	}

	public <T extends Annotation> T getAnnotation(Class<T> annotationClass, int methodIndex) {
		return getMethod(methodIndex).getAnnotation(annotationClass);
	}

	public boolean hasAnnotation(Class<? extends Annotation> annotationClass, int methodIndex) {
		return getMethod(methodIndex).getAnnotation(annotationClass) != null;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.processmining.framework.plugin.PluginDescriptor#getName()
	 */
	public String getHelp() {
		return help;
	}

	public String getMethodHelp(int methodIndex) {
		if (methods.get(methodIndex).isAnnotationPresent(PluginVariant.class)
				&& !methods.get(methodIndex).getAnnotation(PluginVariant.class).help().equals("""")) {
			return methods.get(methodIndex).getAnnotation(PluginVariant.class).help();
		} else {
			return name;
		}
	}

	public String[] getKeywords() {
		return this.keywords;
	}

	public String[] getCategories() {
		String[] categoryLabels = new String[this.categories.length];
		for (int i = 0; i < this.categories.length; i++) {
			categoryLabels[i] = this.categories[i].getName();//.getName();
		}
		return categoryLabels;
	}

	public boolean meetsQualityThreshold() {
		return Boot.PLUGIN_QUALITY_THRESHOLD.getValue() <= quality.getValue();
	}

	public boolean meetsLevelThreshold() {
		return Boot.PLUGIN_LEVEL_THRESHOLD.getValue() <= level.getValue();
	}

	public ImageIcon getIcon() {
		return icon;
	}

	public URL getURL() {
		return url;
	}
}
"
PluginExecutionResultImpl.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.impl;

import java.util.Arrays;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.plugin.IncorrectReturnTypeException;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.events.NameChangeListener;
import org.processmining.framework.providedobjects.ProvidedObjectID;
import org.processmining.framework.util.Cast;

public class PluginExecutionResultImpl implements PluginExecutionResult {

	private Object[] objects;
	private Exception exception = null;
	private final Class<?>[] returnTypes;
	private final String pluginName;
	private final String[] returnNames;
	private final ProvidedObjectID[] ids;
	private Object[] parameters;
	private final PluginDescriptor plugin;

	public PluginExecutionResultImpl(Class<?>[] returnTypes, String[] returnNames, PluginDescriptor plugin) {
		this.returnNames = returnNames;
		this.plugin = plugin;
		pluginName = plugin.getName();
		objects = new Object[returnTypes.length];
		ids = new ProvidedObjectID[returnTypes.length];
		this.returnTypes = returnTypes;
		Arrays.fill(objects, null);
		Arrays.fill(ids, null);
	}

	public int getSize() {
		return returnNames.length;
	}

	void setResult(Object[] objects) throws IncorrectReturnTypeException {
		this.objects = objects;
		for (int i = 0; i < returnTypes.length; i++) {
			if (!returnTypes[i].equals(void.class)) {
				if (objects[i] == null) {
					continue;
				}
				Class<?> type = objects[i].getClass();
				if (objects[i] instanceof ProMFuture<?>) {
					type = Cast.<ProMFuture<?>>cast(objects[i]).getReturnType();
				}
				if (!returnTypes[i].isAssignableFrom(type)) {
					throw new IncorrectReturnTypeException(pluginName, i, returnTypes[i], objects[i].getClass());
				}
				if (objects[i] instanceof ProMFuture<?>) {
					final int index = i;
					((ProMFuture<?>) objects[i]).getNameChangeListeners().add(new NameChangeListener() {

						public void nameChanged(String newName) {
							returnNames[index] = newName;
						}
					});
				}
			}
		}
	}

	Object getObject(int resultIndex) {
		return objects[resultIndex];
	}

	void setException(Exception t) {
		exception = t;
	}

	Exception getException() {
		return exception;
	}

	@SuppressWarnings(""unchecked"")
	public <T> T getResult(int resultIndex) throws ClassCastException {
		return (T) getObject(resultIndex);
	}

	public String getResultName(int resultIndex) {
		synchronized (objects) {
			if (getObject(resultIndex) instanceof ProMFuture<?>) {
				return Cast.<ProMFuture<?>>cast(getObject(resultIndex)).getLabel();
			} else {
				return returnNames[resultIndex];
			}
		}
	}

	public String[] getResultNames() {
		return returnNames;
	}

	public Object[] getResults() {
		return objects;
	}

	public void synchronize() throws CancellationException, ExecutionException, InterruptedException {
		for (int i = 0; i < objects.length; i++) {
			if (objects[i] instanceof ProMFuture<?>) {
				Object o = Cast.<ProMFuture<?>>cast(objects[i]).get();
				synchronized (objects) {
					objects[i] = o;
				}
			}
		}
	}

	int getExpectedSize() {
		return objects.length;
	}

	public void setProvidedObjectID(int i, ProvidedObjectID id) {
		ids[i] = id;
	}

	public ProvidedObjectID getProvidedObjectID(int i) {
		return ids[i];
	}

	public void setInput(Object[] parameters) {
		this.parameters = parameters;
	}

	public Object[] getParameters() {
		return parameters;
	}

	@SuppressWarnings(""unchecked"")
	public <T> Class<? super T> getType(int i) {
		return (Class<? super T>) returnTypes[i];
	}

	public PluginDescriptor getPlugin() {
		return plugin;
	}

}
"
PluginManagerImpl.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.impl;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;

import javax.swing.event.EventListenerList;

import org.processmining.framework.boot.Boot;
import org.processmining.framework.boot.Boot.Level;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.PluginDescriptorID;
import org.processmining.framework.plugin.PluginManager;
import org.processmining.framework.plugin.PluginParameterBinding;
import org.processmining.framework.plugin.annotations.Bootable;
import org.processmining.framework.plugin.annotations.KeepInProMCache;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.collection.ComparablePair;

public final class PluginManagerImpl implements PluginManager {

	private static final char PACKAGE_SEPARATOR = '.';
	private static final char URL_SEPARATOR = '/';
	private static final char INNER_CLASS_MARKER = '$';

	private static PluginManagerImpl pluginManager;

	private final Set<Class<?>> knownObjectTypes = new HashSet<Class<?>>();

	private final Map<PluginDescriptorID, PluginDescriptor> plugins = new HashMap<PluginDescriptorID, PluginDescriptor>();
	private final Map<Class<? extends Annotation>, Set<PluginDescriptor>> annotation2plugins = new HashMap<Class<? extends Annotation>, Set<PluginDescriptor>>();
	private final EventListenerList pluginManagerListeners = new EventListenerList();
	private final Class<? extends PluginContext> pluginContextType;

	private final Map<Class<? extends Annotation>, Set<Class<?>>> annotatedClasses = new HashMap<Class<? extends Annotation>, Set<Class<?>>>();

	private PluginManagerImpl(Class<? extends PluginContext> pluginContextType) {
		this.pluginContextType = pluginContextType;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginManager#addErrorListener(org
	 * .processmining.framework.plugin.PluginManagerImpl.ErrorListener)
	 */
	public void addListener(PluginManagerListener listener) {
		pluginManagerListeners.add(PluginManagerListener.class, listener);
	}

	public Set<Class<?>> getKnownClassesAnnotatedWith(Class<? extends Annotation> annotationType) {
		Set<Class<?>> set = annotatedClasses.get(annotationType);
		if (set == null) {
			return Collections.emptySet();
		} else {
			return Collections.unmodifiableSet(set);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginManager#removeErrorListener(
	 * org.processmining.framework.plugin.PluginManagerImpl.ErrorListener)
	 */
	public void removeListener(PluginManagerListener listener) {
		pluginManagerListeners.remove(PluginManagerListener.class, listener);
	}

	protected void fireError(URL url, Throwable t, String className) {
		for (PluginManagerListener listener : pluginManagerListeners.getListeners(PluginManagerListener.class)) {
			listener.error(url, t, className);
		}

	}

	protected void firePluginAdded(PluginDescriptor plugin, Collection<Class<?>> types) {
		for (PluginManagerListener listener : pluginManagerListeners.getListeners(PluginManagerListener.class)) {
			listener.newPlugin(plugin, types);
		}
	}

	public static void initialize(Class<? extends PluginContext> pluginContextType) {
		if (pluginManager == null) {
			pluginManager = new PluginManagerImpl(pluginContextType);
		}
	}

	public static PluginManager getInstance() {
		return pluginManager;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.plugin.PluginManager#register(java.net.URL)
	 */
	public void register(URL url, PackageDescriptor pack) {
		URLClassLoader loader = new URLClassLoader(new URL[] { url });
		register(url, pack, loader);
	}

	public void register(URL url, PackageDescriptor pack, ClassLoader loader) {
		if (url.getProtocol().equals(FILE_PROTOCOL)) {
			try {
				File file = new File(url.toURI());

				if (file.isDirectory()) {
					scanDirectory(file, pack, loader);
					return;
				}
				//				if (file.getAbsolutePath().endsWith(PluginManager.MCR_EXTENSION)) {
				//					try {
				//						loadClassFromMacro(url.toURI(), pack);
				//					} catch (DependsOnUnknownException e) {
				//						// Can't add this URL.
				//					}
				//				}
				if (file.getAbsolutePath().endsWith(JAR_EXTENSION)) {
					scanUrl(url, pack, loader);
				}
			} catch (URISyntaxException e) {
				fireError(url, e, null);
			}
		} else {
			scanUrl(url, pack, loader);
		}
	}

	private void scanDirectory(File file, PackageDescriptor pack, ClassLoader loader) {
		try {
			URL url = file.toURI().toURL();

			Queue<File> todo = new LinkedList<File>();
			FileFilter filter = new FileFilter() {
				public boolean accept(File pathname) {
					return pathname.isDirectory() || pathname.getPath().endsWith(CLASS_EXTENSION)
							|| pathname.getPath().endsWith(MCR_EXTENSION) || pathname.getPath().endsWith(JAR_EXTENSION);

				}
			};

			todo.add(file);
			while (!todo.isEmpty()) {
				File dir = todo.remove();

				for (File f : dir.listFiles(filter)) {
					if (f.isDirectory()) {
						todo.add(f);
					} else {
						if (f.getAbsolutePath().endsWith(CLASS_EXTENSION)) {
							loadClassFromFile(loader, url,
									makeRelativePath(file.getAbsolutePath(), f.getAbsolutePath()), pack);
							//						} else if (f.getAbsolutePath().endsWith(MCR_EXTENSION)) {
							//							try {
							//								loadClassFromMacro(f.toURI(), pack);
							//							} catch (DependsOnUnknownException e) {
							//								todo.add(dir);
							//							}
						} else if (f.getAbsolutePath().endsWith(JAR_EXTENSION)) {
							scanUrl(f.toURI().toURL(), pack, loader);
						}
					}
				}
			}
		} catch (MalformedURLException e) {
			fireError(null, e, null);
		}
	}

	private String makeRelativePath(String root, String absolutePath) {
		String relative = absolutePath;

		if (relative.startsWith(root)) {
			relative = relative.substring(root.length());
			if (relative.startsWith(File.separator)) {
				relative = relative.substring(File.separator.length());
			}
		}
		return relative;
	}

	private void scanUrl(URL url, PackageDescriptor pack, ClassLoader loader) {

		PluginCacheEntry cached = new PluginCacheEntry(url, Boot.VERBOSE, pack);

		if (cached.isInCache()) {
			for (String className : cached.getCachedClassNames()) {
				loadClass(loader, url, className, pack);
			}
		} else {
			try {
				InputStream is = url.openStream();
				JarInputStream jis = new JarInputStream(is);
				JarEntry je;
				List<String> loadedClasses = new ArrayList<String>();

				while ((je = jis.getNextJarEntry()) != null) {
					if (!je.isDirectory() && je.getName().endsWith(CLASS_EXTENSION)) {
						String loadedClass = loadClassFromFile(loader, url, je.getName(), pack);
						if (loadedClass != null) {
							loadedClasses.add(loadedClass);
						}
					}
				}
				jis.close();
				is.close();

				cached.update(loadedClasses);
			} catch (IOException e) {
				fireError(url, e, null);
			}
		}
	}

	private String loadClassFromFile(ClassLoader loader, URL url, String classFilename, PackageDescriptor pack) {
		if (classFilename.indexOf(INNER_CLASS_MARKER) >= 0) {
			// we're not going to load inner classes
			return null;
		}
		return loadClass(loader, url,
				classFilename.substring(0, classFilename.length() - CLASS_EXTENSION.length())
						.replace(URL_SEPARATOR, PACKAGE_SEPARATOR).replace(File.separatorChar, PACKAGE_SEPARATOR),
				pack);
	}

	//	private String loadClassFromMacro(URI macroFile, PackageDescriptor pack) throws DependsOnUnknownException {
	//		MacroPluginDescriptorImpl plugin = null;
	//		try {
	//			plugin = new MacroPluginDescriptorImpl(new File(macroFile), this, pack);
	//			addPlugin(plugin);
	//		} catch (DOMException e) {
	//			e.printStackTrace();
	//		} catch (IOException e) {
	//			e.printStackTrace();
	//		} catch (SAXException e) {
	//			e.printStackTrace();
	//		} catch (ParserConfigurationException e) {
	//			e.printStackTrace();
	//		} catch (ClassNotFoundException e) {
	//			e.printStackTrace();
	//		} catch (DependsOnUnknownException e) {
	//			throw e;
	//		}
	//		return plugin == null ? null : plugin.getFileName();
	//	}

	/**
	 * Returns the name of the class, if it is annotated, or if any of its
	 * methods carries a plugin annotation!
	 * 
	 * @param loader
	 * @param url
	 * @param className
	 * @return
	 */
	private String loadClass(ClassLoader loader, URL url, String className, PackageDescriptor pack) {
		boolean isAnnotated = false;

		if ((className == null) || className.trim().equals("""") || className.startsWith(""bin-test-instrument"") || className.equals(loader.getClass().getName())) {
			return null;
		}

		className = className.trim();
		try {
			Class<?> pluginClass = Class.forName(className, false, loader);
			//isAnnotated = (pluginClass.getAnnotations().length > 0);

			// register all annotated classes
			if (pluginClass.isAnnotationPresent(KeepInProMCache.class)
					&& !Modifier.isAbstract(pluginClass.getModifiers())) {
				Annotation[] annotations = pluginClass.getAnnotations();
				isAnnotated = true;
				for (int i = 0; i < annotations.length; i++) {
					Set<Class<?>> set = annotatedClasses.get(annotations[i].annotationType());
					if (set == null) {
						set = new HashSet<Class<?>>();
						annotatedClasses.put(annotations[i].annotationType(), set);
					}
					set.add(pluginClass);
				}
			}

			Method[] methods = pluginClass.getMethods();
			// Check if plugin annotation is present
			if (pluginClass.isAnnotationPresent(Plugin.class) && isGoodPlugin(pluginClass, methods)) {
				PluginDescriptorImpl pl = new PluginDescriptorImpl(pluginClass, pluginContextType, pack);
				addPlugin(pl);
				isAnnotated = true;
			}

			for (Method method : methods) {
				if (method.isAnnotationPresent(Plugin.class) && isGoodPlugin(method)) {
					try {
						PluginDescriptorImpl pl = new PluginDescriptorImpl(method, pack);
						addPlugin(pl);
						isAnnotated = true;
					} catch (Exception e) {
						fireError(url, e, className);
						if (Boot.VERBOSE != Level.NONE) {
							System.err.println(""ERROR while adding plugin: "" + url + "":"" + e.getMessage());
						}
					}
				}
			}
		} catch (Throwable t) {
			fireError(url, t, className);
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""ERROR while scanning for plugins at: "" + url + "":"");
				System.err.println(""   in file :"" + className);
				System.err.println(""   "" + t.getMessage());
				//t.printStackTrace();
			}
		}
		if (isAnnotated && !className.startsWith(""org.processmining."")) {
			System.err.println(""INFO class "" + className + "" contains plug-ins."");
		}
		return isAnnotated ? className : null;
	}

	private void addPlugin(PluginDescriptorImpl pl) {
		PluginDescriptorImpl old = (PluginDescriptorImpl) plugins.put(pl.getID(), pl);

		/*
		 * HV 20181130
		 * Sometimes, ProM seems to freeze when started after having updated or installed packages.
		 * However, instead of freezing it seems to be in a busy wait due to an endless loop related
		 * to the annotation2plunis variable. Somehow, it loops endlessly over a set in this map.
		 * Apparently, this set is corrupted somehow. Possibly, the code below is not reentrant.
		 * Therefore, I've added the synchronized on the variable.
		 */
		synchronized (annotation2plugins) {
			if (old != null) {
				if (Boot.VERBOSE == Level.ALL) {
					System.out.println(""Found new version of plugin: "" + pl.getName() + "" ....overwriting."");
				}
				for (Annotation annotation : old.getAnnotatedElement().getAnnotations()) {
					annotation2plugins.get(annotation.annotationType()).remove(old);
				}
			}

			for (Annotation annotation : pl.getAnnotatedElement().getAnnotations()) {
				Set<PluginDescriptor> pls = annotation2plugins.get(annotation.annotationType());
				if (pls == null) {
					pls = new TreeSet<PluginDescriptor>();
					annotation2plugins.put(annotation.annotationType(), pls);
				}
				pls.add(pl);

			}
		}
		checkTypesAfterAdd(pl);

	}

	//	private void addPlugin(MacroPluginDescriptorImpl pl) {
	//		PluginDescriptor old = plugins.put(pl.getID(), pl);
	//
	//		if (old != null) {
	//			if (Boot.VERBOSE == Level.ALL) {
	//				System.out.println(""Found new version of plugin: "" + pl.getName() + "" ....overwriting."");
	//			}
	//			annotation2plugins.get(Plugin.class).remove(old);
	//		}
	//
	//		Set<PluginDescriptor> pls = annotation2plugins.get(Plugin.class);
	//		if (pls == null) {
	//			pls = new TreeSet<PluginDescriptor>();
	//			annotation2plugins.put(Plugin.class, pls);
	//		}
	//		pls.add(pl);
	//
	//		checkTypesAfterAdd(pl);
	//	}

	private void checkTypesAfterAdd(PluginDescriptor pl) {
		HashSet<Class<?>> newTypes = new HashSet<Class<?>>();
		for (List<Class<?>> parTypes : pl.getParameterTypes()) {
			newTypes.addAll(addKnownObjectTypes(parTypes));
		}
		newTypes.addAll(addKnownObjectTypes(pl.getReturnTypes()));

		firePluginAdded(pl, newTypes);
	}

	private Collection<Class<?>> addKnownObjectTypes(Collection<Class<?>> types) {
		List<Class<?>> newTypes = new ArrayList<Class<?>>();
		for (Class<?> type : types) {
			if (type.isArray()) {
				if (knownObjectTypes.add(type.getComponentType())) {
					newTypes.add(type.getComponentType());
				}
			}
			if (knownObjectTypes.add(type)) {
				newTypes.add(type);
			}
		}
		return newTypes;
	}

	private boolean isGoodPlugin(Class<?> type, Method[] methods) {
		try {
			if (!isRightlyAnnotated(type)) {
				return false;
			}
			String[] names = type.getAnnotation(Plugin.class).parameterLabels();
			Class<?>[] returnTypes = type.getAnnotation(Plugin.class).returnTypes();

			// Check if there is at least one method annotated with PluginVariant
			List<Method> pluginMethods = new ArrayList<Method>(methods.length);
			for (Method m : methods) {
				if (m.isAnnotationPresent(PluginVariant.class)) {
					pluginMethods.add(m);
				}
			}

			// Check if for all methods, the requiredTypes are set Correctly
			Iterator<Method> it = pluginMethods.iterator();
			loop: while (it.hasNext()) {
				Method m = it.next();
				int[] required = m.getAnnotation(PluginVariant.class).requiredParameterLabels();
				Set<Integer> set = new HashSet<Integer>();
				for (int i : required) {
					set.add(i);
					if ((i < 0) || (i >= names.length)) {
						if (Boot.VERBOSE != Level.NONE) {
							System.err.println(""Method "" + m.toString()
									+ "" could not be added as a plugin. At least one required parameter is not a valid index.""
									+ ""There is no parameterlabel at index "" + i);
						}
						it.remove();
						continue loop;
					}
				}
				if (set.size() != required.length) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + m.toString()
								+ "" could not be added as a plugin. Some required indices are duplicated."");
					}
					it.remove();
				}
			}

			// Check for corresponding contexts at first indes
			it = pluginMethods.iterator();
			loop: while (it.hasNext()) {
				Method m = it.next();
				if (!isCorrectPluginContextType(m)) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + m.toString()
								+ "" could not be added as a plugin. The context should be asked as first parameter and should be a the same, or a superclass of ""
								+ pluginContextType.getName() + ""."");
					}
					it.remove();
					continue loop;
				}
			}

			it = pluginMethods.iterator();
			loop: while (it.hasNext()) {
				Method m = it.next();
				if ((returnTypes.length > 1) && !Object[].class.isAssignableFrom(m.getReturnType())
						&& !Object.class.equals(m.getReturnType())) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + m.toString()
								+ "" could not be added as a plugin. The plugin should return an array of objects as specified in the context."");
					}
					it.remove();
					continue loop;
				}
			}

			if (pluginMethods.isEmpty()) {
				if (Boot.VERBOSE != Level.NONE) {
					System.err.println(""Plugin "" + type.toString()
							+ "" could not be added as a plugin. At least one variant has to be specified."");
				}
				return false;
			}

			return true;

		} catch (NoClassDefFoundError e) {
			// required class not on classpath, cannot load as plugin
			return false;
		}
	}

	private boolean isCorrectPluginContextType(Method method) {
		if (method.getParameterTypes().length == 0) {
			return false;
		}
		if (!PluginContext.class.isAssignableFrom(method.getParameterTypes()[0])) {
			return false;
		}
		if (!method.getParameterTypes()[0].isAssignableFrom(pluginContextType)) {
			return false;
		}
		return true;
	}

	private boolean isRightlyAnnotated(AnnotatedElement element) {
		if (element.getAnnotation(Plugin.class).returnLabels().length != element.getAnnotation(Plugin.class)
				.returnTypes().length) {
			if (Boot.VERBOSE != Level.NONE) {
				System.err.println(""Plugin "" + element.toString() + "" could not be added as a plugin, the number of ""
						+ ""return types and return labels do not match."");
			}
			return false;
		}
		return true;
	}

	private boolean isGoodPlugin(Method method) throws NoClassDefFoundError {
		try {
			if (!isRightlyAnnotated(method)) {
				return false;
			}

			if ((method.getAnnotation(Plugin.class).parameterLabels().length != 0)
					&& (method.getAnnotation(Plugin.class).parameterLabels().length != method.getParameterTypes().length
							- 1)) {
				if (Boot.VERBOSE != Level.NONE) {
					System.err.println(""Plugin "" + method.toString() + "" could not be added as a plugin, the number of""
							+ "" parameter labels does not match the number of parameters."");
				}
				return false;
			}

			//		if (void.class.equals(method.getReturnType())) {
			//			System.err.println(""Method "" + method.toGenericString()
			//					+ "" could not be added as a plugin, as the resultType is void."");
			//			return false;
			//		}

			Class<?>[] returnTypes = method.getAnnotation(Plugin.class).returnTypes();
			if ((returnTypes.length > 1) && !Object[].class.isAssignableFrom(method.getReturnType())
					&& !Object.class.equals(method.getReturnType())) {
				if (Boot.VERBOSE != Level.NONE) {
					System.err.println(""Method "" + method.toString()
							+ "" could not be added as a plugin. The plugin should return an ""
							+ ""array of objects as specified in the context."");
				}
				return false;
			}

			Class<?>[] pars = method.getParameterTypes();
			if (!isCorrectPluginContextType(method)) {
				if (!method.isAnnotationPresent(Bootable.class)) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + method.toGenericString()
								+ "" could not be added as a plugin, the first parameter has to be a ""
								+ ""PluginContext and assignable from "" + pluginContextType.getName() + ""."");
					}
				}
				return false;
			}
			for (int i = 1; i < pars.length; i++) {
				Class<?> type = pars[i];
				if (PluginContext.class.isAssignableFrom(type)) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + method.toGenericString()
								+ "" could not be added as a plugin, only one context can be requested."");
					}
					return false;
				}
			}
			for (int i = 0; i < pars.length; i++) {
				if (pars[i].getTypeParameters().length > 0) {
					if (Boot.VERBOSE != Level.NONE) {
						System.err.println(""Method "" + method.toGenericString()
								+ "" could not be added as a plugin, as one of the parameters ""
								+ ""is derived from a Type using Generics"");
					}
					return false;
				}
			}
			return true;
		} catch (NoClassDefFoundError e) {
			// required class not on classpath, cannot load as plugin
			return false;
		}
	}

	public Set<Pair<Integer, PluginParameterBinding>> find(Class<? extends Annotation> annotation, Class<?> resultType,
			Class<? extends PluginContext> contextType, boolean totalMatch, boolean orderedParameters,
			boolean mustBeUserVisible, Class<?>... parameters) {

		Set<Pair<Integer, PluginParameterBinding>> result = new TreeSet<Pair<Integer, PluginParameterBinding>>();
		Set<PluginDescriptor> pls = annotation2plugins.get(annotation);
		if (pls == null) {
			return result;
		}
		for (PluginDescriptor plugin : pls) {
			if (mustBeUserVisible && (!plugin.meetsQualityThreshold() || !plugin.meetsLevelThreshold())) {
				/*
				 * Plug-in does not meet some required threshold to do so.
				 * Ignore it.
				 */
				continue;
			}
			if (!mustBeUserVisible || plugin.isUserAccessible()) {
				int i = (resultType == null ? 0 : plugin.getReturnTypes().indexOf(resultType));
				if (i < 0) {
					// Check for returned subtypes of the requested type
					i = checkIfRequestedReturnTypeIsPresent(plugin, resultType);
				}
				if (i >= 0) {
					for (int j = 0; j < plugin.getParameterTypes().size(); j++) {
						if (!plugin.getContextType(j).isAssignableFrom(contextType)) {
							// Check context types
							continue;
						}

						List<PluginParameterBinding> list = PluginParameterBinding.Factory.tryToBind(this, plugin, j,
								totalMatch, orderedParameters, parameters);
						for (PluginParameterBinding binding : list) {

							result.add(new ComparablePair<Integer, PluginParameterBinding>(i, binding));
							//							// Quit the loop since only one binding is to be
							//							// found.
							//							j = plugin.getParameterTypes().size();
						}
					}
				}
			}
		}
		return result;
	}

	public Set<Pair<Integer, PluginParameterBinding>> find(Class<? extends Annotation> annotation,
			Class<?>[] resultTypes, Class<? extends PluginContext> contextType, boolean totalMatch,
			boolean orderedParameters, boolean mustBeUserVisible, Class<?>... parameters) {

		if (resultTypes == null || resultTypes.length == 0) {
			throw new UnsupportedOperationException(
					""Cannot find plugins with empty or null list of return types using the find method with list input."");
		}

		Set<Pair<Integer, PluginParameterBinding>> result = new TreeSet<Pair<Integer, PluginParameterBinding>>();
		Set<PluginDescriptor> pls = annotation2plugins.get(annotation);
		if (pls == null) {
			return result;
		}
		for (PluginDescriptor plugin : pls) {
			if (mustBeUserVisible && (!plugin.meetsQualityThreshold() || !plugin.meetsLevelThreshold())) {
				/*
				 * Plug-in does not meet some required threshold to do so.
				 * Ignore it.
				 */
				continue;
			}
			if (!mustBeUserVisible || plugin.isUserAccessible()) {
				List<Class<?>> returnTypes = plugin.getReturnTypes();
				int[] indices = new int[resultTypes.length];
				boolean ok = returnTypes.size() == indices.length;

				for (int r = 0; ok && r < resultTypes.length; r++) {
					Class<?> resultType = resultTypes[r];
					// check if return type at index r is the right type
					ok &= isParameterAssignable(returnTypes.get(r), resultTypes[r]);
				}
				if (ok) {
					for (int j = 0; j < plugin.getParameterTypes().size(); j++) {
						if (!plugin.getContextType(j).isAssignableFrom(contextType)) {
							// Check context types
							continue;
						}

						List<PluginParameterBinding> list = PluginParameterBinding.Factory.tryToBind(this, plugin, j,
								totalMatch, orderedParameters, parameters);
						for (PluginParameterBinding binding : list) {

							for (int r = 0; r < resultTypes.length; r++) {
								result.add(new ComparablePair<Integer, PluginParameterBinding>(r, binding));
							}
							//							// Quit the loop since only one binding is to be
							//							// found.
							//							j = plugin.getParameterTypes().size();
						}
					}
				}
			}
		}
		return result;
	}

	private int checkIfRequestedReturnTypeIsPresent(PluginDescriptor plugin, Class<?> resultType) {
		for (int i = 0; i < plugin.getReturnTypes().size(); i++) {
			if (isParameterAssignable(plugin.getReturnTypes().get(i), resultType)) {
				return i;
			}
		}

		return -1;
	}

	public Collection<PluginDescriptor> find(String pluginName) {
		List<PluginDescriptor> result = new ArrayList<PluginDescriptor>();
		for (PluginDescriptor plugin : plugins.values()) {
			if (plugin.getName().equals(pluginName)) {
				result.add(plugin);
			}
		}
		return result;
	}

	public PluginDescriptor getPlugin(PluginDescriptorID id) {
		return plugins.get(id);
	}

	public PluginDescriptor getPlugin(String id) {
		for (Map.Entry<PluginDescriptorID, PluginDescriptor> entry : plugins.entrySet()) {
			if (entry.getKey().toString().equals(id)) {
				return entry.getValue();
			}
		}
		return null;
	}

	public Set<PluginParameterBinding> getPluginsAcceptingAtLeast(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters) {
		Set<PluginParameterBinding> result = new TreeSet<PluginParameterBinding>();
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, (Class<?>) null, contextType, false, false,
				mustBeUserVisible, parameters)) {
			result.add(pair.getSecond());
		}
		return result;
	}

	public Set<PluginParameterBinding> getPluginsAcceptingInAnyOrder(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters) {
		Set<PluginParameterBinding> result = new TreeSet<PluginParameterBinding>();
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, (Class<?>) null, contextType, true, false,
				mustBeUserVisible, parameters)) {
			result.add(pair.getSecond());
		}
		return result;
	}

	public Set<PluginParameterBinding> getPluginsAcceptingOrdered(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters) {
		Set<PluginParameterBinding> result = new TreeSet<PluginParameterBinding>();
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, (Class<?>) null, contextType, true, true,
				mustBeUserVisible, parameters)) {
			result.add(pair.getSecond());
		}
		return result;
	}

	public Set<Pair<Integer, PluginDescriptor>> getPluginsResultingIn(Class<?> resultType,
			Class<? extends PluginContext> contextType, boolean mustBeUserVisible) {
		Set<Pair<Integer, PluginDescriptor>> result = new TreeSet<Pair<Integer, PluginDescriptor>>();
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, resultType, contextType, false, false,
				mustBeUserVisible)) {
			result.add(new ComparablePair<Integer, PluginDescriptor>(pair.getFirst(), pair.getSecond().getPlugin()));
		}
		for (Pair<Integer, PluginParameterBinding> pair : find(Plugin.class, resultType, contextType, true, false,
				mustBeUserVisible)) {
			result.add(new ComparablePair<Integer, PluginDescriptor>(pair.getFirst(), pair.getSecond().getPlugin()));
		}
		return result;
	}

	private SortedSet<PluginDescriptor> getAllPluginsSorted(boolean canBeUserVisible, boolean mustBeUserVisible) {
		SortedSet<PluginDescriptor> result = new TreeSet<PluginDescriptor>();
		for (PluginDescriptor plugin : plugins.values()) {
			boolean visible = plugin.isUserAccessible();
			if (mustBeUserVisible && (!plugin.meetsQualityThreshold() || !plugin.meetsLevelThreshold())) {
				/*
				 * Plug-in can be user visible (that is, should end up in the
				 * GUI), but does not meet some required threshold. Ignore it.
				 */
				continue;
			}
			// Do not include, if:
			// mustBeUserVisible AND NOT visible, OR
			// visible AND NOT canBeUserVisible
			if (!((mustBeUserVisible && !visible) || (!canBeUserVisible && visible))) {
				result.add(plugin);
			}
		}
		return Collections.unmodifiableSortedSet(result);
	}

	public SortedSet<PluginDescriptor> getAllPlugins() {
		return getAllPluginsSorted(true, false);
	}

	public SortedSet<PluginDescriptor> getAllPlugins(boolean mustBeVisible) {
		return getAllPluginsSorted(mustBeVisible, mustBeVisible);
	}

	public boolean isParameterAssignable(Class<?> instanceType, Class<?> requestedType) {
		if (requestedType.isAssignableFrom(instanceType)) {
			return true;
		}
		if (requestedType.isArray() && requestedType.getComponentType().isAssignableFrom(instanceType)) {
			return true;
		}
		return false;
	}

	public Set<Class<?>> getKnownObjectTypes() {
		return Collections.unmodifiableSet(knownObjectTypes);
	}

}"
ProgressBarImpl.java,prom-framework-6.9.97,"package org.processmining.framework.plugin.impl;

import java.util.ArrayList;
import java.util.List;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.Progress;

public class ProgressBarImpl implements Progress {

	private int value = 0;
	private int min = 0;
	private int max = 1;
	private boolean indeterminate = true;
	private String message = """";

	private static final long serialVersionUID = -3950799546173352932L;
	private final PluginContext context;
	private boolean canceled = false;

	public ProgressBarImpl(PluginContext context) {
		this.context = context;
	}

	public void setCaption(String message) {
		this.message = message;
		context.getProgressEventListeners().fireProgressCaptionChanged(message);
	}

	public void inc() {
		context.getProgressEventListeners().fireProgressChanged(++value);
		// Thread.yield();
	}

	public void setMinimum(int value) {
		min = value;
		context.getProgressEventListeners().fireProgressBoundsChanged(min, max);
	}

	public void setMaximum(int value) {
		max = value;
		context.getProgressEventListeners().fireProgressBoundsChanged(min, max);
	}

	public void setValue(int value) {
		this.value = value;
		context.getProgressEventListeners().fireProgressChanged(value);
		// Thread.yield();
	}

	public int getValue() {
		return value;
	}

	public void setIndeterminate(boolean makeIndeterminate) {
		indeterminate = makeIndeterminate;
		context.getProgressEventListeners().fireProgressIndeterminateChanged(makeIndeterminate);
	}

	public String getCaption() {
		return message;
	}

	public boolean isIndeterminate() {
		return indeterminate;
	}

	public int getMaximum() {
		return max;
	}

	public int getMinimum() {
		return min;
	}

	public boolean isCancelled() {
		PluginExecutionResult results = context.getResult();
		// [HV] To be safe, check the following:
		if (results == null) {
			return false;
		}
		for (int i = 0; !canceled && (i < results.getSize()); i++) {
			try {
				Object o = results.getResult(i);
				if (o instanceof ProMFuture<?>) {
					return results.<ProMFuture<?>>getResult(i).isCancelled();
				}
			} catch (Exception e) {
				// cancel on fail;
				return true;
			}
		}
		return canceled;
	}

	public void cancel() {
		canceled = true;
		// BVD: Cancel all children too!
		List<PluginContext> children = new ArrayList<>(context.getChildContexts());
		for (PluginContext child : children) {
			if (child != null && child.getProgress() != null) {
				child.getProgress().cancel();
			}
		}
		// Now cancel ProMFutures
		PluginExecutionResult results = context.getResult();
		for (int i = 0; i < results.getSize(); i++) {
			Object o = results.getResult(i);
			if (o instanceof ProMFuture<?>) {
				results.<ProMFuture<?>>getResult(i).cancel(true);
			}
		}
	}

}
"
IncorrectReturnTypeException.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

/**
 * Thrown when a plugin returns an object of the wrong type.
 * 
 * @author bfvdonge
 * 
 */
public class IncorrectReturnTypeException extends RuntimeException {

	private static final long serialVersionUID = 8553687837509819311L;

	public IncorrectReturnTypeException(String plugin, int index, Class<?> expected, Class<?> returned) {
		super(""Plugin "" + plugin + "" produced the wrong type of result at index "" + index + "": Expected: "" + expected
				+ "", but received: "" + (returned == null ? ""nothing"" : returned) + ""."");
	}
}
"
InSufficientResultException.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

/**
 * Thrown when a plugin returns less results than declared.
 * 
 * @author bfvdonge
 * 
 */
public class InSufficientResultException extends RuntimeException {

	private static final long serialVersionUID = -1416206990218147728L;

	public InSufficientResultException(String plugin, int expected, int returned) {
		super(""Plugin "" + plugin + "" produced "" + returned + "" results, while "" + expected + "" results were declared."");
	}

}
"
ObjectConstructor.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

import java.util.Collection;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;

public interface ObjectConstructor {

	/**
	 * Finds as many objects of the given type as can be found through the
	 * connections of the other given type. If no objects can be found, it
	 * constructs as many objects of the given type as there are plugins
	 * available to the framework to do so. These plugins should be able to
	 * execute in a child of the given context and accept, in any order, exactly
	 * the input provided. Any other objects returned by the plugin, not being
	 * the requested type are added to the provided objects of the framework.
	 * Also, listeners are notified where applicable. If no plugings exist, or
	 * if these plugins fail, a ConnectionDoesntExistException is thrown.
	 * 
	 * @param <T>
	 *            The type of the return object required.
	 * @param <C extends Connection> The type of the connections to use when
	 *        trying to find the objects.
	 * @param type
	 *            the type of the return object required.
	 * @param connectionType
	 *            the type of the connections to use when trying to find the
	 *            objects.
	 * @param role
	 *            the assumed role of the object in the connection. Given a
	 *            connection, the object can be retrieved through the role.
	 * @param input
	 *            the input on which the plugin should work
	 * @return a collection of objects as found or returned by the plugins.
	 */
	public <T, C extends Connection> Collection<T> tryToFindOrConstructAllObjects(Class<T> type,
			Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained;

	/**
	 * Returns the first object of the given type as can be found through the
	 * connections of the other given type. If no objects can be found, it
	 * constructs as an object of the given type using a plugin available to the
	 * framework to do so. This plugins should be able to execute in a child of
	 * the given context and accept, in any order, exactly the input provided.
	 * Any other objects returned by the plugin, not being the requested type
	 * are added to the provided objects of the framework. Also, listeners are
	 * notified where applicable. If no plugins exist, or if these plugins fail,
	 * a ConnectionDoesntExistException is thrown.
	 * 
	 * @param <T>
	 *            The type of the return object required.
	 * @param <C extends Connection> The type of the connections to use when
	 *        trying to find the objects.
	 * @param type
	 *            the type of the return object required.
	 * @param connectionType
	 *            the type of the connections to use when trying to find the
	 *            objects.
	 * @param role
	 *            the assumed role of the object in the connection. Given a
	 *            connection, the object can be retrieved through the role.
	 * @param input
	 *            the input on which the plugin should work
	 * @return a collection of objects as returned by the plugins.
	 */
	public <T, C extends Connection> T tryToFindOrConstructFirstObject(Class<T> type, Class<C> connectionType,
			String role, Object... input) throws ConnectionCannotBeObtained;

	/**
	 * Returns the first object of the given type as can be found through the
	 * connections of the other given type. If no objects can be found, it
	 * constructs as an object of the given type using a plugin available to the
	 * framework to do so. This plugins should be able to execute in a child of
	 * the given context and accept, in any order, exactly the input provided.
	 * Furthermore, the returned object should have the right label assigned to
	 * it in the plugin definition. Any other objects returned by the plugin,
	 * not being the requested type are added to the provided objects of the
	 * framework. Also, listeners are notified where applicable. If no plugins
	 * exist, or if these plugins fail, a ConnectionDoesntExistException is
	 * thrown.
	 * 
	 * @param <T>
	 *            The type of the return object required.
	 * @param <C extends Connection> The type of the connections to use when
	 *        trying to find the objects.
	 * @param type
	 *            the type of the return object required.
	 * @param name
	 *            the name of the plugin to use.
	 * @param connectionType
	 *            the type of the connections to use when trying to find the
	 *            objects.
	 * @param role
	 *            the assumed role of the object in the connection. Given a
	 *            connection, the object can be retrieved through the role.
	 * @param input
	 *            the input on which the plugin should work
	 * @return a collection of objects as returned by the plugins.
	 */
	public <T, C extends Connection> T tryToFindOrConstructFirstNamedObject(Class<T> type, String name,
			Class<C> connectionType, String role, Object... input) throws ConnectionCannotBeObtained;

}"
PluginContext.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

import java.util.List;
import java.util.concurrent.Executor;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.plugin.events.Logger;
import org.processmining.framework.plugin.events.Logger.MessageLevel;
import org.processmining.framework.plugin.events.PluginLifeCycleEventListener;
import org.processmining.framework.plugin.events.ProgressEventListener;
import org.processmining.framework.plugin.impl.FieldNotSetException;
import org.processmining.framework.plugin.impl.FieldSetException;
import org.processmining.framework.util.Pair;

public interface PluginContext extends GlobalContext, ObjectConstructor {

	/**
	 * Returns a new plugin context instance, which can be used to invoke other
	 * plugins.
	 * 
	 * @return the new plugin context instance
	 */
	PluginContext createChildContext(String label);

	/* === Getters ==================================================== */

	/**
	 * Returns the progress object corresponding to this context
	 * 
	 * @return the progress object corresponding to this context
	 */
	Progress getProgress();

	/**
	 * Returns the list of registered progress listeners
	 * 
	 * @return the list of registered progress listeners
	 */
	ProgressEventListener.ListenerList getProgressEventListeners();

	/**
	 * Returns the list of registered plugin life cycle listeners.
	 * 
	 * @return the list of registered plugin life cycle listeners.
	 */
	PluginLifeCycleEventListener.List getPluginLifeCycleEventListeners();

	/**
	 * Each PluginContext should carry an ID. This ID is unique within this
	 * plugin context's global context.
	 * 
	 * @return the ID of this context
	 */
	PluginContextID getID();

	/**
	 * Returns the label of this context.
	 * 
	 * @return
	 */
	String getLabel();

	/**
	 * Return the plugin descriptor and method index of the plugin which is
	 * invoked in this context. This descriptor is set by the
	 * PluginDescriptor.invoke() method and will not be set yet before
	 * PluginManager.invoke() is called.
	 * 
	 * @return the descriptor of the plugin which is invoked in this context If
	 *         the plugin is not set yet, a pair of (null,-1) is returned
	 */
	Pair<PluginDescriptor, Integer> getPluginDescriptor();

	/**
	 * Returns the context which created this context or null if it has no
	 * parent.
	 * 
	 * @return
	 */
	PluginContext getParentContext();

	/**
	 * Returns a list of all child contexts which have been created with
	 * createChildContext().
	 * 
	 * @return
	 */
	List<PluginContext> getChildContexts();

	/**
	 * This method returns the PluginExecutionResult of the plugin which is
	 * invoked in this context. This future result is set by
	 * PluginManager.invoke() and will not be available (will be null) until the
	 * invoke() method is called.
	 * 
	 * @return The PluginExecutionResult that represents the result of this
	 *         plugin invocation
	 * @throws FieldNotSetException
	 *             If the future is not know to this context
	 */
	PluginExecutionResult getResult();

	/**
	 * This method should only be used by a plugin, in the body of that plugin.
	 * That is the only location, where it is guaranteed that each result object
	 * in getResults() can safely be cast to a ProMFuture.
	 * 
	 * @param i
	 * @return
	 */
	ProMFuture<?> getFutureResult(int i);

	/**
	 * Returns an executor which can be used to execute plugins in child
	 * contexts.
	 * 
	 * @return
	 */
	Executor getExecutor();

	/**
	 * Returns true if this is a distant child of context, i.e. true if
	 * getParent.getID().equals(context.getID()) ||
	 * getParent().isDistantChildOf(context);
	 * 
	 * @param context
	 * @return
	 */
	boolean isDistantChildOf(PluginContext context);

	/*
	 * === Setters: should only be called by the framework!
	 * ===============================
	 */

	void setFuture(PluginExecutionResult resultToBe);

	void setPluginDescriptor(PluginDescriptor descriptor, int methodIndex) throws FieldSetException,
			RecursiveCallException;

	boolean hasPluginDescriptorInPath(PluginDescriptor descriptor, int methodIndex);

	/**
	 * The provided String is provided to the context for information. It can
	 * for example signal a state change of a plugin. Note that some contexts
	 * can completely ignore this message.
	 * 
	 * @param message
	 *            the message to log
	 * @param level
	 *            the message level
	 */
	void log(String message, MessageLevel level);

	/**
	 * Same as calling log(message, MessageLevel.NORMAL);
	 * 
	 * @param message
	 *            The message
	 */
	void log(String message);

	/**
	 * The provided Exception is provided to the context. It signals the context
	 * about an error in the plugin, that specifically lead to abnormal
	 * termination. The plugin signaling the exception is no longer executing!
	 * 
	 * @param exception
	 *            the exception thrown
	 */
	void log(Throwable exception);

	/**
	 * Returns the list of logging listeners registered to this context.
	 * 
	 * @return
	 */
	Logger.ListenerList getLoggingListeners();

	/**
	 * Returns the root plugin context. This is an instance of PluginContext of
	 * which all other contexts are distant childs.
	 * 
	 * @return
	 */
	PluginContext getRootContext();

	/**
	 * Delete this child from this context.
	 * 
	 * @param child
	 * @returns true if this child was a child of the context and has now been
	 *          deleted. false otherwise
	 */
	boolean deleteChild(PluginContext child);

	/**
	 * Registers the given connection in the global context. The implementation
	 * is
	 * 
	 * addConnection(this,c);
	 * 
	 * @param c
	 */
	<T extends Connection> T addConnection(T c);

	void clear();
}
"
PluginContextID.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

/**
 * Represents an ID of a plugin context.
 * 
 * @author bfvdonge
 * 
 */
public interface PluginContextID extends Comparable<PluginContextID> {

	/**
	 * PluginContextID are used in Collections, so this method has to be
	 * implemented in all its subclasses.
	 * 
	 * @return
	 */
	public boolean equals(Object o);

	/**
	 * PluginContextID are used in HashMaps, so this method has to be
	 * implemented in all its subclasses.
	 * 
	 * @return
	 */
	public int hashCode();

}
"
PluginDescriptor.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

import java.lang.annotation.Annotation;
import java.net.URL;
import java.util.List;
import java.util.Set;

import javax.swing.ImageIcon;

import org.processmining.framework.packages.PackageDescriptor;

public interface PluginDescriptor extends Comparable<PluginDescriptor> {

	/**
	 * Check if this plugin carries the given annotation. Implementing classes
	 * can return false at their discretion, i.e. they are not required to
	 * return true for all annotations carried by the plugin.
	 * 
	 * @param annotationClass
	 * @return
	 */
	boolean hasAnnotation(Class<? extends Annotation> annotationClass);

	/**
	 * Check if the method at the given index carries the given annotation.
	 * Implementing classes can return false at their discretion, i.e. they are
	 * not required to return true for all annotations carried by the plugin.
	 * 
	 * @param annotationClass
	 * @return
	 */
	boolean hasAnnotation(Class<? extends Annotation> annotationClass, int methodIndex);

	/**
	 * Return the annotation of the given class carried by this plugin. Note
	 * that hasAnnotationClass(annotationClass) is assumed.
	 * 
	 * This method should not be used to access any annotation elements carried
	 * by Plugin.class. Implementing classes are allows to return null when
	 * called with Plugin.class.
	 * 
	 * @param <T>
	 * @param annotationClass
	 * @return
	 */
	<T extends Annotation> T getAnnotation(Class<T> annotationClass);

	/**
	 * Return the annotation of the method at the given index. Note that
	 * hasAnnotationClass(annotationClass, methodIndex) is assumed.
	 * 
	 * This method should not be used to access any annotation elements carried
	 * by Plugin.class. Implementing classes are allows to return null when
	 * called with Plugin.class.
	 * 
	 * @param <T>
	 * @param annotationClass
	 * @param methodIndex
	 * @return
	 */
	<T extends Annotation> T getAnnotation(Class<T> annotationClass, int methodIndex);

	/**
	 * Return the package where the plug-in resides.
	 * 
	 * @return
	 */
	PackageDescriptor getPackage();

	/**
	 * Return the name of the plugin. This name is not unique within ProM.
	 * 
	 * @return
	 */
	String getName();

	/**
	 * return hashcode
	 * 
	 * @return
	 */
	int hashCode();

	/**
	 * return equality of plugins. The ID is used for equality.
	 * 
	 * @param other
	 * @return
	 */
	boolean equals(Object other);

	/**
	 * Returns a String representation of the plugin
	 * 
	 * @return
	 */
	String toString();

	/**
	 * Return the number of methods in this plugin. There's always at least 1.
	 * 
	 * @return
	 */
	int getNumberOfMethods();

	/**
	 * Asynchronously invokes a method of this plugin. The methodIndex should
	 * refer to an existing method, i.e. 0 <= methodindex <
	 * getNumberOfMethods();
	 * 
	 * Note that the callers of this plugin should notify the lifeCycleListners
	 * of the given context of the creation of this plugin, i.e. they should
	 * call:
	 * <code>context.getParentContext().getPluginLifeCycleEventListeners().firePluginCreated(context);</code>
	 * 
	 * @param methodIndex
	 *            The index of the method to be invoked
	 * @param context
	 *            the context in which this plugin should be invoked. The plugin
	 *            may assume that this context is meant only for its execution.
	 * @param args
	 *            the objects to be passed to the plugin. These objects should
	 *            be in the right order. However, if <code>ProMFuture</code>
	 *            objects are provided, the plugin will synchronize on them.
	 *            This syncrhonization is performed in a fast-fail fashion, i.e.
	 *            the first future that results in an exception during execution
	 *            will result in an exception while invoking this plugin. This
	 *            exception is caught and the context is signaled about it.
	 * @return a PluginExecutionResult holding pointers to the future outcome of
	 *         this invokation. If synchrounous execution is required, the
	 *         calling method should synchronize on this result
	 */
	PluginExecutionResult invoke(int methodIndex, PluginContext context, Object... args);

	/**
	 * returns the types of the objects returned if this plugin is invoked, in
	 * the order in which they are returned
	 * 
	 * @return
	 */
	List<Class<?>> getReturnTypes();

	/**
	 * returns the labels of the objects returned if this plugin is invoked, in
	 * the order in which they are returned. These are the labels provided by
	 * the plugin definition, not the labels of the objects resulting from a
	 * specific invokation, as these can be obtained through the
	 * <code>PluginExecutionResult</code> object.
	 * 
	 * @return
	 */
	List<String> getReturnNames();

	/**
	 * returns a list of size <code>getNumberOfMethods()</code>, such that
	 * element at index <code>i</code> of the list equals
	 * <code>getParameterTypes(i)</code>
	 * 
	 * @return
	 */
	List<List<Class<?>>> getParameterTypes();

	/**
	 * Returns a list of types that represent the required parameters of the
	 * method at the given index. In other words, the method at index
	 * <code>methodIndex</code> requires exectly the parameter types as provided
	 * in the returned list, in that order.
	 * 
	 * @param methodIndex
	 * @return
	 */
	List<Class<?>> getParameterTypes(int methodIndex);

	/**
	 * Returns a list of labels that represent the possible parameters of this
	 * plugin. Each method required a subset of these labels, while preserving
	 * their order.
	 * 
	 * @return
	 */
	List<String> getParameterNames();

	/**
	 * Returns a list of labels that represent the required parameters of the
	 * method at the given index. In other words, the method at index
	 * <code>methodIndex</code> requires exactly the parameter labels as
	 * provided in the returned list, in that order.
	 * 
	 * @param methodIndex
	 * @return
	 */
	List<String> getParameterNames(int methodIndex);

	/**
	 * Return the type of the parameter at index <code>parameterIndex</code> of
	 * the method at <code>methodIndex</code>.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @param parameterIndex
	 *            <code>0 <= parameterIndex < getParameterTypes().size()</code>
	 * @return may return null if the parameter is not used by the given method
	 */
	Class<?> getPluginParameterType(int methodIndex, int parameterIndex);

	/**
	 * Return the label of the parameter at index <code>parameterIndex</code> of
	 * the method at <code>methodIndex</code>.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @param parameterIndex
	 *            <code>0 <= parameterIndex < getParameterTypes(methodIndex).size()</code>
	 * @return may return null if the parameter is not used by the given method
	 */
	String getPluginParameterName(int methodIndex, int parameterIndex);

	/**
	 * returns the ID of this Plugin. Provided that the code of a plugin does
	 * not change, these IDs are persistent between executions of ProM.
	 * 
	 * @return
	 */
	PluginDescriptorID getID();

	/**
	 * Returns the context type required by the method at index methodIndex.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @return
	 */
	Class<? extends PluginContext> getContextType(int methodIndex);

	/**
	 * Returns a list of types that can be accepted for the parameter at index
	 * <code>globalParameterIndex</code>. The parameter index is global, i.e.
	 * not method specific. Instead, for each type <code>t</code> in the set
	 * returned by this method it is guaranteed that there is at least one
	 * method (suppose at index <code>i</code>), such that
	 * <code>getParameterType(i, getIndexInMethod(i, globalParameterIndex)) == t</code>
	 * 
	 * @param globalParameterIndex
	 *            <code>0 <= globalParameterIndex < getParameterNames().size()</code>
	 * @return
	 */
	Set<Class<?>> getTypesAtParameterIndex(int globalParameterIndex);

	/**
	 * Returns the index of the method parameter of the given method in the list
	 * of global parameters. Each method of a plugin requires a subset of the
	 * global set of parameters that the plugin defines. This method can be used
	 * to map the index of each method parameter to the index of the global
	 * parameter.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @param methodParameterIndex
	 *            <code>0 <= methodParameterIndex < getParameterNames(methodIndex).size()</code>
	 * @return <code>0 <= return < getParameterNames().size()</code>
	 */
	int getIndexInParameterNames(int methodIndex, int methodParameterIndex);

	/**
	 * Returns the index of the global parameter to the index of that parameter
	 * in the given method. Each method of a plugin requires a subset of the
	 * global set of parameters that the plugin defines. This method can be used
	 * to map the index of each global parameter to the index of the method
	 * parameter. Note that if the given method does not require the global
	 * parameter, -1 is returned.
	 * 
	 * @param methodIndex
	 *            <code>0 <= methodIndex < getNumberOfMethods()</code>
	 * @param globalParameterIndex
	 *            <code>0 <= globalParameterIndex < getParameterNames().size()</code>
	 * @return <code>-1 <= return < getParameterNames(methodIndex).size()</code>
	 */
	int getIndexInMethod(int methodIndex, int globalParameterIndex);

	/**
	 * Return the label of the given method, if specified. If no label was
	 * specified, the name of the plugin is returned.
	 * 
	 * @param methodIndex
	 * @return
	 */
	String getMethodLabel(int methodIndex);

	/**
	 * Compares this plugin with another plugins. Uses the
	 * <code>getName().toLowerCase()</code> for comparing. Only if names are
	 * equal, then the IDs are used for comparison. Comparison should be
	 * name-based between different implementing classes.
	 */
	int compareTo(PluginDescriptor plugin);

	/**
	 * Returns true if this plugin can be used by the end-users. If this is set
	 * to false, such a plugin should not be presented to the end user by any
	 * context.
	 * 
	 * @return
	 */
	boolean isUserAccessible();

	/**
	 * Returns whether the plugin handles termination itself.
	 * 
	 * @return
	 */
	boolean handlesCancel();

	/**
	 * Returns the index in the result array of the most significant result for
	 * this plugin
	 * 
	 * @return the index in the result array of the most significant result. If
	 *         no results are returned by this plugin, anything can be returned.
	 */
	int getMostSignificantResult();

	/**
	 * Return the help / description of the plugin.
	 * 
	 * @return
	 */
	String getHelp();

	/**
	 * Return the help / description of the given method, if specified.
	 * 
	 * @param methodIndex
	 * @return
	 */
	String getMethodHelp(int methodIndex);
	
	
	/**
	 * Return the set of keywords.
	 * 
	 * @return a set of keywords
	 */
	String[] getKeywords();
	
	/**
	 * Return the set of categories.
	 * 
	 * @return a set of categories
	 */
	String[] getCategories();

	/**
	 * Return whether this plug-in meets the quality threshold.
	 * 
	 * @return whether this plug-in meets the quality threshold
	 */
	boolean meetsQualityThreshold();
	/**
	 * Return whether this plug-in meets the level threshold.
	 * 
	 * @return whether this plug-in meets the level threshold
	 */
	boolean meetsLevelThreshold();
	
	public ImageIcon getIcon();
	
	public URL getURL();

}
"
PluginDescriptorID.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

/**
 * This interface provides an ID for each plugin. These IDs are persistent
 * between executions of ProM, provided that no code changes are made to the
 * plugin in question.
 * 
 * @author bfvdonge
 * 
 */
public interface PluginDescriptorID extends Comparable<PluginDescriptorID> {

	/**
	 * ProvidedObjectIDs are used in Collections, so this method has to be
	 * implemented in all its subclasses.
	 * 
	 * @return
	 */
	public boolean equals(Object o);

	/**
	 * ProvidedObjectIDs are used in HashMaps, so this method has to be
	 * implemented in all its subclasses.
	 * 
	 * @return
	 */
	public int hashCode();

}
"
PluginExecutionResult.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.providedobjects.ProvidedObjectID;

/**
 * This class represents the result of a plugin execution. It can be used to
 * obtain all details after executing a plugin.
 * 
 * Typically, plugins are executed a-synchronously, but by calling synchronize()
 * on this object, the current thread is suspended untill all results are in (or
 * exceptions are thrown)
 * 
 * @author bfvdonge
 * 
 */
public interface PluginExecutionResult {

	/**
	 * Returns the size of this result, i.e. how many objects were returned by
	 * the plugin
	 * 
	 * @return
	 */
	public int getSize();

	/**
	 * Synchronizes on any futures that might still exist in the result. If no
	 * futures exist, this method does terminate normally
	 * 
	 * @throws CancellationException
	 * @throws ExecutionException
	 * @throws InterruptedException
	 */
	public void synchronize() throws CancellationException, ExecutionException, InterruptedException;

	/**
	 * returns the results of this plugin in an array. If synchronize() was
	 * called, this method returns the actual objects. Otherwise, it might
	 * return ProMFutures on the actual objects (or any combination thereof).
	 * 
	 * @return
	 */
	public Object[] getResults();

	/**
	 * returns the result at the given index, casted to the given returntype. If
	 * synchronize() was called, this method returns the actual object.
	 * Otherwise, it might return a ProMFuture<T> on the actual object.
	 * 
	 * Note that 0<= resultIndex < getSize()
	 * 
	 * @param <T>
	 * @param resultIndex
	 * @return
	 */
	public <T> T getResult(int resultIndex) throws ClassCastException;

	/**
	 * This method returns the names of the results
	 * 
	 * @return
	 */
	public String[] getResultNames();

	/**
	 * this method returns the name of the result at the given index.
	 * 
	 * Note that 0<= resultIndex < getSize()
	 * 
	 * @param resultIndex
	 * @return
	 */
	public String getResultName(int resultIndex);

	/**
	 * Tells this result under which provided object ID the object at index i is
	 * known to the framework
	 * 
	 * @param i
	 *            index of the object
	 * @param id
	 *            the id of the provided object refering to the objet at index i
	 */
	void setProvidedObjectID(int i, ProvidedObjectID id);

	/**
	 * Returns the ProvidedObjectID under which the object at index i is known
	 * to the framework's ProvidedObject manager
	 * 
	 * @param i
	 *            index of the object
	 */
	ProvidedObjectID getProvidedObjectID(int i);

	/**
	 * Returns the type of the object at index i, as declared by the plugin
	 * 
	 * @param i
	 * @return
	 */
	public <T> Class<? super T> getType(int i);

	/**
	 * Returns the plugin used to generate this result
	 * 
	 * @return
	 */
	public PluginDescriptor getPlugin();

}
"
PluginManager.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

import java.lang.annotation.Annotation;
import java.net.URL;
import java.util.Collection;
import java.util.EventListener;
import java.util.Set;
import java.util.SortedSet;

import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.util.Pair;

/**
 * The plugin manager manages plugins. It loads plugins from URLs and provides
 * access to them through search methods.
 * 
 * @author bfvdonge
 * 
 */
public interface PluginManager {

	/**
	 * Constant to denote the file extension for class files.
	 */
	static final String CLASS_EXTENSION = "".class"";

	/**
	 * Constant to denote the file extension for macro files.
	 */
	static final String MCR_EXTENSION = "".mcr"";

	/**
	 * Constant to denote the file extension for jar files.
	 */
	static final String JAR_EXTENSION = "".jar"";

	/**
	 * Constant to denote the file protocol to be used in URLs provided to this
	 * plugin manager.
	 */
	static final String FILE_PROTOCOL = ""file"";

	/**
	 * This interface describes an error listener for the plugin manager. The method
	 * error should be called by a plugin manager while registering packages and
	 * scanning for plugins.
	 * 
	 * @author bfvdonge
	 * 
	 */
	interface PluginManagerListener extends EventListener {
		/**
		 * Listen for errors which occur while registering packages and scanning for
		 * plugins.
		 * 
		 * @param source
		 *            The URL which was being registered while this error occurred
		 * @param t
		 *            The error which occurred
		 * @param className
		 *            The class name of the class which was being registered, may be
		 *            null
		 */
		void error(URL source, Throwable t, String className);

		/**
		 * Listen for plugins that are registered to the manager. Every time a
		 * PluginDescriptor is added to the manager, an event is generated.
		 * 
		 * @param plugin
		 */
		void newPlugin(PluginDescriptor plugin, Collection<Class<?>> newTypes);
	}

	/**
	 * Adds a listener to the plugin manager.
	 * 
	 * @param listener
	 *            the listener to add.
	 */
	void addListener(PluginManagerListener listener);

	/**
	 * Removes the listener from the plugin manager.
	 * 
	 * @param listener
	 *            the listener to remove.
	 */
	void removeListener(PluginManagerListener listener);

	/**
	 * registers a URL to this plugin manager. If the URL uses the
	 * <code>FILE_PROTOCOl</code> protocol and denotes a directory, then this folder
	 * is recursively scanned for files with the <code>CLASS_EXTENSION</code>
	 * extension.
	 * 
	 * Otherwise, the URL is assumed to point to a jar file, of which the classes
	 * are scanned.
	 * 
	 * Each class file is scanned for classes and/or methods annotated with the
	 * <code>Plugin</code> annotation. If a class is annotated with this annotation,
	 * then its methods are scanned for the <code>PluginVariant</code> annotation.
	 * 
	 * For each plugin found, a <code>PluginDescriptor</code> object is
	 * instantiated. These plugin descriptors can later be used to invoke plugins.
	 * 
	 * @param url
	 *            The URL to register
	 * @param pack
	 *            The package that corresponds to the URL
	 */
	void register(URL url, PackageDescriptor pack);

	/**
	 * registers a URL to this plugin manager. If the URL uses the
	 * <code>FILE_PROTOCOl</code> protocol and denotes a directory, then this folder
	 * is recursively scanned for files with the <code>CLASS_EXTENSION</code>
	 * extension.
	 * 
	 * Otherwise, the URL is assumed to point to a jar file, of which the classes
	 * are scanned.
	 * 
	 * Each class file is scanned for classes and/or methods annotated with the
	 * <code>Plugin</code> annotation. If a class is annotated with this annotation,
	 * then its methods are scanned for the <code>PluginVariant</code> annotation.
	 * 
	 * For each plugin found, a <code>PluginDescriptor</code> object is
	 * instantiated. These plugin descriptors can later be used to invoke plugins.
	 * 
	 * @param url
	 *            The URL to register
	 * @param pack
	 *            The package that corresponds to the URL
	 * @param loader
	 *            The class loader used to load the jar files.
	 */
	void register(URL url, PackageDescriptor pack, ClassLoader loader);

	/**
	 * This method retuns a collection of <code>Pair</code>s of <code>Integer</code>
	 * and <code>PluginParameterBinding</code> objects, such that:
	 * <p>
	 * The method belonging to the plugin in the pluginParameterBinding carries the
	 * given annotation. If no specific annotation is required, the method should be
	 * called with <code>Plugin.class</code>. Note that the annotation required has
	 * to be on the same level as the <code>Plugin</code> annotation, i.e. either on
	 * a method or a class
	 * <p>
	 * When invoked, the PluginParameterBinding returns an array of objects, of
	 * which the object at the index given by the integer in the pair is of the
	 * required result type, i.e.
	 * <code>resultType.isAssignableFrom(p.getPlugin().getReturnTypes()[i])</code>
	 * If no specific return type is required, use <code>Object.class</code> for
	 * this parameter.
	 * <p>
	 * The PluginParameterBinding can be executed in a <code>PluginContext</code> of
	 * the given type.
	 * <p>
	 * If <code>totalMatch</code> is true, then the PluginParameterBinding binds all
	 * parameters of the plugin with all arguments. Otherwise, the
	 * PluginParameterBinding only requires a subset of the given arguments and is
	 * therefore not directly executable on the given set of arguments.
	 * <p>
	 * If <code>orderedParameters</code> is true, then the PluginParameterBinding
	 * binds the given arguments in the given order, i.e. no arguments are
	 * reordered.
	 * <p>
	 * If <code>mustBeUserVisible</code> is true, then the plugin must have the
	 * <code>isUserVisible</code> flag set to true.
	 * <p>
	 * The PluginParameterBinding can be executed on arguments of the given types.
	 * The list of arguments can be empty, in which case no arguments are required
	 * to invoke the PluginParameterBinding. Note that only types of arguments are
	 * required, not the values. For checking whether arguments can be assigned to
	 * parameters of the Plugin, the <code>isParameterAssignable</code> method is
	 * used. Any <code>ProMFuture</code>s should be unwrapped.
	 * 
	 * @param annotation
	 *            The annotation that should be present on the plugin (use
	 *            <code>Plugin.class</code> if none is required).
	 * @param resultType
	 *            The required result type (use <code>Object.class</code> if no
	 *            specific type is required).
	 * @param contextType
	 *            The context type in which this plugin should be executable. Note
	 *            that this type should be the contextType of the context from which
	 *            the find is called, or a supertype thereof.
	 * @param totalMatch
	 *            Whether or not all arguments should be used to execute this
	 *            plugin.
	 * @param orderedParameters
	 *            Whether or not the arguments are given in the right order.
	 * @param mustBeUserVisible
	 *            Whether or not all returned plugins should be user visible.
	 * @param args
	 *            The types of the arguments provided to the plugin. Can be empty.
	 * @return A collection of pluginparameterbindings. They are executable if
	 *         totalMatch is true.
	 */
	Set<Pair<Integer, PluginParameterBinding>> find(Class<? extends Annotation> annotation, Class<?> resultType,
			Class<? extends PluginContext> contextType, boolean totalMatch, boolean orderedParameters,
			boolean mustBeUserVisible, Class<?>... args);

	/**
	 * This method retuns a collection of <code>Pair</code>s of <code>Integer</code>
	 * and <code>PluginParameterBinding</code> objects, such that:
	 * <p>
	 * The method belonging to the plugin in the pluginParameterBinding carries the
	 * given annotation. If no specific annotation is required, the method should be
	 * called with <code>Plugin.class</code>. Note that the annotation required has
	 * to be on the same level as the <code>Plugin</code> annotation, i.e. either on
	 * a method or a class
	 * <p>
	 * When invoked, the PluginParameterBinding returns an array of objects, of
	 * which the object at the index given by the integer in the pair is of the
	 * required result type as specified in the input list, i.e. for all
	 * <code>i</code>
	 * <code>resultTypes[i].isAssignableFrom(p.getPlugin().getReturnTypes()[i])</code>
	 * If no specific return type is required, use the other <code>find</code>
	 * method.
	 * <p>
	 * The PluginParameterBinding can be executed in a <code>PluginContext</code> of
	 * the given type.
	 * <p>
	 * If <code>totalMatch</code> is true, then the PluginParameterBinding binds all
	 * parameters of the plugin with all arguments. Otherwise, the
	 * PluginParameterBinding only requires a subset of the given arguments and is
	 * therefore not directly executable on the given set of arguments.
	 * <p>
	 * If <code>orderedParameters</code> is true, then the PluginParameterBinding
	 * binds the given arguments in the given order, i.e. no arguments are
	 * reordered.
	 * <p>
	 * If <code>mustBeUserVisible</code> is true, then the plugin must have the
	 * <code>isUserVisible</code> flag set to true.
	 * <p>
	 * The PluginParameterBinding can be executed on arguments of the given types.
	 * The list of arguments can be empty, in which case no arguments are required
	 * to invoke the PluginParameterBinding. Note that only types of arguments are
	 * required, not the values. For checking whether arguments can be assigned to
	 * parameters of the Plugin, the <code>isParameterAssignable</code> method is
	 * used. Any <code>ProMFuture</code>s should be unwrapped.
	 * 
	 * @param annotation
	 *            The annotation that should be present on the plugin (use
	 *            <code>Plugin.class</code> if none is required).
	 * @param resultTypes
	 *            The exact, sorted list of required result types. If not specific
	 *            type is requested, this find method should not be used.
	 * @param contextType
	 *            The context type in which this plugin should be executable. Note
	 *            that this type should be the contextType of the context from which
	 *            the find is called, or a supertype thereof.
	 * @param totalMatch
	 *            Whether or not all arguments should be used to execute this
	 *            plugin.
	 * @param orderedParameters
	 *            Whether or not the arguments are given in the right order.
	 * @param mustBeUserVisible
	 *            Whether or not all returned plugins should be user visible.
	 * @param args
	 *            The types of the arguments provided to the plugin. Can be empty.
	 * @return A collection of pluginparameterbindings. They are executable if
	 *         totalMatch is true.
	 */
	public Set<Pair<Integer, PluginParameterBinding>> find(Class<? extends Annotation> annotation,
			Class<?>[] resultTypes, Class<? extends PluginContext> contextType, boolean totalMatch,
			boolean orderedParameters, boolean mustBeUserVisible, Class<?>... parameters);

	/**
	 * Find the plugins resulting in the given type. The result are pairs of
	 * integers and plugins, such that for each pair (i,p) holds that
	 * resultType.isAssignableFrom(p.getReturnTypes()[i])
	 * 
	 * @param resultType
	 *            Can be null. if null, then any type is considered.
	 * @param mustBeUserVisible
	 *            Whether or not all returned plugins should be user visible.
	 * @return A collection of pairs of integers and plugins, such that for each
	 *         pair (i,p) holds that
	 *         resultType.isAssignableFrom(p.getReturnTypes()[i])
	 */
	Set<Pair<Integer, PluginDescriptor>> getPluginsResultingIn(Class<? extends Object> resultType,
			Class<? extends PluginContext> contextType, boolean mustBeUserVisible);

	/**
	 * Returns executable PluginParameterBindings, which can be invoked in the given
	 * context on the given parameter types. Note that the PluginParameterBindings
	 * are executable.
	 * 
	 * @param contextType
	 *            The type of the context in which the binding is to be invoked.
	 * @param mustBeUserVisible
	 *            Whether or not the plugin should be user visible.
	 * @param parameters
	 *            The types of the arguments passed to the plugins. They are
	 *            accepted by the plugin in the order in which they are provided.
	 * 
	 * @return a list of executable bindings
	 */
	Set<PluginParameterBinding> getPluginsAcceptingOrdered(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters);

	/**
	 * Returns PluginParameterBindings, which can be invoked in the given context on
	 * the given parameter types. Note that the PluginParameterBindings are not
	 * necessarily executable. However, they accept all given arguments as
	 * parameters.
	 * 
	 * @param contextType
	 *            The type of the context in which the binding is to be invoked.
	 * @param mustBeUserVisible
	 *            Whether or not the plugin should be user visible.
	 * @param parameters
	 *            The types of the arguments passed to the plugins. They are
	 *            accepted by the returned plugins, but not necessarily in this
	 *            order.
	 * @return a list of bindings
	 */
	Set<PluginParameterBinding> getPluginsAcceptingAtLeast(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters);

	/**
	 * Returns executable PluginParameterBindings, which can be invoked in the given
	 * context on the given parameter types. Note that the PluginParameterBindings
	 * are executable.
	 * 
	 * @param contextType
	 *            The type of the context in which the binding is to be invoked.
	 * @param mustBeUserVisible
	 *            Whether or not the plugin should be user visible.
	 * @param parameters
	 *            The types of the arguments passed to the plugins. They are
	 *            accepted by the returned plugins, but not necessarily in this
	 *            order.
	 * @return a list of executable bindings
	 */
	Set<PluginParameterBinding> getPluginsAcceptingInAnyOrder(Class<? extends PluginContext> contextType,
			boolean mustBeUserVisible, Class<?>... parameters);

	/**
	 * Returns a PluginDescriptor with the given id. Note that plugin IDs are
	 * persistent between runs.
	 * 
	 * @param id
	 *            the id of the plugin to get
	 * @return the plugin with the given id.
	 */
	PluginDescriptor getPlugin(PluginDescriptorID id);

	/**
	 * Returns a PluginDescriptor of which the toString() of its id equals the given
	 * id. Note that plugin IDs are persistent between runs.
	 * 
	 * @param id
	 *            the String representation of the id of the plugin to get
	 * @return the plugin with an id of which the String representation equals the
	 *         given id.
	 */
	PluginDescriptor getPlugin(String id);

	/**
	 * Returns all plugin descriptors
	 * 
	 * @return all plugin descriptors known to the plugin manager.
	 */
	SortedSet<PluginDescriptor> getAllPlugins();

	/**
	 * Returns all plugin descriptors known to the plugin manager. If set, only
	 * those plugins which are user visible are returned.
	 * 
	 * @param mustBeVisible
	 *            wether or not the returned plugins should be user visible.
	 * @return the plugin descriptors.
	 */
	SortedSet<PluginDescriptor> getAllPlugins(boolean mustBeVisible);

	/**
	 * Returns true if the instance type can be cast to the requested type, or if
	 * the requested type is an array and the instance type can be cast to the
	 * component type of the requested type.
	 * 
	 * @param instanceType
	 *            the type that has to be cast to the requested type.
	 * @param requestedType
	 *            the requested type
	 * @return true if a cast can be made, i.e. if an object of type instanceType
	 *         can be assigned to a parameter of type requestedType of a plugin.
	 */
	boolean isParameterAssignable(Class<?> instanceType, Class<?> requestedType);

	/**
	 * Returns the set of types that is known to the plugin manager. Basically, this
	 * set contains all types that are ever used as a parameter or a return type of
	 * a plugin.
	 * 
	 * @return a set of types.
	 */
	Set<Class<?>> getKnownObjectTypes();

	/**
	 * Returns all known classes annotated with a certain annotationType. Not all of
	 * these classes are plugins! Note that only classes are available that carry
	 * the @KeepInProMCache annotation
	 * 
	 * @param annotationType
	 *            the type of annotation to be found
	 * @return a (possibly empty) set of classes (not null)
	 */
	Set<Class<?>> getKnownClassesAnnotatedWith(Class<? extends Annotation> annotationType);

}"
PluginParameterBinding.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.processmining.framework.util.ArrayUtils;

/**
 * This class represents a binding between a method of a plugin and a set of
 * parameters. The semantics of this object are as follows.
 * 
 * First, the {@code PluginParameterBinding.Factory.tryToBind()} should be used
 * to construct a list of PluginParameterBindings. This method is called with a
 * variable array of parameter types, such that for each returned binding, the
 * <code>invoke()</code> method can be called with a variable array of
 * instantiations of these types, in that order.
 * 
 * Any reordering that needs to be done (if <code>tryToBind()</code> was called
 * with <code>orderedParameters == false</code>) is handled by the binding.
 * 
 * A PluginParameterBinding is only guaranteed to be executable, if the factory
 * method was called with <code>mustBeTotal</code> set to true.
 * 
 * @author bfvdonge
 * 
 */
public class PluginParameterBinding implements Comparable<PluginParameterBinding> {

	/**
	 * Factory for instantiating PluginParameterBindings binding plugins with a
	 * given input.
	 * 
	 * @author bfvdonge
	 * 
	 */
	public static class Factory {

		private Factory() {
		}

		/**
		 * This method instantiates binding objects binding the method and index
		 * <code>methodIndex</code> of the given plugin to the given set of
		 * parameter types, if possible. If no binding is possible, an empty
		 * list is returned.
		 * 
		 * If a total binding is requested (indicated by
		 * <code>mustBeTotal == true</code>), then the returned binding assigns
		 * objects from the given parameters to all inputParameters of the
		 * plugin method.
		 * 
		 * If no total binding is required, the resulting bindings is not
		 * necessarily executable, as the method bound might require more input.
		 * However, all provided parameterTypes are bound to a parameter.
		 * 
		 * Using the flag <code>orderedParameters</code> the user can request
		 * bindings that consider the given parameters, in the given order only,
		 * i.e. no reordering is done. Any binding <code>b</code> returned with
		 * <code>orderedParameters == true</code> will satisfy the property that
		 * <code>b.getBinding()[i] == i</code> for all <code>i</code>.
		 * 
		 * @param plugin
		 *            the plugin for which to try to bind the parameters
		 * @param mustBeTotal
		 *            indicating whether the resulting binding should be total
		 * @param orderedParameters
		 *            whether or not the parameters are ordered.
		 * @param parameterTypes
		 *            the available types to be distributed over the parameters.
		 *            Note that if one of the objects is a Object[] then, this
		 *            array will be kept as one. Multiple objects of type T,
		 *            might end up in an array of type S super T, i.e. they can
		 *            be bound into one S[] to be passed to a single element of
		 *            plugin.getTypes()
		 * @return A list of length 0 if no binding exists, or a list of length
		 *         1 if a binding exists. Note that this may change in the
		 *         future to lists of length n.
		 */
		public static List<PluginParameterBinding> tryToBind(PluginManager manager, PluginDescriptor plugin,
				int methodIndex, boolean mustBeTotal, boolean orderedParameters, Class<?>... parameterTypes) {

			List<PluginParameterBinding> result = new ArrayList<PluginParameterBinding>();

			if (mustBeTotal && (parameterTypes.length < plugin.getParameterTypes(methodIndex).size())) {
				// Quick check. the result is empty if it should be total, but their
				// are less provided parameters than required.
				return result;
			}
			if (!mustBeTotal && (parameterTypes.length > 0) && (plugin.getParameterTypes(methodIndex).size() <= 1)) {
				// Quick check. A partial mapping to one type is not possible, when
				// having
				// to assign all parameters
				return result;
			}
			if (orderedParameters && (parameterTypes.length != plugin.getParameterTypes(methodIndex).size())) {
				// can't do this, parameters.size should match required params

				return result;
			}

			// We are dealing with multiple parameters, and we are sure that
			// there are more parameters than types if the mapping needs to be
			// total.
			if ((parameterTypes.length == plugin.getParameterTypes(methodIndex).size())
					&& ((parameterTypes.length == 1) || orderedParameters)) {
				// if ordered, or only 1 to match
				int[] list = new int[parameterTypes.length];
				for (int i = 0; i < parameterTypes.length; i++) {
					// This single parameter matches the required type
					Class<?> parType = plugin.getParameterTypes(methodIndex).get(i);
					//				if (parType.isAssignableFrom(parameters.get(i))
					//						|| (parType.isArray() && parType.getComponentType().isAssignableFrom(parameters.get(i)))) {
					if (manager.isParameterAssignable(parameterTypes[i], parType)) {
						list[i] = i;
					} else {
						return result;
					}

				}
				PluginParameterBinding binding = new PluginParameterBinding(plugin, methodIndex, true, list);
				result.add(binding);

				return result;
			}

			boolean[] fullyUsed = new boolean[plugin.getParameterNames(methodIndex).size()];
			boolean[] used = new boolean[plugin.getParameterNames(methodIndex).size()];
			Arrays.fill(fullyUsed, false);
			Arrays.fill(used, false);

			int[] list = new int[parameterTypes.length];
			for (int i = 0; i < parameterTypes.length; i++) {
				Class<?> par = parameterTypes[i];
				boolean done = false;
				int matchingIndex = -1;
				Class<?> parType = null;
				// First try to match to an unused input parameter
				for (int j = 0; (j < plugin.getParameterNames(methodIndex).size()) && !done; j++) {
					if (used[j]) {
						continue;
					}
					parType = plugin.getParameterTypes(methodIndex).get(j);
					boolean match = manager.isParameterAssignable(par, parType);
					if (match) {
						matchingIndex = j;
						done = true;
					}
				}
				// Then, to a used, but not fully used parameter
				for (int j = 0; (j < plugin.getParameterNames(methodIndex).size()) && !done; j++) {
					if (fullyUsed[j]) {
						continue;
					}
					parType = plugin.getParameterTypes(methodIndex).get(j);
					boolean match = manager.isParameterAssignable(par, parType);
					if (match) {
						matchingIndex = j;
						done = true;
					}
				}

				if (done) {
					assert ((matchingIndex >= 0) && (parType != null));
					list[i] = matchingIndex;
					used[matchingIndex] = true;
					fullyUsed[matchingIndex] = !parType.isArray();
				} else {
					// Could not assign this parameter
					return result;
				}
				// }
			}
			boolean complete = true;
			for (int i = 0; (i < used.length) && complete; i++) {
				complete &= used[i];
			}

			if (mustBeTotal == complete) {
				PluginParameterBinding binding = new PluginParameterBinding(plugin, methodIndex, complete, list);
				result.add(binding);
			}

			return result;
		}

	}

	private final PluginDescriptor plugin;
	private final int methodIndex;
	private final boolean isComplete;

	// Binding represents the index of the parameter to which
	// an object should be bound
	private final int[] binding;

	/**
	 * Constructs a binding on the given plugin, method and binding.
	 * 
	 * @param plugin
	 * @param methodIndex
	 * @param isComplete
	 * @param binding
	 */
	private PluginParameterBinding(PluginDescriptor plugin, int methodIndex, boolean isComplete, int[] binding) {
		this.plugin = plugin;
		this.methodIndex = methodIndex;
		this.isComplete = isComplete;
		this.binding = binding;

	}

	/**
	 * Invokes the method of the plugin referenced by this binding on the given
	 * parameterObjects. It should be noted that the number of given parameter
	 * object should be the same as the number of parameter types provided to
	 * the <code>tryToBind()</code> method of the factory. Furthermore, the
	 * types of these parameters should be right, i.e. each object should be of
	 * the right type, or should be a <code>ProMFuture</code> on that type.
	 * 
	 * In this method, the given parameters are first re-ordered according to
	 * the given binding and then
	 * <code>getPlugin().invoke(getMethodIndex(), context, ...)</code> is
	 * called, on the newly ordered parameters.
	 * 
	 * No checks are done if this plugin is executable or not on the given
	 * input, it's up to the plugin to handle this
	 * 
	 * @param context
	 *            Note that the plugin should be executable in this context.
	 *            However, since PluginContext's should be kept uniformly typed
	 *            within one instance of ProM, no checks are done here.
	 * @param parameterObjects
	 * @return
	 */
	public PluginExecutionResult invoke(PluginContext context, Object... parameterObjects) {
		Object[] args = prepareArguments(parameterObjects);
		return plugin.invoke(methodIndex, context, args);
	}

	/**
	 * Sorts the parameters according the ordering specified in the binding
	 * array. Produces arrays if multiple objects are bound to the same
	 * parameter.
	 * 
	 * @param parameterObjects
	 * @return
	 */
	private Object[] prepareArguments(Object... parameterObjects) {
		Object[] args = new Object[plugin.getParameterNames(methodIndex).size()];
		Arrays.fill(args, null);
		for (int i = 0; i < parameterObjects.length; i++) {
			int index = binding[i];
			if (index < 0) {
				continue;
			}
			if (!plugin.getParameterTypes(methodIndex).get(index).isArray()) {
				// Single parameter
				args[index] = parameterObjects[i];
				continue;
			}
			// Array Parameter (there might be more added to this array).
			Object[] arg;
			if (args[index] == null) {
				arg = new Object[0];
			} else {
				arg = (Object[]) args[index];
			}
			Object[] newArg = ArrayUtils.copyOf(arg, arg.length + 1);
			newArg[arg.length] = parameterObjects[i];
			args[index] = newArg;
		}
		return args;
	}

	/**
	 * Returns the Plugin which is bound by this binding.
	 * 
	 * @return
	 */
	public PluginDescriptor getPlugin() {
		return plugin;
	}

	/**
	 * This method returns an array of integers, of which the length corresponds
	 * to the length of the list of parameters types provided to the
	 * PluginParameterBinding factory. For each parameter type, this array
	 * indicates to which parameter of the plugin it is bound.
	 * 
	 * For each element <code>x</code> of this array is holds that
	 * <code>0 <= x < getPlugin().getParameterNames(getMethodIndex())</code>
	 * 
	 * If the same parameter index is provided for different parameters (i.e.
	 * <code>getBinding()[x] == getBinding()[y]</code> with <code>x != y</code>,
	 * then this impliest that the parameter is an array type, to which multiple
	 * objects can be connected. In other words, this implies that
	 * 
	 * <code>getPlugin().getParameterType(getMethodIndex(),getBinding()[x]).isArray() == true</code>
	 * 
	 * @return
	 */
	public int[] getBinding() {
		return binding;
	}

	/**
	 * Equality of bindings is based on the binding, plugin and complete status.
	 */
	public boolean equals(Object o) {
		if (!(o instanceof PluginParameterBinding)) {
			return false;
		}
		PluginParameterBinding b = (PluginParameterBinding) o;
		return (isComplete == b.isComplete) && plugin.equals(b.plugin) && (methodIndex == b.methodIndex)
				&& Arrays.equals(b.binding, binding);
	}

	/**
	 * Returns a hashcode based on the binding, plugin and complete status
	 */
	public int hashCode() {
		int hash = 7;
		hash = 31 * hash + Arrays.hashCode(binding);
		hash = 31 * hash + plugin.hashCode();
		hash = 31 * hash + methodIndex;
		return 31 * hash + (isComplete ? 13 : 17);

	}

	/**
	 * Returns the method index of the method which is bound by this binding.
	 * 
	 * When this binding is invoked, this method inside the plugin provided by
	 * getPlugin() is invoked.
	 * 
	 * @return
	 */
	public int getMethodIndex() {
		return methodIndex;
	}

	public int compareTo(PluginParameterBinding other) {
		if (other == this) {
			return 0;
		}
		int c = plugin.compareTo(other.plugin);
		if (c == 0) {
			c = methodIndex - other.methodIndex;
		}
		if (c == 0) {
			return Arrays.toString(binding).compareTo(Arrays.toString(other.binding));
		}
		return c;
	}

}"
Progress.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

/**
 * Interface for progress indicator
 * 
 * @author bfvdonge
 * 
 */
public interface Progress {

	void setMinimum(int value);

	void setMaximum(int value);

	void setValue(int value);

	void setCaption(String message);

	String getCaption();

	int getValue();

	void inc();

	void setIndeterminate(boolean makeIndeterminate);

	boolean isIndeterminate();

	int getMinimum();

	int getMaximum();

	boolean isCancelled();

	void cancel();
}
"
ProMCanceller.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

/**
 * Interface that can be used by visualizations to receive a notification from
 * the framework when they are removed. {@link #isCancelled()} will return true
 * in this case.
 * 
 * @author F. Mannhardt, S.J.J Leemans
 *
 */
public interface ProMCanceller {

	/**
	 * {@link ProMCanceller} that never returns true for {@link #isCancelled()}
	 */
	public final static ProMCanceller NEVER_CANCEL = new ProMCanceller() {

		public boolean isCancelled() {
			return false;
		}
	};

	boolean isCancelled();

}
"
ProMFuture.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import javax.swing.SwingWorker;

import org.processmining.framework.plugin.events.FutureListener;
import org.processmining.framework.plugin.events.NameChangeListener;

/**
 * Class to represent a future on an object.
 * 
 * @author bfvdonge
 * 
 * @param <T>
 */
public abstract class ProMFuture<T> implements Future<T> {

	private final Class<?> classType;
	private final SwingWorker<T, Void> worker;
	private String label;
	private final NameChangeListener.ListenerList nameChangeListeners = new NameChangeListener.ListenerList();
	private final FutureListener.ListenerList futureListeners = new FutureListener.ListenerList();

	/**
	 * Instantiates a ProMFuture object of the given type and with the given
	 * label.
	 * 
	 * A SwingWorker is instantiated by the constructor. This SwingWorker is
	 * provided through the <code>getRunnable()</code> method and once executed,
	 * it will execute the <code>doInBackground()</code> method of this
	 * ProMFuture.
	 * 
	 * When finished, the <code>done()</code> method is invoked, after which any
	 * Future listeners are notified that this future is ready.
	 * 
	 * @param resultClass
	 *            Any type that extends T. However, no subtype of ProMFuture can
	 *            be provided.
	 * @param label
	 */
	public ProMFuture(Class<? extends T> resultClass, String label) {
		if (ProMFuture.class.isAssignableFrom(resultClass)) {
			// Cannot put a future inside a future.
			throw new RuntimeException(""Cannot put a future in a future"");
		}
		this.classType = resultClass;
		this.label = label;
		this.worker = new SwingWorker<T, Void>() {
			@Override
			protected T doInBackground() throws Exception {
				return ProMFuture.this.doInBackground();
			}

			@Override
			protected void done() {
				// invoke the setLabel() on getLabel() after finishing execution.
				// this is necessary to fire name-changed events to any 
				// listeners registered after the last call to setLabel();
				ProMFuture.this.setLabel(ProMFuture.this.getLabel());

				ProMFuture.this.done();
				ProMFuture.this.getFutureListeners().fireFutureReady(ProMFuture.this);
			}
		};
	}

	/**
	 * This method is called by the runnable of this future as soon as the
	 * computation of the result is ready, but before any listeners are notified
	 * of the completion.
	 * 
	 * Any overriding implementation can use the get() method to return the
	 * object computed, as this method is guaranteed not to throw exceptions
	 * when done() is reached.
	 */
	protected void done() {
		// Default empty implementation
	}

	/**
	 * Returns the Runnable representing the execution that needs to be
	 * performed to produce the result of this future.
	 * 
	 * @return
	 */
	public Runnable getRunnable() {
		return worker;
	}

	/**
	 * The return type of this future.
	 * 
	 * @return
	 */
	public Class<?> getReturnType() {
		return classType;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#get()
	 */
	public boolean cancel(boolean mayInterruptIfRunning) {
		return worker.cancel(mayInterruptIfRunning);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#get()
	 */
	public T get() throws InterruptedException, ExecutionException, CancellationException {
		return worker.get();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)
	 */
	public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException,
			CancellationException {
		return worker.get(timeout, unit);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#isCancelled()
	 */
	public boolean isCancelled() {
		return worker.isCancelled();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.util.concurrent.Future#isDone()
	 */
	public boolean isDone() {
		return worker.isDone();
	}

	/**
	 * This method should be implemented by all subclasses of ProMFuture. Here,
	 * the object of type T is computed and returned.
	 * 
	 * @return
	 * @throws Exception
	 *             This exception should be any exception thrown by the logic of
	 *             the underlying method. Note that ""wrapper""-Exceptions such as
	 *             InvocationTargetException and ExecutionException should be
	 *             unwrapped.
	 */
	protected abstract T doInBackground() throws Exception;

	/**
	 * Return a string representation of this future.
	 */
	public String toString() {
		if (isCancelled()) {
			return (""Cancelled calculation of "" + getLabel());
		}
		return (isDone() ? ""Processing: "" : """") + getLabel();
	}

	/**
	 * returns the label of this future
	 * 
	 * @return
	 */
	public String getLabel() {
		return label;
	}

	/**
	 * Sets the label of this future to the given label and fires name change
	 * events in any registered name change listeners.
	 * 
	 * @param label
	 */
	public void setLabel(String label) {
		this.label = label;
		nameChangeListeners.fireNameChanged(label);
	}

	/**
	 * Returns a ListenerList containing the registered name change listeners
	 * 
	 * @return
	 */
	public NameChangeListener.ListenerList getNameChangeListeners() {
		return nameChangeListeners;
	}

	/**
	 * Returns a ListenerList containing the registered future listeners
	 * 
	 * @return
	 */
	public FutureListener.ListenerList getFutureListeners() {
		return futureListeners;
	}

}
"
RecursiveCallException.java,prom-framework-6.9.97,"package org.processmining.framework.plugin;

public class RecursiveCallException extends Exception {

	private static final long serialVersionUID = -1731740485590676086L;

	public RecursiveCallException(PluginContext context, PluginDescriptor plugin, int methodIndex) {
		super(""A recursive call to method "" + methodIndex + "" of plugin "" + plugin.getName()
				+ "" was discrovered when creating context "" + context.getID() + ""."");
	}
}
"
ProMID.java,prom-framework-6.9.97,"package org.processmining.framework;

import java.util.UUID;

public interface ProMID extends Comparable<ProMID> {

	/**
	 * ProMID are used in Collections, so this method has to be implemented in
	 * all its subclasses.
	 * 
	 * @return
	 */
	public boolean equals(Object o);

	/**
	 * ProMID are used in HashMaps, so this method has to be implemented in all
	 * its subclasses.
	 * 
	 * @return
	 */
	public int hashCode();

	/**
	 * Determines equality between this ProMID and any given object. Basically
	 * checks for equality using the toString() methods of both objects.
	 * 
	 * @param o
	 *            the object to compare the string representation with
	 * @return true if the toString() of this provided object ID equals the
	 *         toString() of the given object parameter.
	 */
	public boolean equalsIgnoreType(Object o);

	/**
	 * Returns a UUID that is used for this object.
	 * 
	 * @return
	 */
	public UUID getUUID();

}
"
ContextAwareObject.java,prom-framework-6.9.97,"package org.processmining.framework.providedobjects;

import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.plugin.PluginManager;

/**
 * If an object implements this interface, then this object should use transient
 * fields to store pointers to the three managers.
 * 
 * Upon deserialization of the object by the ProM framework, the three methods
 * in this interface are called before the object is used and added to the
 * framework as a provided object.
 * 
 * Using this interface, objects can instantiate themselves as listeners on the
 * relevant parts of the framework that would otherwise only be available upon
 * instantiation from a PluginContext.
 * 
 * @author bfvdonge
 * 
 */
public interface ContextAwareObject {

	public void setManagers(ConnectionManager connectionManager, PluginManager pluginManager,
			ProvidedObjectManager providedObjectManager);
}
"
ProvidedObjectIDImpl.java,prom-framework-6.9.97,"package org.processmining.framework.providedobjects.impl;

import java.util.UUID;

import org.processmining.framework.ProMID;
import org.processmining.framework.providedobjects.ProvidedObjectID;

public class ProvidedObjectIDImpl implements ProvidedObjectID {

	private final UUID id = UUID.randomUUID();

	public String toString() {
		return id.toString();
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof ProvidedObjectIDImpl)) {
			return false;
		} else {
			return ((ProvidedObjectIDImpl) o).id.equals(id);
		}
	}

	public boolean equalsIgnoreType(Object o) {
		return toString().equals(o.toString());
	}

	public int compareTo(ProMID o) {
		return o.getUUID().compareTo(id);
	}

	public UUID getUUID() {
		return id;
	}
}
"
ProvidedObjectImpl.java,prom-framework-6.9.97,"package org.processmining.framework.providedobjects.impl;

import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.events.FutureListener;
import org.processmining.framework.plugin.events.NameChangeListener;
import org.processmining.framework.providedobjects.ProvidedObject;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;
import org.processmining.framework.providedobjects.ProvidedObjectManager;

public class ProvidedObjectImpl implements ProvidedObject, NameChangeListener, FutureListener {

	private final ProvidedObjectID id;
	private Object object;
	private boolean deleted = false;
	private final ProvidedObjectManager manager;
	private String label;
	private final Class<?> type;

	public <T> ProvidedObjectImpl(String label, ProvidedObjectID id, T object, Class<? super T> type,
			ProvidedObjectManager manager) throws NullPointerException {
		this.manager = manager;
		this.id = id;
		this.type = type;
		if (object == null) {
			throw new NullPointerException(""Null cannot be provided as an object"");
		}
		try {
			setObject(object, false);
		} catch (ProvidedObjectDeletedException e) {
			assert (false);
		}
		this.label = label;
	}

	public void deleteObject() {
		deleted = true;
		// unregister as a name-change listener on the old object
		unregisterFromFuture();
		object = null;
		// Notify all listeners to the deleted object
		manager.getProvidedObjectLifeCylceListeners().fireProvidedObjectDeleted(getID());
	}

	private void unregisterFromFuture() {
		if (object instanceof ProMFuture<?>) {
			((ProMFuture<?>) object).getNameChangeListeners().remove(this);
			((ProMFuture<?>) object).getFutureListeners().remove(this);
		}
	}

	public ProvidedObjectID getID() {
		return id;
	}

	public Object getObject() throws ProvidedObjectDeletedException {
		return getObject(true);
	}

	public Object getObject(boolean waitIfFuture) throws ProvidedObjectDeletedException {
		if (deleted) {
			throw new ProvidedObjectDeletedException(""Object "" + getLabel() + "" has been deleted."");
		}
		if (waitIfFuture && (object instanceof ProMFuture<?>)) {
			try {
				return ((ProMFuture<?>) object).get();
			} catch (Exception e) {
				// This is a listener on object and will receive a message
				// from ProMFuture resulting in a delete.
				setObject(null);
			}
		}
		return object;
	}

	public void setObject(Object newObject) throws ProvidedObjectDeletedException {
		setObject(newObject, true);
	}

	private void setObject(Object newObject, boolean signalChange) throws ProvidedObjectDeletedException {
		if (deleted) {
			throw new ProvidedObjectDeletedException(""Object "" + getLabel() + "" has been deleted."");
		}
		// unregister as a name-change listener on the old object
		unregisterFromFuture();
		if (newObject == null) {
			deleteObject();
			return;
		}
		object = newObject;
		synchronized (object) {
			if (object instanceof ProMFuture<?>) {
				// register as a name-change listener on the new object
				((ProMFuture<?>) object).getNameChangeListeners().add(this);
				// To make sure that no name changed are missed:
				label = (((ProMFuture<?>) object).getLabel());
				((ProMFuture<?>) object).getFutureListeners().add(this);
			}
		}
		if (signalChange) {
			// Notify the listeners of the manager
			manager.getProvidedObjectLifeCylceListeners().fireProvidedObjectObjectChanged(id);
		}
	}

	public String toString() {

		return getLabel() + "": "" + (deleted ? "" DELETED"" : object.toString());
	}

	public String getLabel() {
		return label;
	}

	public int hashCode() {
		return id.hashCode();
	}

	public boolean equals(Object o) {
		if (o instanceof ProvidedObject) {
			return id.equals(((ProvidedObject) o).getID());
		} else {
			return false;
		}
	}

	public synchronized void nameChanged(String newName) {
		label = newName;
		manager.getProvidedObjectLifeCylceListeners().fireProvidedObjectNameChanged(getID());
	}

	public void setLabel(String label) throws ProvidedObjectDeletedException {
		if (isDeleted()) {
			throw new ProvidedObjectDeletedException(""Provided Object with ID "" + getID() + "" was deleted before."");
		}
		nameChanged(label);
	}

	public synchronized void pluginCancelled(PluginContext context) {
		// if the plugin was cancelled, then delete this
		// providedObject
		try {
			setObject(null);
		} catch (ProvidedObjectDeletedException e) {
			// Don't care
		}
	}

	public boolean isDeleted() {
		return deleted;
	}

	public Class<? extends Object> getType() throws ProvidedObjectDeletedException {
		if (isDeleted()) {
			throw new ProvidedObjectDeletedException(""Provided Object with ID "" + getID() + "" was deleted before."");
		}
		return type;
	}

	public synchronized void futureReady(ProMFuture<? extends Object> future) {
		try {
			try {
				if (!deleted) {
					Object tmpObject = ((ProMFuture<?>) object).get();
					setObject(tmpObject, false);
					if (tmpObject != null) {
						// if tmpObject == null, then this is deleted by
						// the setObject method;
						manager.getProvidedObjectLifeCylceListeners().fireProvidedObjectFutureReady(getID());
					}
				}
			} catch (CancellationException e) {
				setObject(null);
			} catch (InterruptedException e) {
				setObject(null);
			} catch (ExecutionException e) {
				setObject(null);
			}
		} catch (ProvidedObjectDeletedException e) {
			// Ignore;

		}
	}
}
"
ProvidedObjectManagerImpl.java,prom-framework-6.9.97,"package org.processmining.framework.providedobjects.impl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.PluginExecutionResult;
import org.processmining.framework.plugin.ProMFuture;
import org.processmining.framework.plugin.events.ProvidedObjectLifeCycleListener;
import org.processmining.framework.providedobjects.ProvidedObject;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;
import org.processmining.framework.providedobjects.ProvidedObjectManager;
import org.processmining.framework.providedobjects.SubstitutionType;

public class ProvidedObjectManagerImpl implements ProvidedObjectManager {

	private final ProvidedObjectLifeCycleListener.ListenerList providedObjectLifeCycleListeners = new ProvidedObjectLifeCycleListener.ListenerList();
	private final HashMap<ProvidedObjectID, ProvidedObjectImpl> localProvidedObjects;
	private final List<ProvidedObjectID> ids;

	private boolean enabled = true;

	public ProvidedObjectManagerImpl() {
		localProvidedObjects = new HashMap<ProvidedObjectID, ProvidedObjectImpl>();
		ids = new ArrayList<ProvidedObjectID>();
	}

	public ProvidedObjectLifeCycleListener.ListenerList getProvidedObjectLifeCylceListeners() {
		return providedObjectLifeCycleListeners;
	}

	@SuppressWarnings(""unchecked"")
	public <T> ProvidedObjectID createProvidedObject(String label, T object, PluginContext context) {
		Class<?> realType;
		if (object instanceof ProMFuture<?>) {
			realType = ((ProMFuture<?>) object).getReturnType();
		} else {
			realType = object.getClass();
		}
		if (realType.isAnnotationPresent(SubstitutionType.class)) {
			Class<?> declaredType = realType.getAnnotation(SubstitutionType.class).substitutedType();
			if (declaredType.isAssignableFrom(realType)) {
				realType = declaredType;
			}
		}
		return createProvidedObject(label, object, (Class<? super T>) realType, context);
	}

	public <T> ProvidedObjectID createProvidedObject(String label, T object, Class<? super T> type,
			PluginContext context) {

		// construct a new ProvidedObject
		ProvidedObjectImpl po = new ProvidedObjectImpl(label, new ProvidedObjectIDImpl(), object, type, this);

		if (enabled) {
			// add it to the list of maintained PO's
			localProvidedObjects.put(po.getID(), po);
			ids.add(po.getID());
			providedObjectLifeCycleListeners.fireProvidedObjectCreated(po.getID(), context);
			if (!(object instanceof ProMFuture<?>)) {
				providedObjectLifeCycleListeners.fireProvidedObjectFutureReady(po.getID());
			} else {
				try {
					po.setLabel(((ProMFuture<?>) object).toString());
				} catch (ProvidedObjectDeletedException e) {
					assert (false);
				}
			}
		}
		return po.getID();

	}

	public List<ProvidedObjectID> createProvidedObjects(PluginContext context) {
		List<ProvidedObjectID> newIds = new ArrayList<ProvidedObjectID>();
		PluginExecutionResult result = context.getResult();
		for (int i = 0; i < result.getSize(); i++) {
			ProvidedObjectID id = createProvidedObject(result.getResultName(i), result.getResult(i), result.getType(i),
					context);
			newIds.add(id);
			//			ids.add(id);
			result.setProvidedObjectID(i, id);
		}
		return newIds;
	}

	private ProvidedObjectImpl getProvidedObject(ProvidedObjectID id) throws ProvidedObjectDeletedException {
		ProvidedObjectImpl po = localProvidedObjects.get(id);
		if (po == null) {
			throw new ProvidedObjectDeletedException(""ProvidedObject with ID "" + id + "" is not known to the manager."");
		}
		return po;
	}

	public Object getProvidedObjectObject(ProvidedObjectID id, boolean waitIfFuture)
			throws ProvidedObjectDeletedException {
		ProvidedObject po = getProvidedObject(id);
		return po.getObject(waitIfFuture);
	}

	public String getProvidedObjectLabel(ProvidedObjectID id) throws ProvidedObjectDeletedException {
		ProvidedObject po = getProvidedObject(id);
		return po.getLabel();
	}

	public Class<? extends Object> getProvidedObjectType(ProvidedObjectID id) throws ProvidedObjectDeletedException {
		ProvidedObject po = getProvidedObject(id);
		return po.getType();
	}

	public void changeProvidedObjectObject(ProvidedObjectID id, Object newObject) throws ProvidedObjectDeletedException {
		ProvidedObject po = getProvidedObject(id);
		po.setObject(newObject);
	}

	public void deleteProvidedObject(ProvidedObjectID id) throws ProvidedObjectDeletedException {
		ProvidedObjectImpl po = getProvidedObject(id);
		localProvidedObjects.remove(id);
		ids.remove(id);
		po.deleteObject();
	}

	public List<ProvidedObjectID> getProvidedObjects() {
		return Collections.unmodifiableList(ids);
	}

	public void relabelProvidedObject(ProvidedObjectID id, String label) throws ProvidedObjectDeletedException {
		getProvidedObject(id).setLabel(label);
	}

	public void providedObjectNameChanged(ProvidedObjectID objectID) {
		// Ignore
	}

	public void providedObjectObjectChanged(ProvidedObjectID objectID) {
		// Ignore
	}

	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}

	public boolean isEnabled() {
		return enabled;
	}
	
	public void clear() {
		localProvidedObjects.clear();
		ids.clear();
		providedObjectLifeCycleListeners.removeAll();
	}
	
	
}
"
ProvidedObject.java,prom-framework-6.9.97,"package org.processmining.framework.providedobjects;

public interface ProvidedObject {

	/**
	 * Returns the ID of this Provided Object
	 * 
	 * @return
	 */
	ProvidedObjectID getID();

	/**
	 * Returns the label of this provided object
	 * 
	 * @return
	 */
	String getLabel();

	/**
	 * Sets the label of this provided object to the new label.
	 * 
	 * @param label
	 *            the new label of the object
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	void setLabel(String label) throws ProvidedObjectDeletedException;

	/**
	 * Returns the object stored in this provided object. If the object is not
	 * an instance of ProMFuture, then the object itself is returned. Otherwise,
	 * it depends on the parameter whether the ProMFuture is returned, or the
	 * calling thread is blocked until the future finished (or is cancelled)
	 * 
	 * @param waitIfFuture
	 *            if set to false, the returned object might be an instance of
	 *            ProMFuture. Otherwise not.
	 * @return
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	Object getObject(boolean waitIfFuture) throws ProvidedObjectDeletedException;

	/**
	 * Same as calling getObject(true);
	 * 
	 * @return
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	Object getObject() throws ProvidedObjectDeletedException;

	/**
	 * Changes the content of this provided object by replacing the original
	 * object with the new object. This can only be done if the current object
	 * has not been deleted yet.
	 * 
	 * @param object
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	void setObject(Object object) throws ProvidedObjectDeletedException;

	/**
	 * Returns whether or not this object has been deleted. Note that if this
	 * method returns false, no ProvidedObjectDeletedExceptions are thrown in
	 * subsequent, synchronized calls to this provided object.
	 * 
	 * @return
	 */
	boolean isDeleted();

	/**
	 * Signals the provided object to delete itself. After calling this method,
	 * isDeleted() will return true and where applicable,
	 * ProvidedObjectDeletedExceptions will be thrown.
	 */
	void deleteObject();

	/**
	 * Returns the type of the object contained in this Provided Object. If the
	 * internal object is a ProMFuture, then the result type of the future is
	 * returned, i.e. ProMFuture.class is never returned by this method.
	 * 
	 * @return
	 * @throws ProvidedObjectDeletedException
	 *             If the object was removed from memory because there were no
	 *             useful references to it anymore
	 */
	Class<?> getType() throws ProvidedObjectDeletedException;

}
"
ProvidedObjectDeletedException.java,prom-framework-6.9.97,"package org.processmining.framework.providedobjects;

public class ProvidedObjectDeletedException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = -4591364700388792910L;

	public ProvidedObjectDeletedException(String name) {
		super(name);
	}

}
"
ProvidedObjectID.java,prom-framework-6.9.97,"package org.processmining.framework.providedobjects;

import org.processmining.framework.ProMID;

public interface ProvidedObjectID extends ProMID {

}
"
ProvidedObjectManager.java,prom-framework-6.9.97,"package org.processmining.framework.providedobjects;

import java.util.List;

import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.events.ProvidedObjectLifeCycleListener;

public interface ProvidedObjectManager {

	ProvidedObjectLifeCycleListener.ListenerList getProvidedObjectLifeCylceListeners();

	/**
	 * This method creates a new providedObjectID. The context passed to this
	 * method should refer to the PluginContext of which the ProMFuture object
	 * is the result, i.e. this.getProvidedObjectObject(createProvidedObject(
	 * String name, PluginContext context)) = context.getFutureResult(); The
	 * object will be wrapped in a ProMFuture, and a new childContext is created
	 * for this ProMFuture
	 * 
	 * @param name
	 *            The label of the providedObject identified by the returned
	 *            ProvidedObjectID (can be retrieved with
	 *            getProvidedObjectLabel()
	 * @param object
	 *            the object to be wrapped in a new ProMFuture.
	 * @param type
	 *            the type of the object,
	 * @return a globally new id, identifying the providedObject
	 */
	<T> ProvidedObjectID createProvidedObject(String name, T object, Class<? super T> type, PluginContext context);

	/**
	 * This method creates a new providedObjectID. The context passed to this
	 * method should refer to the PluginContext of which the ProMFuture object
	 * is the result, i.e. this.getProvidedObjectObject(createProvidedObject(
	 * String name, PluginContext context)) = context.getFutureResult(); The
	 * object will be wrapped in a ProMFuture, and a new childContext is created
	 * for this ProMFuture
	 * 
	 * Note that no type is provided with this method. Instead, the framework
	 * will use the type of the given object, or if an @SubstitutionType
	 * annotation was used on the object's class definition, the substitution
	 * type is used.
	 * 
	 * @param name
	 *            The label of the providedObject identified by the returned
	 *            ProvidedObjectID (can be retrieved with
	 *            getProvidedObjectLabel()
	 * @param object
	 *            the object to be wrapped in a new ProMFuture.
	 * 
	 * @return a globally new id, identifying the providedObject
	 */
	<T> ProvidedObjectID createProvidedObject(String name, T object, PluginContext context);

	/**
	 * This method creates a list of new providedObjectIDs for each object in
	 * the PluginExecutionResult of the context.
	 * 
	 * @param context
	 *            The context of which this providedObject will be the result
	 * @return a list of globally new ids, identifying the providedObjects
	 */
	List<ProvidedObjectID> createProvidedObjects(PluginContext context);

	/**
	 * returns the provided object identified by this ID. Do not use this method
	 * if not necessary, as the providedObject might not exist in memory
	 * locally.
	 * 
	 * @param id
	 * @param waitIfFuture
	 *            TODO
	 * @return
	 * @throws ProvidedObjectDeletedException
	 */
	Object getProvidedObjectObject(ProvidedObjectID id, boolean waitIfFuture) throws ProvidedObjectDeletedException;

	String getProvidedObjectLabel(ProvidedObjectID id) throws ProvidedObjectDeletedException;

	Class<?> getProvidedObjectType(ProvidedObjectID id) throws ProvidedObjectDeletedException;

	void changeProvidedObjectObject(ProvidedObjectID id, Object newObject) throws ProvidedObjectDeletedException;

	void deleteProvidedObject(ProvidedObjectID id) throws ProvidedObjectDeletedException;

	/**
	 * Returns all provided Object IDs known to the framework. The list is
	 * ordered in order of Arrival, i.e. the first objectID added to the
	 * framework is returned first.
	 * 
	 * @return
	 */
	List<ProvidedObjectID> getProvidedObjects();

	void relabelProvidedObject(ProvidedObjectID id, String label) throws ProvidedObjectDeletedException;

	void setEnabled(boolean enabled);

	boolean isEnabled();

	void clear();
	
}
"
SubstitutionType.java,prom-framework-6.9.97,"package org.processmining.framework.providedobjects;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface SubstitutionType {
	Class<?> substitutedType();
}
"
ArrayUtils.java,prom-framework-6.9.97,"package org.processmining.framework.util;

import java.lang.reflect.Array;

public class ArrayUtils {

	/**
	 * No need for instantiation. Only static methods
	 * 
	 */
	private ArrayUtils() {

	}

	/**
	 * Makes a copy of an array. If newLength is greater than the length of
	 * source, then the result is an array with the contents of source, appended
	 * with null elements. If the new array is shorter, then only a part is
	 * copied.
	 * 
	 * @param <T>
	 *            type of the array
	 * @param source
	 *            source array
	 * @param newlength
	 *            new length of the target array
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
	public static <T> T[] copyOf(T[] source, int newlength) {
		Class<?> type = source.getClass().getComponentType();
		T[] target = (T[]) Array.newInstance(type, newlength);
		System.arraycopy(source, 0, target, 0, Math.min(newlength, source.length));
		for (int i = source.length; i < target.length; i++) {
			target[i] = null;
		}
		return target;

	}

	/**
	 * Concatenates arrays
	 * 
	 * @param <T>
	 *            type of the array
	 * @param first
	 *            first array
	 * @param rest
	 *            arrays to be added
	 * @return
	 */
	public static <T> T[] concatAll(T[] first, T[]... rest) {

		int totalLength = first.length;
		for (T[] array : rest) {
			totalLength += array.length;
		}
		T[] result = copyOf(first, totalLength);
		int offset = first.length;
		for (T[] array : rest) {
			System.arraycopy(array, 0, result, offset, array.length);
			offset += array.length;
		}
		return result;
	}

}
"
AutoHelpCommandLineParser.java,prom-framework-6.9.97,"package org.processmining.framework.util;

import jargs.gnu.CmdLineParser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

public class AutoHelpCommandLineParser extends CmdLineParser {
	private final List<Pair<Option, String>> optionHelpStrings = new ArrayList<Pair<Option, String>>();
	private final String programName;
	private final Command[] commands;

	public static abstract class Command {
		private final String name;
		private final String help;

		public Command(String name, String help) {
			this.name = name;
			this.help = help;
		}

		public abstract int run(List<String> args) throws Exception;

		public String getName() {
			return name;
		}

		public String getHelp() {
			return help;
		}
	}

	public AutoHelpCommandLineParser(String programName) {
		this(programName, null);
	}

	public AutoHelpCommandLineParser(String programName, Command[] commands) {
		this.programName = programName;
		this.commands = commands;
	}

	public Option addHelp(Option option, String helpString) {
		optionHelpStrings.add(new Pair<Option, String>(option, helpString));
		return option;
	}

	public void printUsage() {
		if (commands != null) {
			System.err.println(""Usage: "" + programName + "" [options] COMMAND [command arguments]"");
		} else {
			System.err.println(""Usage: "" + programName + "" [options]"");
		}

		int width = 0;
		for (Pair<Option, String> option : optionHelpStrings) {
			width = Math.max(width, getOptionString(option).length());
		}
		width = Math.min(25, width);

		for (Pair<Option, String> option : optionHelpStrings) {
			System.err.println(String.format(""  %-"" + width + ""s  %s"", getOptionString(option), option.getSecond()));
		}

		if (commands != null) {
			width = 0;

			for (Command c : commands) {
				width = Math.max(width, c.getName().length());
			}
			width = Math.min(25, width);

			System.err.println(""The following commands are available:"");
			for (Command c : commands) {
				System.err.println(String.format(""  %-"" + width + ""s  %s"", c.getName(), c.getHelp()));
			}
		}
	}

	private String getOptionString(Pair<Option, String> option) {
		return ""-"" + option.getFirst().shortForm() + "" / --"" + option.getFirst().longForm();
	}

	public int runCommand() throws Exception {
		LinkedList<String> arguments = new LinkedList<String>(Arrays.asList(getRemainingArgs()));
		String commandName = arguments.removeFirst();

		for (Command c : commands) {
			if (c.getName().equals(commandName)) {
				return c.run(arguments);
			}
		}
		return -1;
	}
}
"
Cast.java,prom-framework-6.9.97,"package org.processmining.framework.util;

public class Cast {

	private Cast() {

	}

	/**
	 * Casts the given object to type T. This static method can be used to avoid
	 * ""unchecked cast"" warnings. Note that a runtime exception is still thrown
	 * if the cast is not valid. However, using this method eliminates the use
	 * of the @@SupressWarnings annotation, which obfuscates any valid warnings.
	 * Note that this method should be used in combination with assertions to
	 * assert the right type!
	 * 
	 * @param <T>
	 *            The type to cast to.
	 * @param x
	 *            the object to cast
	 * @return (T) x;
	 */
	@SuppressWarnings(""unchecked"")
	public static <T> T cast(Object x) {
		return (T) x;
	}
}
"
Cleanable.java,prom-framework-6.9.97,"package org.processmining.framework.util;

public interface Cleanable {

	void cleanUp();
}
"
AbstractMultiSet.java,prom-framework-6.9.97,"package org.processmining.framework.util.collection;

import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.Set;

import org.processmining.framework.util.Cast;

/**
 * This class implements a mutliset. The implementation is synchronized.
 * 
 * @author bfvdonge
 * 
 * @param <T>
 *            the type of the objects in this multiset.
 */
public abstract class AbstractMultiSet<T, M extends Map<T, Integer>> extends AbstractCollection<T> implements
		MultiSet<T> {

	protected M map;
	protected int size;
	private int hashCode;
	private boolean hashValid = false;

	private static final long serialVersionUID = -6521454214767452945L;

	abstract <S> MultiSet<S> newMultiSet(Collection<S> collection);

	abstract MultiSet<T> newMultiSet();

	/**
	 * Keeps all elements of the given collection in this multiset. Multicities
	 * are taken into account, i.e. as many of the same objects are kept as
	 * returned by the collections iterator.
	 * 
	 * @return true if the multiset changed from calling this method.
	 */
	@Override
	public boolean retainAll(Collection<?> c) {
		hashValid = false;
		return retainAll(newMultiSet(c));
	}

	/**
	 * adds one object to the multiset. If the object was not contained before,
	 * then it now has one occerrence, otherwise, the number of occurrences is
	 * increased.
	 * 
	 * @return true, since the collection is always modified.
	 */
	@Override
	public boolean add(T par) {
		add(par, 1);
		hashValid = false;
		return true;
	}

	/**
	 * Keeps all elements of the given collection in this multiset.
	 * Multiplicities are taken into account.
	 * 
	 * @return true if the multiset changed from calling this method.
	 */
	public boolean retainAll(MultiSet<?> c) {
		boolean changed = false;
		Iterator<T> it = map.keySet().iterator();
		while (it.hasNext()) {
			T key = it.next();
			
			Integer occToRetain = c.occurrences(key);
			Integer occInThis = occurrences(key);
			if (occInThis >= occToRetain) {
				// keep occToRetain
				size -= (occInThis - occToRetain);
				if (occToRetain == 0) {
					it.remove();
				} else {
					map.put(key, occToRetain);
				}
				changed = true;
				hashValid = false;
			}
		}
		return changed;
	}

	/**
	 * Adds the given object to the multiset, as many times as indicated by the
	 * given weight parameter.
	 * 
	 * @param par
	 *            the object to add
	 * @param weight
	 *            the number of times to add it
	 * @return the new number of occurrences of the object (>0)
	 */
	public Integer add(T par, Integer weight) {
		if (weight == 0) {
			return weight;
		}
		hashValid = false;
		long newSize = (long) size + (long) weight;
		if (newSize > Integer.MAX_VALUE) {
			size = Integer.MAX_VALUE;
		} else {
			size = (int) newSize;
		}
		if (!map.containsKey(par)) {
			assert (weight > 0);
			map.put(par, weight);
			return weight;
		} else {
			long num = (long) map.get(par) + (long) weight;
			if (num > Integer.MAX_VALUE) {
				num = Integer.MAX_VALUE;
			}
			if (num == 0) {
				map.remove(par);
			} else {
				assert (num > 0);
				map.put(par, (int) num);
			}
			return (int) num;
		}
	}

	/**
	 * Adds the given collection to this multiset. If the given collection is
	 * not a multiset, then the implementation is diverted to
	 * abstractcollection.
	 * 
	 * @param collection
	 *            the collection to add
	 * @return true if the multiset changed due to this method call.
	 */
	@Override
	public boolean addAll(Collection<? extends T> collection) {
		if (collection.isEmpty()) {
			return false;
		}
		hashValid = false;
		if (collection instanceof MultiSet<?>) {
			MultiSet<? extends T> mset = Cast.<MultiSet<? extends T>>cast(collection);
			for (T key : mset.baseSet()) {
				add(key, mset.occurrences(key));
			}
		} else {
			for (T key : collection) {
				add(key);
			}
		}
		return true;
	}

	/**
	 * Converts this multiset to a list, such that each element occurs as often
	 * as returned by the iterator of the multiset (its number of occurrences).
	 * 
	 * @return a list of objects as returned by the iterator
	 */
	public List<T> toList() {
		List<T> list = new ArrayList<T>(size);
		for (T occ : this) {
			list.add(occ);
		}
		return list;
	}

	/**
	 * returns true if this multiset is less or equal to the given multiset,
	 * i.e. all objects in this multiset should be contained in the given set
	 * and the number of occurrences in the given set is at least the number of
	 * occurrences in this multiset.
	 * 
	 * @param multiSet
	 *            the multiset to test
	 * @return true if the given multiset is less or equal.
	 */
	public boolean isLessOrEqual(MultiSet<T> multiSet) {
		for (T element : baseSet()) {
			if (multiSet.occurrences(element) < occurrences(element)) {
				return false;
			}
		}
		return true;
	}

	protected boolean containsAtLeast(T element, int occ) {
		return occurrences(element) >= occ;
	}

	/**
	 * returns true if the multisets are equal, i.e. if they contain the same
	 * objects with the same number of occurrences.
	 */
	@Override
	public boolean equals(Object o) {
		if (o instanceof AbstractMultiSet<?, ?>) {
			return map.equals(((AbstractMultiSet<?, ?>) o).map);
		}
		return false;
	}

	/**
	 * returns the size of the multiset, i.e. the sum over the multiplicities of
	 * all contained objects.
	 */
	@Override
	public int size() {
		return size;
	}

	/**
	 * returns a string representing this multiset. The string contains, between
	 * brackets, pairs of objects and their multiplicities.
	 */
	@Override
	public String toString() {
		String s = ""["";
		for (Map.Entry<T, Integer> entry : map.entrySet()) {
			if (!s.equals(""["")) {
				s += "" "";
			}
			s += ""("" + entry.getKey() + "","" + entry.getValue() + "")"";
		}
		return s + ""]"";
	}

	/**
	 * returns a hashCode for this multiset.
	 */
	@Override
	public int hashCode() {
		if (!hashValid) {
			hashCode = map.hashCode();
			hashValid = true;
		}
		return hashCode;

	}

	/**
	 * returns the number of occurrences of the given object in this multiset.
	 * 
	 * @param source
	 *            the object to get the occurrences for
	 * @return the number of occurrences, 0 if the object does not occur.
	 */
	public Integer occurrences(Object source) {
		return (map.keySet().contains(source) ? map.get(source) : 0);
	}

	/**
	 * returns an iterator over the elements of the multiset. Note that if an
	 * object appears n times in the multiset, it is returned n times by the
	 * iterator.
	 * 
	 * For an iterator over unique elements of the multiset, use the toSet()
	 * method.
	 */
	@Override
	public Iterator<T> iterator() {
		return new MultiSetIterator<T, M>(this);
	}

	/**
	 * returns an unmodifiable set of unique objects in the multiset.
	 * 
	 * @return an unmodifiable set of unique objects in the multiset.
	 */
	public Set<T> baseSet() {
		return Collections.unmodifiableSet(map.keySet());
	}

	/**
	 * checks whether the number of occurrences of the given object is greater
	 * or equal to 1.
	 */
	@Override
	public boolean contains(Object o) {
		return map.containsKey(o);
	}

	/**
	 * Checks whether the number of occurrences of elements in the given
	 * collection is at most what is specified in this collection, i.e., this
	 * method returns (new MultiSet(c)).isLessOrEqual(this)
	 */
	@SuppressWarnings(""unchecked"")
	@Override
	public boolean containsAll(Collection<?> c) {
		MultiSet set;
		if (c instanceof MultiSet) {
			set = (MultiSet) c;
		} else {
			set = newMultiSet(c);
		}
		return set.isLessOrEqual(this);
	}

	/**
	 * removes the given object from this multiset, if it is in there. Only one
	 * occurrence is removed, i.e. contains(o) can still be true after calling
	 * remove(o)
	 */
	@SuppressWarnings(""unchecked"")
	@Override
	public boolean remove(Object o) {
		if (occurrences(o) == 0) {
			return false;
		} else {
			hashValid = false;
			// removing 1 occurrence
			size--;
			Integer occ = map.get(o);
			if (occ == 1) {
				map.remove(o);
				return true;
			} else {
				// since o is in this multiset, it can safely
				// be cast to T
				map.put((T) o, occ - 1);
				return true;
			}
		}
	}

	/**
	 * removes the elements in the given multiset from this multiset.
	 * 
	 * @param mset
	 *            the multiset of elements needing to be removed.
	 * @return a new multiset where the occurrences are the occurrences in this
	 *         multiset, minus the occurrences in the given multiset
	 */
	@Override
	public boolean removeAll(Collection<?> collection) {
		if (collection instanceof AbstractMultiSet<?, ?>) {
			return !removeAllMultiSet(Cast.<AbstractMultiSet<?, ?>>cast(collection), newMultiSet()).isEmpty();
		} else {
			boolean b = false;
			for (Object o : collection) {
				b |= remove(o);
			}
			return b;
		}
	}

	protected <S extends MultiSet<T>> S removeAllMultiSet(AbstractMultiSet<?, ?> mset, S removed) {
		for (Map.Entry<?, Integer> entry : mset.map.entrySet()) {
			if (!map.containsKey(entry.getKey())) {
				continue;
			}
			// Since map.containsKey(entry.getKey()), this is a safe cast
			T key = Cast.<T>cast(entry.getKey());
			Integer val = map.get(key);
			// What's the minimum of the amount I have and the amount I have to remove
			Integer toRemove = Math.min(entry.getValue(), val);
			removed.add(key, toRemove);

			size -= toRemove;
			if (val - toRemove == 0) {
				map.remove(key);
			} else {
				assert (val - toRemove > 0);
				map.put(key, val - toRemove);
			}
		}
		hashValid = false;
		return removed;
	}

	public String toHTMLString(boolean includeHTMLTags) {

		String s = (includeHTMLTags ? ""<html>"" : """") + ""["";
		for (Map.Entry<T, Integer> entry : map.entrySet()) {
			if (!s.endsWith(""["")) {
				s += "","";
			}
			s += entry.getKey();
			if (entry.getValue() > 1) {
				s += ""<sup>"" + entry.getValue() + ""</sup>"";
			}
		}
		return s + ""]"" + (includeHTMLTags ? ""</html>"" : """");
	}

	@Override
	public void clear() {
		map.clear();
		hashValid = false;
		size = 0;
	}

	@Override
	public boolean isEmpty() {
		return size == 0;
	}

}

/**
 * Provides an iterator over a MultiSet. This iterator returns objects as many
 * times as they are contained in the multiset.
 * 
 * @author bfvdonge
 * 
 * @param <T>
 */
class MultiSetIterator<T, M extends Map<T, Integer>> implements Iterator<T> {

	private final AbstractMultiSet<T, M> multiset;
	private final Iterator<Map.Entry<T, Integer>> iterator;
	private Entry<T, Integer> currentEntry = null;
	private Integer toGiveCount = 0;
	private boolean removed = false;

	public MultiSetIterator(AbstractMultiSet<T, M> multiset) {
		this.multiset = multiset;
		this.iterator = multiset.map.entrySet().iterator();
	}

	public boolean hasNext() {
		// No next object, if toGiveCount ==0 and iterator has no next object
		return !((toGiveCount == 0) && !iterator.hasNext());
	}

	public T next() throws NoSuchElementException {
		if (!hasNext()) {
			throw new NoSuchElementException();
		}
		if (toGiveCount == 0) {
			this.currentEntry = iterator.next();
			this.toGiveCount = currentEntry.getValue();
		}
		// reduce the toGiveCount by 1.
		toGiveCount--;
		removed = false;
		return currentEntry.getKey();
	}

	public void remove() {
		if (removed) {
			throw new IllegalStateException();
		}
		int val = currentEntry.getValue();
		if (val > 1) {
			currentEntry.setValue(val - 1);
		} else {
			iterator.remove();
		}
		multiset.size--;
		removed = true;
	}

}
"
AlphanumComparator.java,prom-framework-6.9.97,"package org.processmining.framework.util.collection;

/*
 * The Alphanum Algorithm is an improved sorting algorithm for strings
 * containing numbers. Instead of sorting numbers in ASCII order like a standard
 * sort, this algorithm sorts numbers in numeric order.
 * 
 * The Alphanum Algorithm is discussed at http://www.DaveKoelle.com
 * 
 * 
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or any later version.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

import java.util.Comparator;

/**
 * This is an updated version with enhancements made by Daniel Migowski, Andre
 * Bogus, and David Koelle
 * 
 * To convert to use Templates (Java 1.5+): - Change ""implements Comparator"" to
 * ""implements Comparator<String>"" - Change ""compare(Object o1, Object o2)"" to
 * ""compare(String s1, String s2)"" - Remove the type checking and casting in
 * compare().
 * 
 * To use this class: Use the static ""sort"" method from the
 * java.util.Collections class: Collections.sort(your list, new
 * AlphanumComparator());
 */
public class AlphanumComparator implements Comparator<String> {
	private final boolean isDigit(char ch) {
		return ch >= 48 && ch <= 57;
	}

	/**
	 * Length of string is passed in for improved efficiency (only need to
	 * calculate it once)
	 **/
	private final String getChunk(String s, int slength, int marker) {
		StringBuilder chunk = new StringBuilder();
		char c = s.charAt(marker);
		chunk.append(c);
		marker++;
		if (isDigit(c)) {
			while (marker < slength) {
				c = s.charAt(marker);
				if (!isDigit(c))
					break;
				chunk.append(c);
				marker++;
			}
		} else {
			while (marker < slength) {
				c = s.charAt(marker);
				if (isDigit(c))
					break;
				chunk.append(c);
				marker++;
			}
		}
		return chunk.toString();
	}

	public int compare(String s1, String s2) {
		int thisMarker = 0;
		int thatMarker = 0;
		int s1Length = s1.length();
		int s2Length = s2.length();

		while (thisMarker < s1Length && thatMarker < s2Length) {
			String thisChunk = getChunk(s1, s1Length, thisMarker);
			thisMarker += thisChunk.length();

			String thatChunk = getChunk(s2, s2Length, thatMarker);
			thatMarker += thatChunk.length();

			// If both chunks contain numeric characters, sort them numerically
			int result = 0;
			if (isDigit(thisChunk.charAt(0)) && isDigit(thatChunk.charAt(0))) {
				// Simple chunk comparison by length.
				int thisChunkLength = thisChunk.length();
				result = thisChunkLength - thatChunk.length();
				// If equal, the first different number counts
				if (result == 0) {
					for (int i = 0; i < thisChunkLength; i++) {
						result = thisChunk.charAt(i) - thatChunk.charAt(i);
						if (result != 0) {
							return result;
						}
					}
				}
			} else {
				result = thisChunk.compareTo(thatChunk);
			}

			if (result != 0)
				return result;
		}

		return s1Length - s2Length;
	}
}
"
ComparablePair.java,prom-framework-6.9.97,"package org.processmining.framework.util.collection;

import org.processmining.framework.util.Pair;

public class ComparablePair<F extends Comparable<? super F>, S extends Comparable<? super S>> extends Pair<F, S>
		implements Comparable<ComparablePair<F, S>> {

	public ComparablePair(F first, S second) {
		super(first, second);
	}

	public <T extends Comparable<? super T>> int compareTo(T x, T y) {
		if (x == null) {
			return y == null ? 0 : -1;
		} else {
			return x.compareTo(y);
		}
	}

	public int compareTo(ComparablePair<F, S> other) {
		if (other == null) {
			return 1;
		}
		int result = compareTo(first, other.first);
		return result == 0 ? compareTo(second, other.second) : result;
	}

}
"
HashMultiSet.java,prom-framework-6.9.97,"package org.processmining.framework.util.collection;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

public class HashMultiSet<T> extends AbstractMultiSet<T, Map<T, Integer>> {

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are returned by the iterator of that
	 * collection.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public HashMultiSet(Collection<? extends T> collection) {
		this();
		addAll(collection);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are in the given array.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public HashMultiSet(T[] collection) {
		this();
		for (T par : collection) {
			add(par);
		}
	}

	/**
	 * Constructs a new, empty multiset, such that all elements of the given
	 * collection are added as many times as they are returned by the iterator
	 * of that collection.
	 */
	public HashMultiSet() {
		size = 0;
		map = new HashMap<T, Integer>();
	}

	<S> MultiSet<S> newMultiSet(Collection<S> collection) {
		return new HashMultiSet<S>(collection);
	}

	MultiSet<T> newMultiSet() {
		return new HashMultiSet<T>();
	}
}
"
LinkedHashMultiSet.java,prom-framework-6.9.97,"package org.processmining.framework.util.collection;

import java.util.Collection;
import java.util.LinkedHashMap;

public class LinkedHashMultiSet<T> extends HashMultiSet<T> {

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are returned by the iterator of that
	 * collection.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public LinkedHashMultiSet(Collection<? extends T> collection) {
		this();
		addAll(collection);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are in the given array.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public LinkedHashMultiSet(T... collection) {
		this();
		for (T par : collection) {
			add(par);
		}
	}

	/**
	 * Constructs a new, empty multiset, such that all elements of the given
	 * collection are added as many times as they are returned by the iterator
	 * of that collection.
	 */
	public LinkedHashMultiSet() {
		size = 0;
		map = new LinkedHashMap<T, Integer>();
	}

}
"
MultiSet.java,prom-framework-6.9.97,"package org.processmining.framework.util.collection;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import org.processmining.framework.util.HTMLToString;

/**
 * This class implements a mutliset. The implementation is synchronized.
 * 
 * @author bfvdonge
 * 
 * @param <T>
 *            the type of the objects in this multiset.
 */
public interface MultiSet<T> extends Collection<T>, HTMLToString {

	/**
	 * Adds the given object to the multiset, as many times as indicated by the
	 * given weight parameter.
	 * 
	 * @param par
	 *            the object to add
	 * @param weight
	 *            the number of times to add it
	 * @return the new number of occurrences of the object (>0)
	 */
	public Integer add(T par, Integer weight);

	/**
	 * Converts this multiset to a list, such that each element occurs as often
	 * as returned by the iterator of the multiset (its number of occurrences).
	 * 
	 * @return a list of objects as returned by the iterator
	 */
	public List<T> toList();

	/**
	 * returns true if this multiset is less or equal to the given multiset,
	 * i.e. all objects in this multiset should be contained in the given set
	 * and the number of occurrences in the given set is at least the number of
	 * occurrences in this multiset.
	 * 
	 * @param multiSet
	 *            the multiset to test
	 * @return true if the given multiset is less or equal.
	 */
	public boolean isLessOrEqual(MultiSet<T> multiSet);

	/**
	 * returns the number of occurrences of the given object in this multiset.
	 * 
	 * @param source
	 *            the object to get the occurrences for
	 * @return the number of occurrences, 0 if the object does not occur.
	 */
	public Integer occurrences(Object source);

	/**
	 * returns an unmodifiable set of unique objects in the multiset.
	 * 
	 * @return an unmodifiable set of unique objects in the multiset.
	 */
	public Set<T> baseSet();

}
"
SortedMultiSet.java,prom-framework-6.9.97,"package org.processmining.framework.util.collection;

import java.util.Comparator;
import java.util.SortedSet;

public interface SortedMultiSet<T> extends MultiSet<T> {

	Comparator<? super T> comparator();

	/**
	 * returns an unmodifiable set of unique objects in the multiset.
	 * 
	 * @return an unmodifiable set of unique objects in the multiset.
	 */
	SortedSet<T> baseSet();

}
"
TreeMultiSet.java,prom-framework-6.9.97,"package org.processmining.framework.util.collection;

import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

public class TreeMultiSet<T> extends AbstractMultiSet<T, TreeMap<T, Integer>> implements SortedMultiSet<T> {

	private Comparator<? super T> comparator;

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are returned by the iterator of that
	 * collection.
	 * 
	 * All elements inserted into the multiset must implement the Comparable
	 * interface. Furthermore, all such elements must be mutually comparable:
	 * e1.compareTo(e2) must not throw a ClassCastException for any elements e1
	 * and e2 in the set.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public TreeMultiSet(Collection<T> collection) {
		this((Comparator<T>) null);
		addAll(collection);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are in the given array.
	 * 
	 * All elements inserted into the multiset must implement the Comparable
	 * interface. Furthermore, all such elements must be mutually comparable:
	 * e1.compareTo(e2) must not throw a ClassCastException for any elements e1
	 * and e2 in the set.
	 * 
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public TreeMultiSet(T... collection) {
		this((Comparator<T>) null);
		for (T par : collection) {
			add(par);
		}
	}

	/**
	 * Constructs a new, empty multiset, such that all elements of the given
	 * collection are added as many times as they are returned by the iterator
	 * of that collection.
	 * 
	 * All elements inserted into the multiset must implement the Comparable
	 * interface. Furthermore, all such elements must be mutually comparable:
	 * e1.compareTo(e2) must not throw a ClassCastException for any elements e1
	 * and e2 in the set.
	 * 
	 */
	public TreeMultiSet() {
		this((Comparator<T>) null);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are returned by the iterator of that
	 * collection.
	 * 
	 * @param comp
	 *            A comparator providing sorting on the elements of the multiset
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public TreeMultiSet(Collection<T> collection, Comparator<? super T> comp) {
		this(comp);
		addAll(collection);
	}

	/**
	 * Constructs a new multiset, such that all elements of the given collection
	 * are added as many times as they are in the given array.
	 * 
	 * @param comp
	 *            A comparator providing sorting on the elements of the multiset
	 * @param collection
	 *            Representing the objects that should be put in a multiset
	 */
	public TreeMultiSet(Comparator<? super T> comp, T... collection) {
		this(comp);
		for (T par : collection) {
			add(par);
		}
	}

	/**
	 * Constructs a new, empty multiset, such that all elements of the given
	 * collection are added as many times as they are returned by the iterator
	 * of that collection.
	 * 
	 * @param comp
	 *            A comparator providing sorting on the elements of the multiset
	 */
	public TreeMultiSet(Comparator<? super T> comp) {
		size = 0;
		TreeMap<T, Integer> newMap = new TreeMap<T, Integer>(comp);
		comparator = newMap.comparator();
		map = newMap;
	}

	<S> MultiSet<S> newMultiSet(Collection<S> collection) {
		return new TreeMultiSet<S>(collection);
	}

	MultiSet<T> newMultiSet() {
		return new TreeMultiSet<T>();
	}

	public Comparator<? super T> comparator() {
		return comparator;
	}

	/**
	 * returns an unmodifiable set of unique objects in the multiset.
	 * 
	 * @return an unmodifiable set of unique objects in the multiset.
	 */
	public SortedSet<T> baseSet() {
		// JAVA 5 CODE:
		SortedSet<T> set = new TreeSet<T>(comparator);
		set.addAll(map.keySet());
		// JAVA 6 CODE:
		// SortedSet<T> set = map.navigableKeySet());
		return Collections.unmodifiableSortedSet(set);
	}
}
"
WeakKeyValueMap.java,prom-framework-6.9.97,"package org.processmining.framework.util.collection;

import java.lang.ref.WeakReference;
import java.util.AbstractMap;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

public class WeakKeyValueMap<K, V> extends AbstractMap<K, V> {

	private final Map<K, WeakReference<V>> map;

	public WeakKeyValueMap(int initialCapacity, float loadFactor) {
		map = new WeakHashMap<K, WeakReference<V>>(initialCapacity, loadFactor);
	}

	public WeakKeyValueMap(int initialCapacity) {
		map = new WeakHashMap<K, WeakReference<V>>(initialCapacity);
	}

	public WeakKeyValueMap() {
		map = new WeakHashMap<K, WeakReference<V>>();

	}

	public WeakKeyValueMap(Map<? extends K, ? extends V> m) {
		this();
		putAll(m);
	}

	public void clear() {
		map.clear();
	}

	public boolean containsKey(Object key) {
		return map.containsKey(key);
	}

	public boolean containsValue(Object value) {
		for (WeakReference<V> w : map.values()) {
			if (value.equals(w.get())) {
				return true;
			}
		}
		return false;
	}

	public Set<java.util.Map.Entry<K, V>> entrySet() {
		Set<java.util.Map.Entry<K, V>> set = new HashSet<java.util.Map.Entry<K, V>>();
		for (java.util.Map.Entry<K, WeakReference<V>> entry : map.entrySet()) {
			set.add(new SimpleEntry<K, V>(entry.getKey(), entry.getValue().get()));
		}
		return set;
	}

	public V get(Object key) {
		WeakReference<V> val = map.get(key);
		return val == null ? null : val.get();
	}

	public boolean isEmpty() {
		return map.isEmpty();
	}

	public Set<K> keySet() {
		return map.keySet();
	}

	public V put(K key, V value) {
		V val = get(key);
		map.put(key, new WeakReference<V>(value));
		return val;
	}

	public void putAll(Map<? extends K, ? extends V> m) {
		for (Map.Entry<? extends K, ? extends V> entry : m.entrySet()) {
			put(entry.getKey(), entry.getValue());
		}
	}

	public V remove(Object key) {
		return map.remove(key).get();
	}

	public int size() {
		return map.size();
	}

	public Collection<V> values() {
		Set<V> set = new HashSet<V>();
		for (WeakReference<V> val : map.values()) {
			set.add(val.get());
		}
		return set;
	}

}
"
CommandLineArgumentList.java,prom-framework-6.9.97,"package org.processmining.framework.util;

import java.util.ArrayList;

public class CommandLineArgumentList extends ArrayList<String> {

	private static final long serialVersionUID = -1574623826051169007L;

	public String[] toStringArray() {
		return toArray(new String[0]);
	}

}
"
GoogleAnalyticsUtil.java,prom-framework-6.9.97,"package org.processmining.framework.util;

import com.brsanthu.googleanalytics.EventHit;
import com.brsanthu.googleanalytics.GoogleAnalytics;

public class GoogleAnalyticsUtil {

	private GoogleAnalytics ga = new GoogleAnalytics(""UA-1999775-7""); // www.promtools.org
//	private GoogleAnalytics ga = new GoogleAnalytics(""UA-1999775-1""); // www.win.tue.nl/~hverbeek

	public void runPluginEvent(String pluginName, String packageName) {
		EventHit eh = new EventHit();
		// Anonymize the IP. We're not that interested in it. 
		eh.anonymizeIp(true);
		eh.eventAction(""Run ProM Plug-in"");
		if (pluginName == null) {
			eh.eventLabel(""<No plug-in name>"");
		} else {
			eh.eventLabel(pluginName);
		}
		if (packageName == null) {
			eh.eventCategory(""<No package name>"");
		} else {
			eh.eventCategory(packageName);
		}
		
//		ga.post(eh);
		// Use https if possible. 
		ga.getConfig().setUseHttps(true);
		ga.postAsync(eh);
		/*
		 * if you uncomment the next line, make sure you're using post() and not postAsync() in the previous lines.
		 * Both post() and postAsync() may change the content of variable eh, which may cause problesm when writing
		 * out the value of this variable.
		 * 
		 */
//		System.out.println(""[GoogleAnalyticsUtil] "" + eh);
	}
}
"
HTMLToString.java,prom-framework-6.9.97,"package org.processmining.framework.util;

import java.awt.Color;
import java.awt.Component;

import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.ListCellRenderer;

public interface HTMLToString {

	public String toHTMLString(boolean includeHTMLTags);

	public static class HTMLCellRenderer extends JLabel implements ListCellRenderer {
		/**
		 * 
		 */
		private static final long serialVersionUID = -808355468668630456L;

		public HTMLCellRenderer() {
			setOpaque(true);
		}

		public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected,
				boolean cellHasFocus) {

			if (value instanceof HTMLToString) {
				setText(Cast.<HTMLToString>cast(value).toHTMLString(true));
			} else {
				setText(value.toString());
			}

			setBackground(isSelected ? Color.RED : Color.WHITE);
			setForeground(isSelected ? Color.WHITE : Color.BLACK);
			return this;

		}
	}

}
"
IconLoader.java,prom-framework-6.9.97,"package org.processmining.framework.util;

import java.io.File;
import java.net.MalformedURLException;

import javax.swing.ImageIcon;

import org.processmining.framework.boot.Boot;

public class IconLoader {

	public static ImageIcon getStandardIcon(String name) {
		String imgLocation = ""toolbarButtonGraphics/"" + name + "".gif"";
		java.net.URL imageURL = Thread.currentThread().getContextClassLoader().getResource(imgLocation);

		return new ImageIcon(imageURL);
	}

	public static ImageIcon getProMLibIcon(String name) {
		try {
			File file = new File(Boot.IMAGES_FOLDER + File.separator + name + "".gif"");
			java.net.URL imageURL = file.toURI().toURL();
			return new ImageIcon(imageURL);
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

}
"
LevenshteinDistance.java,prom-framework-6.9.97,"package org.processmining.framework.util;

import java.util.List;

/**
 * @author R.P. Jagadeesh Chandra 'JC' Bose
 * @date 08 July 2010 
 * @since 01 June 2009
 * @version 1.0
 * @email j.c.b.rantham.prabhakara@tue.nl
 * @copyright R.P. Jagadeesh Chandra 'JC' Bose
 * 			  Architecture of Information Systems Group (AIS) 
 * 			  Department of Mathematics and Computer Science
 * 			  University of Technology, Eindhoven, The Netherlands
 */

public class LevenshteinDistance{
	int encodingLength;
	float[][] distanceMatrix;
	
	public LevenshteinDistance(int encodingLength, List<String> charStreamList){
		this.encodingLength = encodingLength;
		int noTraces = charStreamList.size();
		distanceMatrix = new float[noTraces][noTraces];
		computeLevenshteinDistanceLinearSpace(charStreamList);
	}
	
	public LevenshteinDistance(){
		this.encodingLength = 1;
	}
	
	protected void computeLevenshteinDistanceLinearSpace(List<String> charStreams){
		int noCharStreams = charStreams.size();
		
		String seq1, seq2;
		int lengthSeq1, lengthSeq2, maxLength, dist;
		float distanceNorm1;
		
		for(int i = 0; i < noCharStreams; i++){
		
			seq1 = charStreams.get(i);
			lengthSeq1 = seq1.length()/encodingLength;
			
			for(int j = 0; j < i; j++){
				seq2 = charStreams.get(j);
				
				if(seq1.equals(seq2)){
					distanceNorm1 = 0;
				}else{
				
					lengthSeq2 = seq2.length()/encodingLength;
				
					maxLength = lengthSeq1;
					if(lengthSeq2 > maxLength)
						maxLength = lengthSeq2;
					
					dist = getLevenshteinDistanceLinearSpace(seq1, seq2);
					distanceNorm1 = dist/(float)(lengthSeq1+lengthSeq2);
				}
				
				distanceMatrix[i][j] = distanceNorm1;
				distanceMatrix[j][i] = distanceNorm1;
				
			}
		}
	}

	public int getLevenshteinDistanceLinearSpace(String seq1, String seq2){
		
		String sI, tJ;
		int lengthSeq1, lengthSeq2, cost;
		
		
		lengthSeq1 = seq1.length()/encodingLength;
		lengthSeq2 = seq2.length()/encodingLength;
		
		int[] S = new int[lengthSeq2+1];
		
		S[0] = 0;
		S[1] = S[0] + 1; //Insert first symbol
		for(int j = 2; j <= lengthSeq2; j++){
			S[j] = S[j-1]+1;
		}
		
		int s,c;
		for(int i = 1; i <= lengthSeq1; i++){
			s = S[0];
			S[0] = c = S[0]+ 1; //Insertion of first symbol
			sI = seq1.substring((i-1)*encodingLength, i*encodingLength);
			for(int j = 1; j <= lengthSeq2; j++){
				tJ = seq2.substring((j-1)*encodingLength, j*encodingLength);
				
				cost = 0;
				if(!sI.equals(tJ))
					cost = 1;
				c = Minimum(S[j]+1, s+cost, c+1);
				s = S[j];
				S[j] = c;
			}
		}
		
		return S[lengthSeq2];
		
	}

	private int Minimum(int a, int b, int c) {
		int mi;

		mi = a;
		if (b < mi) {
			mi = b;
		}
		if (c < mi) {
			mi = c;
		}
		return mi;

	}
	
	public float[][] getDistanceMatrix(){
		return distanceMatrix;
	}
}
"
OsUtil.java,prom-framework-6.9.97,"package org.processmining.framework.util;

import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;

import javax.management.MBeanServer;
import javax.management.ObjectName;

import org.processmining.framework.boot.Boot;

import sun.management.ManagementFactoryHelper;

import com.sun.management.OperatingSystemMXBean;

public class OsUtil {

	public static final String OS_WIN32 = ""Windows 32 bit"";
	public static final String OS_WIN64 = ""Windows 64 bit"";
	public static final String OS_MACOSX = ""Mac OS X"";
	public static final String OS_MACOSCLASSIC = ""Mac OS 7-9"";
	public static final String OS_LINUX = ""Linux"";
	public static final String OS_BSD = ""BSD"";
	public static final String OS_RISCOS = ""RISC OS"";
	public static final String OS_BEOS = ""BeOS"";
	public static final String OS_UNKNOWN = ""unknown"";

	private static String currentOs = null;

	public static String determineOS() {
		if (currentOs == null) {
			String osString = System.getProperty(""os.name"").trim().toLowerCase();
			if (osString.startsWith(""windows"")) {
				currentOs = OS_WIN32;
			} else if (osString.startsWith(""mac os x"")) {
				currentOs = OS_MACOSX;
			} else if (osString.startsWith(""mac os"")) {
				currentOs = OS_MACOSCLASSIC;
			} else if (osString.startsWith(""risc os"")) {
				currentOs = OS_RISCOS;
			} else if ((osString.indexOf(""linux"") >= 0) || (osString.indexOf(""debian"") >= 0)
					|| (osString.indexOf(""redhat"") >= 0) || (osString.indexOf(""lindows"") >= 0)) {
				currentOs = OS_LINUX;
			} else if ((osString.indexOf(""freebsd"") >= 0) || (osString.indexOf(""openbsd"") >= 0)
					|| (osString.indexOf(""netbsd"") >= 0) || (osString.indexOf(""irix"") >= 0)
					|| (osString.indexOf(""solaris"") >= 0) || (osString.indexOf(""sunos"") >= 0)
					|| (osString.indexOf(""hp/ux"") >= 0) || (osString.indexOf(""risc ix"") >= 0)
					|| (osString.indexOf(""dg/ux"") >= 0)) {
				currentOs = OS_BSD;
			} else if (osString.indexOf(""beos"") >= 0) {
				currentOs = OS_BEOS;
			} else {
				currentOs = OS_UNKNOWN;
			}
		}
		return currentOs;
	}

	public static boolean is64Bit() {
		return System.getProperty(""sun.arch.data.model"").equals(""64"");
	}

	public static boolean is32Bit() {
		return System.getProperty(""sun.arch.data.model"").equals(""32"");
	}

	public static boolean isRunningWindows() {
		return determineOS() == OS_WIN32;
	}

	public static boolean isRunningMacOsX() {
		return determineOS() == OS_MACOSX;
	}

	public static boolean isRunningLinux() {
		return determineOS() == OS_LINUX;
	}

	public static boolean isRunningUnix() {
		String os = determineOS();
		return (os == OS_BSD) || (os == OS_LINUX) || (os == OS_MACOSX);
	}

	public static void setWorkingDirectoryAtStartup() {
		if (isRunningMacOsX()) {
			System.setProperty(""apple.laf.useScreenMenuBar"", ""true"");
			File here = new File(""."");
			try {
				if (new File(here.getAbsolutePath() + ""/ProM.app"").exists()) {
					System.out.println(""--> Mac OS X: running from application bundle (1)."");
					File nextHere = new File(here.getCanonicalPath() + ""/ProM.app/Contents/Resources/ProMhome"");
					System.setProperty(""user.dir"", nextHere.getCanonicalPath());
				} else if (here.getAbsolutePath().matches(""^(.*)ProM\\.app(/*)$"")) {
					System.out.println(""--> Mac OS X: running from application bundle (2)."");
					File nextHere = new File(here.getCanonicalPath() + ""/Contents/Resources/ProMhome"");
					System.setProperty(""user.dir"", nextHere.getCanonicalPath());
				}
				System.out.println(""Mac OS X: Working directory set to "" + System.getProperty(""user.dir"") + "" (from ""
						+ here.getAbsolutePath() + "")"");
			} catch (IOException e) {
				e.printStackTrace();
			}
			System.out.println(""Mac OS X: Working directory set to "" + System.getProperty(""user.dir"") + "" (from ""
					+ here.getAbsolutePath() + "")"");
		}
	}

	//	public static File getProMUserDirectory() {
	//		File dir = new File(Boot.PROM_USER_FOLDER);
	//		//System.getProperty(""user.home"", """"), "".ProM"");
	//		dir.mkdirs();
	//		return dir;
	//	}

	/**
	 * Returns a handle to the ProM package folder. Creates the folder in case
	 * it does not yet exist.
	 * 
	 * @return The handle to the folder.
	 */
	public static File getProMPackageDirectory() {
		return getDirectory(Boot.PACKAGE_FOLDER);
	}

	/**
	 * Returns whether the ProM package folder exists on this system.
	 * 
	 * @return Whether the folder exists.
	 */
	public static boolean hasProMPackageDirectory() {
		return hasDirectory(Boot.PACKAGE_FOLDER);
	}

	/**
	 * Returns a handle to the ProM workspace folder. Creates the folder in case
	 * it does not yet exist.
	 * 
	 * @return The handle to the folder.
	 */
	public static File getProMWorkspaceDirectory() {
		return getDirectory(Boot.WORKSPACE_FOLDER);
	}

	/**
	 * Returns whether the ProM workspace folder exists on this system.
	 * 
	 * @return Whether the folder exists.
	 */
	public static boolean hasProMWorkspaceDirectory() {
		return hasDirectory(Boot.WORKSPACE_FOLDER);
	}

	/*
	 * Returns a handle to the folder with provided name. Creates the folder in
	 * case it does not yet exist.
	 * 
	 * @return The handle to the folder.
	 */
	private static File getDirectory(String dirName) {
		File dir = new File(dirName);
		dir.mkdirs();
		return dir;
	}

	/*
	 * Returns whether the folder with provided name exists on this system.
	 * 
	 * @return Whether the folder exists.
	 */
	private static boolean hasDirectory(String dirName) {
		File dir = new File(dirName);
		return dir.exists();
	}

	public static long getPhysicalMemory() {
		try {
			OperatingSystemMXBean operatingSystemMXBean = (OperatingSystemMXBean) ManagementFactoryHelper
					.getOperatingSystemMXBean();
			return operatingSystemMXBean.getTotalPhysicalMemorySize();
		} catch (Exception e) {
			// Does not work, try something else.
		}
		try {
			MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
			Object attribute = mBeanServer.getAttribute(new ObjectName(""java.lang"", ""type"", ""OperatingSystem""),
					""TotalPhysicalMemorySize"");
			return Long.parseLong(attribute.toString());
		} catch (Exception e) {
			// Does not work, try something else.
		}
		// If all else fails, assume thare is just 1 GB of RAM.
		return 1024 * 1024 * 1024;
	}
}
"
Pair.java,prom-framework-6.9.97,"package org.processmining.framework.util;

public class Pair<F, S> {

	protected final S second;
	protected final F first;

	public Pair(F first, S second) {
		this.first = first;
		this.second = second;
	}

	public F getFirst() {
		return first;
	}

	public S getSecond() {
		return second;
	}

	private static boolean equals(Object x, Object y) {
		return ((x == null) && (y == null)) || ((x != null) && x.equals(y));
	}

	@SuppressWarnings(""unchecked"")
	@Override
	public boolean equals(Object other) {
		return (other instanceof Pair) && equals(first, ((Pair<F, S>) other).first)
				&& equals(second, ((Pair<F, S>) other).second);
	}

	@Override
	public int hashCode() {
		if (first == null) {
			return second == null ? 0 : second.hashCode() + 1;
		} else {
			return second == null ? first.hashCode() + 2 : first.hashCode() * 17 + second.hashCode();
		}
	}

	@Override
	public String toString() {
		return ""("" + first + "","" + second + "")"";
	}

}
"
PathHacker.java,prom-framework-6.9.97,"package org.processmining.framework.util;

import java.io.File;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Properties;

/**
 * Dynamically adds jars or dll files at runtime to the environment for direct
 * use
 * 
 * @author T. van der Wiel
 * 
 */
public class PathHacker {
	@SuppressWarnings(""unchecked"")
	private static final Class[] parameters = new Class[] { URL.class };

	/**
	 * ensures the given path is in java.library.path
	 * 
	 * @param path
	 * @throws Exception
	 */
	public static void addLibPath(String path) throws Exception {
		File file = new File(path);
		// Append the specified path to the existing java.library.path (if there is one already)
		String newLibraryPath = System.getProperty(""java.library.path"");
		if ((newLibraryPath == null) || (newLibraryPath.length() < 1)) {
			newLibraryPath = file.getCanonicalPath();
		} else if (newLibraryPath.contains(file.getCanonicalPath())) {
			return;
		} else {
			newLibraryPath += File.pathSeparator + file.getCanonicalPath();
		}

		// Reflect into java.lang.System to get the static Properties reference
		Field f = System.class.getDeclaredField(""props"");
		f.setAccessible(true);
		Properties props = (Properties) f.get(null);
		// replace the java.library.path with our new one
		props.put(""java.library.path"", newLibraryPath);

		// The classLoader may have already been initialized, so it needs to be fixed up.
		// Reflect into java.lang.ClassLoader to get the static String[] of user paths to native libraries
		Field usr_pathsField = ClassLoader.class.getDeclaredField(""usr_paths"");
		usr_pathsField.setAccessible(true);
		String[] usr_paths = (String[]) usr_pathsField.get(null);
		String[] newUsr_paths = new String[usr_paths == null ? 1 : usr_paths.length + 1];
		if (usr_paths != null) {
			System.arraycopy(usr_paths, 0, newUsr_paths, 0, usr_paths.length);
		}
		// Add the specified path to the end of a new String[] of user paths to native libraries
		newUsr_paths[newUsr_paths.length - 1] = file.getAbsolutePath();
		usr_pathsField.set(null, newUsr_paths);
	}

	public static void addLibraryPathFromDirectory(File dir) {
		if (!dir.exists() || !dir.isDirectory() || !dir.canRead()) {
			return;
		}

		for (File f : dir.listFiles()) {
			if (f.isDirectory()) {
				try {
					addLibPath(f.getAbsolutePath());
				} catch (Exception e) {
					// Failed, no big deal
				}
				addLibraryPathFromDirectory(f);
			} else {
				//skip
			}
		}
	}

	//	/**
	//	 * tries to load the given file to the runtime environment
	//	 * @param file
	//	 * @throws IOException if an UnsatisfiedLinkError occurs
	//	 * @throws SecurityException if a security manager exists and its checkLink method doesn't allow loading of the specified dynamic library
	//	 * @throws UnsatisfiedLinkError if the file does not exist. 
	//	 * @throws NullPointerException if filename is null
	//	 */
	//	public static void addLib(String file) throws Exception {
	//		try {
	//        	Runtime.getRuntime().load(file);
	//		} catch(UnsatisfiedLinkError e) {
	//			throw new IOException(""UnsatisfiedLinkError"");
	//		}
	//	}

	public static void addJar(String s) {
		File f = new File(s);
		addJar(f);
	}

	public static void addJar(File f) {
		try {
			// File.toURL() was deprecated, so use File.toURI().toURL()
			addJar(f.toURI().toURL());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Adds the given URL to the classpath for direct use
	 * 
	 * @param URL
	 *            of the Java Archive
	 */
	public static void addJar(URL u) {
		URLClassLoader sysloader = (URLClassLoader) ClassLoader.getSystemClassLoader();
		for (URL u2 : sysloader.getURLs()) {
			if (u.equals(u2)) {
				return;
			}
		}
		try {
			/* Class was uncheched, so used URLClassLoader.class instead */
			Method method = URLClassLoader.class.getDeclaredMethod(""addURL"", parameters);
			method.setAccessible(true);
			method.invoke(sysloader, new Object[] { u });
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
"
XMonitoredInputStream.java,prom-framework-6.9.97,"/*
 * OpenXES
 * 
 * The reference implementation of the XES meta-model for event 
 * log data management.
 * 
 * Copyright (c) 2008 Christian W. Guenther (christian@deckfour.org)
 * 
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 * 
 * EXEMPTION:
 * 
 * The use of this software can also be conditionally licensed for
 * other programs, which do not satisfy the specified conditions. This
 * requires an exemption from the general license, which may be
 * granted on a per-case basis.
 * 
 * If you want to license the use of this software with a program
 * incompatible with the LGPL, please contact the author for an
 * exemption at the following email address: 
 * christian@deckfour.org
 * 
 */
package org.processmining.framework.util.progress;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

import javax.swing.JProgressBar;

/**
 * This class implements an input stream which can provide
 * a progress listener with feedback about how much of the
 * data in the stream has already been read.
 * 
 * This is a useful utility for reading XML-based data,
 * while still providing feedback about expected progress.
 * 
 * @author Christian W. Guenther (christian@deckfour.org)
 *
 */
public class XMonitoredInputStream extends InputStream {
	
	/**
	 * The number of steps to be used for progress expression.
	 */
	protected int stepNumber = 1000;
	/**
	 * Number of bytes per step.
	 */
	protected long stepSize;
	/**
	 * The last step which has been notified about.
	 */
	protected int lastStep;
	/**
	 * Number of bytes read so far.
	 */
	protected long bytesRead = 0;
	/**
	 * Wrapped, monitored input stream.
	 */
	protected InputStream stream;
	/**
	 * Progress listener which is being notified.
	 */
	protected XProgressListener progressListener;
	
	/**
	 * Creates a new monitored input stream.
	 * 
	 * @param file The file to be read from.
	 * @param progressListener Progress listener to be notified.
	 */
	public XMonitoredInputStream(File file, XProgressListener progressListener) throws FileNotFoundException {
		this(new BufferedInputStream(new FileInputStream(file)), file.length(), progressListener);
	}
	
	/**
	 * Creates a new monitored input stream.
	 * 
	 * @param stream Monitored, wrapped lower-level input stream.
	 * @param size Number of bytes to be read from the stream.
	 * @param progressBar Progress bar to be updated.
	 */
	public XMonitoredInputStream(InputStream stream, long size, JProgressBar progressBar) {
		this(stream, size, new XProgressBarListener(progressBar), 1000);
	}
	
	/**
	 * Creates a new monitored input stream.
	 * 
	 * @param stream Monitored, wrapped lower-level input stream.
	 * @param size Number of bytes to be read from the stream.
	 * @param progressListener Progress listener to be notified.
	 */
	public XMonitoredInputStream(InputStream stream, long size, XProgressListener progressListener) {
		this(stream, size, progressListener, 1000);
	}
	
	/**
	 * Creates a new monitored input stream.
	 * 
	 * @param stream Monitored, wrapped lower-level input stream.
	 * @param size Number of bytes to be read from the stream.
	 * @param progressListener Progress listener to be notified.
	 * @param stepNumber Number of steps used to express progress.
	 */
	public XMonitoredInputStream(InputStream stream, long size, XProgressListener progressListener, int stepNumber) {
		this.progressListener = progressListener;
		this.stream = stream;
		this.stepNumber = stepNumber;
		// avoid potential divide by 0 when stepsize == 0
		this.stepSize = Math.max(size / stepNumber, 1);
		this.lastStep = 0;
		this.bytesRead = 0;
	}
	
	/**
	 * This method is called by the actual input stream method
	 * to provide feedback about the number of read bytes.
	 * 
	 * Notifies the attached progress listener if appropriate.
	 * 
	 * @param readBytes The number of read bytes in this call.
	 */
	protected void update(long readBytes) throws IOException {
		if (progressListener.isAborted()) {
			throw new IOException(""Reading Cancelled by ProgressListener"");
		}
		this.bytesRead += readBytes;
		int step = (int)(bytesRead / stepSize);
		if(step > lastStep) {
			lastStep = step;
			progressListener.updateProgress(step, stepNumber);
		}
	}
	
	/**
	 * Returns the number of steps so far.
	 * 
	 * @return Number of steps.
	 */
	public int getStepNumber() {
		return stepNumber;
	}
	
	/* (non-Javadoc)
	 * @see java.io.InputStream#read()
	 */
	@Override
	public int read() throws IOException {
		int result = stream.read();
		update(1);
		return result;
	}

	/* (non-Javadoc)
	 * @see java.io.InputStream#read(byte[], int, int)
	 */
	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		int result = stream.read(b, off, len);
		update(result);
		return result;
	}

	/* (non-Javadoc)
	 * @see java.io.InputStream#read(byte[])
	 */
	@Override
	public int read(byte[] b) throws IOException {
		int result = stream.read(b);
		update(result);
		return result;
	}

	/* (non-Javadoc)
	 * @see java.io.InputStream#skip(long)
	 */
	@Override
	public long skip(long n) throws IOException {
		long result = stream.skip(n);
		update(result);
		return result;
	}
	
	

}
"
XProgressBarListener.java,prom-framework-6.9.97,"/*
 * OpenXES
 * 
 * The reference implementation of the XES meta-model for event 
 * log data management.
 * 
 * Copyright (c) 2008 Christian W. Guenther (christian@deckfour.org)
 * 
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 * 
 * EXEMPTION:
 * 
 * The use of this software can also be conditionally licensed for
 * other programs, which do not satisfy the specified conditions. This
 * requires an exemption from the general license, which may be
 * granted on a per-case basis.
 * 
 * If you want to license the use of this software with a program
 * incompatible with the LGPL, please contact the author for an
 * exemption at the following email address: 
 * christian@deckfour.org
 * 
 */
package org.processmining.framework.util.progress;

import javax.swing.JProgressBar;

/**
 * This class implements a progress listener for controlling
 * an attached Swing progress bar. The progress bar will then reflect
 * the progress as received by this listener.
 * 
 * @author Christian W. Guenther (christian@deckfour.org)
 *
 */
public class XProgressBarListener implements XProgressListener {

	/**
	 * Controlled progress bar.
	 */
	protected JProgressBar progressBar;
	/**
	 * Start value to use in progress bar.
	 * When the progress listener begins, this will be
	 * the displayed value on the progress bar.
	 */
	protected int startValue;
	/**
	 * Stop value to use in progress bar.
	 * When the progress listener is completed, this will
	 * be the displayed value on the progress bar.
	 */
	protected int stopValue;
	
	/**
	 * Creates a new progress bar listener with the specified progress
	 * bar for display. The progress bar will accurately and completely
	 * reflect the progress, as received by this listener.
	 * 
	 * @param progressBar Progress bar to display progress.
	 */
	public XProgressBarListener(JProgressBar progressBar) {
		this(progressBar, progressBar.getMinimum(), progressBar.getMaximum());
	}
	
	/**
	 * Creates a new progress bar listener with the specified progress
	 * bar for display. Allows the specification of start and stop values
	 * for the progress bar, so that this listener may control only part
	 * of a more higher-level progress (e.g., the loading of one from
	 * a number of files).
	 * 
	 * @param progressBar Progress bar to display progress.
	 * @param startValue When the progress listener begins, this will be
	 * the displayed value on the progress bar.
	 * @param stopValue When the progress listener is completed, this will
	 * be the displayed value on the progress bar.
	 */
	public XProgressBarListener(JProgressBar progressBar, int startValue, int stopValue) {
		this.progressBar = progressBar;
		this.startValue = startValue;
		this.stopValue = stopValue;
	}
	
	/* (non-Javadoc)
	 * @see org.deckfour.xes.util.MonitoredInputStream.ProgressListener#updateProgress(int, int)
	 */
	public void updateProgress(int progress, int maxProgress) {
		int increment = (int)((double)(stopValue - startValue) * ((double)maxProgress / (double)progress));
		progressBar.setValue(startValue + increment);
	}

	/**
	 * Checks whether the monitored process has been canceled.
	 */
	public boolean isAborted() {
		return false;
	}

}
"
XProgressListener.java,prom-framework-6.9.97,"/*
 * OpenXES
 * 
 * The reference implementation of the XES meta-model for event 
 * log data management.
 * 
 * Copyright (c) 2008 Christian W. Guenther (christian@deckfour.org)
 * 
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 * 
 * EXEMPTION:
 * 
 * The use of this software can also be conditionally licensed for
 * other programs, which do not satisfy the specified conditions. This
 * requires an exemption from the general license, which may be
 * granted on a per-case basis.
 * 
 * If you want to license the use of this software with a program
 * incompatible with the LGPL, please contact the author for an
 * exemption at the following email address: 
 * christian@deckfour.org
 * 
 */
package org.processmining.framework.util.progress;

/**
 * Interface for listening for progress on
 * an unspecified process.
 * 
 * A progress listener can abort the monitored
 * process. Abortion is specified by using the
 * <code>isAborted()</code> method, which should
 * be queried periodically by the using party.
 * 
 * @author Christian W. Guenther (christian@deckfour.org)
 *
 */
public interface XProgressListener {

	/**
	 * Notifies the listener about progress being made.
	 * 
	 * @param progress Current progress step achieved.
	 * @param maxProgress Maximal progress steps available.
	 */
	public void updateProgress(int progress, int maxProgress);
	
	/**
	 * Checks whether the monitored process has been canceled.
	 */
	public boolean isAborted();
	
}
"
ProMClassLoader.java,prom-framework-6.9.97,"package org.processmining.framework.util;

import java.net.URL;
import java.net.URLClassLoader;

public class ProMClassLoader extends URLClassLoader {

	public ProMClassLoader(ClassLoader loader) {
		super(new URL[] { }, loader);
	}
	
//	protected Class<?> findClass(String name) throws ClassNotFoundException {
//		System.err.println(""[ProMClassLoader] Find class "" + name);
//		return super.findClass(name);
//	}

//    @Override public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
//        System.out.println(""[ProMClassLoader] Load class "" + name);
//        return super.loadClass(name, resolve);
//    }
    
}
"
BreadthFirstExpandCollection.java,prom-framework-6.9.97,"package org.processmining.framework.util.search;

import java.util.Collection;

public class BreadthFirstExpandCollection<N> extends DepthFirstExpandCollection<N> {

	public void add(Collection<? extends N> newElements) {
		stack.addAll(0, newElements);
	}

}
"
DepthFirstExpandCollection.java,prom-framework-6.9.97,"package org.processmining.framework.util.search;

import java.util.Collection;
import java.util.Stack;

public class DepthFirstExpandCollection<N> implements ExpandCollection<N> {

	protected Stack<N> stack = new Stack<N>();

	public void add(Collection<? extends N> newElements) {
		stack.addAll(newElements);
	}

	public N pop() {
		return stack.pop();
	}

	public boolean isEmpty() {
		return stack.isEmpty();
	}

}
"
ExpandCollection.java,prom-framework-6.9.97,"package org.processmining.framework.util.search;

import java.util.Collection;

/**
 * 
 * @author bfvdonge
 * 
 * @param <N>
 */
public interface ExpandCollection<N> {

	/**
	 * Gets and removes the first element to be expanded by the node expander.
	 * 
	 * Implementing classes may assume that isEmpty() returns false before any
	 * call to pop, i.e. the first line of the implementation can be:
	 * <code>assert (!isEmpty())</code>
	 * 
	 * @return the first element to be investigated by the searcher.
	 */
	public N pop();

	/**
	 * Adds the given elements to the collection. Note that implementing classes
	 * may safely assume that the calling thread owns the monitor, i.e. there is
	 * no need to synchronize on the collection retained by this
	 * expandcollection and removals are allowed. Furthermore, the implementing
	 * class may decide not to include any of the given newElements if it
	 * decides that they are not to be investigated further.
	 * 
	 * @param newElements
	 *            the nodes to expand further
	 */
	public void add(Collection<? extends N> newElements);

	/**
	 * Checks whether or not the collection retained by this ExpandCollection is
	 * empty. If this method returns false, a call to pop() can be made.
	 * 
	 * @return
	 */
	public boolean isEmpty();

}
"
MultiThreadedSearcher.java,prom-framework-6.9.97,"package org.processmining.framework.util.search;

import java.rmi.server.UID;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;

import javax.swing.SwingWorker;

import org.processmining.framework.plugin.Progress;

/**
 * This class implements a multi-threaded search algorithm.
 * 
 * Internally, each instance of this class keeps a stack of objects of type N,
 * representing the nodes in the tree. Each thread pops an element off the stack
 * and asks the registered NodeExpander<N> to expand it. If the node turns out
 * to be a leaf, the expander is asked to process the leaf.
 * 
 * The use of this class is as follows (in pseudo-code):
 * 
 * <code>
 * Collection<N> initialSearchNodes;
 * Collection<N> resultCollection;
 * NodeExpander<N> expander = new NodeExpander<N>();
 * MultiThreadedSearcher<N> searcher = new MultiThreadedSearcher<N>(expander, BREADTHFIRST);
 * searcher.addInitialNodes(initialSearchNodes);
 * 
 * searcher.startSearch(executor, progress, resultCollection); 
 * </code>
 * 
 * Note that if you use this code from a plugin, you can also use:
 * 
 * <code>
 * searcher.startSearch(context.getExecutor(), context.getProgress(), resultCollection);
 * </code>
 * 
 * The progress object given to the startSearch method is only used for
 * cancellation checks, i.e. progress is never incremented.
 * 
 * @author bfvdonge
 * 
 * @param <N>
 */
public class MultiThreadedSearcher<N> {

	/**
	 * Constant representing a DEPTH-FIRST search.
	 */
	public final static int DEPTHFIRST = 0;

	/**
	 * Constant representing a BREADTH-FIRST search.
	 */
	public final static int BREADTHFIRST = 1;

	private final NodeExpander<N> expander;
	private final int threads;
	private Map<MultiThreadedSearchWorker<N>, Boolean> waiting;
	private final ExpandCollection<N> stack;

	/**
	 * Instantiates a searcher. The searcher will use as many threads as
	 * specified. Furthermore, the given expander is used for the expansion of
	 * search nodes and the processing of leaf nodes.
	 * 
	 * The searchtype can be either DEPTHFIRST, or BREADTHFIRST. In the first
	 * case, new nodes produced by the expand method of the expander are added
	 * to the bottom of the stack, whereas in the latter case, the new nodes are
	 * pushed to the top of the stack.
	 * 
	 * @param numberOfThreads
	 *            specifies the number of threads to use. If unsure how to set
	 *            this value, use the other constructor without this parameter
	 * @param expander
	 *            The expander that will be used to expand each search node and
	 *            process the leafs of the search tree
	 * @param searchType
	 *            the type of search, either DEPTHFIRST or BREADTHFIRST
	 */
	public MultiThreadedSearcher(int numberOfThreads, NodeExpander<N> expander, int searchType) {
		this.threads = numberOfThreads;
		this.expander = expander;
		if (searchType == DEPTHFIRST) {
			this.stack = new DepthFirstExpandCollection<N>();
		} else if (searchType == BREADTHFIRST) {
			this.stack = new BreadthFirstExpandCollection<N>();
		} else {
			throw new IllegalArgumentException(""Wrong search type specified."");
		}
	}

	/**
	 * Instantiates a searcher. The searcher will use as many threads as the
	 * virtual machine reports to have CPUs. Furthermore, the given expander is
	 * used for the expansion of search nodes and the processing of leaf nodes.
	 * 
	 * The searchtype can be either DEPTHFIRST, or BREADTHFIRST. In the first
	 * case, new nodes produced by the expand method of the expander are added
	 * to the bottom of the stack, whereas in the latter case, the new nodes are
	 * pushed to the top of the stack.
	 * 
	 * By default, as many threads are used as there are CPUs reported by
	 * <code>Runtime.getRuntime().availableProcessors()</code>
	 * 
	 * @param expander
	 *            The expander that will be used to expand each search node and
	 *            process the leafs of the search tree
	 * @param searchType
	 *            the type of search, either DEPTHFIRST or BREADTHFIRST
	 */
	public MultiThreadedSearcher(NodeExpander<N> expander, int searchType) {
		this(Runtime.getRuntime().availableProcessors(), expander, searchType);
	}

	/**
	 * Instantiates a searcher. The searcher will use as many threads as
	 * specified. Furthermore, the given expander is used for the expansion of
	 * search nodes and the processing of leaf nodes and the given
	 * expandCollection to store nodes that need to be expanded further.
	 * 
	 * @param numberOfThreads
	 *            specifies the number of threads to use. If unsure how to set
	 *            this value, use the other constructor without this parameter
	 * @param expander
	 *            The expander that will be used to expand each search node and
	 *            process the leafs of the search tree
	 * @param expandCollection
	 *            the collection to store nodes that need to be expanded
	 */
	public MultiThreadedSearcher(int numberOfThreads, NodeExpander<N> expander, ExpandCollection<N> expandCollection) {
		this.threads = numberOfThreads;
		this.expander = expander;
		this.stack = expandCollection;
	}

	/**
	 * Instantiates a searcher. The searcher will use as many threads as
	 * specified. Furthermore, the given expander is used for the expansion of
	 * search nodes and the processing of leaf nodes and the given
	 * expandCollection to store nodes that need to be expanded further.
	 * 
	 * By default, as many threads are used as there are CPUs reported by
	 * <code>Runtime.getRuntime().availableProcessors()</code>
	 * 
	 * @param expander
	 *            The expander that will be used to expand each search node and
	 *            process the leafs of the search tree
	 * @param expandCollection
	 *            the collection to store nodes that need to be expanded
	 */
	public MultiThreadedSearcher(NodeExpander<N> expander, ExpandCollection<N> expandCollection) {
		this(Runtime.getRuntime().availableProcessors(), expander, expandCollection);
	}

	/**
	 * Sets the initial nodes of the search tree. Note that you can provide an
	 * empty collection, in which case the search returns immediately, without
	 * calling any methods in the expander.
	 * 
	 * @param initialNodes
	 *            the collection of initial nodes.
	 */
	public void addInitialNodes(Collection<N> initialNodes) {
		synchronized (stack) {
			stack.add(initialNodes);
		}
	}

	/**
	 * Sets the initial nodes of the search tree. Note that you don't have to
	 * provide any nodes, in which case the search returns immediately, without
	 * calling any methods in the expander.
	 * 
	 * @param initialNodes
	 *            zero or more initial nodes.
	 */
	public void addInitialNodes(N... initialNodes) {
		synchronized (stack) {
			stack.add(Arrays.asList(initialNodes));
		}
	}

	/**
	 * A call to this method initiates the search. The calling thread is
	 * suspended until the search is completed, or the progress was canceled.
	 * The resultCollection given to this method is passes through to the
	 * processLeaf method of the NodeExpander, i.e. no changes to this
	 * collection are made by the searcher.
	 * 
	 * @param executor
	 *            The executor in which the searcher can schedule it's threads.
	 *            If called from a plugin, use context.getExector() to pass to
	 *            this method.
	 * @param progress
	 *            The progress which is polled for cancellation. Note that no
	 *            other changes are made to the progress. If changes are
	 *            necessary, this has to be handled by the NodeExpander. If
	 *            called from a plugin, use context.getProgress() to pass to
	 *            this method.
	 * @param resultCollection
	 *            The collection in which the final result is stored by the
	 *            processLeaf method of the node expander. Note that the
	 *            searcher does not change this collection in any way, nor does
	 *            it handle any necessary synchronization.
	 * @throws InterruptedException
	 *             If one of the threads was interupted;
	 * @throws ExecutionException
	 *             If one of the threads threw an exception;
	 */
	public void startSearch(final Executor executor, final Progress progress, final Collection<N> resultCollection)
			throws InterruptedException, ExecutionException {

		// Set the number of waiting threads to 0;
		waiting = new HashMap<MultiThreadedSearchWorker<N>, Boolean>();

		MultiThreadedSearchWorker<N> worker = null;

		// Syncrhonize on the object ""waiting"" to make sure that first all
		// workers are registered to this map, before any of them accesses it.
		synchronized (waiting) {
			for (int i = 0; i < threads; i++) {
				worker = new MultiThreadedSearchWorker<N>(this, progress, resultCollection);
				waiting.put(worker, false);
			}
		}

		for (MultiThreadedSearchWorker<N> w : waiting.keySet()) {
			executor.execute(w);
		}

		// Just synchronize on the last worker. It stops only when all workers are finished.
		worker.get();

	}

	NodeExpander<N> getExpander() {
		return expander;
	}

	ExpandCollection<N> getStack() {
		return stack;
	}

	boolean setWaiting(MultiThreadedSearchWorker<N> worker, Boolean state) {
		synchronized (waiting) {
			waiting.put(worker, state);
			return !waiting.containsValue(false);
		}
	}
}

class MultiThreadedSearchWorker<N> extends SwingWorker<Object, Void> {

	private final MultiThreadedSearcher<N> owner;
	private final Progress progress;

	private final Collection<N> resultCollection;

	private final ExpandCollection<N> stack;
	private final UID id = new UID();

	public MultiThreadedSearchWorker(MultiThreadedSearcher<N> owner, Progress progress, Collection<N> resultCollection) {
		this.owner = owner;
		this.progress = progress;
		this.resultCollection = resultCollection;
		this.stack = owner.getStack();
	}

	public int hashCode() {
		return id.hashCode();
	}

	@SuppressWarnings(""unchecked"")
	public boolean equals(Object o) {
		if (o instanceof MultiThreadedSearchWorker) {
			return id.equals(((MultiThreadedSearchWorker) o).id);
		}
		return false;
	}

	@Override
	protected Object doInBackground() throws Exception {
		while (!progress.isCancelled()) {
			// First get the node to expand
			N toExpand = getNodeToExpand(progress);
			if (toExpand == null) {
				// Cancellation occurred, or the search is finished.
				// stop execution
				synchronized (stack) {
					stack.notifyAll();
				}
				break /* while */;
			}

			// Ask the expander for new nodes. Note that this call does not 
			// synchronize on stack, hence multiple of these calls can be 
			// processed in parallel.
			Collection<N> expandFurther = owner.getExpander().expandNode(toExpand, progress, resultCollection);

			// Let the searcher process the newly found nodes. Note that this is
			// synchronized as it requires to change the stack.
			processNewNodes(toExpand, expandFurther, resultCollection, progress);
		}
		// all threads are done, so quit.
		return null;
	}

	private N getNodeToExpand(Progress progress) throws InterruptedException {
		synchronized (stack) {
			while (!progress.isCancelled()) {
				if (stack.isEmpty()) {
					// Notify the searcher that we enter the waiting state
					if (owner.setWaiting(this, true)) {
						// All threads are waiting for the stack and this is the last
						// that will start waiting. Hence, there is nothing to do anymore.
						// Stop the execution by returning null.
						return null;
					} else {
						// Let's sleep until stack is filled again.
						stack.wait();
						continue;
					}
				} else {
					// Notify the searcher that we leave the waiting state
					owner.setWaiting(this, false);
					// get the node to expand.
					N toExpand = stack.pop();
					stack.notifyAll();
					return toExpand;
				}
			}
		}
		// In case of a cancellation, throw an exception;
		owner.setWaiting(this, true);
		return null;
	}

	private void processNewNodes(N toExpand, Collection<N> expandFurther, final Collection<N> resultCollection,
			Progress progress) {
		synchronized (stack) {
			if (!expandFurther.isEmpty()) {
				// There are tuples that need to be expanded further.
				stack.add(expandFurther);
			} else {
				synchronized (resultCollection) {
					owner.getExpander().processLeaf(toExpand, progress, resultCollection);
				}
			}
			// notify threads waiting on stack
			stack.notifyAll();
		}

	}

}
"
NodeExpander.java,prom-framework-6.9.97,"package org.processmining.framework.util.search;

import java.util.Collection;

import org.processmining.framework.plugin.Progress;

/**
 * This class is used by the MultiThreadedSearcher to handle callbacks. Each
 * time the searcher considers a node, it asks the registered expander to expand
 * the node. If a node cannot be expanded, then a call to processLeaf is made.
 * The expander should not process any leafs from within the expandNode method.
 * 
 * @author bfvdonge
 * 
 * @param <N>
 */
public interface NodeExpander<N> {

	/**
	 * This method is called by the searcher when a node in the search tree has
	 * to be considered for expansion. The node to expand is given as a
	 * parameter and the method should return a collection of nodes representing
	 * the children of this node. If the node turns out to be a leaf, an empty
	 * collection has to be returned.
	 * 
	 * @param toExpand
	 *            The node to expand.
	 * @param progress
	 *            The progress indicator provided to the searcher in which this
	 *            expander is registered. The expander may increment the
	 *            progress, but it should check for cancellation, especially
	 *            when doing long computations.
	 * @param unmodifiableResultCollection
	 *            the leafs of the search space that have been added to the
	 *            resultCollection by the processLeaf method. Note that any
	 *            access to this collection should be synchronized and this
	 *            collection should not be modified in this method. However the
	 *            provided collection is modifiable, as for synchronization
	 *            purposes, the actual resultCollection is provided.
	 * @return A collection of child nodes, or an empty collection if this node
	 *         turns out to be a leaf.
	 */
	public Collection<N> expandNode(N toExpand, Progress progress, Collection<N> unmodifiableResultCollection);

	/**
	 * This method is called by the searcher to which this expander is
	 * registered each time a leaf was encountered. The provided
	 * resultCollection was specified in the startSearch method of the searcher
	 * and can be used to store this result. A typical implementation is:
	 * 
	 * <code>
	 * synchronized(resultCollection) {
	 *     resultCollection.add(leaf);
	 * }
	 * </code>
	 * 
	 * However, more advanced implementations are possible.
	 * 
	 * Finally, note that calls to this method are not thread-safe, i.e. the
	 * implementing class should take care of synchronization on the
	 * resultCollection if necessary (as in the example above).
	 * 
	 * @param leaf
	 *            The node that was found to be a leaf by the expandNode method
	 *            (i.e. the expandNode method returned and empty collection)
	 * @param progress
	 *            The progress indicator provided to the searcher in which this
	 *            expander is registered. The expander may increment the
	 *            progress, but it should check for cancellation, especially
	 *            when doing long computations.
	 * @param resultCollection
	 *            The collection to which to add the leaf node. More advanced
	 *            computations are allowed here, i.e. the resultCollection can
	 *            be changed. Note however that this requires syncrhonization on
	 *            the collection, as calls to this method are not thread-safe.
	 */
	public void processLeaf(N leaf, Progress progress, Collection<N> resultCollection);

}
"
Service.java,prom-framework-6.9.97,"package org.processmining.framework.util.socket;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executor;

import org.processmining.framework.plugin.events.Logger.MessageLevel;

/**
 * This is a wrapper for a server socket. It has an arbitrary number of
 * registered ServiceHandler-s. Whenever a client connects to the service, all
 * registered handlers are notified. Each handler can further communucate with
 * the client.
 * 
 * @author christian
 * 
 */

public class Service {

	protected ServerSocket serverSocket; // server socket
	private final int port; // port for the server socket
	protected List<ServiceHandler> handlers = new ArrayList<ServiceHandler>(); // registered handlers

	/**
	 * The only constructor, which simply sets a port to be used by the server
	 * socket. Note that the constructor does not open the server socket.
	 * 
	 * @param port
	 *            for the server socket.
	 */
	public Service(int port) {
		super();
		this.port = port;
		serverSocket = null;
	}

	/**
	 * Registers a new handler. From this moment, the handler will be notified
	 * about new client connections.
	 * 
	 * @param handler
	 *            to be registered.
	 */
	public void addServiceHandler(ServiceHandler handler) {
		handlers.add(handler);
	}

	/**
	 * Unregister the handler. From this moment, the handler will not longer be
	 * notified about new client connections.
	 * 
	 * @param handler
	 *            to be unregistered.
	 */
	public void removeServiceHandler(ServiceHandler handler) {
		handlers.remove(handler);
	}

	/**
	 * Opens the server socked on the given port. Periodically notifies the
	 * environment that the service is alive. Notifies all registered handlers
	 * about every new client connection. It keeps on listening on the socket
	 * until the environment is canceled, upon which the socket is closed.
	 * 
	 * @param environment
	 *            is the environment of this service.
	 * @param executor
	 *            enables notification of handlers in a new thread.
	 * @throws IOException
	 */
	public void start(ServiceEnvironment environment, Executor executor) throws IOException {
		serverSocket = new ServerSocket(getPort());

		while (!environment.isCancelled()) {
			try {
				environment.stillAlive();
				// wait for and handle incoming connections
				serverSocket.setSoTimeout(500);
				Socket clientSocket = serverSocket.accept();
				handleConnection(clientSocket, environment, executor);
			} catch (SocketTimeoutException e) {
				// environment.log(""No Connection Accepted"", MessageLevel.DEBUG);
				continue;
			} catch (IOException e) {
				// abort and give up
				environment.log(""Operational Support Server Failed: "" + e.getMessage(), MessageLevel.ERROR);
				serverSocket.close();
				throw e;
			}
		}
		serverSocket.close();

		environment.log(""Operational Support Server Finished"", MessageLevel.DEBUG);
	}

	/**
	 * Notifies all registered handlers about every new client connection.
	 * 
	 * @param socket
	 *            is the client socket.
	 * @param environment
	 *            is the environment of this service.
	 * @param executor
	 *            enables notification of handlers in a new thread.
	 */
	protected void handleConnection(Socket socket, ServiceEnvironment environment, Executor executor) {
		ConnectionHandlerRunnable handler = new ConnectionHandlerRunnable(socket, environment);
		executor.execute(handler);
	}

	/**
	 * Get the server port.
	 * 
	 * @return the port.
	 */
	public int getPort() {
		return port;
	}

	/**
	 * A simple class that enables notification of ServiceHandler-s in a new
	 * thread.
	 * 
	 * @author christian
	 * 
	 */
	protected class ConnectionHandlerRunnable implements Runnable {

		protected Socket clientSocket;
		private final ServiceEnvironment environment;

		public ConnectionHandlerRunnable(Socket aSocket, ServiceEnvironment environment) {
			clientSocket = aSocket;
			this.environment = environment;
		}

		/**
		 * Notifies all registered handlers about a new client connection in a
		 * new thread.
		 */
		public void run() {
			try {
				BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
				PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);
				for (ServiceHandler handler : handlers) {
					handler.handleRequest(environment, in, out);
				}
			} catch (IOException e) {
				// abort and give up

				environment.log(""Fatal error handling connection,"", MessageLevel.ERROR);
				environment.log(""failed with IO Exception:"", MessageLevel.ERROR);
				environment.log(e);
			} finally {
				// clean up connection
				try {
					if (clientSocket != null) {
						clientSocket.close();
					}
				} catch (IOException ie) { /* this one's forsaken.. */
				}
			}
		}
	}

}
"
ServiceEnvironment.java,prom-framework-6.9.97,"package org.processmining.framework.util.socket;

import org.processmining.framework.plugin.events.Logger.MessageLevel;

/**
 * This interface represents a service environment. It allows communication
 * between a service and its environment.
 * 
 * @author Maja Pesic
 */

public interface ServiceEnvironment {

	/**
	 * Provides the information about the state of the environment. A service
	 * uses this method to decide when to close its socket.
	 * 
	 * @return true - if the socket should be closed false - if the service
	 *         should continue listening on the socket.
	 */
	public boolean isCancelled();

	/**
	 * A service uses this method to log messages in the environment.
	 * 
	 * @param message
	 *            is the message that should be logged
	 * @param level
	 *            is the type of message
	 */
	public void log(String message, MessageLevel level);

	/**
	 * A service uses this method to log messages in the environment.
	 * 
	 * @param message
	 *            is the message that should be logged
	 */
	public void log(String message);

	/**
	 * A service uses this method to log occurrence of an exception in the
	 * environment.
	 * 
	 * @param t
	 *            is the exception that occurred and should be logged
	 */
	public void log(Throwable t);

	/**
	 * While listening on its socket, a service will regularly invoke this
	 * method. This method periodically signals to the environment that the
	 * service is still listening to its socket.
	 */
	public void stillAlive();

	/**
	 * A service uses this method to signal that it has been canceled (i.e., the
	 * socket is closed).
	 */
	public void cancel();

}
"
ServiceHandler.java,prom-framework-6.9.97,"package org.processmining.framework.util.socket;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;

/**
 * This interface enables a service to respond to newly connected clients. If a
 * class wants to be informed about and/or respond to new requests of a service,
 * then this class should implement this interface and it should be added as a
 * handler to the service.
 * 
 * @author christian
 */

public interface ServiceHandler {
	/**
	 * Invoked whenever a client connects to the service.
	 * 
	 * @param environment
	 *            is the registered environment of the service. A handler can
	 *            use this parameter to, for example, log messages.
	 * @param in
	 *            is the buffer from which the client's request can be read.
	 * @param out
	 *            is the buffer where a possible response to the client can be
	 *            written.
	 * @throws IOException
	 */
	public void handleRequest(ServiceEnvironment environment, BufferedReader in, PrintWriter out) throws IOException;
}
"
StringUtils.java,prom-framework-6.9.97,"package org.processmining.framework.util;

public class StringUtils {

	private StringUtils() {

	}

	public static String getJavaIdentifier(String name) {
		StringBuffer result = new StringBuffer();
		boolean underscoreAdded = false;

		name = name.toLowerCase().trim();
		for (int i = 0; i < name.length(); i++) {
			char c = name.charAt(i);
			if ((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z'))
					|| ((result.length() > 0) && ('0' <= c) && (c <= '9'))) {
				result.append(c);
				underscoreAdded = false;
			} else if (!underscoreAdded) {
				result.append(""_"");
				underscoreAdded = true;
			}
		}
		return result.toString();
	}

}
"
ExpandButton.java,prom-framework-6.9.97,"package org.processmining.framework.util.ui;

/*
 * Copyright (c) 2007 Christian W. Guenther (christian@deckfour.org)
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 * 
 * EXEMPTION:
 * 
 * License to link and use is also granted to open source programs which are not
 * licensed under the terms of the GPL, given that they satisfy one or more of
 * the following conditions: 1) Explicit license is granted to the ProM and
 * ProMimport programs for usage, linking, and derivative work. 2) Carte blance
 * license is granted to all programs developed at Eindhoven Technical
 * University, The Netherlands, or under the umbrella of STW Technology
 * Foundation, The Netherlands. For further exemptions not covered by the above
 * conditions, please contact the author of this code.
 */

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.BorderFactory;
import javax.swing.JButton;

/**
 * @author Christian W. Guenther (christian@deckfour.org)
 * 
 */
public class ExpandButton extends JButton {

	private static final long serialVersionUID = -8427659617273150458L;

	protected Color colorTriangle = new Color(220, 220, 220, 220);

	protected boolean isExpanded = false;
	protected boolean mouseOver = false;

	public ExpandButton() {
		setOpaque(false);
		setBorder(BorderFactory.createEmptyBorder());
		Dimension size = new Dimension(21, 21);
		setMinimumSize(size);
		setMaximumSize(size);
		setPreferredSize(size);
		addMouseListener(new MouseListener() {
			public void mouseClicked(MouseEvent arg0) { /* ignore */
			}

			public void mouseEntered(MouseEvent arg0) {
				mouseOver = true;
				repaint();
			}

			public void mouseExited(MouseEvent arg0) {
				mouseOver = false;
				repaint();
			}

			public void mousePressed(MouseEvent arg0) { /* ignore */
			}

			public void mouseReleased(MouseEvent arg0) { /* ignore */
			}
		});
	}

	public boolean isExpanded() {
		return isExpanded;
	}

	public void setExpanded(boolean expanded) {
		isExpanded = expanded;
		repaint();
	}

	protected void paintComponent(Graphics g) {
		Graphics2D g2d = (Graphics2D) g.create();
		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		int y[] = new int[] { 5, 15, 5 };
		int x[] = new int[] { 5, 10, 15 };
		g2d.setColor(colorTriangle);
		if (mouseOver == false) {
			g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.7f));
		}
		if (isExpanded == true) {
			g2d.fillPolygon(x, y, 3);
		} else {
			g2d.fillPolygon(y, x, 3);
		}
		g2d.dispose();
	}

}
"
SlickerConsole.java,prom-framework-6.9.97,"package org.processmining.framework.util.ui;

/*
 * Copyright (c) 2007 Christian W. Guenther (christian@deckfour.org)
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 * 
 * EXEMPTION:
 * 
 * License to link and use is also granted to open source programs which are not
 * licensed under the terms of the GPL, given that they satisfy one or more of
 * the following conditions: 1) Explicit license is granted to the ProM and
 * ProMimport programs for usage, linking, and derivative work. 2) Carte blance
 * license is granted to all programs developed at Eindhoven Technical
 * University, The Netherlands, or under the umbrella of STW Technology
 * Foundation, The Netherlands. For further exemptions not covered by the above
 * conditions, please contact the author of this code.
 */

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.geom.Rectangle2D;
import java.io.File;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;

import org.processmining.framework.plugin.events.Logger.MessageLevel;

/**
 * @author Christian W. Guenther (christian@deckfour.org)
 * 
 */
public class SlickerConsole extends JComponent {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1434476056589473230L;

	protected static SimpleDateFormat dateFormat = new SimpleDateFormat(""HH:mm:ss"");

	protected static File logFile;
	protected static File testFile;

	protected Color colorBg = new Color(30, 30, 30);
	protected Color colorFontBg = new Color(20, 20, 20, 140);
	public static Color colorNormal = new Color(250, 250, 250, 180);
	public static Color colorWarning = new Color(240, 200, 40, 200);
	public static Color colorError = new Color(250, 40, 40, 200);
	public static Color colorDebug = new Color(170, 170, 160, 200);
	public static Color colorTest = new Color(20, 250, 20, 200);

	protected ArrayList<String> messages;
	protected ArrayList<MessageLevel> types;
	protected ArrayList<String> timestamps;
	protected int maxSize;

	protected boolean showMessages = true;
	protected boolean showWarnings = true;
	protected boolean showErrors = true;
	protected boolean showDebug = true;
	protected boolean showTest = true;

	protected boolean expanded;
	protected int lineHeight;
	protected int stringHeight;
	protected int leftBorder = 10;

	public SlickerConsole(int bufferSize) {
		setFont((new JLabel()).getFont().deriveFont(12f));
		FontMetrics fm = getFontMetrics(getFont());
		lineHeight = fm.getHeight();
		stringHeight = fm.getLeading() + fm.getAscent();
		messages = new ArrayList<String>();
		types = new ArrayList<MessageLevel>();
		timestamps = new ArrayList<String>();
		maxSize = bufferSize;
		expanded = false;
		int height = lineHeight + 10;
		setMinimumSize(new Dimension(400, height));
		setMaximumSize(new Dimension(6000, height));
		setPreferredSize(new Dimension(2000, height));

		addAncestorListener(new AncestorListener() {
			public void ancestorAdded(AncestorEvent arg0) {
				if (expanded == true) {
					scrollToBottom();
				}
			}

			public void ancestorMoved(AncestorEvent arg0) { /* ignore */
			}

			public void ancestorRemoved(AncestorEvent arg0) { /* ignore */
			}
		});
	}

	public void setExpanded(boolean expanded) {
		this.expanded = expanded;
		int height = lineHeight + 10;
		if (expanded == true) {
			height = (messages.size() * lineHeight) + 15;
		}
		setMinimumSize(new Dimension(600, height));
		setMaximumSize(new Dimension(6000, height));
		setPreferredSize(new Dimension(4000, height));
		if (expanded == true) {
			setMaximumSize(new Dimension(6000, 2000));
			scrollToBottom();
		}
		revalidate();
		repaint();
	}

	public void receiveMessage(String text, MessageLevel type) {
		String timestamp = dateFormat.format(new Date(System.currentTimeMillis()));

		if (((type == MessageLevel.NORMAL) && (showMessages == false))
				|| ((type == MessageLevel.WARNING) && (showWarnings == false))
				|| ((type == MessageLevel.ERROR) && (showErrors == false))
				|| ((type == MessageLevel.DEBUG) && (showDebug == false))
				|| ((type == MessageLevel.TEST) && (showTest == false))) {
			return; // filtered
		}
		// add to message log
		messages.add(text);
		types.add(type);
		timestamps.add(timestamp);
		if (messages.size() <= maxSize) {
			if (expanded == true) {
				int height = messages.size() * lineHeight + 15;
				setMinimumSize(new Dimension(600, height));
				setMaximumSize(new Dimension(6000, 2000));
				setPreferredSize(new Dimension(4000, height));
				scrollToBottom();
			}
		} else {
			messages.remove(0);
			types.remove(0);
			timestamps.remove(0);
		}
		revalidate();
		repaint();
	}

	public void scrollToBottom() {
		scrollRectToVisible(new Rectangle(-23, getHeight() - 2, 25, 25));
		revalidate();
		repaint();
	}

	protected void paintComponent(Graphics g) {
		Rectangle2D clip = g.getClipBounds();
		Graphics2D g2d = (Graphics2D) g;
		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		g2d.setFont(getFont());
		if (messages.size() == 0) {
			return; // nothing to draw
		}
		if (expanded == true) {
			int startY = (int) clip.getY() - ((int) clip.getY() % lineHeight);
			int index = (startY / lineHeight);
			int endY = (int) (clip.getY() + clip.getHeight());
			while (startY <= endY) {
				drawLine(index, leftBorder, startY + stringHeight, g2d, false);
				startY += lineHeight;
				index++;
			}
		} else {
			int fontY = ((getHeight() - lineHeight) / 2) + stringHeight;
			drawLine(messages.size() - 1, leftBorder, fontY, g2d, true);
		}
	}

	protected void drawLine(int index, int x, int y, Graphics2D g2d, boolean shadow) {
		if ((index < 0) || (index >= messages.size())) {
			return;
		}
		// set appropriate font color
		String prefix = timestamps.get(index);
		Color fontColor = Color.WHITE;
		if (types.get(index) == MessageLevel.NORMAL) {
			fontColor = colorNormal;
			prefix += "" [M] "";
		} else if (types.get(index) == MessageLevel.WARNING) {
			fontColor = colorWarning;
			prefix += "" [W] "";
		} else if (types.get(index) == MessageLevel.ERROR) {
			fontColor = colorError;
			prefix += "" [E] "";
		} else if (types.get(index) == MessageLevel.DEBUG) {
			fontColor = colorDebug;
			prefix += "" [D] "";
		} else if (types.get(index) == MessageLevel.TEST) {
			fontColor = colorTest;
			prefix += "" [T] "";
		}
		if (shadow == true) {
			g2d.setColor(colorFontBg);
			g2d.drawString(prefix + messages.get(index), x + 1, y + 1);
		}
		g2d.setColor(fontColor);
		g2d.drawString(prefix + messages.get(index), x, y);
	}

	/**
	 * @return the showMessages
	 */
	public boolean isShowMessages() {
		return showMessages;
	}

	/**
	 * @param showMessages
	 *            the showMessages to set
	 */
	public void setShowMessages(boolean showMessages) {
		this.showMessages = showMessages;
	}

	/**
	 * @return the showWarnings
	 */
	public boolean isShowWarnings() {
		return showWarnings;
	}

	/**
	 * @param showWarnings
	 *            the showWarnings to set
	 */
	public void setShowWarnings(boolean showWarnings) {
		this.showWarnings = showWarnings;
	}

	/**
	 * @return the showErrors
	 */
	public boolean isShowErrors() {
		return showErrors;
	}

	/**
	 * @param showErrors
	 *            the showErrors to set
	 */
	public void setShowErrors(boolean showErrors) {
		this.showErrors = showErrors;
	}

	/**
	 * @return the showDebug
	 */
	public boolean isShowDebug() {
		return showDebug;
	}

	/**
	 * @param showDebug
	 *            the showDebug to set
	 */
	public void setShowDebug(boolean showDebug) {
		this.showDebug = showDebug;
	}

	/**
	 * @return the showTest
	 */
	public boolean isShowTest() {
		return showTest;
	}

	/**
	 * @param showTest
	 *            the showTest to set
	 */
	public void setShowTest(boolean showTest) {
		this.showTest = showTest;
	}

}
"
SlickerMessageBar.java,prom-framework-6.9.97,"package org.processmining.framework.util.ui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JPanel;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;

import org.processmining.framework.plugin.events.Logger.MessageLevel;

import com.fluxicon.slickerbox.components.GradientPanel;
import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.ui.SlickerScrollBarUI;

public class SlickerMessageBar extends GradientPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 3098268894613400200L;
	protected static Color colorTop = new Color(90, 90, 90);
	protected static Color colorBottom = new Color(40, 40, 40);
	protected static Color colorBorder = new Color(60, 60, 60);

	protected SlickerConsole console;
	protected RoundedPanel largeConsolePanel;
	protected JPanel expandPanel;
	protected ExpandButton expand;
	protected JScrollPane largeConsoleScrollPane;
	protected JPanel filterPanel;
	private final TypeToggleButton messageButton;
	private final TypeToggleButton warningButton;
	private final TypeToggleButton errorButton;
	private final TypeToggleButton debugButton;
	private final TypeToggleButton testButton;

	/**
	 * @param colorTop
	 * @param colorBottom
	 */
	public SlickerMessageBar() {
		super(colorTop, colorBottom);
		//this.setBorder(BorderFactory.createLineBorder(colorBorder));
		console = new SlickerConsole(300);
		largeConsolePanel = new RoundedPanel(10, 6, 0);
		largeConsolePanel.setBackground(new Color(20, 20, 20, 160));
		largeConsolePanel.setLayout(new BorderLayout());
		largeConsoleScrollPane = new JScrollPane();
		largeConsoleScrollPane.setOpaque(false);
		largeConsoleScrollPane.getViewport().setOpaque(false);
		largeConsoleScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		largeConsoleScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		JScrollBar vBar = largeConsoleScrollPane.getVerticalScrollBar();
		vBar.setUI(new SlickerScrollBarUI(vBar, new Color(0, 0, 0, 0), new Color(140, 140, 140), new Color(110, 110,
				110), 4, 12));
		largeConsoleScrollPane.setBorder(BorderFactory.createEmptyBorder());
		largeConsolePanel.add(largeConsoleScrollPane, BorderLayout.CENTER);
		expandPanel = new JPanel();
		expandPanel.setLayout(new BoxLayout(expandPanel, BoxLayout.Y_AXIS));
		expandPanel.setMinimumSize(new Dimension(30, 23));
		expandPanel.setMaximumSize(new Dimension(30, 1000));
		expandPanel.setPreferredSize(new Dimension(30, 500));
		expandPanel.setOpaque(false);
		expand = new ExpandButton();
		expand.setExpanded(false);
		expand.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				toggleExpanded();
			}
		});
		expandPanel.add(Box.createVerticalGlue());
		setLayout(new BorderLayout());
		this.add(expandPanel, BorderLayout.WEST);
		this.add(console, BorderLayout.CENTER);
		setMinimumSize(new Dimension(600, 23));
		setMaximumSize(new Dimension(3000, 23));
		setPreferredSize(new Dimension(2000, 23));
		filterPanel = new JPanel();
		filterPanel.setOpaque(false);
		filterPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
		filterPanel.setLayout(new BoxLayout(filterPanel, BoxLayout.Y_AXIS));
		messageButton = new TypeToggleButton(""messages"", ""M"", SlickerConsole.colorNormal);
		messageButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				console.setShowMessages(!console.isShowMessages());
			}
		});
		warningButton = new TypeToggleButton(""warnings"", ""W"", SlickerConsole.colorWarning);
		warningButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				console.setShowWarnings(!console.isShowWarnings());
			}
		});
		errorButton = new TypeToggleButton(""errors"", ""E"", SlickerConsole.colorError);
		errorButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				console.setShowErrors(!console.isShowErrors());
			}
		});
		debugButton = new TypeToggleButton(""debug messages"", ""D"", SlickerConsole.colorDebug);
		debugButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				console.setShowDebug(!console.isShowDebug());
			}
		});
		testButton = new TypeToggleButton(""test messages"", ""T"", SlickerConsole.colorTest);
		testButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				console.setShowTest(!console.isShowTest());
			}
		});
		filterPanel.add(messageButton);
		filterPanel.add(warningButton);
		filterPanel.add(errorButton);
		filterPanel.add(debugButton);
		filterPanel.add(testButton);
		filterPanel.add(Box.createVerticalGlue());
		expand.doClick();
	}

	public void toggleExpanded() {
		expand.setExpanded(!expand.isExpanded());
		toggleDimension();
	}

	public void receiveMessage(String text, MessageLevel type) {
		console.receiveMessage(text, type);
	}

	protected void toggleDimension() {
		removeAll();
		this.add(expandPanel, BorderLayout.WEST);
		if (expand.isExpanded() == true) {
			setMinimumSize(new Dimension(600, 200));
			setMaximumSize(new Dimension(3000, 200));
			setPreferredSize(new Dimension(1000, 200));
			console.setExpanded(true);
			largeConsolePanel = new RoundedPanel(10, 6, 0);
			largeConsolePanel.setBackground(new Color(20, 20, 20, 160));
			largeConsolePanel.setLayout(new BorderLayout());
			largeConsoleScrollPane = new JScrollPane();
			largeConsoleScrollPane.setOpaque(false);
			largeConsoleScrollPane.getViewport().setOpaque(false);
			largeConsoleScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
			largeConsoleScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
			JScrollBar vBar = largeConsoleScrollPane.getVerticalScrollBar();
			vBar.setUI(new SlickerScrollBarUI(vBar, new Color(0, 0, 0, 0), new Color(140, 140, 140), new Color(110,
					110, 110), 4, 12));
			vBar.setOpaque(false);
			largeConsoleScrollPane.setBorder(BorderFactory.createEmptyBorder());
			largeConsolePanel.add(largeConsoleScrollPane, BorderLayout.CENTER);
			expandPanel.removeAll();
			expandPanel.add(expand);
			expandPanel.add(filterPanel);
			expandPanel.add(Box.createVerticalGlue());
			this.add(largeConsolePanel, BorderLayout.CENTER);
			revalidate();
			largeConsoleScrollPane.getViewport().setView(console);
			revalidate();
			console.scrollToBottom();
			repaint();
		} else {
			setMinimumSize(new Dimension(600, 23));
			setMaximumSize(new Dimension(3000, 23));
			setPreferredSize(new Dimension(2000, 23));
			console.setExpanded(false);
			this.add(console, BorderLayout.CENTER);
			expandPanel.removeAll();
			expandPanel.add(expand);
			expandPanel.add(Box.createVerticalGlue());
			revalidate();
			repaint();
		}
		revalidate();
		repaint();
	}

	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		int width = getWidth();
		Graphics2D g2d = (Graphics2D) g;
		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		g2d.setColor(new Color(0, 0, 0, 180));
		g2d.drawLine(0, 0, width - 1, 0);
		g2d.setColor(new Color(0, 0, 0, 90));
		g2d.drawLine(0, 1, width - 1, 1);
	}

	/**
	 * @return the showMessages
	 */
	public boolean isShowMessages() {
		return console.isShowMessages();
	}

	/**
	 * @param showMessages
	 *            the showMessages to set
	 */
	public void setShowMessages(boolean showMessages) {
		if (isShowMessages() != showMessages) {
			messageButton.doClick();
		}
	}

	/**
	 * @return the showWarnings
	 */
	public boolean isShowWarnings() {
		return console.isShowWarnings();
	}

	/**
	 * @param showWarnings
	 *            the showWarnings to set
	 */
	public void setShowWarnings(boolean showWarnings) {
		if (isShowWarnings() != showWarnings) {
			warningButton.doClick();
		}
	}

	/**
	 * @return the showErrors
	 */
	public boolean isShowErrors() {
		return console.isShowErrors();
	}

	/**
	 * @param showErrors
	 *            the showErrors to set
	 */
	public void setShowErrors(boolean showErrors) {
		if (isShowErrors() != showErrors) {
			errorButton.doClick();
		}
	}

	/**
	 * @return the showDebug
	 */
	public boolean isShowDebug() {
		return console.isShowDebug();
	}

	/**
	 * @param showDebug
	 *            the showDebug to set
	 */
	public void setShowDebug(boolean showDebug) {
		if (isShowDebug() != showDebug) {
			debugButton.doClick();
		}
	}

	/**
	 * @return the showTest
	 */
	public boolean isShowTest() {
		return console.isShowTest();
	}

	/**
	 * @param showTest
	 *            the showTest to set
	 */
	public void setShowTest(boolean showTest) {
		if (isShowTest() != showTest) {
			testButton.doClick();
		}
	}

}
"
TypeToggleButton.java,prom-framework-6.9.97,"package org.processmining.framework.util.ui;

/*
 * Copyright (c) 2007 Christian W. Guenther (christian@deckfour.org)
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 * 
 * EXEMPTION:
 * 
 * License to link and use is also granted to open source programs which are not
 * licensed under the terms of the GPL, given that they satisfy one or more of
 * the following conditions: 1) Explicit license is granted to the ProM and
 * ProMimport programs for usage, linking, and derivative work. 2) Carte blance
 * license is granted to all programs developed at Eindhoven Technical
 * University, The Netherlands, or under the umbrella of STW Technology
 * Foundation, The Netherlands. For further exemptions not covered by the above
 * conditions, please contact the author of this code.
 */

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.Rectangle2D;

import javax.swing.BorderFactory;
import javax.swing.JButton;

/**
 * @author Christian W. Guenther (christian@deckfour.org)
 * 
 */
public class TypeToggleButton extends JButton {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8489141352439288484L;
	protected Color colorPassive = new Color(90, 90, 90, 200);
	protected Color colorTextPassive = new Color(180, 180, 180, 200);
	protected Color colorTextActive = new Color(10, 10, 10, 200);
	protected FontMetrics metrics;
	protected int size = 20;

	protected boolean mouseOver = false;
	protected boolean buttonIsEnabled = true;

	protected String type;
	protected String letter;
	protected Color active;

	public TypeToggleButton(String type, String letter, Color active) {
		setOpaque(false);
		setBorder(BorderFactory.createEmptyBorder());
		setToolTipText(""Click to disable "" + type);
		this.type = type;
		this.letter = letter;
		this.active = active;
		setFont(getFont().deriveFont(12f));
		metrics = getFontMetrics(getFont());
		addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				setButtonEnabled(!buttonIsEnabled);
			}
		});
		addMouseListener(new MouseListener() {
			public void mouseClicked(MouseEvent arg0) { /* ignore */
			}

			public void mouseEntered(MouseEvent arg0) {
				mouseOver = true;
				repaint();
			}

			public void mouseExited(MouseEvent arg0) {
				mouseOver = false;
				repaint();
			}

			public void mousePressed(MouseEvent arg0) { /* ignore */
			}

			public void mouseReleased(MouseEvent arg0) { /* ignore */
			}
		});
		Dimension dim = new Dimension(size + 4, size + 4);
		setMinimumSize(dim);
		setMaximumSize(dim);
		setPreferredSize(dim);
	}

	public boolean isEnabled() {
		return buttonIsEnabled;
	}

	public void setButtonEnabled(boolean enabled) {
		buttonIsEnabled = enabled;
		if (buttonIsEnabled == true) {
			setToolTipText(""Click to disable "" + type);
		} else {
			setToolTipText(""Click to enable "" + type);
		}
		repaint();
	}

	protected void paintComponent(Graphics g) {
		int width = getWidth();
		int height = getHeight();
		Graphics2D g2d = (Graphics2D) g.create();
		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		if (mouseOver == false) {
			g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.8f));
		}
		if (buttonIsEnabled == true) {
			g2d.setColor(active);
		} else {
			g2d.setColor(colorPassive);
		}
		g2d.fillRoundRect(((width - size) / 2), ((height - size) / 2), size - 1, size - 1, 8, 8);
		if (buttonIsEnabled == true) {
			g2d.setColor(colorTextActive);
		} else {
			g2d.setColor(colorTextPassive);
		}
		Rectangle2D stringBounds = metrics.getStringBounds(letter, g2d);
		int fontX = (width - (int) stringBounds.getWidth()) / 2;
		int fontY = ((height - (int) stringBounds.getHeight()) / 2) + metrics.getAscent();
		g2d.drawString(letter, fontX, fontY);
		g2d.dispose();
	}

}
"
WeakValueHashMap.java,prom-framework-6.9.97,"package org.processmining.framework.util;

/*
 * The contents of this file are subject to the terms of the Common Development
 * and Distribution License (the ""License""). You may not use this file except in
 * compliance with the License.
 * 
 * You can obtain a copy of the license at
 * glassfish/bootstrap/legal/CDDLv1.0.txt or
 * https://glassfish.dev.java.net/public/CDDLv1.0.html. See the License for the
 * specific language governing permissions and limitations under the License.
 * 
 * When distributing Covered Code, include this CDDL HEADER in each file and
 * include the License file at glassfish/bootstrap/legal/CDDLv1.0.txt. If
 * applicable, add the following below this CDDL HEADER, with the fields
 * enclosed by brackets ""[]"" replaced with your own identifying information:
 * Portions Copyright [yyyy] [name of copyright owner]
 */

/*
 * Copyright 2005 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.AbstractCollection;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

/**
 * A WeakValueHashMap is implemented as a HashMap that maps keys to WeakValues.
 * Because we don't have access to the innards of the HashMap, we have to
 * wrap/unwrap value objects with WeakValues on every operation. Fortunately
 * WeakValues are small, short-lived objects, so the added allocation overhead
 * is tolerable. This implementaton directly extends java.util.HashMap.
 * 
 * @author Markus Fuchs
 * @see java.util.HashMap
 * @see java.lang.ref.WeakReference
 */

@SuppressWarnings({ ""rawtypes"", ""unchecked"" })
public class WeakValueHashMap extends HashMap {

	private static final long serialVersionUID = 5475499430802156108L;
	/* Reference queue for cleared WeakValues */
	private ReferenceQueue queue = new ReferenceQueue();

	/**
	 * Returns the number of key-value mappings in this map.
	 * <p>
	 * 
	 * @return the number of key-value mappings in this map.
	 */
	public int size() {
		// delegate to entrySet, as super.size() also counts WeakValues
		return entrySet().size();
	}

	/**
	 * Returns <tt>true</tt> if this map contains no key-value mappings.
	 * <p>
	 * 
	 * @return <tt>true</tt> if this map contains no key-value mappings.
	 */
	public boolean isEmpty() {
		return size() == 0;
	}

	/**
	 * Returns <tt>true</tt> if this map contains a mapping for the specified
	 * key.
	 * <p>
	 * 
	 * @param key
	 *            key whose presence in this map is to be tested
	 * @return <tt>true</tt> if this map contains a mapping for the specified
	 *         key.
	 */
	public boolean containsKey(Object key) {
		// need to clean up gc'ed values before invoking super method
		processQueue();
		return super.containsKey(key);
	}

	/**
	 * Returns <tt>true</tt> if this map maps one or more keys to the specified
	 * value.
	 * <p>
	 * 
	 * @param value
	 *            value whose presence in this map is to be tested
	 * @return <tt>true</tt> if this map maps one or more keys to this value.
	 */
	public boolean containsValue(Object value) {
		return super.containsValue(WeakValue.create(value));
	}

	/**
	 * Gets the value for the given key.
	 * <p>
	 * 
	 * @param key
	 *            key whose associated value, if any, is to be returned
	 * @return the value to which this map maps the specified key.
	 */
	public Object get(Object key) {
		// We don't need to remove garbage collected values here;
		// if they are garbage collected, the get() method returns null;
		// the next put() call with the same key removes the old value
		// automatically so that it can be completely garbage collected
		return getReferenceObject((WeakReference) super.get(key));
	}

	/**
	 * Puts a new (key,value) into the map.
	 * <p>
	 * 
	 * @param key
	 *            key with which the specified value is to be associated.
	 * @param value
	 *            value to be associated with the specified key.
	 * @return previous value associated with specified key, or null if there
	 *         was no mapping for key or the value has been garbage collected by
	 *         the garbage collector.
	 */
	public Object put(Object key, Object value) {
		// If the map already contains an equivalent key, the new key
		// of a (key, value) pair is NOT stored in the map but the new
		// value only. But as the key is strongly referenced by the
		// map, it can not be removed from the garbage collector, even
		// if the key becomes weakly reachable due to the old
		// value. So, it isn't necessary to remove all garbage
		// collected values with their keys from the map before the
		// new entry is made. We only clean up here to distribute
		// clean up calls on different operations.
		processQueue();

		WeakValue oldValue = (WeakValue) super.put(key, WeakValue.create(key, value, queue));
		return getReferenceObject(oldValue);
	}

	/**
	 * Removes key and value for the given key.
	 * <p>
	 * 
	 * @param key
	 *            key whose mapping is to be removed from the map.
	 * @return previous value associated with specified key, or null if there
	 *         was no mapping for key or the value has been garbage collected by
	 *         the garbage collector.
	 */
	public Object remove(Object key) {
		return getReferenceObject((WeakReference) super.remove(key));
	}

	/**
	 * A convenience method to return the object held by the weak reference or
	 * <code>null</code> if it does not exist.
	 */
	private final Object getReferenceObject(WeakReference ref) {
		return (ref == null) ? null : ref.get();
	}

	/**
	 * Removes all garbage collected values with their keys from the map. Since
	 * we don't know how much the ReferenceQueue.poll() operation costs, we
	 * should not call it every map operation.
	 */
	private void processQueue() {
		WeakValue wv = null;

		while ((wv = (WeakValue) this.queue.poll()) != null) {
			// ""super"" is not really necessary but use it
			// to be on the safe side
			super.remove(wv.key);
		}
	}

	/* -- Helper classes -- */

	/**
	 * We need this special class to keep the backward reference from the value
	 * to the key, so that we are able to remove the key if the value is garbage
	 * collected.
	 */
	private static class WeakValue extends WeakReference {
		/**
		 * It's the same as the key in the map. We need the key to remove the
		 * value if it is garbage collected.
		 */
		private Object key;

		private WeakValue(Object value) {
			super(value);
		}

		/**
		 * Creates a new weak reference without adding it to a ReferenceQueue.
		 */
		private static WeakValue create(Object value) {
			if (value == null)
				return null;
			else
				return new WeakValue(value);
		}

		private WeakValue(Object key, Object value, ReferenceQueue queue) {
			super(value, queue);
			this.key = key;
		}

		/**
		 * Creates a new weak reference and adds it to the given queue.
		 */
		private static WeakValue create(Object key, Object value, ReferenceQueue queue) {
			if (value == null)
				return null;
			else
				return new WeakValue(key, value, queue);
		}

		/**
		 * A WeakValue is equal to another WeakValue iff they both refer to
		 * objects that are, in turn, equal according to their own equals
		 * methods.
		 */
		public boolean equals(Object obj) {
			if (this == obj)
				return true;

			if (!(obj instanceof WeakValue))
				return false;

			Object ref1 = this.get();
			Object ref2 = ((WeakValue) obj).get();

			if (ref1 == ref2)
				return true;

			if ((ref1 == null) || (ref2 == null))
				return false;

			return ref1.equals(ref2);
		}

		/**
         *
         */
		public int hashCode() {
			Object ref = this.get();

			return (ref == null) ? 0 : ref.hashCode();
		}
	}

	/**
	 * Internal class for entries. This class wraps/unwraps the values of the
	 * Entry objects returned from the underlying map.
	 */
	private class Entry implements Map.Entry {
		private Map.Entry ent;
		private Object value; /*
							 * Strong reference to value, so that the GC will
							 * leave it alone as long as this Entry exists
							 */

		Entry(Map.Entry ent, Object value) {
			this.ent = ent;
			this.value = value;
		}

		public Object getKey() {
			return ent.getKey();
		}

		public Object getValue() {
			return value;
		}

		public Object setValue(Object value) {
			// This call changes the map. Please see the comment on 
			// the put method for the correctness remark.
			Object oldValue = this.value;
			this.value = value;
			ent.setValue(WeakValue.create(getKey(), value, queue));
			return oldValue;
		}

		private boolean valEquals(Object o1, Object o2) {
			return (o1 == null) ? (o2 == null) : o1.equals(o2);
		}

		public boolean equals(Object o) {
			if (!(o instanceof Map.Entry))
				return false;
			Map.Entry e = (Map.Entry) o;
			return (valEquals(ent.getKey(), e.getKey()) && valEquals(value, e.getValue()));
		}

		public int hashCode() {
			Object k;
			return ((((k = ent.getKey()) == null) ? 0 : k.hashCode()) ^ ((value == null) ? 0 : value.hashCode()));
		}

	}

	/**
	 * Internal class for entry sets to unwrap/wrap WeakValues stored in the
	 * map.
	 */
	private class EntrySet extends AbstractSet {

		public Iterator iterator() {
			// remove garbage collected elements
			processQueue();

			return new Iterator() {
				Iterator hashIterator = hashEntrySet.iterator();
				Entry next = null;

				public boolean hasNext() {
					if (hashIterator.hasNext()) {
						// since we removed garbage collected elements,
						// we can simply return the next entry.
						Map.Entry ent = (Map.Entry) hashIterator.next();
						WeakValue wv = (WeakValue) ent.getValue();
						Object v = (wv == null) ? null : wv.get();
						next = new Entry(ent, v);
						return true;
					}
					return false;
				}

				public Object next() {
					if ((next == null) && !hasNext())
						throw new NoSuchElementException();
					Entry e = next;
					next = null;
					return e;
				}

				public void remove() {
					hashIterator.remove();
				}

			};
		}

		public boolean isEmpty() {
			return !(iterator().hasNext());
		}

		public int size() {
			int j = 0;
			for (Iterator i = iterator(); i.hasNext(); i.next())
				j++;
			return j;
		}

		public boolean remove(Object o) {
			if (!(o instanceof Map.Entry))
				return false;
			Map.Entry e = (Map.Entry) o;
			Object ek = e.getKey();
			Object ev = e.getValue();
			Object hv = WeakValueHashMap.this.get(ek);
			if (hv == null) {
				// if the map's value is null, we have to check, if the
				// entry's value is null and the map contains the key
				if ((ev == null) && WeakValueHashMap.this.containsKey(ek)) {
					WeakValueHashMap.this.remove(ek);
					return true;
				} else {
					return false;
				}
				// otherwise, simply compare the values
			} else if (hv.equals(ev)) {
				WeakValueHashMap.this.remove(ek);
				return true;
			}

			return false;
		}

		public int hashCode() {
			int h = 0;
			for (Iterator i = hashEntrySet.iterator(); i.hasNext();) {
				Map.Entry ent = (Map.Entry) i.next();
				Object k;
				WeakValue wv = (WeakValue) ent.getValue();
				if (wv == null)
					continue;
				h += ((((k = ent.getKey()) == null) ? 0 : k.hashCode()) ^ wv.hashCode());
			}
			return h;
		}

	}

	// internal helper variable, because we can't access
	// entrySet from the superclass inside the EntrySet class
	private Set hashEntrySet = null;
	// stores the EntrySet instance
	private Set entrySet = null;

	/**
	 * Returns a <code>Set</code> view of the mappings in this map.
	 * <p>
	 * 
	 * @return a <code>Set</code> view of the mappings in this map.
	 */
	public Set entrySet() {
		if (entrySet == null) {
			hashEntrySet = super.entrySet();
			entrySet = new EntrySet();
		}
		return entrySet;
	}

	// stores the value collection
	private transient Collection values = null;

	/**
	 * Returns a <code>Collection</code> view of the values contained in this
	 * map.
	 * <p>
	 * 
	 * @return a <code>Collection</code> view of the values contained in this
	 *         map.
	 */
	public Collection values() {
		// delegates to entrySet, because super method returns
		// WeakValues instead of value objects
		if (values == null) {
			values = new AbstractCollection() {
				public Iterator iterator() {
					return new Iterator() {
						private Iterator i = entrySet().iterator();

						public boolean hasNext() {
							return i.hasNext();
						}

						public Object next() {
							return ((Entry) i.next()).getValue();
						}

						public void remove() {
							i.remove();
						}
					};
				}

				public int size() {
					return WeakValueHashMap.this.size();
				}

				public boolean contains(Object v) {
					return WeakValueHashMap.this.containsValue(v);
				}
			};
		}
		return values;
	}

}
"
GraphLayoutConnection.java,prom-models-6.9.32,"package org.processmining.models.connections;

import java.awt.Dimension;
import java.awt.geom.Dimension2D;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.jgraph.graph.GraphConstants;
import org.processmining.framework.connections.DynamicConnection;
import org.processmining.framework.connections.impl.AbstractConnection;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.AttributeMapOwner;
import org.processmining.models.graphbased.Expandable;
import org.processmining.models.graphbased.ExpansionListener;
import org.processmining.models.graphbased.ExpansionListener.ListenerList;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphElement;

public class GraphLayoutConnection extends AbstractConnection implements DynamicConnection {

	/**
	 * A List<java.awt.geom.Point2D> of points, which are the inner points of
	 * the spline.
	 * 
	 */
	protected final static String EDGEPOINTS = ""edgepoints"";

	public boolean setEdgePoints(AttributeMapOwner owner, List<Point2D> edgepoints) {
		return map.putViewSpecific(owner, EDGEPOINTS, edgepoints);
	}

	public List<Point2D> getEdgePoints(AttributeMapOwner owner) {
		return map.get(owner, EDGEPOINTS, Collections.<Point2D>emptyList());
	}

	/**
	 * a get on size returns a java.awt.geom.Dimension2D.
	 */
	protected static final String SIZE = ""size"";

	public boolean setSize(AttributeMapOwner owner, Dimension2D size) {
		return map.putViewSpecific(owner, SIZE, size);
	}

	public Dimension getSize(AttributeMapOwner owner) {
		return map.get(owner, SIZE, new Dimension(100, 100));
	}

	/**
	 * a get on size returns a java.awt.geom.Point2D.
	 */
	protected static final String POSITION = ""position"";

	public boolean setPosition(AttributeMapOwner owner, Point2D position) {
		return map.putViewSpecific(owner, POSITION, position);
	}

	public Point2D getPosition(AttributeMapOwner owner) {
		return map.get(owner, POSITION, null);
	}

	protected static final String COLLAPSED = ""collapsed"";

	public boolean collapse(AttributeMapOwner owner) {
		return map.putViewSpecific(owner, COLLAPSED, false);
	}

	public boolean expand(AttributeMapOwner owner) {
		return map.putViewSpecific(owner, COLLAPSED, true);
	}

	public boolean isCollapsed(AttributeMapOwner owner) {
		return map.get(owner, COLLAPSED, false);
	}

	protected final static String PORTOFFSET = ""portOffset"";

	public boolean setPortOffset(AttributeMapOwner owner, Point2D position) {
		return map.putViewSpecific(owner, PORTOFFSET, position);
	}

	public Point2D getPortOffset(AttributeMapOwner owner) {
		return map.get(owner, PORTOFFSET, new Point2D.Double(GraphConstants.PERMILLE / 2, GraphConstants.PERMILLE / 2));
	}

	public static interface Listener {
		public void layoutConnectionUpdated(AttributeMapOwner... owners);
	}

	public static final String GRAPH = ""graph"";
	private boolean layedOut = false;
	private final ViewSpecificAttributeMap map;
	private transient ExpansionListener.ListenerList expListeners = new ExpansionListener.ListenerList();
	private transient List<Listener> listeners = new ArrayList<Listener>();

	public GraphLayoutConnection(GraphLayoutConnection cloneFrom) {
		super(cloneFrom.getLabel());
		this.map = cloneFrom.map.createClone();
		put(GRAPH, cloneFrom.get(GRAPH));
		this.layedOut = cloneFrom.layedOut;

	}

	public GraphLayoutConnection(DirectedGraph<?, ?> graph) {
		super(""Layout information for "" + graph.getLabel());
		this.map = new ViewSpecificAttributeMap();
		put(GRAPH, graph);

		for (AttributeMapOwner node : graph.getNodes()) {
			setSize(node, node.getAttributeMap().get(AttributeMap.SIZE, new Dimension(50, 50)));
			setPortOffset(
					node,
					node.getAttributeMap().get(AttributeMap.PORTOFFSET,
							new Point2D.Double(GraphConstants.PERMILLE / 2, GraphConstants.PERMILLE / 2)));
		}

	}

	public DirectedGraph<?, ?> getGraph() {
		return (DirectedGraph<?, ?>) get(GRAPH);
	}

	//	public ViewSpecificAttributeMap getMap() {
	//		return map;
	//	}

	public void setLayedOut(boolean layedOut) {
		this.layedOut = layedOut;
		updatedAttributes();
	}

	public boolean isLayedOut() {
		return layedOut;
	}

	public void expandAll() {
		List<Expandable> updated = new ArrayList<Expandable>();
		for (AttributeMapOwner owner : map.keySet()) {
			if (owner instanceof Expandable) {
				updated.add((Expandable) owner);
			}
		}
		expandAll(updated);
	}

	public void collapseAll() {
		List<Expandable> updated = new ArrayList<Expandable>();
		for (AttributeMapOwner owner : map.keySet()) {
			if (owner instanceof Expandable) {
				updated.add((Expandable) owner);
			}
		}
		collapseAll(updated);
	}

	public void expandAll(Collection<Expandable> toExpand) {
		for (Expandable owner : toExpand) {
			expand(owner, false);
		}
		updatedAttributes(toExpand.toArray(new Expandable[0]));
	}

	public void collapseAll(Collection<Expandable> toCollapse) {
		for (Expandable owner : toCollapse) {
			collapse(owner, false);
		}
		updatedAttributes(toCollapse.toArray(new Expandable[0]));
	}

	public void expand(Expandable expandable) {
		expand(expandable, true);
	}

	public void collapse(Expandable expandable) {
		collapse(expandable, true);
	}

	void expand(Expandable expandable, boolean update) {
		expListeners.fireNodeExpanded(expandable);
	}

	void collapse(Expandable expandable, boolean update) {
		expListeners.fireNodeCollapsed(expandable);
	}

	public ExpansionListener.ListenerList getExpansionListeners() {
		return expListeners;
	}

	public void addListener(Listener listener) {
		listeners.add(listener);
	}

	public void removeListener(Listener listener) {
		listeners.remove(listener);
	}

	public void updatedAttributes(AttributeMapOwner... owners) {
		for (Listener l : listeners) {
			l.layoutConnectionUpdated(owners);
		}
		super.updated();
	}

	private Object readResolve() {
		this.expListeners = new ListenerList();
		listeners = new ArrayList<Listener>();
		return this;

	}

	protected static final String MULTIGRAPHELEMENTS = ""multigraphelements"";

	public boolean setMultiGraphElements(AttributeMapOwner owner, List<DirectedGraphElement> tempGraphElements) {
		return map.putViewSpecific(owner, MULTIGRAPHELEMENTS, tempGraphElements);
	}

	public List<DirectedGraphElement> getMultiGraphElements(AttributeMapOwner owner) {
		return map.get(owner, MULTIGRAPHELEMENTS, Collections.<DirectedGraphElement>emptyList());
	}

}
"
AbstractGraph.java,prom-models-6.9.32,"package org.processmining.models.graphbased;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;

public class AbstractGraph extends AbstractGraphElement {

	protected final NodeID id = new NodeID();

	public AbstractGraph() {
		super();
	}

	public boolean equals(Object o) {
		if (!(o instanceof AbstractGraph)) {
			return false;
		}
		AbstractGraph net = (AbstractGraph) o;
		return net.id.equals(id);
	}

	protected synchronized <T> T removeNodeFromCollection(Collection<T> collection, T object) {
		for (T toRemove : collection) {
			if (toRemove.equals(object)) {
				collection.remove(toRemove);
				graphElementRemoved(object);
				return toRemove;
			}
		}
		return null;
	}

	/**
	 * Returns the edges from source to target, contained in the given
	 * collection
	 * 
	 * @param <T>
	 *            The type of edges
	 * @param source
	 *            the source node
	 * @param target
	 *            the target node
	 * @param collection
	 *            the collection of edges to search through
	 * @return
	 */
	protected <T extends AbstractGraphEdge<?, ?>> Collection<T> getEdges(AbstractGraphNode source,
			AbstractGraphNode target, Collection<T> collection) {
		Collection<T> s2t = new HashSet<T>();
		for (T a : collection) {
			if (a.getSource().equals(source) && a.getTarget().equals(target)) {
				s2t.add(a);
			}
		}
		return Collections.unmodifiableCollection(s2t);

	}

	protected synchronized <T extends AbstractGraphEdge<?, ?>> T removeFromEdges(AbstractGraphNode source,
			AbstractGraphNode target, Collection<T> collection) {
		for (T a : collection) {
			if (a.getSource().equals(source) && a.getTarget().equals(target)) {
				collection.remove(a);
				graphElementRemoved(a);
				return a;
			}
		}
		return null;
	}

	public int hashCode() {
		return id.hashCode();
	}

	public synchronized void graphElementAdded(Object element) {
		//		isLayedOut = false;
		//		elementsAdded.add(element);
	}

	public synchronized void graphElementRemoved(Object element) {
		//		elementsRemoved.add(element);
	}

	public synchronized void graphElementChanged(Object element) {
		//		elementsChanged.add(element);
	}

}
"
AbstractGraphEdge.java,prom-models-6.9.32,"package org.processmining.models.graphbased;

import org.processmining.models.graphbased.directed.AbstractDirectedGraphEdge;

public abstract class AbstractGraphEdge<S, T> extends AbstractGraphElement implements
		Comparable<AbstractGraphEdge<S, T>> {

	protected final int hash;
	protected final S source;
	protected final T target;

	public AbstractGraphEdge(S source, T target) {
		super();
		this.source = source;
		this.target = target;
		this.hash = source.hashCode() + 37 * target.hashCode();
	}

	public int hashCode() {
		// Hashcode based on source and target, which
		// respects contract that this.equals(o) implies
		// this.hashCode()==o.hashCode()
		return hash;
	}

	public boolean equals(Object o) {
		if (!(this.getClass().equals(o.getClass()))) {
			return false;
		}
		AbstractDirectedGraphEdge<?, ?> edge = (AbstractDirectedGraphEdge<?, ?>) o;

		return edge.source.equals(source) && edge.target.equals(target);

	}

	public S getSource() {
		return source;
	}

	public T getTarget() {
		return target;
	}

}
"
AbstractGraphElement.java,prom-models-6.9.32,"package org.processmining.models.graphbased;

public abstract class AbstractGraphElement implements AttributeMapOwner {

	private final AttributeMap map;

	public AbstractGraphElement() {
		map = new AttributeMap();
	}

	public String getLabel() {
		return map.get(AttributeMap.LABEL, ""no label"");
	}

	public AttributeMap getAttributeMap() {
		return map;
	}

	public String toString() {
		return getLabel();
	}

}
"
AbstractGraphNode.java,prom-models-6.9.32,"package org.processmining.models.graphbased;

public abstract class AbstractGraphNode extends AbstractGraphElement {

	private final NodeID id = new NodeID();

	public AbstractGraphNode() {
		super();
	}

	public int hashCode() {
		return getId().hashCode();
	}

	public boolean equals(Object o) {
		if (!(o instanceof AbstractGraphNode)) {
			return false;
		}
		AbstractGraphNode node = (AbstractGraphNode) o;
		return node.getId().equals(getId());
	}

	public NodeID getId() {
		return id;
	}

}
"
AttributeMap.java,prom-models-6.9.32,"package org.processmining.models.graphbased;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

public class AttributeMap {
	private final static String PREFIX = ""ProM_Vis_attr_"";

	public enum ArrowType {
		ARROWTYPE_CLASSIC(PREFIX + ""arrow_classic""), //
		ARROWTYPE_TECHNICAL(PREFIX + ""arrow_tech""), //
		ARROWTYPE_SIMPLE(PREFIX + ""arrow_simple""), //
		ARROWTYPE_DIAMOND(PREFIX + ""arrow_diamond""), //
		ARROWTYPE_CIRCLE(PREFIX + ""arrow_circle""), //
		ARROWTYPE_LINE(PREFIX + ""arrow_line""), //
		ARROWTYPE_DOUBLELINE(PREFIX + ""arrow_double""), //
		ARROWTYPE_NONE(PREFIX + ""arrow_none""), //
		ARROW_CROSS(PREFIX + ""arrow_cross""), //
		ARROW_TECHNICAL_CIRCLE(PREFIX + ""arrow_technical_circle"");

		ArrowType(String s) {
		}
	}

	public final static String SHAPE = PREFIX + ""shape"";
	public static final String SHAPEDECORATOR = PREFIX + ""ShapeDecorator"";

	public final static String FILLCOLOR = PREFIX + ""fillcolor"";
	public final static String GRADIENTCOLOR = PREFIX + ""gradientcolor"";
	public final static String ICON = PREFIX + ""icon"";
	public final static String BORDERWIDTH = PREFIX + ""border"";
	public final static String LABEL = PREFIX + ""label"";
	public final static String TOOLTIP = PREFIX + ""tooltip"";

	public final static String EDGESTART = PREFIX + ""edgestart"";
	public final static String EDGESTARTFILLED = PREFIX + ""edgeStartFilled"";

	public final static String EDGEEND = PREFIX + ""edge end"";
	public final static String EDGEENDFILLED = PREFIX + ""edgeEndFilled"";

	public final static String EDGEMIDDLE = PREFIX + ""edge middle"";
	public final static String EDGEMIDDLEFILLED = PREFIX + ""edgeMiddleFilled"";

	public final static String LABELVERTICALALIGNMENT = PREFIX + ""labelVerticalAlignment"";
	public final static String EDGECOLOR = PREFIX + ""edgeColor""; // added by arya
	public final static String STROKECOLOR = PREFIX + ""strokeColor""; // added by arya

	public final static String INSET = PREFIX + ""inset""; // added by jribeiro
	public final static String STROKE = PREFIX + ""stroke""; // added by jribeiro
	public final static String DASHPATTERN = PREFIX + ""dashPattern""; // added by jribeiro
	public final static String DASHOFFSET = PREFIX + ""dashOffset""; // added by jribeiro
	public final static String LABELCOLOR = PREFIX + ""labelColor""; // added by jribeiro
	public final static String LABELALONGEDGE = PREFIX + ""labelAlongEdge""; // added by jribeiro

	/**
	 * A Float representing the linewidth of a line.
	 */
	public final static String LINEWIDTH = PREFIX + ""lineWidth"";
	public final static String NUMLINES = PREFIX + ""numLines"";

	public final static String STYLE = PREFIX + ""style"";

	public final static String POLYGON_POINTS = PREFIX + ""polygonpoints"";

	public static final String SQUAREBB = PREFIX + ""squareBB"";
	public static final String RESIZABLE = PREFIX + ""resizable"";
	public static final String AUTOSIZE = PREFIX + ""autosize"";
	public static final String SHOWLABEL = PREFIX + ""showLabel"";
	public static final String MOVEABLE = PREFIX + ""movable""; // added by arya

	/**
	 * This should be set to SwingConstants.SOUTH, SwingConstants.WEST and so
	 * on. SwingConstants.NORTH means the graph prefers drawn Top-Down
	 * SwingConstants.WEST means the graph prefers drawn Left to Right
	 */
	public static final String PREF_ORIENTATION = PREFIX + ""orientation"";
	public static final String LABELHORIZONTALALIGNMENT = PREFIX + ""horizontal alignment"";
	public static final String SIZE = ""size"";
	public static final String PORTOFFSET = ""portoffset"";

	/**
	 * The value of this attribute should be an array of type Point2D[]
	 * (size>0), as used in the method GraphConstants.setExtraLabelPositions()
	 */
	public static final String EXTRALABELPOSITIONS = ""Label positions"";
	/**
	 * The value of this attribute should be an array of type String[] (size>0),
	 * as used in the method GraphConstants.setExtraLabels()
	 */
	public static final String EXTRALABELS = ""Extra Labels"";

	/**
	 * Renderer to be used.
	 */
	public static final String RENDERER = ""Renderer"";

	private final Map<String, Object> mapping = new LinkedHashMap<String, Object>();

	public AttributeMap() {
	}

	public Object get(String key) {
		return mapping.get(key);
	}

	@SuppressWarnings(""unchecked"")
	public <T> T get(String key, T defaultValue) {
		synchronized (mapping) {
			Object o = mapping.get(key);
			if (o != null) {
				return (T) o;
			}
			if (mapping.containsKey(key)) {
				return null;
			} else {
				return defaultValue;
			}
		}
	}

	public void clear() {
		mapping.clear();
	}

	public Set<String> keySet() {
		return mapping.keySet();
	}

	/**
	 * This method updates the map and signals the owner. The origin is passed
	 * in this update, to make sure that no unnecessary updates are performed
	 * 
	 * @param key
	 * @param value
	 * @param origin
	 * @return
	 */
	public boolean put(String key, Object value) {
		Object old;
		synchronized (mapping) {
			old = mapping.get(key);
			mapping.put(key, value);
		}
		if (value == old) {
			return false;
		}
		if ((value == null) || (old == null) || !value.equals(old)) {
			return true;
		}
		return false;
	}

	public void remove(String key) {
		synchronized (mapping) {
			mapping.remove(key);
		}
	}

	public boolean containsKey(String key) {
		return mapping.containsKey(key);
	}

}"
AttributeMapOwner.java,prom-models-6.9.32,"package org.processmining.models.graphbased;

public interface AttributeMapOwner {

	AttributeMap getAttributeMap();

}
"
AbstractDirectedGraph.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;

import org.processmining.framework.util.Cast;
import org.processmining.models.graphbased.AbstractGraph;

public abstract class AbstractDirectedGraph<N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>>
		extends AbstractGraph implements DirectedGraph<N, E> {

	private final Map<DirectedGraphNode, Collection<E>> inEdgeMap = new LinkedHashMap<DirectedGraphNode, Collection<E>>();;
	private final Map<DirectedGraphNode, Collection<E>> outEdgeMap = new LinkedHashMap<DirectedGraphNode, Collection<E>>();;

	public AbstractDirectedGraph() {
		super();
	}

	public AbstractDirectedGraph<?, ?> getGraph() {
		return this;
	}

	protected abstract AbstractDirectedGraph<N, E> getEmptyClone();

	/**
	 * The returned mapping satisfies:
	 * map.keySet().containsAll(graph.getNodes()) and
	 * map.keySet().containsAll(graph.getEdges())
	 * 
	 * @param graph
	 * @return
	 */
	protected abstract Map<? extends DirectedGraphElement, ? extends DirectedGraphElement> cloneFrom(
			DirectedGraph<N, E> graph);

	@SuppressWarnings(""unchecked"")
	public abstract void removeEdge(DirectedGraphEdge edge);

	protected void removeSurroundingEdges(N node) {
		for (E edge : getInEdges(node)) {
			removeEdge(edge);
		}
		for (E edge : getOutEdges(node)) {
			removeEdge(edge);
		}
	}

	protected void checkAddEdge(N source, N target) {
		Collection<N> nodes = getNodes();
		if (!nodes.contains(source) || !nodes.contains(target)) {
			throw new IllegalArgumentException(""Cannot add an arc between "" + source.toString() + "" and ""
					+ target.toString() + "", since one of these nodes is not in the graph."");
		}

	}

	public Collection<E> getInEdges(DirectedGraphNode node) {
		Collection<E> col = inEdgeMap.get(node);
		if (col == null) {
			return Collections.emptyList();
		} else {
			return new ArrayList<E>(col);
		}
	}

	public Collection<E> getOutEdges(DirectedGraphNode node) {
		Collection<E> col = outEdgeMap.get(node);
		if (col == null) {
			return Collections.emptyList();
		} else {
			return new ArrayList<E>(col);
		}
	}

	@Override
	public void graphElementAdded(Object element) {
		if (element instanceof DirectedGraphNode) {
			DirectedGraphNode node = (DirectedGraphNode) element;
			synchronized (inEdgeMap) {
				inEdgeMap.put(node, new LinkedHashSet<E>());
			}
			synchronized (outEdgeMap) {
				outEdgeMap.put(node, new LinkedHashSet<E>());
			}
		}
		if (element instanceof DirectedGraphEdge<?, ?>) {
			E edge = Cast.<E>cast(element);
			synchronized (inEdgeMap) {
				Collection<E> collection = inEdgeMap.get(edge.getTarget());
				collection.add(edge);
			}
			synchronized (outEdgeMap) {
				Collection<E> collection = outEdgeMap.get(edge.getSource());
				collection.add(edge);
			}
		}
		super.graphElementAdded(element);
	}

	public void graphElementRemoved(Object element) {
		if (element instanceof DirectedGraphNode) {
			DirectedGraphNode node = (DirectedGraphNode) element;
			synchronized (inEdgeMap) {
				inEdgeMap.remove(node);
			}
			synchronized (outEdgeMap) {
				outEdgeMap.remove(node);
			}
		}
		if (element instanceof DirectedGraphEdge<?, ?>) {
			E edge = Cast.<E>cast(element);
			synchronized (inEdgeMap) {
				Collection<E> collection = inEdgeMap.get(edge.getTarget());
				collection.remove(element);
			}
			synchronized (outEdgeMap) {
				Collection<E> collection = outEdgeMap.get(edge.getSource());
				collection.remove(element);
			}
		}
		super.graphElementRemoved(element);
	}

	public void graphElementChanged(Object element) {
		super.graphElementChanged(element);
	}

	public int compareTo(DirectedGraph<N, E> o) {
		if (!(o instanceof AbstractDirectedGraph<?, ?>)) {
			return getLabel().compareTo(o.getLabel());
		}
		AbstractDirectedGraph<?, ?> graph = (AbstractDirectedGraph<?, ?>) o;
		return id.compareTo(graph.id);
	}
}"
AbstractDirectedGraphEdge.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed;

import org.processmining.models.graphbased.AbstractGraphEdge;

public abstract class AbstractDirectedGraphEdge<S extends AbstractDirectedGraphNode, T extends AbstractDirectedGraphNode>
		extends AbstractGraphEdge<S, T> implements DirectedGraphEdge<S, T> {

	private final AbstractDirectedGraph<?, ?> graph;

	public AbstractDirectedGraphEdge(S source, T target) {
		super(source, target);
		assert (source.getGraph() == target.getGraph());
		this.graph = source.getGraph();
	}

	public AbstractDirectedGraph<?, ?> getGraph() {
		return graph;
	}

	public int compareTo(AbstractGraphEdge<S, T> edge) {
		int c;
		c = getClass().getName().compareTo(edge.getClass().getName());
		if (c != 0) {
			return c;
		}
		c = source.compareTo(edge.getSource());
		if (c != 0) {
			return c;
		}
		return target.compareTo(edge.getTarget());
	}

}
"
AbstractDirectedGraphNode.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed;

import org.processmining.models.graphbased.AbstractGraphNode;

public abstract class AbstractDirectedGraphNode extends AbstractGraphNode implements DirectedGraphNode {

	public AbstractDirectedGraphNode() {
		super();
	}

	public abstract AbstractDirectedGraph<?, ?> getGraph();

	public int compareTo(DirectedGraphNode node) {
		int comp = getId().compareTo(node.getId());
		//		assert (Math.abs(comp) == Math.abs(getLabel().compareTo(getLabel())));
		return comp;

	}

}
"
ComponentFactory.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed.analysis;

import java.util.Collection;
import java.util.HashSet;
import java.util.TreeSet;

import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

public class ComponentFactory {

	/**
	 * Computes strongly connected components for the given directed graph.
	 * 
	 * @param <N>
	 *            Node type of the graph
	 * @param <E>
	 *            Edge type of the graph
	 * @param graph
	 *            The graph to componentize
	 * @return The set of strongly connected components of the graph
	 */
	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> Collection<Collection<N>> componentize(
			DirectedGraph<N, E> graph) {
		/**
		 * The set of nodes to still componentize.
		 */
		Collection<N> toDo = new HashSet<N>(graph.getNodes());
		/**
		 * The set of components found so far.
		 */
		Collection<Collection<N>> components = new HashSet<Collection<N>>();
		/**
		 * Until no nodes need componentizing...
		 */
//		System.out.println(""E: "" + graph.getEdges().size());
//		System.out.println(""N: "" + graph.getNodes().size());
		while (!toDo.isEmpty()) {
			/**
			 * Take a node, and create a component for it.
			 */
			N node = toDo.iterator().next();
			toDo.remove(node);
			Collection<N> component = new TreeSet<N>();
			component.add(node);
			/**
			 * Add the successors of this node, if possible (that is, if there
			 * is some path from the successor to the selected node.
			 */
			HashSet<N> reDo = new HashSet<N>();
			Collection<E> edges = graph.getOutEdges(node);
			for (E edge : edges) {
				N succNode = edge.getTarget();
				checkForComponent(graph, succNode, component, toDo, reDo);
			}
			/**
			 * Add the component.
			 */
//			System.out.println(""REDO: "" + reDo.size() + ""    "" + System.currentTimeMillis());
			components.add(component);
			toDo.addAll(reDo);
//			System.out.println(""TODO: "" + toDo.size() + ""    "" + System.currentTimeMillis());
		}
		return components;
	}

	/**
	 * Add all nodes reachable from the given node from which some node in the
	 * given component is reachable.
	 * 
	 * @param <N>
	 *            The type of nodes in the graph
	 * @param <E>
	 *            The type of edges in the graph
	 * @param graph
	 *            The given graph
	 * @param node
	 *            The given node
	 * @param component
	 *            The component
	 * @param toDo
	 *            The nodes to consider
	 */
	private static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> void checkForComponent(
			DirectedGraph<N, E> graph, N node, Collection<N> component, Collection<N> toDo, Collection<N> reDo) {
		/**
		 * Check whether this node should be considered
		 */
		if (toDo.contains(node)) {
			/**
			 * Node is being considered now...
			 */
			toDo.remove(node);
			/**
			 * Check all successors...
			 */
			boolean added = false;
			Collection<E> edges = graph.getOutEdges(node);
			for (E edge : edges) {
				N succNode = edge.getTarget();
				if (component.contains(succNode)) {
					/**
					 * Found a successor with a path to the component. Hence
					 * there is a path from this node to the componetn as well.
					 * Add it.
					 */
					added = true;
					component.add(node);
				} else {
					checkForComponent(graph, succNode, component, toDo, reDo);
				}
			}
			/**
			 * Node has not been added to component. Hence, it should be
			 * reconsidered in the future.
			 */
			if (!added) {
				reDo.add(node);
			}
		}
	}

	/**
	 * Checks whether a component is terminal, that is, whether it has no
	 * outgoing edges.
	 * 
	 * @param <N>
	 *            The type of nodes in the graph
	 * @param <E>
	 *            The type of edges in the graph
	 * @param graph
	 *            The given graph
	 * @param component
	 *            The given component
	 * @return Whether the component is terminal
	 */
	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> boolean isTerminal(
			DirectedGraph<N, E> graph, Collection<N> component) {
		for (N node : component) {
			Collection<E> edges = graph.getOutEdges(node);
			for (E edge : edges) {
				if (!component.contains(edge.getTarget())) {
					/**
					 * Found an edge leaving the component, hence it is not
					 * terminal.
					 */
					return false;
				}
			}
		}
		/**
		 * No edges leave the component, hence it is temrinal.
		 */
		return true;
	}
}
"
ShortestPathFactory.java,prom-models-6.9.32,"/**
 * 
 */
package org.processmining.models.graphbased.directed.analysis;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

/**
 * This class generate a shortest path from one node in a directed graph to
 * another.
 * 
 * @author arya
 * @email arya.adriansyah@gmail.com
 * @version Dec 12, 2008
 */
public class ShortestPathFactory {
	public static int UNLIMITEDMAX = Integer.MAX_VALUE;

	private ShortestPathFactory() {

	}

	/**
	 * Calculate shortest distance from a node to every other node in the graph.
	 * Algorithm in use is Dijkstra's algorithm written in Introduction to
	 * Algorithm, chapter 25.
	 * 
	 * @param source
	 * @param graph
	 * @return
	 */
	private static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> int[][] calculateShortestDistanceDijkstra(
			N source, DirectedGraph<N, E> graph, ShortestPathInfo<N, E> shortestPathInfo) {

		// start of Dijkstra's algorithm
		Set<N> S = new HashSet<N>(); // to store set of vertices whose final shortest-path weights from the source have already been determined
		Set<N> Q = new HashSet<N>(); // to store queue that contains all the vertices in V - S, V is total vertices in graph

		int[] d = new int[graph.getNodes().size()]; // to store shortest-path estimate
		Arrays.fill(d, ShortestPathFactory.UNLIMITEDMAX);

		int[] phi = new int[d.length];
		Arrays.fill(phi, -1); // -1 means that no node is before this node in a shortest path

		// initialize single source, as well as complete all mapping
		for (N node : graph.getNodes()) {
			Q.add(node);
		}

		// init source node
		d[shortestPathInfo.getIndexOf(source)] = 0;

		// start loop
		while (!Q.isEmpty()) {
			N currentNode = extractMin(d, Q, shortestPathInfo);
			if (currentNode == null) {
				break;
			} else {
				S.add(currentNode);
				Q.remove(currentNode);

				// update each vertex connected to indexMin 
				int currentNodeIndex = shortestPathInfo.getIndexOf(currentNode);
				Collection<E> edges = graph.getOutEdges(currentNode);
				for (E edge : edges) {
					// do RELAX. Please notice that the weight of an arc is always 1 in our case 
					if (d[shortestPathInfo.getIndexOf(edge.getTarget())] > (d[currentNodeIndex] + 1)) {
						d[shortestPathInfo.getIndexOf(edge.getTarget())] = d[currentNodeIndex] + 1;
						phi[shortestPathInfo.getIndexOf(edge.getTarget())] = currentNodeIndex;
					}

				}
			}
		}

		// result consist of 2 array : 1st array for shortestpath distance, 2nd array for nodes listing
		int[][] result = new int[2][];
		result[0] = d;
		result[1] = phi;
		return result;
	}

	private static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> N extractMin(
			int[] d, Set<N> q, ShortestPathInfo<N, E> shortestPathInfo) {

		int minValue = ShortestPathFactory.UNLIMITEDMAX;
		N resultNode = null;

		// find the minimum value
		for (N node : q) {
			int currentNodeIndex = shortestPathInfo.getIndexOf(node);
			if ((d[currentNodeIndex] <= minValue) && (d[currentNodeIndex] != ShortestPathFactory.UNLIMITEDMAX)) {
				minValue = d[currentNodeIndex];
				resultNode = node;
			}
		}
		return resultNode;
	}

	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> ShortestPathInfo<N, E> calculateAllShortestDistanceDijkstra(
			DirectedGraph<N, E> graph) {

		// create shortest path info
		ShortestPathInfo<N, E> shortestPathInfo = new ShortestPathInfo<N, E>(graph);

		// insert distances to shortest path info
		for (N node : graph.getNodes()) {
			int[][] temp = calculateShortestDistanceDijkstra(node, graph, shortestPathInfo);
			int currentNodeIndex = shortestPathInfo.getIndexOf(node);
			for (int i = 0; i < temp[0].length; i++) {
				if (temp[0][i] != ShortestPathFactory.UNLIMITEDMAX) {
					shortestPathInfo.setShortestPathLength(currentNodeIndex, i, temp[0][i]);
					shortestPathInfo.setLastOnShortestPath(currentNodeIndex, i, temp[1][i]);
				}
			}
			shortestPathInfo.setShortestPathLength(currentNodeIndex, currentNodeIndex, 0); // set distance to itself with zero
		}

		return shortestPathInfo;
	}
}
"
ShortestPathInfo.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed.analysis;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

public class ShortestPathInfo<N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> {

	public final static int NOPATH = -1;

	private final DirectedGraph<N, E> graph;
	private final Map<N, Integer> map;
	private final int[][] lengths;
	private final int[][] lastNodeInShortestPath;

	ShortestPathInfo(DirectedGraph<N, E> graph) {
		this.graph = graph;
		int n = graph.getNodes().size();
		int i = 0;
		map = new HashMap<N, Integer>(n, 1F);
		for (N node : graph.getNodes()) {
			map.put(node, i++);
		}
		lengths = new int[n][];
		lastNodeInShortestPath = new int[n][];
		for (i = 0; i < n; i++) {
			lengths[i] = new int[n];
			lastNodeInShortestPath[i] = new int[n];
			Arrays.fill(lengths[i], ShortestPathInfo.NOPATH);
			Arrays.fill(lastNodeInShortestPath[i], -1);
		}
	}

	public int getShortestPathLength(N source, N target) {
		assert (map.get(source) != null);
		assert (map.get(target) != null);
		return lengths[map.get(source)][map.get(target)];
	}

	void setShortestPathLength(N source, N target, int length) {
		assert (map.get(source) != null);
		assert (map.get(target) != null);
		assert ((length == ShortestPathInfo.NOPATH) || (length >= 0));
		lengths[map.get(source)][map.get(target)] = length;
	}

	int getIndexOf(N node) {
		assert (map.get(node) != null);
		return map.get(node);
	}

	void setShortestPathLength(int sourceIndex, int targetIndex, int length) {
		assert (0 <= sourceIndex) && (sourceIndex < lengths.length);
		assert (0 <= targetIndex) && (targetIndex < lengths.length);
		assert ((length == ShortestPathInfo.NOPATH) || (length >= 0));
		lengths[sourceIndex][targetIndex] = length;
	}

	/**
	 * Returns the shortest path from the source to the target. If
	 * source.equals(target), then a list of length 1 is returned. Otherwise,
	 * the list returned contains the nodes from source to target that make up
	 * the path, including source as the first node and target as the last node.
	 * 
	 * If no path exist, an empty list is returned.
	 * 
	 * @param source
	 * @param target
	 * @return
	 */
	public List<N> getShortestPath(N source, N target) {
		int sourceIndex = getIndexOf(source);
		int targetIndex = getIndexOf(target);

		// check if target has a previous node in the shortest path
		List<N> result = new LinkedList<N>();
		result.add(target);
		while (lastNodeInShortestPath[sourceIndex][targetIndex] >= 0) {
			// find a node which is mapped to previousNodeInShortesPath[sourceIndex][targetIndex]
			N temp = getNodeFromIndex(lastNodeInShortestPath[sourceIndex][targetIndex]);
			if (temp != null) {
				result.add(temp);
				targetIndex = lastNodeInShortestPath[sourceIndex][targetIndex];
			} else {
				return Collections.emptyList();
			}
		}
		if (targetIndex == sourceIndex) {
			Collections.reverse(result);
			return result;
		} else {
			return Collections.emptyList();
		}
	}

	private N getNodeFromIndex(int index) {
		if (!map.containsValue(index)) {
			return null;
		} else {
			for (N node : graph.getNodes()) {
				if (map.get(node) == index) {
					return node;
				}
			}
			return null;
		}
	}

	void setLastOnShortestPath(int fromNodeIndex, int toNodeIndex, int lastNodeIndex) {
		assert (0 <= fromNodeIndex) && (fromNodeIndex < lengths.length);
		assert (0 <= toNodeIndex) && (toNodeIndex < lengths.length);
		assert (-1 <= lastNodeIndex) && (lastNodeIndex < lengths.length);
		assert (lengths[fromNodeIndex][toNodeIndex] >= 0);
		assert ((lengths[fromNodeIndex][toNodeIndex] > 0) || (lastNodeIndex == -1));
		lastNodeInShortestPath[fromNodeIndex][toNodeIndex] = lastNodeIndex;
	}
}
"
BoundaryDirectedGraphNode.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed;

/**
 * Interface to represent a node that can be drawn on the boundary of another
 * node (e.g.: an exception on a BPMN activity.) The other node will be a
 * ContainingDirectedGraphNode.
 * 
 * @author Remco Dijkman
 * 
 */
public interface BoundaryDirectedGraphNode extends DirectedGraphNode {

	DirectedGraphNode getBoundingNode();

}
"
ContainableDirectedGraphElement.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed;

import org.processmining.models.graphbased.AttributeMapOwner;

/**
 * Interface to represent a directed graph element that can be the child of a
 * node. (E.g.: a task in a subprocess.)
 * 
 * @author Remco Dijkman
 * 
 */
public interface ContainableDirectedGraphElement extends AttributeMapOwner {

	ContainingDirectedGraphNode getParent();

}
"
ContainingDirectedGraphNode.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed;

import java.util.Set;

import org.processmining.models.graphbased.Expandable;

/**
 * Interface to represent a directed graph node that contain other elements.
 * 
 * @author Remco Dijkman
 * 
 */
public interface ContainingDirectedGraphNode extends DirectedGraphNode, Expandable {

	Set<? extends ContainableDirectedGraphElement> getChildren();

	void addChild(ContainableDirectedGraphElement child);
}
"
DirectedGraph.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed;

import java.util.Collection;
import java.util.Set;

public interface DirectedGraph<N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>>
		extends DirectedGraphElement, Comparable<DirectedGraph<N, E>> {

	Set<N> getNodes();

	Set<E> getEdges();

	Collection<E> getInEdges(DirectedGraphNode node);

	Collection<E> getOutEdges(DirectedGraphNode node);

	/**
	 * Removes the given edge from the graph.
	 * 
	 * @param edge
	 */
	@SuppressWarnings(""unchecked"")
	void removeEdge(DirectedGraphEdge edge);

	void removeNode(DirectedGraphNode cell);

}
"
DirectedGraphEdge.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed;

import java.util.Collection;

public interface DirectedGraphEdge<S extends DirectedGraphNode, T extends DirectedGraphNode> extends
		DirectedGraphElement {

	/**
	 * Implementations of this class should also implement DirectedGraphEdge<N,
	 * ?>
	 * 
	 * @author bfvdonge
	 * 
	 * @param <N>
	 */
	public static interface MultipleSources<N extends DirectedGraphNode> {
		/**
		 * returns all target nodes of this DirectedGraphEdge, including the
		 * node returned by getSource() of DirectedGraphEdge.
		 * 
		 * @return
		 */
		Collection<N> getSources();
	}

	/**
	 * Implementations of this class should also implement DirectedGraphEdge<?,
	 * N>
	 * 
	 * @author bfvdonge
	 * 
	 * @param <N>
	 */
	public static interface MultipleTargets<N extends DirectedGraphNode> {

		/**
		 * returns all target nodse of this DirectedGraphEdge, including the
		 * node returned by getTarget() of DirectedGraphEdge.
		 * 
		 * @return
		 */
		Collection<N> getTargets();
	}

	S getSource();

	T getTarget();

}
"
DirectedGraphElement.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed;

import org.processmining.models.graphbased.AttributeMapOwner;

/**
 * Main interface for elements of a directed graph. Elements are nodes and
 * edges. All implementing classes of this interface should implement an equals
 * method based on some globally unique ID.
 * 
 * @author bfvdonge
 * 
 */
public interface DirectedGraphElement extends AttributeMapOwner, Cloneable {

	String getLabel();

	DirectedGraph<?, ?> getGraph();

	boolean equals(Object o);

	int hashCode();
}"
DirectedGraphElementWeights.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed;

import java.util.ArrayList;
import java.util.HashMap;

public class DirectedGraphElementWeights extends HashMap<Object, Integer> {

	/**
	 * 
	 */
	private static final long serialVersionUID = 6950324561008737936L;

	public DirectedGraphElementWeights() {
	}

	/**
	 * Add the given weight to the given object, which will typically be a node
	 * identifier.
	 * 
	 * @param nodeId
	 *            The node identifier
	 * @param weight
	 *            The weight to add
	 */
	public void add(Object nodeId, int weight) {
		if (keySet().contains(nodeId)) {
			put(nodeId, get(nodeId) + weight);
		} else {
			put(nodeId, weight);
		}
	}

	/**
	 * Returns the current weight of the given object, which will typically be a
	 * node identifier. Returns the given default weight if no current weight is
	 * found.
	 * 
	 * @param nodeId
	 *            The node identifier
	 * @param defaultWeight
	 *            The default weight
	 * @return The weight of the node with the given identifier
	 */
	public int get(Object nodeId, int defaultWeight) {
		if (keySet().contains(nodeId)) {
			return get(nodeId);
		}
		return defaultWeight;
	}

	/**
	 * Adds the given weight to the edge identified by its source identifier,
	 * target identifier, and its own identifier. Note that the combination of
	 * these three should be unique.
	 * 
	 * @param sourceId
	 *            The source node identifier
	 * @param targetId
	 *            The target node identifier
	 * @param edgeId
	 *            The edge identifier
	 * @param weight
	 *            The weight to add
	 */
	public void add(Object sourceId, Object targetId, Object edgeId, int weight) {
		ArrayList<Object> list = new ArrayList<Object>(3);
		list.add(sourceId);
		list.add(targetId);
		list.add(edgeId);
		if (keySet().contains(list)) {
			put(list, get(list) + weight);
		} else {
			put(list, weight);
		}
	}

	/**
	 * Returns the current weight of the edge identified by its source
	 * identifier, target identifier, and its own identifier. Returns the
	 * default weight if no current weight is found.
	 * 
	 * @param sourceId
	 *            The source node identifier
	 * @param targetId
	 *            The target node identifier
	 * @param edgeId
	 *            The edge identifier
	 * @param defaultWeight
	 *            The default weight
	 * @return The weight of the edge identified by its source identifier,
	 *         target identifier, and its own identifier
	 */
	public int get(Object sourceId, Object targetId, Object edgeId, int defaultWeight) {
		ArrayList<Object> list = new ArrayList<Object>(3);
		list.add(sourceId);
		list.add(targetId);
		list.add(edgeId);
		if (keySet().contains(list)) {
			return get(list);
		}
		return defaultWeight;
	}
}
"
DirectedGraphNode.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed;

import org.processmining.models.graphbased.NodeID;

public interface DirectedGraphNode extends DirectedGraphElement, Comparable<DirectedGraphNode> {

	NodeID getId();

}
"
GraphIterator.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed.utils;

import java.util.Collection;
import java.util.HashSet;

import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

public class GraphIterator {

	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> Collection<N> getDirectSuccessors(
			final N node, DirectedGraph<N, E> graph) {
		return getDepthFirstSuccessors(node, graph, new EdgeAcceptor<N, E>() {
			public boolean acceptEdge(E edge, int depth) {
				return depth == 0;
			}
		}, new NodeAcceptor<N>() {
			public boolean acceptNode(N node, int depth) {
				return true;
			}
		});
	}

	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> Collection<N> getDepthFirstSuccessors(
			N node, DirectedGraph<N, E> graph, EdgeAcceptor<N, E> edgeAcceptor, NodeAcceptor<N> nodeAcceptor) {
		Collection<N> result = new HashSet<N>();
		HashSet<N> seen = new HashSet<N>();
		getDepthFirstSuccessors(node, graph, result, edgeAcceptor, nodeAcceptor, 0, seen);
		return result;

	}

	private static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> void getDepthFirstSuccessors(
			N node, DirectedGraph<N, E> graph, Collection<N> result, EdgeAcceptor<N, E> edgeAcceptor,
			NodeAcceptor<N> nodeAcceptor, final int depth, final HashSet<N> seen) {

		for (E edge : graph.getOutEdges(node)) {
			if (edgeAcceptor.acceptEdge(edge, depth)) {
				N target = edge.getTarget();
				if (nodeAcceptor.acceptNode(target, depth)) {
					result.add(target);
				}
				if (!seen.contains(target)) {
					seen.add(target);
					getDepthFirstSuccessors(target, graph, result, edgeAcceptor, nodeAcceptor, depth + 1, seen);
					seen.remove(target);
				}
			}
		}
	}

	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> Collection<N> getDirectPredecessors(
			final N node, DirectedGraph<N, E> graph) {
		return getDepthFirstPredecessors(node, graph, new EdgeAcceptor<N, E>() {
			public boolean acceptEdge(E edge, int depth) {
				return depth == 0;
			}
		}, new NodeAcceptor<N>() {
			public boolean acceptNode(N node, int depth) {
				return true;
			}
		});
	}

	public static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> Collection<N> getDepthFirstPredecessors(
			N node, DirectedGraph<N, E> graph, EdgeAcceptor<N, E> edgeAcceptor, NodeAcceptor<N> nodeAcceptor) {
		Collection<N> result = new HashSet<N>();
		HashSet<N> seen = new HashSet<N>();
		getDepthFirstPredecessors(node, graph, result, edgeAcceptor, nodeAcceptor, 0, seen);
		return result;

	}

	private static <N extends DirectedGraphNode, E extends DirectedGraphEdge<? extends N, ? extends N>> void getDepthFirstPredecessors(
			N node, DirectedGraph<N, E> graph, Collection<N> result, EdgeAcceptor<N, E> edgeAcceptor,
			NodeAcceptor<N> nodeAcceptor, final int depth, final HashSet<N> seen) {

		for (E edge : graph.getInEdges(node)) {
			if (edgeAcceptor.acceptEdge(edge, depth)) {
				N source = edge.getSource();
				if (nodeAcceptor.acceptNode(source, depth)) {
					result.add(source);
				}
				if (!seen.contains(source)) {
					seen.add(source);
					getDepthFirstPredecessors(source, graph, result, edgeAcceptor, nodeAcceptor, depth + 1, seen);
					seen.remove(source);
				}
			}
		}
	}

	public interface EdgeAcceptor<N, E extends DirectedGraphEdge<? extends N, ? extends N>> {
		/**
		 * Used while searching. If this method returns false for a certain
		 * edge, then this edge is not traversed in the search.
		 * 
		 * @param edge
		 * @return
		 */
		public boolean acceptEdge(E edge, int depth);
	}

	public interface NodeAcceptor<T extends DirectedGraphNode> {
		/**
		 * Used while searching. If this method returns false for a certain
		 * node, then this node is not added to the search result and the search
		 * does not continue along this node.
		 * 
		 * @param edge
		 * @return
		 */
		public boolean acceptNode(T node, int depth);
	}

}
"
Node.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directed.utils;

import java.util.ArrayList;
import java.util.List;

// taken from
// http://sujitpal.blogspot.com/2006/05/java-data-structure-generic-tree.html
// 27th August 2008
// modified for ProM by Arya Adriansyah (arya.adriansyah@gmail.com)

/**
 * Represents a node of the Tree<T> class. The Node<T> is also a container, and
 * can be thought of as instrumentation to determine the location of the type T
 * in the Tree<T>.
 */
public class Node<T> {

	private T data;
	private List<Node<T>> children;
	private Node<T> parent;

	/**
	 * Default ctor.
	 */
	public Node() {
		super();
		setParent(null);
	}

	/**
	 * Convenience ctor to create a Node<T> with an instance of T.
	 * 
	 * @param data
	 *            an instance of T.
	 */
	public Node(T data) {
		this();
		setData(data);
		setParent(null);
	}

	/**
	 * Return the children of Node<T>. The Tree<T> is represented by a single
	 * root Node<T> whose children are represented by a List<Node<T>>. Each of
	 * these Node<T> elements in the List can have children. The getChildren()
	 * method will return the children of a Node<T>.
	 * 
	 * @return the children of Node<T>
	 */
	public List<Node<T>> getChildren() {
		if (this.children == null) {
			return new ArrayList<Node<T>>();
		}
		return this.children;
	}

	/**
	 * Sets the children of a Node<T> object. See docs for getChildren() for
	 * more information.
	 * 
	 * @param children
	 *            the List<Node<T>> to set.
	 */
	public void setChildren(List<Node<T>> children) {
		this.children = children;
	}

	/**
	 * Returns the number of immediate children of this Node<T>.
	 * 
	 * @return the number of immediate children.
	 */
	public int getNumberOfChildren() {
		if (children == null) {
			return 0;
		}
		return children.size();
	}

	/**
	 * Adds a child to the list of children for this Node<T>. The addition of
	 * the first child will create a new List<Node<T>>.
	 * 
	 * @param child
	 *            a Node<T> object to set.
	 */
	public void addChild(Node<T> child) {
		if (children == null) {
			children = new ArrayList<Node<T>>();
		}
		children.add(child);
	}

	/**
	 * Inserts a Node<T> at the specified position in the child list. Will *
	 * throw an ArrayIndexOutOfBoundsException if the index does not exist.
	 * 
	 * @param index
	 *            the position to insert at.
	 * @param child
	 *            the Node<T> object to insert.
	 * @throws IndexOutOfBoundsException
	 *             if thrown.
	 */
	public void insertChildAt(int index, Node<T> child) throws IndexOutOfBoundsException {
		if (index == getNumberOfChildren()) {
			// this is really an append
			addChild(child);
			return;
		} else {
			children.get(index); //just to throw the exception, and stop here
			children.add(index, child);
		}
	}

	/**
	 * Remove the Node<T> element at index index of the List<Node<T>>.
	 * 
	 * @param index
	 *            the index of the element to delete.
	 * @throws IndexOutOfBoundsException
	 *             if thrown.
	 */
	public void removeChildAt(int index) throws IndexOutOfBoundsException {
		children.remove(index);
	}

	public T getData() {
		return this.data;
	}

	public void setData(T data) {
		this.data = data;
	}

	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append(""{"").append(getData().toString()).append("",["");
		int i = 0;
		for (Node<T> e : getChildren()) {
			if (i > 0) {
				sb.append("","");
			}
			sb.append(e.getData().toString());
			i++;
		}
		sb.append(""]"").append(""}"");
		return sb.toString();
	}

	public Node<T> getParent() {
		return parent;
	}

	public void setParent(Node<T> parent) {
		this.parent = parent;
	}
}
"
AbstractDirectedHypergraph.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directedhypergraph;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Set;

import org.processmining.models.graphbased.AbstractGraph;

public abstract class AbstractDirectedHypergraph<N extends DirectedHypergraphNode, I extends DirectedIncomingHyperedge<? extends N, ? extends N>, O extends DirectedOutgoingHyperedge<? extends N, ? extends N>>
		extends AbstractGraph implements DirectedHypergraph<N, I, O> {

	public AbstractDirectedHypergraph() {
		super();
	}

	public AbstractDirectedHypergraph<?, ?, ?> getGraph() {
		return this;
	}

	protected abstract AbstractDirectedHypergraph<N, I, O> getEmptyClone();

	protected abstract void cloneFrom(AbstractDirectedHypergraph<N, I, O> graph);

	@SuppressWarnings(""unchecked"")
	public abstract void removeEdge(DirectedIncomingHyperedge edge);

	@SuppressWarnings(""unchecked"")
	public abstract void removeEdge(DirectedOutgoingHyperedge edge);

	protected void checkAddEdge(N source, Set<N> targets) {
		Collection<N> nodes = getNodes();
		if (!nodes.contains(source) && !nodes.containsAll(targets)) {
			throw new IllegalArgumentException(""Cannot add an edge between "" + source.toString() + "" and ""
					+ targets.toString() + "", since one of these nodes is not in the graph."");
		}

	}

	protected void checkAddEdge(Set<N> sources, N target) {
		Collection<N> nodes = getNodes();
		if (!nodes.containsAll(sources) && !nodes.contains(target)) {
			throw new IllegalArgumentException(""Cannot add an edge between "" + sources.toString() + "" and ""
					+ target.toString() + "", since one of these nodes is not in the graph."");
		}

	}

	public Collection<I> getIncomingInEdges(DirectedHypergraphNode node) {
		Collection<I> edges = new ArrayList<I>();
		for (I edge : getInEdges()) {
			if (edge.getTarget().equals(node)) {
				edges.add(edge);
			}
		}
		return edges;
	}

	public Collection<O> getOutgoingOutEdges(DirectedHypergraphNode node) {
		Collection<O> edges = new ArrayList<O>();
		for (O edge : getOutEdges()) {
			if (edge.getSource().equals(node)) {
				edges.add(edge);
			}
		}
		return edges;

	}

	public Collection<O> getIncomingOutEdges(DirectedHypergraphNode node) {
		Collection<O> edges = new ArrayList<O>();
		for (O edge : getOutEdges()) {
			if (edge.getTargets().contains(node)) {
				edges.add(edge);
			}
		}
		return edges;
	}

	public Collection<I> getOutgoingInEdges(DirectedHypergraphNode node) {
		Collection<I> edges = new ArrayList<I>();
		for (I edge : getInEdges()) {
			if (edge.getSources().contains(node)) {
				edges.add(edge);
			}
		}
		return edges;
	}

	public int compareTo(DirectedHypergraph<N, I, O> o) {
		if (!(o instanceof AbstractDirectedHypergraph<?, ?, ?>)) {
			return getLabel().compareTo(o.getLabel());
		}
		AbstractDirectedHypergraph<?, ?, ?> graph = (AbstractDirectedHypergraph<?, ?, ?>) o;
		return id.compareTo(graph.id);
	}

}
"
AbstractDirectedHypergraphNode.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directedhypergraph;

import java.awt.Dimension;

import org.processmining.models.graphbased.AbstractGraphNode;
import org.processmining.models.graphbased.AttributeMap;

public class AbstractDirectedHypergraphNode extends AbstractGraphNode implements DirectedHypergraphNode {

	private final AbstractDirectedHypergraph<?, ?, ?> graph;

	public AbstractDirectedHypergraphNode(String label, AbstractDirectedHypergraph<?, ?, ?> graph) {
		super();
		this.graph = graph;
		getAttributeMap().put(AttributeMap.LABEL, label);
		getAttributeMap().put(AttributeMap.SIZE, new Dimension(50, 50));
	}

	public DirectedHypergraph<?, ?, ?> getGraph() {
		return graph;
	}



	public int compareTo(DirectedHypergraphNode node) {
		if (node instanceof AbstractDirectedHypergraphNode) {
			return getId().compareTo(((AbstractDirectedHypergraphNode) node).getId());
		}
		return getLabel().compareTo(node.getLabel());

	}

}
"
AbstractDirectedIncomingHyperedge.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directedhypergraph;

import java.util.Iterator;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import org.processmining.framework.util.Cast;
import org.processmining.models.graphbased.AbstractGraphEdge;
import org.processmining.models.graphbased.AttributeMap;

public abstract class AbstractDirectedIncomingHyperedge<S extends AbstractDirectedHypergraphNode, T extends AbstractDirectedHypergraphNode>
		extends AbstractGraphEdge<Set<S>, T> implements DirectedIncomingHyperedge<S, T> {

	private final AbstractDirectedHypergraph<?, ?, ?> graph;

	public AbstractDirectedIncomingHyperedge(Set<S> sources, T target, String label) {
		super(sources, target);
		// DO NOT uncomment the next line. It is not valid,
		// but the idea is clear.
		// assert(for (source:sources) {source.getGraph() ==
		// target.getGraph()});
		assert (target.getGraph() instanceof AbstractDirectedHypergraph<?, ?, ?>);
		this.graph = Cast.<AbstractDirectedHypergraph<?, ?, ?>>cast(target.getGraph());
		getAttributeMap().put(AttributeMap.LABEL, label);
	}

	public AbstractDirectedHypergraph<?, ?, ?> getGraph() {
		return graph;
	}

	public int compareTo(AbstractGraphEdge<Set<S>, T> edge) {
		int c;
		c = getClass().getName().compareTo(edge.getClass().getName());
		if (c != 0) {
			return c;
		}
		// Check for same target
		c = target.compareTo(edge.getTarget());
		if (c != 0) {
			return c;
		}
		// Check for same sources size
		c = source.size() - edge.getSource().size();
		if ((c != 0) || (source.size() == 0)) {
			return c;
		}
		SortedSet<S> sources = new TreeSet<S>(source);
		SortedSet<S> edgeSources = new TreeSet<S>(edge.getSource());
		Iterator<S> it = sources.iterator();
		Iterator<S> it2 = edgeSources.iterator();
		do {
			c = (it.next().compareTo(it2.next()));
		} while ((c == 0) && it.hasNext());
		return c;
	}

	public Set<S> getSources() {
		return getSource();
	}
}
"
AbstractDirectedOutgoingHyperedge.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directedhypergraph;

import java.util.Iterator;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import org.processmining.framework.util.Cast;
import org.processmining.models.graphbased.AbstractGraphEdge;
import org.processmining.models.graphbased.AttributeMap;

public abstract class AbstractDirectedOutgoingHyperedge<S extends AbstractDirectedHypergraphNode, T extends AbstractDirectedHypergraphNode>
		extends AbstractGraphEdge<S, Set<T>> implements DirectedOutgoingHyperedge<S, T> {

	private final AbstractDirectedHypergraph<?, ?, ?> graph;

	public AbstractDirectedOutgoingHyperedge(S source, Set<T> targets, String label) {
		super(source, targets);
		// DO NOT uncomment the next line. It is not valid,
		// but the idea is clear.
		// assert(for (source:sources) {source.getGraph() ==
		// target.getGraph()});
		assert (source.getGraph() instanceof AbstractDirectedHypergraph<?, ?, ?>);
		this.graph = Cast.<AbstractDirectedHypergraph<?, ?, ?>>cast(source.getGraph());
		getAttributeMap().put(AttributeMap.LABEL, label);
	}

	public AbstractDirectedHypergraph<?, ?, ?> getGraph() {
		return graph;
	}

	public int compareTo(AbstractGraphEdge<S, Set<T>> edge) {
		int c;
		c = getClass().getName().compareTo(edge.getClass().getName());
		if (c != 0) {
			return c;
		}
		// Check for same source
		c = source.compareTo(edge.getSource());
		if (c != 0) {
			return c;
		}
		// Check for same sources size
		c = target.size() - edge.getTarget().size();
		if ((c != 0) || (target.size() == 0)) {
			return c;
		}
		SortedSet<T> targets = new TreeSet<T>(target);
		SortedSet<T> edgeTargets = new TreeSet<T>(edge.getTarget());
		Iterator<T> it = targets.iterator();
		Iterator<T> it2 = edgeTargets.iterator();
		do {
			c = (it.next().compareTo(it2.next()));
		} while ((c == 0) && it.hasNext());
		return c;
	}

	public Set<T> getTargets() {
		return getTarget();
	}
}
"
DirectedHypergraph.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directedhypergraph;

import java.util.Collection;

public interface DirectedHypergraph<N extends DirectedHypergraphNode, I extends DirectedIncomingHyperedge<? extends N, ? extends N>, O extends DirectedOutgoingHyperedge<? extends N, ? extends N>>
		extends DirectedHypergraphElement, Comparable<DirectedHypergraph<N, I, O>> {

	Collection<N> getNodes();

	Collection<I> getInEdges();

	Collection<O> getOutEdges();

	Collection<I> getIncomingInEdges(DirectedHypergraphNode node);

	Collection<O> getOutgoingOutEdges(DirectedHypergraphNode node);

	Collection<O> getIncomingOutEdges(DirectedHypergraphNode node);

	Collection<I> getOutgoingInEdges(DirectedHypergraphNode node);

	@SuppressWarnings(""unchecked"")
	void removeEdge(DirectedIncomingHyperedge edge);

	@SuppressWarnings(""unchecked"")
	void removeEdge(DirectedOutgoingHyperedge edge);

}
"
DirectedHypergraphElement.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directedhypergraph;

import org.processmining.models.graphbased.AttributeMapOwner;

public interface DirectedHypergraphElement extends AttributeMapOwner, Cloneable {

	String getLabel();

	DirectedHypergraph<?, ?, ?> getGraph();

	boolean equals(Object o);

	int hashCode();
}"
DirectedHypergraphNode.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directedhypergraph;

public interface DirectedHypergraphNode extends DirectedHypergraphElement, Comparable<DirectedHypergraphNode> {

}
"
DirectedIncomingHyperedge.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directedhypergraph;

import java.util.Set;

/**
 * represents edges going from multiple sources towards one target
 * 
 * @author bfvdonge
 * 
 * @param <S>
 * @param <T>
 */
public interface DirectedIncomingHyperedge<S extends DirectedHypergraphNode, T extends DirectedHypergraphNode> extends
		DirectedHypergraphElement {

	Set<S> getSources();

	T getTarget();

}
"
DirectedOutgoingHyperedge.java,prom-models-6.9.32,"package org.processmining.models.graphbased.directedhypergraph;

import java.util.Set;

/**
 * represents edges going from a source towards multiple targets
 * 
 * @author bfvdonge
 * 
 * @param <S>
 * @param <T>
 */
public interface DirectedOutgoingHyperedge<S extends DirectedHypergraphNode, T extends DirectedHypergraphNode> extends
		DirectedHypergraphElement {

	S getSource();

	Set<T> getTargets();

}"
EdgeID.java,prom-models-6.9.32,"package org.processmining.models.graphbased;

import java.io.Serializable;
import java.util.UUID;

public class EdgeID implements Comparable<EdgeID>, Serializable {

	private static final long serialVersionUID = -6457455085857447745L;

	private final UUID id = UUID.randomUUID();

	public int compareTo(EdgeID edge) {
		return id.compareTo(edge.id);
	}

	public String toString() {
		return ""node "" + id;
	}

	public boolean equals(Object o) {
		if (!(o instanceof EdgeID)) {
			return false;
		}
		EdgeID edgeID = (EdgeID) o;
		return edgeID.id.equals(id);
	}

	public int hashCode() {
		return id.hashCode();
	}

}
"
Expandable.java,prom-models-6.9.32,"package org.processmining.models.graphbased;

import java.awt.Dimension;

public interface Expandable extends AttributeMapOwner {

	Dimension getCollapsedSize();

	//	ExpansionListener.ListenerList getExpansionListeners();
	//
	//	void expand();
	//
	//	void collapse();
	//
	//	boolean isCollapsed();
	//
	//	boolean isExpanded();
}
"
ExpansionListener.java,prom-models-6.9.32,"package org.processmining.models.graphbased;

import java.util.EventListener;

import org.processmining.framework.plugin.events.ProMEventListenerList;

public interface ExpansionListener extends EventListener {

	void nodeExpanded(Expandable source);

	void nodeCollapsed(Expandable source);

	public class ListenerList extends ProMEventListenerList<ExpansionListener> {
		public void fireNodeExpanded(Expandable source) {
			for (ExpansionListener listener : getListeners()) {
				listener.nodeExpanded(source);
			}
		}

		public void fireNodeCollapsed(Expandable source) {
			for (ExpansionListener listener : getListeners()) {
				listener.nodeCollapsed(source);
			}
		}

	}

}
"
NodeID.java,prom-models-6.9.32,"package org.processmining.models.graphbased;

import java.io.Serializable;
import java.util.UUID;

public class NodeID implements Comparable<NodeID>, Serializable {

	private static final long serialVersionUID = -6457455085857447745L;

	private final UUID id = UUID.randomUUID();

	public int compareTo(NodeID node) {
		return id.compareTo(node.id);
	}

	public String toString() {
		return ""node "" + id;
	}

	public boolean equals(Object o) {
		if (!(o instanceof NodeID)) {
			return false;
		}
		NodeID nodeID = (NodeID) o;
		return nodeID.id.equals(id);
	}

	public int hashCode() {
		return id.hashCode();
	}

}
"
AbstractUndirectedEdge.java,prom-models-6.9.32,"package org.processmining.models.graphbased.undirected;

import org.processmining.framework.util.Cast;
import org.processmining.models.graphbased.AbstractGraphEdge;
import org.processmining.models.graphbased.AttributeMap;

public abstract class AbstractUndirectedEdge<T extends UndirectedGraphNode> extends AbstractGraphEdge<T, T> implements
		UndirectedGraphEdge<T> {

	private final AbstractUndirectedGraph<?, ?> graph;

	public AbstractUndirectedEdge(T source, T target, String label) {
		super(source, target);
		assert (source.getGraph() == target.getGraph());
		assert (source.getGraph() instanceof AbstractUndirectedGraph<?, ?>);
		this.graph = Cast.<AbstractUndirectedGraph<?, ?>>cast(source.getGraph());
		getAttributeMap().put(AttributeMap.LABEL, label);
	}

	public UndirectedGraph<?, ?> getGraph() {
		return graph;
	}

}
"
AbstractUndirectedGraph.java,prom-models-6.9.32,"package org.processmining.models.graphbased.undirected;

import java.util.ArrayList;
import java.util.Collection;

import org.processmining.models.graphbased.AbstractGraph;

public abstract class AbstractUndirectedGraph<N extends UndirectedGraphNode, E extends UndirectedGraphEdge<? extends N>>
		extends AbstractGraph implements UndirectedGraph<N, E> {

	public AbstractUndirectedGraph() {
		super();
	}

	public AbstractUndirectedGraph<?, ?> getGraph() {
		return this;
	}

	protected abstract AbstractUndirectedGraph<N, E> getEmptyClone();

	protected abstract void cloneFrom(UndirectedGraph<N, E> graph);

	@SuppressWarnings(""unchecked"")
	public abstract void removeEdge(UndirectedGraphEdge edge);

	protected void checkAddEdge(N source, N target) {
		Collection<N> nodes = getNodes();
		if (!nodes.contains(source) && !nodes.contains(target)) {
			throw new IllegalArgumentException(""Cannot add an arc between "" + source.toString() + "" and ""
					+ target.toString() + "", since one of these nodes is not in the graph."");
		}

	}

	public Collection<E> getEdges(UndirectedGraphNode node) {
		Collection<E> edges = new ArrayList<E>();
		for (E edge : getEdges()) {
			if (edge.getTarget().equals(node) || edge.getSource().equals(node)) {
				edges.add(edge);
			}
		}
		return edges;
	}

	public int compareTo(UndirectedGraph<N, E> o) {
		if (!(o instanceof AbstractUndirectedGraph<?, ?>)) {
			return getLabel().compareTo(o.getLabel());
		}
		AbstractUndirectedGraph<?, ?> graph = (AbstractUndirectedGraph<?, ?>) o;
		return id.compareTo(graph.id);
	}

}
"
AbstractUndirectedNode.java,prom-models-6.9.32,"package org.processmining.models.graphbased.undirected;

import org.processmining.models.graphbased.AbstractGraphNode;
import org.processmining.models.graphbased.AttributeMap;

public abstract class AbstractUndirectedNode extends AbstractGraphNode implements UndirectedGraphNode {

	private final AbstractUndirectedGraph<?, ?> graph;

	public AbstractUndirectedNode(String label, AbstractUndirectedGraph<?, ?> graph) {
		super();
		this.graph = graph;
		getAttributeMap().put(AttributeMap.LABEL, label);
	}

	public UndirectedGraph<?, ?> getGraph() {
		return graph;
	}

	public int compareTo(UndirectedGraphNode node) {
		if (node instanceof AbstractUndirectedNode) {
			return getId().compareTo(((AbstractUndirectedNode) node).getId());
		} else {
			return getLabel().compareTo(node.getLabel());
		}
	}

}
"
UndirectedGraph.java,prom-models-6.9.32,"package org.processmining.models.graphbased.undirected;

import java.util.Collection;

public interface UndirectedGraph<N extends UndirectedGraphNode, E extends UndirectedGraphEdge<? extends N>> extends
		UndirectedGraphElement, Comparable<UndirectedGraph<N, E>> {

	Collection<N> getNodes();

	Collection<E> getEdges();

	Collection<E> getEdges(UndirectedGraphNode node);

	@SuppressWarnings(""unchecked"")
	void removeEdge(UndirectedGraphEdge edge);

}
"
UndirectedGraphEdge.java,prom-models-6.9.32,"package org.processmining.models.graphbased.undirected;

public interface UndirectedGraphEdge<T extends UndirectedGraphNode> extends UndirectedGraphElement {

	T getSource();

	T getTarget();

}
"
UndirectedGraphElement.java,prom-models-6.9.32,"package org.processmining.models.graphbased.undirected;

import org.processmining.models.graphbased.AttributeMapOwner;

public interface UndirectedGraphElement extends AttributeMapOwner, Cloneable {

	String getLabel();

	UndirectedGraph<?, ?> getGraph();

	boolean equals(Object o);

	int hashCode();

}
"
UndirectedGraphNode.java,prom-models-6.9.32,"package org.processmining.models.graphbased.undirected;

public interface UndirectedGraphNode extends UndirectedGraphElement, Comparable<UndirectedGraphNode> {

}
"
ViewSpecificAttributeMap.java,prom-models-6.9.32,"package org.processmining.models.graphbased;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class ViewSpecificAttributeMap {

	public static final ViewSpecificAttributeMap EMPTYMAP = new ViewSpecificAttributeMap();

	private final Map<AttributeMapOwner, AttributeMap> maps = new HashMap<AttributeMapOwner, AttributeMap>();

	public Object get(AttributeMapOwner owner, String key) {
		AttributeMap map = maps.get(owner);
		if ((map == null) || !map.containsKey(key)) {
			map = owner.getAttributeMap();
		}
		return map.get(key);

	}

	@SuppressWarnings(""unchecked"")
	public <T> T get(AttributeMapOwner owner, String key, T defaultValue) {
		AttributeMap map = maps.get(owner);
		if (map != null) {
			if (map.containsKey(key)) {
				Object o = map.get(key);
				if (o == null) {
					return null;
				}
				return (T) map.get(key);
			}
		}
		map = owner.getAttributeMap();
		if (map.containsKey(key)) {
			Object o = map.get(key);
			if (o == null) {
				return null;
			}
			return (T) map.get(key);
		} else {
			return defaultValue;
		}
	}

	public void clearViewSpecific(AttributeMapOwner owner) {
		AttributeMap map = maps.get(owner);
		if (map != null) {
			for (String key : map.keySet()) {
				putViewSpecific(owner, key, null);
			}
		}
		maps.remove(owner);
	}

	public Set<String> keySet(AttributeMapOwner owner) {
		Set<String> result = new HashSet<String>(owner.getAttributeMap().keySet());
		AttributeMap map = maps.get(owner);
		if (map != null) {
			result.addAll(map.keySet());
		}
		return result;
	}

	/**
	 * This method updates the map and signals the owner. The origin is passed
	 * in this update, to make sure that no unnecessary updates are performed
	 * 
	 * @param key
	 * @param value
	 * @param origin
	 * @return
	 */
	public boolean putViewSpecific(AttributeMapOwner owner, String key, Object value) {
		AttributeMap map = getMapFor(owner);
		Object old = map.get(key);
		map.put(key, value);
		if (value == old) {
			return false;
		}
		if ((value == null) || (old == null) || !value.equals(old)) {
			return true;
		}
		return false;
	}

	public void removeViewSpecific(AttributeMapOwner owner, String key) {
		AttributeMap map = maps.get(owner);
		if (map == null) {
			return;
		}
		map.remove(key);
	}

	public Set<AttributeMapOwner> keySet() {
		return maps.keySet();
	}

	public AttributeMap getMapFor(AttributeMapOwner node) {
		AttributeMap m = maps.get(node);
		if (m == null) {
			m = new AttributeMap();
			maps.put(node, m);
		}
		return m;
	}

	public ViewSpecificAttributeMap createClone() {
		ViewSpecificAttributeMap map = new ViewSpecificAttributeMap();
		for (AttributeMapOwner owner : maps.keySet()) {
			for (String key : maps.get(owner).keySet()) {
				map.putViewSpecific(owner, key, maps.get(owner).get(key));
			}
		}
		return map;
	}
}
"
ExecutionInformation.java,prom-models-6.9.32,"package org.processmining.models.semantics;

public interface ExecutionInformation {

}
"
ExtendedSemantics.java,prom-models-6.9.32,"package org.processmining.models.semantics;

public interface ExtendedSemantics<S, T> extends Semantics<S, T> {

	ExecutionInformation executeTransition(T toExecute);

}
"
IllegalTransitionException.java,prom-models-6.9.32,"package org.processmining.models.semantics;

public class IllegalTransitionException extends Exception {

	private static final long serialVersionUID = -3136219267846046893L;

	public IllegalTransitionException(Object trans, Object state) {
		super(""Cannot execute transition "" + trans + "" in state "" + state);
	}

	public <S> IllegalTransitionException(Object trans, Object state, String reason) {
		super(""Cannot execute transition "" + trans + "" in state "" + state + "" Reason: "" + reason);
	}
}
"
Semantics.java,prom-models-6.9.32,"package org.processmining.models.semantics;

import java.io.Serializable;
import java.util.Collection;

public interface Semantics<S, T> extends Serializable {

	void setCurrentState(S currentState);

	S getCurrentState();

	Collection<T> getExecutableTransitions();

	ExecutionInformation executeExecutableTransition(T toExecute) throws IllegalTransitionException;

	/**
	 * Initializes this semantics. Note that the set of transitions is
	 * considered read only, i.e. no changes can be made to it by a
	 * Semantics<S,T> implementation. However, the initial state is not read
	 * only.
	 * 
	 * @param transitions
	 * @param initialState
	 */
	void initialize(Collection<T> transitions, S initialState);
}
"
AbstractShape.java,prom-models-6.9.32,"package org.processmining.models.shapes;

import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

public abstract class AbstractShape implements Shape {

	protected Point2D intersection(Point2D a1, Point2D a2, Point2D b1, Point2D b2) {

		double ua_t = (b2.getX() - b1.getX()) * (a1.getY() - b1.getY()) - (b2.getY() - b1.getY())
				* (a1.getX() - b1.getX());
		double ub_t = (a2.getX() - a1.getX()) * (a1.getY() - b1.getY()) - (a2.getY() - a1.getY())
				* (a1.getX() - b1.getX());
		double u_b = (b2.getY() - b1.getY()) * (a2.getX() - a1.getX()) - (b2.getX() - b1.getX())
				* (a2.getY() - a1.getY());

		if (u_b != 0) {
			double ua = ua_t / u_b;
			double ub = ub_t / u_b;

			if ((0 <= ua) && (ua <= 1) && (0 <= ub) && (ub <= 1)) {
				return new Point2D.Double(a1.getX() + ua * (a2.getX() - a1.getX()), a1.getY() + ua
						* (a2.getY() - a1.getY()));
			}
		}
		return null;
	}

	public Point2D getPerimeterPoint(Rectangle2D bounds, Point2D source, Point2D p) {

		double x = bounds.getX();
		double y = bounds.getY();
		double width = bounds.getWidth() - 1;
		double height = bounds.getHeight() - 1;

		double xCenter = x + width / 2;
		double yCenter = y + height / 2;
		double dx = p.getX() - xCenter; // Compute Angle
		double dy = p.getY() - yCenter;
		double alpha = Math.atan2(dy, dx);
		double xout = 0, yout = 0;
		double pi = Math.PI;
		double pi2 = Math.PI / 2.0;
		double beta = pi2 - alpha;
		double t = Math.atan2(height, width);
		if ((alpha < -pi + t) || (alpha > pi - t)) { // Left edge
			xout = x;
			yout = yCenter - width * Math.tan(alpha) / 2;
		} else if (alpha < -t) { // Top Edge
			yout = y;
			xout = xCenter - height * Math.tan(beta) / 2;
		} else if (alpha < t) { // Right Edge
			xout = x + width;
			yout = yCenter + width * Math.tan(alpha) / 2;
		} else { // Bottom Edge
			yout = y + height;
			xout = xCenter + height * Math.tan(beta) / 2;
		}
		return new Point2D.Double(xout, yout);
	}

}
"
Decorated.java,prom-models-6.9.32,"package org.processmining.models.shapes;

import java.awt.Graphics2D;

public interface Decorated {

	public void decorate(Graphics2D g2d, double x, double y, double width, double height);

}
"
Diamond.java,prom-models-6.9.32,"package org.processmining.models.shapes;

import java.awt.geom.Point2D;

public class Diamond extends Polygon {

	protected Point2D[] getPoints(double x, double y, double width, double height) {
		Point2D[] points = new Point2D[4];
		points[0] = new Point2D.Double(x, y + (height - 1) / 2);
		points[1] = new Point2D.Double(x + (width - 1) / 2, y);
		points[2] = new Point2D.Double(x + (width - 1), y + (height - 1) / 2);
		points[3] = new Point2D.Double(x + (width - 1) / 2, y + (height - 1));
		return points;
	}

}
"
Ellipse.java,prom-models-6.9.32,"package org.processmining.models.shapes;

import java.awt.Point;
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

public class Ellipse implements Shape {

	public Ellipse() {
	}

	public GeneralPath getPath(double x, double y, double width, double height) {
		GeneralPath path = new GeneralPath();

		Ellipse2D e = new Ellipse2D.Double(x, y, width - 1, height - 1);

		path.append(e, false);

		return path;
	}

	public Point2D getPerimeterPoint(Rectangle2D bounds, Point2D source, Point2D p) {

		double x = bounds.getX();
		double y = bounds.getY();
		double a = (bounds.getWidth() - 1) / 2;
		double b = (bounds.getHeight() - 1) / 2;

		// x0,y0 - center of ellipse
		double x0 = x + a;
		double y0 = y + b;

		// x1, y1 - point
		double x1 = p.getX();
		double y1 = p.getY();

		// calculate straight line equation through point and ellipse center
		// y = d * x + h
		double dx = x1 - x0;
		double dy = y1 - y0;

		if (dx == 0) {
			return new Point((int) x0, (int) (y0 + b * dy / Math.abs(dy)));
		}

		double d = dy / dx;
		double h = y0 - d * x0;

		// calculate intersection
		double e = a * a * d * d + b * b;
		double f = -2 * x0 * e;
		double g = a * a * d * d * x0 * x0 + b * b * x0 * x0 - a * a * b * b;

		double det = Math.sqrt(f * f - 4 * e * g);

		// two solutions (perimeter points)
		double xout1 = (-f + det) / (2 * e);
		double xout2 = (-f - det) / (2 * e);
		double yout1 = d * xout1 + h;
		double yout2 = d * xout2 + h;

		double dist1Squared = Math.pow((xout1 - x1), 2) + Math.pow((yout1 - y1), 2);
		double dist2Squared = Math.pow((xout2 - x1), 2) + Math.pow((yout2 - y1), 2);

		// correct solution
		double xout, yout;

		if (dist1Squared < dist2Squared) {
			xout = xout1;
			yout = yout1;
		} else {
			xout = xout2;
			yout = yout2;
		}

		return new Point2D.Double(xout, yout);
	}

}
"
Gate.java,prom-models-6.9.32,"package org.processmining.models.shapes;

import java.awt.geom.GeneralPath;
import java.awt.geom.QuadCurve2D;

public class Gate extends AbstractShape {

	public final static int RIGHT = 0;
	public final static int TOP = 2;
	public final static int LEFT = 4;
	public final static int BOTTOM = 6;

	private final int direction;

	public Gate(int direction) {
		this.direction = direction;
	}

	public GeneralPath getPath(double x, double y, double width, double height) {

		// Width and height have correct ratio;
		GeneralPath path = new GeneralPath();
		double[] points = new double[] { x, y, x + width, y, x + width, y + height, x, y + height };
		double[] midpts = new double[] { x + width, y + height / 2., x + width / 2., y, x, y + height / 2.,
				x + width / 2., y };

		int d = direction;
		path.moveTo(points[d % 8], points[d % 8]);

		//		path.curveTo(points[d++ % 8], points[d++ % 8], points[d++ % 8], points[d++ % 8], points[d++ % 8],
		//				points[d++ % 8]);

		QuadCurve2D curve = new QuadCurve2D.Double(points[d++ % 8], points[d++ % 8], points[d++ % 8], points[d++ % 8],
				midpts[direction], midpts[direction + 1]);
		path.append(curve, true);

		curve = new QuadCurve2D.Double(midpts[direction], midpts[direction + 1], points[d++ % 8], points[d++ % 8],
				points[d++ % 8], points[d++ % 8]);
		path.append(curve, true);

		path.lineTo(points[d++ % 8], points[d++ % 8]);

		return path;
	}
}
"
Hexagon.java,prom-models-6.9.32,"package org.processmining.models.shapes;

import java.awt.geom.Point2D;

public class Hexagon extends Polygon {

	private final double cornerOffset;

	public Hexagon(double cornerOffset) {
		this.cornerOffset = cornerOffset;
	}

	protected Point2D[] getPoints(double x, double y, double width, double height) {
		Point2D[] points = new Point2D[6];
		double offset = width * cornerOffset;

		points[0] = new Point2D.Double(x + offset, y);
		points[1] = new Point2D.Double(x, y + (height - 1) / 2);
		points[2] = new Point2D.Double(x + offset, y + height - 1);
		points[3] = new Point2D.Double(x + width - 1 - offset, y + height - 1);
		points[4] = new Point2D.Double(x + width - 1, y + (height - 1) / 2);
		points[5] = new Point2D.Double(x + width - 1 - offset, y);
		return points;
	}

}
"
Octagon.java,prom-models-6.9.32,"package org.processmining.models.shapes;

import java.awt.geom.Point2D;

public class Octagon extends Polygon {

	private final double cornerOffset;

	public Octagon(double cornerOffset) {
		this.cornerOffset = cornerOffset;
	}

	protected Point2D[] getPoints(double x, double y, double width, double height) {
		Point2D[] points = new Point2D[8];
		double offset = width * cornerOffset;

		points[0] = new Point2D.Double(x + offset, y);
		points[1] = new Point2D.Double(x, y + (height - 1) / 3);
		points[2] = new Point2D.Double(x, y + 2 * (height - 1) / 3);
		points[3] = new Point2D.Double(x + offset, y + height - 1);
		points[4] = new Point2D.Double(x + width - 1 - offset, y + height - 1);
		points[5] = new Point2D.Double(x + width - 1, y + 2 * (height - 1) / 3);
		points[6] = new Point2D.Double(x + width - 1, y + (height - 1) / 3);
		points[7] = new Point2D.Double(x + width - 1 - offset, y);
		return points;
	}

}"
Polygon.java,prom-models-6.9.32,"package org.processmining.models.shapes;

import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

public abstract class Polygon extends AbstractShape {

	public Point2D getPerimeterPoint(Rectangle2D bounds, Point2D source, Point2D p) {
		// Use a linde from centerPoint to p, juist like ellipse. This is
		// an ""estimate"", but the centerpoint is sure to be inside the perimiter

		double x = bounds.getX();
		double y = bounds.getY();
		double height = bounds.getHeight();
		double width = bounds.getWidth();

		// x0,y0 - center of ellipse
		Point2D center = new Point2D.Double(x + (width + 1) / 2, y + (height + 1) / 2);

		Point2D[] points = getPoints(x, y, width, height);

		Point2D point = null;

		for (int i = 0; i < points.length; i++) {
			point = intersection(p, center, points[i], points[(i + 1) % points.length]);
			if (point != null) {
				return point;
			}
		}

		return point;
	}

	protected abstract Point2D[] getPoints(double x, double y, double width, double height);

	public GeneralPath getPath(double x, double y, double width, double height) {
		// Width and height have correct ratio;
		GeneralPath path = new GeneralPath();

		Point2D[] points = getPoints(x, y, width, height);

		path.moveTo((float) points[0].getX(), (float) points[0].getY());
		for (int i = 1; i < points.length; i++) {
			path.lineTo((float) points[i].getX(), (float) points[i].getY());
		}
		path.closePath();
		return path;

	}

}
"
Rectangle.java,prom-models-6.9.32,"package org.processmining.models.shapes;

import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RoundRectangle2D;

public class Rectangle extends AbstractShape {

	private final boolean rounded;

	public Rectangle() {
		this(false);
	}

	public Rectangle(boolean rounded) {
		this.rounded = rounded;
	}

	public GeneralPath getPath(double x, double y, double width, double height) {

		java.awt.Shape rect;
		if (rounded) {
			double m = Math.max(width, height) * .125;
			rect = new RoundRectangle2D.Double(x, y, width - 1, height - 1, m, m);
		} else {
			rect = new Rectangle2D.Double(x, y, width - 1, height - 1);
		}
		// Width and height have correct ratio;
		GeneralPath path = new GeneralPath();
		path.append(rect, false);
		return path;

	}

}
"
RoundedRect.java,prom-models-6.9.32,"/**
 * 
 */
package org.processmining.models.shapes;

import java.awt.geom.GeneralPath;
import java.awt.geom.RoundRectangle2D;

/**
 * @author Arya Adriansyah
 * @email a.adriansyah@tue.nl
 * @version Apr 5, 2010
 * 
 */
public class RoundedRect extends AbstractShape {

	public GeneralPath getPath(double x, double y, double width, double height) {
		double m = Math.max(width, height) * .125;

		// Width and height have correct ratio;
		GeneralPath path = new GeneralPath();

		// main border
		java.awt.Shape rect = new RoundRectangle2D.Double(x, y, width, height, m, m);
		path.append(rect, false);

		return path;
	}

}
"
Shape.java,prom-models-6.9.32,"package org.processmining.models.shapes;

import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

public interface Shape {

	public GeneralPath getPath(double x, double y, double width, double height);

	public Point2D getPerimeterPoint(Rectangle2D bounds, Point2D source, Point2D p);

}
"
HelloWorld.java,prom-plugins-6.9.67,"package org.processmining.plugins;

import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;

public class HelloWorld {
        @Plugin(
                name = ""My Hello World Plugin"", 
                parameterLabels = {}, 
                returnLabels = { ""Hello world string"" }, 
                returnTypes = { String.class }, 
                userAccessible = true, 
                help = ""Produces the string: 'Hello world'""
        )
        @UITopiaVariant(
                affiliation = ""My company"", 
                author = ""My name"", 
                email = ""My e-mail address""
        )
        public static String helloWorld(PluginContext context) {
                return ""Hello World"";
        }
}"
ShowPackageOverviewPlugin.java,prom-plugins-6.9.67,"package org.processmining.plugins;

import java.util.Collection;
import java.util.List;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UIExportPlugin;
import org.processmining.contexts.uitopia.annotations.UIImportPlugin;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.contexts.uitopia.packagemanager.PMController;
import org.processmining.contexts.uitopia.packagemanager.PMPackage;
import org.processmining.framework.boot.Boot;
import org.processmining.framework.packages.PackageDescriptor;
import org.processmining.framework.plugin.PluginDescriptor;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginLevel;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.HTMLToString;

@Plugin(name = ""Show Package Overview"", parameterLabels = {}, level= PluginLevel.BulletProof, returnLabels = { ""Release info"" }, returnTypes = { HTMLToString.class }, userAccessible = true)
public class ShowPackageOverviewPlugin implements HTMLToString {

	private Collection<PluginDescriptor> pluginDescriptors;

	private ShowPackageOverviewPlugin(UIPluginContext context) {
		pluginDescriptors = context.getPluginManager().getAllPlugins();
	}

	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""H.M.W. Verbeek"", email = ""h.m.w.verbeek@tue.nl"")
	@PluginVariant(variantLabel = ""Default"", requiredParameterLabels = {})
	public static HTMLToString info(final UIPluginContext context) {
		return new ShowPackageOverviewPlugin(context);
	}

	@Override
	public String toHTMLString(boolean includeHTMLTags) {
		StringBuffer buffer = new StringBuffer();

		if (includeHTMLTags) {
			buffer.append(""<html>"");
		}
		buffer.append(""<h1>ProM Package Overview</h1>"");

		PMController packageController = new PMController(Boot.Level.NONE);
		List<? extends PMPackage> uptodatePackages = packageController.getToUninstallPackages();
		List<? extends PMPackage> outofdatePackages = packageController.getToUpdatePackages();
		buffer.append(""<h2>Installed packages</h2>"");
		buffer.append(""<table>"");
		buffer.append(""<tr><th>Package</th><th>Dependency</th><th>Version</th><th>Author</th></tr>"");
		for (PMPackage pack : uptodatePackages) {
			buffer.append(""<tr>"");
			buffer.append(""<td>"" + pack.getPackageName() + ""</td>"");
			buffer.append(""<td></td>"");
			buffer.append(""<td>"" + pack.getVersion() + ""</td>"");
			buffer.append(""<td>"" + pack.getAuthorName() + ""</td>"");
			buffer.append(""</tr>"");
			for (String s : pack.getDependencies()) {
				buffer.append(""<tr><td></td><td>"" + s + ""</td><td></td><td></td></tr>"");
			}
		}
		buffer.append(""</table>"");
		buffer.append(""<h3>Updates available</h3>"");
		buffer.append(""<table>"");
		buffer.append(""<tr><th>Package name</th><th>Dependency names</th><th>Version number</th><th>Author name</th></tr>"");
		for (PMPackage pack : outofdatePackages) {
			buffer.append(""<tr>"");
			buffer.append(""<td>"" + pack.getPackageName() + ""</td>"");
			buffer.append(""<td></td>"");
			buffer.append(""<td>"" + pack.getVersion() + ""</td>"");
			buffer.append(""<td>"" + pack.getAuthorName() + ""</td>"");
			buffer.append(""</tr>"");
			for (String s : pack.getDependencies()) {
				buffer.append(""<tr><td></td><td>"" + s + ""</td><td></td><td></td></tr>"");
			}
		}
		buffer.append(""</table>"");

		buffer.append(""<h2>Available plug-ins</h2>"");
		buffer.append(""<table>"");
		buffer.append(""<tr><th>Plug-in name</th><th>UITopia</th><th>UITopia name</th><th>Package name</th><th>Author name</th></tr>"");
		for (PluginDescriptor pluginDescriptor : pluginDescriptors) {
			String uiName = null;
			boolean isUITopia = false;
			UITopiaVariant variant = pluginDescriptor.getAnnotation(UITopiaVariant.class);
			if (variant != null) {
				uiName = variant.uiLabel();
				isUITopia = true;
				buffer.append(""<tr>"");
				buffer.append(""<td>"" + pluginDescriptor.getName() + ""</td>"");
				buffer.append(""<td>Plug-in</td>"");
				buffer.append(""<td>"" + (uiName == null ? """" : uiName) + ""</td>"");
				String packName = null;
				PackageDescriptor packageDescriptor = pluginDescriptor.getPackage();
				if (packageDescriptor != null) {
					packName = packageDescriptor.getName();
				}
				buffer.append(""<td>"" + (packName == null ? """" : packName) + ""</td>"");
				buffer.append(""<td>"" + variant.author() + ""</td>"");
				buffer.append(""</tr>"");
			}
			Visualizer visualizer = pluginDescriptor.getAnnotation(Visualizer.class);
			if (visualizer != null) {
				uiName = visualizer.name();
				isUITopia = true;
				buffer.append(""<tr>"");
				buffer.append(""<td>"" + pluginDescriptor.getName() + ""</td>"");
				buffer.append(""<td>Visualizer</td>"");
				buffer.append(""<td>"" + (uiName == null ? """" : uiName) + ""</td>"");
				String packName = null;
				String authorName = null;
				PackageDescriptor packageDescriptor = pluginDescriptor.getPackage();
				if (packageDescriptor != null) {
					packName = packageDescriptor.getName();
					authorName = packageDescriptor.getAuthor();
				}
				buffer.append(""<td>"" + (packName == null ? """" : packName) + ""</td>"");
				buffer.append(""<td>"" + (authorName == null ? """" : authorName) + ""</td>"");
				buffer.append(""</tr>"");
			}
			UIImportPlugin importPlugin = pluginDescriptor.getAnnotation(UIImportPlugin.class);
			if (importPlugin != null) {
				uiName = pluginDescriptor.getName();
				isUITopia = true;
				buffer.append(""<tr>"");
				buffer.append(""<td>"" + pluginDescriptor.getName() + ""</td>"");
				buffer.append(""<td>Import</td>"");
				buffer.append(""<td>"" + (uiName == null ? """" : uiName) + ""</td>"");
				String packName = null;
				String authorName = null;
				PackageDescriptor packageDescriptor = pluginDescriptor.getPackage();
				if (packageDescriptor != null) {
					packName = packageDescriptor.getName();
					authorName = packageDescriptor.getAuthor();
				}
				buffer.append(""<td>"" + (packName == null ? """" : packName) + ""</td>"");
				buffer.append(""<td>"" + (authorName == null ? """" : authorName) + ""</td>"");
				buffer.append(""</tr>"");
			}
			UIExportPlugin exportPlugin = pluginDescriptor.getAnnotation(UIExportPlugin.class);
			if (exportPlugin != null) {
				uiName = pluginDescriptor.getName();
				isUITopia = true;
				buffer.append(""<tr>"");
				buffer.append(""<td>"" + pluginDescriptor.getName() + ""</td>"");
				buffer.append(""<td>Export</td>"");
				buffer.append(""<td>"" + (uiName == null ? """" : uiName) + ""</td>"");
				String packName = null;
				String authorName = null;
				PackageDescriptor packageDescriptor = pluginDescriptor.getPackage();
				if (packageDescriptor != null) {
					packName = packageDescriptor.getName();
					authorName = packageDescriptor.getAuthor();
				}
				buffer.append(""<td>"" + (packName == null ? """" : packName) + ""</td>"");
				buffer.append(""<td>"" + (authorName == null ? """" : authorName) + ""</td>"");
				buffer.append(""</tr>"");
			}
			for (int i = 0; i < pluginDescriptor.getNumberOfMethods(); i++) {
				variant = pluginDescriptor.getAnnotation(UITopiaVariant.class, i);
				if (variant != null) {
					uiName = variant.uiLabel();
					isUITopia = true;
					buffer.append(""<tr>"");
					buffer.append(""<td>"" + pluginDescriptor.getName() + ""</td>"");
					buffer.append(""<td>Plug-in variant</td>"");
					buffer.append(""<td>"" + (uiName == null ? """" : uiName) + ""</td>"");
					String packName = null;
					PackageDescriptor packageDescriptor = pluginDescriptor.getPackage();
					if (packageDescriptor != null) {
						packName = packageDescriptor.getName();
					}
					buffer.append(""<td>"" + (packName == null ? """" : packName) + ""</td>"");
					buffer.append(""<td>"" + variant.author() + ""</td>"");
					buffer.append(""</tr>"");
				}
			}
			if (!isUITopia) {
				buffer.append(""<tr>"");
				buffer.append(""<td>"" + pluginDescriptor.getName() + ""</td>"");
				buffer.append(""<td></td>"");
				buffer.append(""<td>"" + (uiName == null ? """" : uiName) + ""</td>"");
				String packName = null;
				String authorName = null;
				PackageDescriptor packageDescriptor = pluginDescriptor.getPackage();
				if (packageDescriptor != null) {
					packName = packageDescriptor.getName();
					authorName = packageDescriptor.getAuthor();
				}
				buffer.append(""<td>"" + (packName == null ? """" : packName) + ""</td>"");
				buffer.append(""<td>"" + (authorName == null ? """" : authorName) + ""</td>"");
				buffer.append(""</tr>"");
			}
		}
		buffer.append(""</table>"");
		if (includeHTMLTags) {
			buffer.append(""</html>"");
		}
		return buffer.toString();
	}
}
"
License.java,saxon-6.9.69,"package org.processmining.saxon;

public class License {
	
	public static String VALUE = ""MPL"";

}
"
CheckComboBox.java,widgets-6.9.234,"/*
 * Copyright (c) 2006, 2007, The Cytoscape Consortium (www.cytoscape.org)
 * 
 * The Cytoscape Consortium is: - Institute for Systems Biology - University of
 * California San Diego - Memorial Sloan-Kettering Cancer Center - Institut
 * Pasteur - Agilent Technologies
 * 
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or any later version.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. The software and documentation provided hereunder
 * is on an ""as is"" basis, and the Institute for Systems Biology and the
 * Whitehead Institute have no obligations to provide maintenance, support,
 * updates, enhancements or modifications. In no event shall the Institute for
 * Systems Biology and the Whitehead Institute be liable to any party for
 * direct, indirect, special, incidental or consequential damages, including
 * lost profits, arising out of the use of this software and its documentation,
 * even if the Institute for Systems Biology and the Whitehead Institute have
 * been advised of the possibility of such damage. See the GNU Lesser General
 * Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 */

package csplugins.id.mapping.ui;

import java.awt.Color;
import java.awt.Component;
import java.awt.event.ActionEvent;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.Vector;

import javax.swing.DefaultListCellRenderer;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JList;
import javax.swing.ListCellRenderer;
import javax.swing.SwingConstants;

/**
 * ComboBox containing checkbox
 * 
 * @author gjj
 * 
 * Added configureable colors
 * 
 * @author Massimiliano de Leoni
 */
@SuppressWarnings(""rawtypes"")
public class CheckComboBox extends JComboBox/* <Object> */{
	// checkbox renderer for combobox
	class CheckBoxRenderer implements ListCellRenderer {
		private final List<ObjCheckBox> cbs;
		private final DefaultListCellRenderer defaultRenderer = new DefaultListCellRenderer();
		private final javax.swing.JSeparator separator;

		//private final Set objs;

		public CheckBoxRenderer(final List<ObjCheckBox> cbs) {
			//setOpaque(true);
			this.cbs = cbs;
			//this.objs = objs;
			separator = new javax.swing.JSeparator(SwingConstants.HORIZONTAL);
		}

		@Override
		public Component getListCellRendererComponent(final JList list, final Object value, final int index,
				final boolean isSelected, final boolean cellHasFocus) {
			if (index > 0 && index <= cbs.size()) {
				final ObjCheckBox cb = cbs.get(index - 1);
				if (cb.getObj() == nullObject) {
					return separator;
				}

				cb.setBackground(isSelected ? backgroundSelected : backgroundNotSelected);
				cb.setForeground(isSelected ? foregroundSelected : foregroundNotSelected);

				return cb;
			}

			String str;
			final Collection objs = getSelectedItems();
			final Vector<String> strs = new Vector<String>();
			if (objs == null) {
				str = ""Please select one or more ID types"";
			} else {
				for (final Object obj : objs) {
					strs.add(obj.toString());
				}
				str = strs.toString();
			}

			Component comp=defaultRenderer.getListCellRendererComponent(list, str, index, isSelected, cellHasFocus);	
			return comp;
		}
	}

	class ObjCheckBox extends JCheckBox {
		/**
	 * 
	 */
		private static final long serialVersionUID = 1L;
		private final Object obj;

		public ObjCheckBox(final Object obj) {
			super(obj.toString());
			this.obj = obj;
		}

		public Object getObj() {
			return obj;
		}
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private List<ObjCheckBox> cbs;

	private final List<CheckComboBoxSelectionChangedListener> changedListeners = new Vector<CheckComboBoxSelectionChangedListener>();

	private Map<Object, Boolean> mapObjSelected;

	private final Object nullObject = new Object();
	
	private Color backgroundSelected=Color.BLUE;
	private Color backgroundNotSelected=Color.WHITE;
	private Color foregroundSelected=Color.WHITE;
	private Color foregroundNotSelected=Color.BLACK;

	/**
	 * @param objs
	 */
	public CheckComboBox(final Collection<?> objs) {
		this(objs, false);
	}

	/**
	 * @param objs
	 * @param selected
	 */
	public CheckComboBox(final Collection<?> objs, final boolean selected) {
		resetObjs(objs, selected);
	}

	/**
	 * @param objs
	 * @param selected
	 */
	public CheckComboBox(final Collection<?> objs, final Collection selected) {
		mapObjSelected = new LinkedHashMap<Object, Boolean>();
		for (Object obj : objs) {
			if (obj == null) {
				obj = nullObject;
			}
			mapObjSelected.put(obj, selected.contains(obj));
		}

		reset();
	}

	/**
	 * @param mapObjSelected
	 */
	public CheckComboBox(final Map<Object, Boolean> mapObjSelected) {
		this.mapObjSelected = mapObjSelected;
		reset();
	}

	/**
	 * @param objs
	 */
	public CheckComboBox(final Object[] objs) {
		this(objs, false);
	}

	/**
	 * @param objs
	 * @param selected
	 */
	public CheckComboBox(final Object[] objs, final boolean selected) {
		resetObjs(objs, selected);
	}

	/**
	 * @see javax.swing.JComboBox#actionPerformed(java.awt.event.ActionEvent)
	 */
	@Override
	public void actionPerformed(final ActionEvent e) {
		final int sel = getSelectedIndex();

		if (sel == 0) {
			getUI().setPopupVisible(this, false);
		} else if (sel > 0) {
			checkBoxSelectionChanged(sel - 1);
			for (final CheckComboBoxSelectionChangedListener l : changedListeners) {
				l.selectionChanged(sel - 1);
			}
		}

		setSelectedIndex(-1); // clear selection
	}

	/**
	 * @param c
	 */
	public void addSelectedItems(final Collection c) {
		if (c == null) {
			return;
		}

		for (final Object obj : c) {
			if (mapObjSelected.containsKey(obj)) {
				mapObjSelected.put(obj, true);
			}
		}

		reset();
		repaint();
	}

	/**
	 * @param objs
	 */
	public void addSelectedItems(final Object[] objs) {
		if (objs == null) {
			return;
		}

		for (final Object obj : objs) {
			if (mapObjSelected.containsKey(obj)) {
				mapObjSelected.put(obj, true);
			}
		}

		reset();
		repaint();
	}

	/**
	 * @param l
	 */
	public void addSelectionChangedListener(final CheckComboBoxSelectionChangedListener l) {
		if (l == null) {
			return;
		}
		changedListeners.add(l);
	}

	/**
	 * 
	 */
	@SuppressWarnings({ ""unchecked"" })
	public void clearSelection() {
		for (final Object key : new ArrayList(mapObjSelected.keySet())) {
			mapObjSelected.put(key, false);
		}

		reset();
		repaint();
	}

	/**
	 * @return
	 */
	public Collection getSelectedItems() {
		final Set<Object> ret = new TreeSet<Object>(); // alphabetically
		for (final Map.Entry<Object, Boolean> entry : mapObjSelected.entrySet()) {
			final Object obj = entry.getKey();
			final Boolean selected = entry.getValue();

			if (selected) {
				ret.add(obj);
			}
		}

		if (ret.isEmpty()) {
			return null;
		}

		return ret;
	}

	/**
	 * @param l
	 */
	public void removeSelectionChangedListener(final CheckComboBoxSelectionChangedListener l) {
		changedListeners.remove(l);
	}

	/**
	 * @param objs
	 * @param selected
	 */
	public void resetObjs(final Collection<?> objs, final boolean selected) {
		mapObjSelected = new LinkedHashMap<Object, Boolean>();
		for (final Object obj : objs) {
			mapObjSelected.put(obj, selected);
		}

		reset();
	}

	/**
	 * @param objs
	 * @param selected
	 */
	public void resetObjs(final Object[] objs, final boolean selected) {
		mapObjSelected = new LinkedHashMap<Object, Boolean>();
		for (final Object obj : objs) {
			mapObjSelected.put(obj, selected);
		}

		reset();
	}

	/**
	 * @see javax.swing.JComboBox#setPopupVisible(boolean)
	 */
	@Override
	public void setPopupVisible(final boolean flag) {
		//TODO this not work, fix it
		// Not code here prevents the populist from closing
	}

	private void checkBoxSelectionChanged(final int index) {
		final int n = cbs.size();
		if (index < 0 || index >= n) {
			return;
		}

		//Set selectedObj = getSelected();
		if (index < n - 2) {
			final ObjCheckBox cb = cbs.get(index);
			if (cb.getObj() == nullObject) {
				return;
			}

			if (cb.isSelected()) {
				cb.setSelected(false);
				mapObjSelected.put(cb.getObj(), false);

				cbs.get(n - 2).setSelected(false); //Select all
				cbs.get(n - 1).setSelected(getSelectedItems() == null); // select none
			} else {
				cb.setSelected(true);
				mapObjSelected.put(cb.getObj(), true);

				final Collection sobjs = getSelectedItems();
				cbs.get(n - 2).setSelected(sobjs != null && sobjs.size() == n - 2); // Select all
				cbs.get(n - 1).setSelected(false); // select none
			}
		} else if (index == n - 2) {
			for (final Object obj : mapObjSelected.keySet()) {
				if (obj != nullObject) {
					mapObjSelected.put(obj, true);
				}
			}

			for (int i = 0; i < n - 1; i++) {
				if (cbs.get(i) != nullObject) {
					cbs.get(i).setSelected(true);
				}
			}
			cbs.get(n - 1).setSelected(false);
		} else { // if (index==n-1)
			for (final Object obj : mapObjSelected.keySet()) {
				mapObjSelected.put(obj, false);
			}

			for (int i = 0; i < n - 1; i++) {
				cbs.get(i).setSelected(false);
			}
			cbs.get(n - 1).setSelected(true);
		}

	}

	private void initCBs() {
		cbs = new Vector<ObjCheckBox>();

		boolean selectedAll = true;
		boolean selectedNone = true;

		ObjCheckBox cb;
		for (final Map.Entry<Object, Boolean> entry : mapObjSelected.entrySet()) {
			final Object obj = entry.getKey();
			final Boolean selected = entry.getValue();

			if (selected) {
				selectedNone = false;
			} else {
				selectedAll = false;
			}

			cb = new ObjCheckBox(obj);
			cb.setSelected(selected);
			cbs.add(cb);
		}

		cb = new ObjCheckBox(""Select all"");
		cb.setSelected(selectedAll);
		cbs.add(cb);

		cb = new ObjCheckBox(""Select none"");
		cb.setSelected(selectedNone);
		cbs.add(cb);
	}

	@SuppressWarnings(""unchecked"")
	private void reset() {
		removeAllItems();

		initCBs();

		addItem(new String());
		for (final JCheckBox cb : cbs) {
			addItem(cb);
		}

		setRenderer(new CheckBoxRenderer(cbs));
		addActionListener(this);
	}

	public Color getBackgroundSelected() {
		return backgroundSelected;
	}

	public Color getBackgroundNotSelected() {
		return backgroundNotSelected;
	}

	public Color getForegroundSelected() {
		return foregroundSelected;
	}

	public Color getForegroundNotSelected() {
		return foregroundNotSelected;
	}

	public void setBackgroundSelected(Color backgroundSelected) {
		this.backgroundSelected = backgroundSelected;
	}

	public void setBackgroundNotSelected(Color backgroundNotSelected) {
		this.backgroundNotSelected = backgroundNotSelected;
	}

	public void setForegroundSelected(Color foregroundSelected) {
		this.foregroundSelected = foregroundSelected;
	}

	public void setForegroundNotSelected(Color foregroundNotSelected) {
		this.foregroundNotSelected = foregroundNotSelected;
	}

}

interface CheckComboBoxSelectionChangedListener extends java.util.EventListener {
	public void selectionChanged(int idx);
}
"
DashedBorder.java,widgets-6.9.234,"package org.processmining.framework.util.ui.scalableview;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Stroke;

public class DashedBorder extends javax.swing.border.LineBorder {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1357931293759243135L;

	public DashedBorder(Color color) {
		super(color);
	}

	public void paintBorder(java.awt.Component comp, Graphics g, int x1,
			int x2, int y1, int y2) {

		Stroke old = ((Graphics2D) g).getStroke();
		BasicStroke bs = new BasicStroke(5.0f, BasicStroke.CAP_BUTT,
				BasicStroke.JOIN_MITER, 10.0f, new float[] { 15.0f, 30.0f },
				2.0f);
		((Graphics2D) g).setStroke(bs);
		super.paintBorder(comp, g, x1, x2, y1, y2);
		((Graphics2D) g).setStroke(old);
	}
}"
CompoundViewInteractionPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.scalableview.interaction;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.swing.BorderFactory;
import javax.swing.DefaultListCellRenderer;
import javax.swing.DefaultListModel;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JLayeredPane;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingConstants;

import org.processmining.framework.util.Pair;
import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;

import com.fluxicon.slickerbox.factory.SlickerDecorator;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class CompoundViewInteractionPanel extends JPanel implements ViewInteractionPanel, MouseMotionListener {
	protected final static int BUTTONHEIGHT = (ScalableViewPanel.TAB_HEIGHT * 5) / 6;
	protected final static int BUTTONWIDTH = (ScalableViewPanel.TAB_WIDTH * 5) / 6;

	private static final long serialVersionUID = -4871727332152661398L;
	private final String name;
	private JList list;
	private ScalableComponent scalable;
	private List<ViewInteractionPanel> panelList = new ArrayList<ViewInteractionPanel>();
	private Map<ViewInteractionPanel, Pair<JPanel, JPanel>> panels = new HashMap<ViewInteractionPanel, Pair<JPanel, JPanel>>();
	protected SlickerFactory factory = SlickerFactory.instance();
	private ScalableViewPanel parentPanel;
	private JScrollPane scroll;
	private CompoundListCellRenderer renderer;

	public CompoundViewInteractionPanel(String name) {
		super();
		setLayout(null);
		this.name = name;
		this.list = new JList(new DefaultListModel());
		renderer = new CompoundListCellRenderer(panels);
		list.setCellRenderer(renderer);

		list.setEnabled(false);

		list.addMouseMotionListener(this);
		this.scroll = new JScrollPane(list);
		SlickerDecorator.instance().decorate(scroll, Color.WHITE, Color.GRAY, Color.DARK_GRAY);

		this.list.setOpaque(false);

		// add the title
		JLabel panelTitle = factory.createLabel(name);
		panelTitle.setHorizontalTextPosition(SwingConstants.CENTER);
		panelTitle.setVerticalTextPosition(SwingConstants.CENTER);
		panelTitle.setForeground(Color.WHITE);
		panelTitle.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 13));
		panelTitle.setOpaque(false);
		this.add(panelTitle, BorderLayout.NORTH);
		this.setOpaque(false);

		scroll.getViewport().setOpaque(false);
		scroll.setOpaque(false);
		scroll.setBorder(BorderFactory.createEmptyBorder());
		scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scroll.getVerticalScrollBar().setOpaque(false);

		this.add(scroll);

		validate();
		repaint();

	}

	public void mouseDragged(MouseEvent e) {

	}

	private ViewInteractionPanel oldPanel = null;

	public synchronized void mouseMoved(MouseEvent e) {
		Point p = e.getPoint();
		if (e.getComponent() == scroll) {
			Point p2 = scroll.getViewport().getViewPosition();
			p.setLocation(p.getX() - p2.getX(), p.getY() - p2.getY());
		}
		if (oldPanel != null) {
			oldPanel.willChangeVisibility(false);
			JPanel panelOn = panels.get(oldPanel).getFirst();
			JPanel panelOff = panels.get(oldPanel).getSecond();
			panelOn.setEnabled(false);
			panelOn.setVisible(false);
			panelOff.setEnabled(true);
			panelOff.setVisible(true);
			oldPanel = null;

		}
		int x = p.x;
		int y = p.y;
		if (x < 00 || x > BUTTONWIDTH + 50) {
			return;
		}
		int index = y / (BUTTONHEIGHT);
		if (index >= list.getModel().getSize()) {
			return;
		}
		Point offset = CompoundViewInteractionPanel.this.getParent().getLocation();
		ViewInteractionPanel panel = (ViewInteractionPanel) list.getModel().getElementAt(index);

		JPanel panelOn = panels.get(panel).getFirst();
		JPanel panelOff = panels.get(panel).getSecond();

		parentPanel.setSize(panel, panelOn, panelOff);
		panelOn.setPreferredSize(new Dimension(panel.getComponent().getWidth() + 20,
				panel.getComponent().getHeight() + 20));
		int w = panel.getComponent().getWidth() + 20;
		int h = panel.getComponent().getHeight() + 20;
		panelOn.setSize(new Dimension(w, h));
		int l_x = offset.x + BUTTONWIDTH + 40;
		int l_y = offset.y + 10 + index * BUTTONHEIGHT;
		if ((l_x + w > parentPanel.getWidth()) && (offset.x + 10 >= w)) {
			l_x = offset.x - w + 10;

		}
		if ((l_y + h > parentPanel.getHeight()) && (parentPanel.getHeight() >= h)) {
			l_y = parentPanel.getHeight() - h;
		}

		panelOn.setLocation(l_x, l_y);

		oldPanel = panel;
		panel.willChangeVisibility(true);
		panelOn.setEnabled(true);
		panelOn.setVisible(true);
		panelOff.setEnabled(false);
		panelOff.setVisible(false);

	}

	public void updated() {
		for (ViewInteractionPanel p : panelList) {
			p.updated();
		}
	}

	public String getPanelName() {
		return name;
	}

	public JComponent getComponent() {
		return this;
	}

	public void setScalableComponent(ScalableComponent scalable) {
		this.scalable = scalable;
		for (ViewInteractionPanel p : panelList) {
			p.setScalableComponent(scalable);
		}
	}

	public void setParent(ScalableViewPanel parent) {
		parentPanel = parent;
		for (ViewInteractionPanel p : panelList) {
			p.setParent(parent);
			parentPanel.add(panels.get(p).getFirst(), JLayeredPane.MODAL_LAYER);
		}
	}

	public double getHeightInView() {
		return BUTTONHEIGHT * length();
	}

	public double getWidthInView() {
		return BUTTONWIDTH + 10;
	}

	public void willChangeVisibility(boolean to) {
		if (to) {
			scroll.setBounds(0, 0, BUTTONWIDTH + 30, getHeight());
			list.setSize(list.getPreferredSize());
			invalidate();
			repaint();
		} else {
			if (oldPanel != null) {
				// hmm, moved out of the list and out of the panel:
				JPanel panelOn = panels.get(oldPanel).getFirst();
				JPanel panelOff = panels.get(oldPanel).getSecond();
				panelOn.setEnabled(false);
				panelOn.setVisible(false);
				panelOff.setEnabled(true);
				panelOff.setVisible(true);
				oldPanel = null;
			}
		}
	}

	public void addViewInteractionPanel(ViewInteractionPanel panel) {
		JPanel panelOn = factory.createRoundedPanel(15, Color.LIGHT_GRAY);
		JPanel panelOff = factory.createRoundedPanel(15, Color.DARK_GRAY);
		panelOn.setLayout(null);
		panelOff.setLayout(null);

		panelOn.add(panel.getComponent());
		panelOn.setVisible(false);
		panelOn.setEnabled(false);
		panelOff.setVisible(true);
		panelOff.setEnabled(true);
		panelOff.setToolTipText(panel.getPanelName());
		JLabel panelTitle = factory.createLabel(panel.getPanelName());
		panelTitle.setHorizontalTextPosition(SwingConstants.CENTER);
		panelTitle.setVerticalTextPosition(SwingConstants.CENTER);
		panelTitle.setForeground(Color.WHITE);
		panelTitle.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 14));
		panelTitle.setBounds(10, 0, BUTTONWIDTH, BUTTONHEIGHT);

		panelOff.add(panelTitle);
		//		panelOff.setBounds(0, 0, 120, BUTTONHEIGHT);
		panelOff.setPreferredSize(new Dimension(BUTTONWIDTH, BUTTONHEIGHT));

		panel.getComponent().setLocation(10, 10);

		panels.put(panel, new Pair<JPanel, JPanel>(panelOn, panelOff));
		panelList.add(panel);
		((DefaultListModel) list.getModel()).addElement(panel);

		panelOn.setLocation(0, 0);
		if (parentPanel != null) {
			parentPanel.add(panelOn, JLayeredPane.MODAL_LAYER);
			panel.setParent(parentPanel);
		}
		if (scalable != null) {
			panel.setScalableComponent(scalable);
		}
		//		this.add(panelOff, JLayeredPane.DRAG_LAYER);

		panel.updated();
	}

	public int length() {
		return panelList.size();
	}
}

class CompoundListCellRenderer extends DefaultListCellRenderer {
	/**
	 * 
	 */
	private static final long serialVersionUID = -808355468668630456L;
	private final Map<ViewInteractionPanel, Pair<JPanel, JPanel>> panels;

	public CompoundListCellRenderer(Map<ViewInteractionPanel, Pair<JPanel, JPanel>> panels) {
		this.panels = panels;
	}

	public Component getListCellRendererComponent(JList component, Object value, int index, boolean isSelected,
			boolean cellHasFocus) {
		ViewInteractionPanel panel = (ViewInteractionPanel) value;
		JPanel off = panels.get(panel).getSecond();
		return off;
	}
}
"
ExportInteractionPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.scalableview.interaction;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JComponent;
import javax.swing.JPanel;

import org.freehep.graphicsbase.util.export.ExportDialog;
import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;

import com.fluxicon.slickerbox.components.SlickerButton;

import info.clearthought.layout.TableLayout;
import info.clearthought.layout.TableLayoutConstants;

public class ExportInteractionPanel extends JPanel implements ViewInteractionPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1036741994786060955L;
	protected final ScalableViewPanel panel;
	private ScalableComponent scalable;
	private SlickerButton exportButton;

	public ExportInteractionPanel(ScalableViewPanel panel) {
		this.panel = panel;
		double size[][] = { { 10, TableLayoutConstants.FILL, 10 }, { 10, TableLayoutConstants.FILL, 10 } };
		setLayout(new TableLayout(size));
		exportButton = new SlickerButton(""Export view..."");
		exportButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				export();
			}
		});
		this.add(exportButton, ""1, 1"");
	}

	private void export() {
		ExportDialog export = new ExportDialog();
		export.showExportDialog(this, ""Export view as ..."", scalable.getComponent(), ""View"");
	}

	public void updated() {
		// TODO Auto-generated method stub

	}

	public String getPanelName() {
		return ""Export"";
	}

	public JComponent getComponent() {
		return this;
	}

	public void setScalableComponent(ScalableComponent scalable) {
		this.scalable = scalable;
	}

	public void setParent(ScalableViewPanel viewPanel) {
	}

	public double getHeightInView() {
		return 50;
	}

	public double getWidthInView() {
		return 100;
	}

	public void willChangeVisibility(boolean to) {
	}
}
"
PIPInteractionPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.scalableview.interaction;

import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Stroke;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;

import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JViewport;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;

import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;

public class PIPInteractionPanel extends JPanel implements MouseListener, MouseMotionListener, ViewInteractionPanel {

	public static final int PIPSIZE = 250;
	public static final Stroke DEFAULTSTROKE = new BasicStroke(2);

	private static final long serialVersionUID = 5563202305263696868L;

	// new FlowLayout(FlowLayout.LEADING, 0, 0);
	private Rectangle2D rect = new Rectangle2D.Double(0, 0, 0, 0);
	private Stroke stroke = DEFAULTSTROKE;
	private Color color = Color.BLUE;
	private JViewport parentScroll;
	private final ScalableViewPanel panel;

	private JComponent component;

	private ScalableComponent scalable;

	public PIPInteractionPanel(ScalableViewPanel panel) {

		super(new BorderLayout());

		this.setBorder(BorderFactory.createEmptyBorder());
		this.setOpaque(true);

		this.addMouseMotionListener(this);
		this.addMouseListener(this);

		this.parentScroll = panel.getViewport();
		this.panel = panel;

	}

	public synchronized void initializeImage() {
		Dimension size = component.getPreferredSize();
		if (size.getWidth() > 0 && size.getHeight() > 0) {
			if (this.getComponentCount() > 0) {
				this.remove(0);
			}

			double rx = (double) getWidth() / (double) size.width;
			double ry = (double) getHeight() / (double) size.height;
			double r = Math.min(rx, ry);

			BufferedImage image = (BufferedImage) component.createImage(getWidth(), getHeight());
			Graphics2D g2ds = image.createGraphics();

			g2ds.setColor(component.getBackground());
			g2ds.fillRect(0, 0, getWidth(), getHeight());

			double oldScale = scalable.getScale();
			scalable.setScale(r * oldScale);
			component.paint(g2ds);
			scalable.setScale(oldScale);
			g2ds.dispose();

			drawMain(rect.getX(), rect.getY());
			setRect();

			JLabel label = new JLabel(new ImageIcon(image), SwingConstants.LEFT);
			label.setBorder(BorderFactory.createEmptyBorder());
			this.add(label, BorderLayout.NORTH);
			this.invalidate();
			this.repaint();
			repaintNeeded = false;
		}

	}

	public double getVisWidth() {
		return component.getSize().getWidth();
	}

	public double getVisHeight() {
		return component.getSize().getHeight();
	}

	@Override
	public void paint(Graphics g) {

		super.paint(g);
		if (rect != null) {
			Graphics2D g2d = (Graphics2D) g;
			g.setColor(color);
			g2d.setStroke(stroke);
			g2d.draw(rect);
		}
	}

	public Rectangle2D getRect() {
		return rect;
	}

	public void setRect() {
		Rectangle2D rect2 = parentScroll.getViewRect();
		double s = getScale();
		double x = s * Math.max(0, rect2.getX());
		double y = s * Math.max(0, rect2.getY());
		double w = s * Math.min(rect2.getWidth(), getVisWidth());
		double h = s * Math.min(rect2.getHeight(), getVisHeight());
		this.rect = new Rectangle2D.Double(x, y, w, h);
	}

	public synchronized void mouseDragged(MouseEvent evt) {
		if (SwingUtilities.isLeftMouseButton(evt)) {
			// a is the point in the graph where I dragged to
			if (pressPoint == null) {
				// I didn't start dragging inside rectangle.
				return;
			}
			double offsetX = pressPoint.getX() - rect.getX();
			double offsetY = pressPoint.getY() - rect.getY();
			pressPoint = evt.getPoint();
			double x = pressPoint.getX() - offsetX;
			double maxX = getWidth() - rect.getWidth();
			if (x > maxX) {
				x = maxX;
			}
			if (x < 0) {
				x = 0;
			}
			double maxY = getHeight() - rect.getHeight();
			double y = pressPoint.getY() - offsetY;
			if (y > maxY) {
				y = maxY;
			}
			if (y < 0) {
				y = 0;
			}
			drawMain(x, y);

			rect = new Rectangle2D.Double(x, y, rect.getWidth(), rect.getHeight());
		} else if (SwingUtilities.isRightMouseButton(evt)) {
			double endX = Math.max(0, Math.min(evt.getPoint().getX(), getWidth()));
			double endY = Math.max(0, Math.min(evt.getPoint().getY(), getHeight()));

			if (startDragPoint != null) {

				double startX = startDragPoint.getX();
				double startY = startDragPoint.getY();

				double r = ((double) parentScroll.getHeight() / (double) parentScroll.getWidth());
				double w = Math.abs(endX - startX);
				double h = w * r;

				if ((endX >= startX) && (endY >= startY)) {
					if (startY + h > getHeight()) {
						h = getHeight() - startY;
						w = h / r;
					}
					rect = new Rectangle2D.Double(startX, startY, w, h);
				} else if ((endX >= startX) && (endY < startY)) {
					if (startY - h < 0) {
						h = startY;
						w = h / r;
					}
					rect = new Rectangle2D.Double(startX, startY - h, w, h);
				} else if ((endX < startX) && (endY >= startY)) {
					if (startY + h > getHeight()) {
						h = getHeight() - startY;
						w = h / r;
					}
					rect = new Rectangle2D.Double(startX - w, startY, w, h);
				} else {
					if (startY - h < 0) {
						h = startY;
						w = h / r;
					}
					rect = new Rectangle2D.Double(startX - w, startY - h, w, h);
				}
			}
		}
		repaint();
	}

	private Point2D pressPoint = null;
	private Point startDragPoint;
	private Rectangle2D lastRect;
	private boolean repaintNeeded = true;

	public void mouseClicked(MouseEvent e) {
	}

	public void mouseEntered(MouseEvent e) {
	}

	public void mouseExited(MouseEvent e) {
	}

	public void mouseMoved(MouseEvent e) {
	}

	public synchronized void mousePressed(MouseEvent e) {
		// store the point where I clicked the mouse
		if (rect != null) {
			if (SwingUtilities.isLeftMouseButton(e)) {
				pressPoint = null;
				Point2D a = e.getPoint();
				if (rect.contains(a)) {
					pressPoint = a;
				}
				stroke = DEFAULTSTROKE;
				color = Color.BLUE;
			} else if (SwingUtilities.isRightMouseButton(e)) {
				pressPoint = null;
				startDragPoint = null;
				Rectangle2D visRect = new Rectangle2D.Double(0, 0, getWidth(), getHeight());
				if (visRect.contains(e.getPoint())) {
					startDragPoint = e.getPoint();
					lastRect = rect;
					rect = null;
					stroke = new BasicStroke(2.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f,
							new float[] { 5.0f }, 0.0f);
					color = Color.BLUE;
					repaint();
				}
			}
		}
	}

	public synchronized void mouseReleased(MouseEvent e) {
		if (SwingUtilities.isRightMouseButton(e)) {
			stroke = DEFAULTSTROKE;
			color = Color.BLUE;
			if (rect == null || lastRect == null) {
				return;
			}

			double f = getScale();

			double w = Math.max(parentScroll.getExtentSize().getWidth() * f, lastRect.getWidth()) / lastRect.getWidth();
			double h = Math.max(parentScroll.getExtentSize().getHeight() * f, lastRect.getHeight())
					/ lastRect.getHeight();

			double scaleFactor = rect.getWidth() / lastRect.getWidth() / w;
			scaleFactor = Math.max(scaleFactor, rect.getHeight() / lastRect.getHeight() / h);
			double x = rect.getX();
			double y = rect.getY();

			panel.setScale(panel.getScale() / scaleFactor);

			drawMain(x, y);
			setRect();

		}
	}

	public void drawMain(double x, double y) {
		// The point I have now should be translated back
		// to a point in the main graph.

		double f = getScale();
		int xPos = (int) Math.ceil(x / f);
		int yPos = (int) Math.ceil(y / f);

		if (!panel.getVerticalScrollBar().isShowing()) {
			xPos = xPos - panel.getVerticalScrollBar().getWidth();
			xPos = Math.max(xPos, 0);
		}
		if (!panel.getHorizontalScrollBar().isShowing()) {
			yPos = yPos - panel.getHorizontalScrollBar().getHeight();
			yPos = Math.max(yPos, 0);
		}

		parentScroll.setViewPosition(new Point(xPos, yPos));

	}

	public double getScale() {
		Dimension size = component.getPreferredSize();

		double rx = (double) getWidth() / (double) size.width;
		double ry = (double) getHeight() / (double) size.height;
		double r = Math.min(rx, ry);
		return r;
	}

	public void setScalableComponent(ScalableComponent scalable) {
		this.scalable = scalable;
		this.component = scalable.getComponent();
	}

	public void setParent(ScalableViewPanel parent) {

	}

	public JComponent getComponent() {
		return this;
	}

	public int getPosition() {
		return SwingConstants.NORTH;
	}

	public String getPanelName() {
		return ""PIP"";
	}

	public void updated() {
		repaintNeeded = true;
	}

	public double getHeightInView() {
		Dimension size = component.getPreferredSize();
		double ratio = (size.getWidth() / size.getHeight());
		if (ratio > 1) {
			// wider than heigh, so height depends on width
			return PIPSIZE / ratio;
		}
		return PIPSIZE;
	}

	public double getWidthInView() {
		Dimension size = component.getPreferredSize();
		double ratio = (size.getWidth() / size.getHeight());
		if (ratio < 1) {
			// heigher than wide, so width depends on height
			return PIPSIZE / ratio;
		}
		return PIPSIZE;
	}

	public void willChangeVisibility(boolean to) {
		if (repaintNeeded) {
			initializeImage();
		}
		setRect();
	}

	public void setSize(int width, int height) {
		Dimension oldSize = getSize();
		super.setSize(width, height);
		if (!getSize().equals(oldSize)) {
			repaintNeeded = true;
		}
	}

}
"
ViewInteractionPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.scalableview.interaction;

import javax.swing.JComponent;

import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.framework.util.ui.scalableview.ScalableComponent.UpdateListener;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;

/**
 * This interaction panel is used in the ProMScalableView. It is interacting
 * with the view.
 * 
 * 
 * @author bfvdonge
 * 
 */
public interface ViewInteractionPanel extends UpdateListener {

	/**
	 * Returns the name of the panel. This name is shown in the user interface
	 * when the component is not shown.
	 * 
	 * @return
	 */
	public String getPanelName();

	/**
	 * Returns the component that is shown if this panel is activated by the
	 * user.
	 * 
	 * Most implementations will actually override JComponent and return
	 * <code>this</code> in this method.
	 * 
	 * @return a component
	 */
	public JComponent getComponent();

	/**
	 * This method is called by the ProM scalable view as soon as the panel is
	 * added to this view. The scalable provided can be used for interaction.
	 */
	public void setScalableComponent(ScalableComponent scalable);

	/**
	 * This method is called by the ProM scalable view as soon as the panel is
	 * added to this view. The scalable provided can be used for interaction.
	 * 
	 * @param viewPanel
	 */
	public void setParent(ScalableViewPanel viewPanel);

	/**
	 * Returns the preferred height of this component when shown to the user. A
	 * value between 0 and 1 (including 1) indicates a requested height relative
	 * to the height of the screen.
	 * 
	 * A value greater than 1 indicates a fixed height in pixels .
	 * 
	 * @return
	 */
	public double getHeightInView();

	/**
	 * Returns the preferred width of this component when shown to the user. A
	 * value between 0 and 1 (including 1) indicates a requested width relative
	 * to the width of the screen.
	 * 
	 * A value greater than 1 indicates a fixed width in pixels.
	 * 
	 * @return
	 */
	public double getWidthInView();

	/**
	 * This method is called by the ProMScalableView panel just before the
	 * component of this interaction panel will be shown to the user or hidden
	 * from the user.
	 * 
	 * The height and width of the component are set to what is requested by
	 * getHeightInView() and getWidthInView();
	 * 
	 * @param to
	 *            TODO
	 * 
	 */
	public void willChangeVisibility(boolean to);
}
"
ZoomInteractionPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.scalableview.interaction;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.SwingConstants;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;

import com.fluxicon.slickerbox.factory.SlickerFactory;

public class ZoomInteractionPanel extends JPanel implements ViewInteractionPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8415559591750873766L;
	private final JSlider slider;
	private JLabel sliderMinValue, sliderMaxValue;
	JButton sliderFitValue;
	JLabel sliderValue;

	protected int fitZoom;
	protected ScalableComponent scalable;
	protected final ScalableViewPanel panel;
	protected boolean recalculateFit = true;

	public ZoomInteractionPanel(ScalableViewPanel panel, int maximumZoom) {

		super(null);
		this.panel = panel;

		this.slider = SlickerFactory.instance().createSlider(1);

		this.slider.setMinimum(1);
		this.slider.setMaximum(maximumZoom);
		this.slider.setValue(fitZoom);

		this.slider.addChangeListener(new ChangeListener() {
			public void stateChanged(ChangeEvent e) {
				update();
			}
		});

		this.sliderMinValue = SlickerFactory.instance().createLabel(""0%"");
		this.sliderMaxValue = SlickerFactory.instance().createLabel(maximumZoom + ""%"");
		this.sliderFitValue = SlickerFactory.instance().createButton(""Fit >"");
		this.sliderFitValue.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				fit();
			}
		});
		this.sliderValue = SlickerFactory.instance().createLabel(fitZoom + ""%"");

		this.sliderMinValue.setHorizontalAlignment(SwingConstants.CENTER);
		this.sliderMaxValue.setHorizontalAlignment(SwingConstants.CENTER);
		this.sliderFitValue.setHorizontalAlignment(SwingConstants.RIGHT);
		this.sliderValue.setHorizontalAlignment(SwingConstants.LEFT);

		this.sliderMinValue.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 14));
		this.sliderMaxValue.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 14));
		this.sliderFitValue.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 14));
		this.sliderValue.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 14));

		this.sliderMinValue.setForeground(Color.GRAY);
		this.sliderMaxValue.setForeground(Color.GRAY);
		this.sliderFitValue.setForeground(Color.GRAY);
		this.sliderValue.setForeground(Color.DARK_GRAY);

		this.add(this.slider);
		this.add(this.sliderMinValue);
		this.add(this.sliderMaxValue);
		this.add(this.sliderFitValue);
		this.add(this.sliderValue);

		this.setBackground(Color.LIGHT_GRAY);
	}

	public void setSize(int width, int height) {
		super.setSize(width, height);
		setHeight(height);
	}

	public void setHeight(int height) {

		int sliderHeight = height - 60;

		// this.title.setBounds(0, (int) (height * 0.5) - 25, 30, 50);

		this.slider.setBounds(35, 30, 30, sliderHeight);
		this.sliderMaxValue.setBounds(0, 10, 100, 20);
		this.sliderMinValue.setBounds(0, height - 30, 100, 20);

		int value = this.slider.getValue();
		int span = this.slider.getMaximum() - this.slider.getMinimum();
		int position = 33 + (int) ((float) (this.slider.getMaximum() - this.fitZoom) / (float) span * (sliderHeight - 28));
		this.sliderFitValue.setBounds(0, position, 40, 20);

		if (value == this.fitZoom) {
			this.sliderValue.setBounds(65, position, 60, 20);
		} else {
			position = 33 + (int) ((float) (this.slider.getMaximum() - value) / (float) span * (sliderHeight - 28));
			this.sliderValue.setBounds(65, position, 60, 20);
		}
	}

	private void update() {

		int value = this.slider.getValue();

		int span = this.slider.getMaximum() - this.slider.getMinimum();
		int position = 33 + (int) ((float) (this.slider.getMaximum() - value) / (float) span * (this.slider.getBounds().height - 28));

		this.sliderValue.setText(value + ""%"");
		this.sliderValue.setBounds(65, position, 60, 20);

		scalable.setScale(getZoomValue());

	}

	public double getZoomValue() {
		return this.slider.getValue() / 100.;
	}

	public void setValue(int value) {
		this.slider.setValue(value);
	}

	public void setFitValue(int value) {

		this.fitZoom = value;

		int span = this.slider.getMaximum() - this.slider.getMinimum();
		int position = (int) (33 + Math.floor(((float) (this.slider.getMaximum() - value) / (float) span * (this.slider
				.getBounds().height - 28))));
		this.sliderFitValue.setBounds(0, position, 40, 20);
	}

	public void fit() {
		setValue(fitZoom);
	}

	public void setScalableComponent(ScalableComponent scalable) {
		this.scalable = scalable;
	}

	public void setParent(ScalableViewPanel parent) {

	}

	public JComponent getComponent() {
		return this;
	}

	public int getPosition() {
		return SwingConstants.WEST;
	}

	public String getPanelName() {
		return ""Zoom"";
	}

	public void updated() {
		recalculateFit = true;
	}

	public double getHeightInView() {
		return 0.66;
	}

	public double getWidthInView() {
		return 100;
	}

	protected void computeFitScale() {
		double scale = scalable.getScale();
		Dimension b = scalable.getComponent().getPreferredSize();
		double w = b.getWidth() / scale;
		double h = b.getHeight() / scale;
		double rx = panel.getViewport().getExtentSize().getWidth() / w;
		double ry = panel.getViewport().getExtentSize().getHeight() / h;

		setFitValue((int) (Math.min(rx, ry) * 100));
		recalculateFit = false;
	}

	public void willChangeVisibility(boolean to) {
		setValue((int) Math.floor(100 * scalable.getScale()));
		if (fitZoom <= 0 || recalculateFit) {
			computeFitScale();
		}
	}
}
"
ScalableComponent.java,widgets-6.9.234,"package org.processmining.framework.util.ui.scalableview;

import javax.swing.JComponent;

public interface ScalableComponent {

	public static interface UpdateListener {
		/**
		 * This method should be called if the component is updated (layout,
		 * content, etc.)
		 */
		public void updated();
	}

	/**
	 * Returns the component that will be scaled using getScale and setScale
	 * methods
	 * 
	 * Most implementations will actually override JComponent and return
	 * <code>this</code> in this method.
	 * 
	 * @return a component
	 */
	public JComponent getComponent();

	/**
	 * Returns the current scale.
	 * 
	 * @return the current scale as a double
	 */
	public double getScale();

	/**
	 * Sets the current scale.
	 * <p>
	 * 
	 * @param newValue
	 *            the new scale
	 */
	public void setScale(double newScale);

	/**
	 * Adds an updatelistener to this scalable component. This listener will be
	 * updated as soon as the contents of the component change, i.e. if the
	 * component
	 * 
	 * @param listener
	 */
	public void addUpdateListener(UpdateListener listener);

	/**
	 * Removes an updatelistener from this scalable component.
	 * 
	 * @param listener
	 */
	public void removeUpdateListener(UpdateListener listener);

}
"
ScalableViewPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.scalableview;

import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.ActionListener;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JLayeredPane;
import javax.swing.JPanel;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JSlider;
import javax.swing.JViewport;
import javax.swing.SwingConstants;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import org.processmining.framework.util.Cleanable;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.ui.scalableview.ScalableComponent.UpdateListener;
import org.processmining.framework.util.ui.scalableview.interaction.ViewInteractionPanel;

import com.fluxicon.slickerbox.factory.SlickerDecorator;
import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * Panel for visualizing components.
 * 
 * @author hverbeek
 * 
 */
public class ScalableViewPanel extends JLayeredPane implements Cleanable, ChangeListener, MouseMotionListener,
		UpdateListener {

	/**
	 * 
	 */
	private static final long serialVersionUID = -7826982030435169712L;

	/**
	 * The maximal zoom factor for the primary view on the transition system.
	 */
	public static final int MAX_ZOOM = 250;

	/**
	 * The access to scalable methods of primary view
	 */
	protected final ScalableComponent scalable;

	/**
	 * The primary view
	 */
	private JComponent component;

	/**
	 * The scroll pane containing the primary view on the transition system.
	 */
	protected JScrollPane scroll;

	private ViewInteractionPanel visiblePanel = null;
	private Map<ViewInteractionPanel, Pair<JPanel, JPanel>> panels = new HashMap<ViewInteractionPanel, Pair<JPanel, JPanel>>();
	private Map<ViewInteractionPanel, Integer> locations = new HashMap<ViewInteractionPanel, Integer>();

	private JButton[] buttons = new JButton[4];

	private int north = 0, south = 0, east = 0, west = 0;

	/**
	 * The bounds for the primary view on the transition system.
	 */
	private Rectangle normalBounds;

	protected SlickerFactory factory;

	protected SlickerDecorator decorator;

	/**
	 * Create a panel for visualizing the given view.
	 * 
	 * @param scalableComponent
	 *            The given graph
	 */
	public ScalableViewPanel(final ScalableComponent scalableComponent) {
		/*
		 * We will not use a layout manager, instead we will set the bounds of
		 * every panel.
		 */
		setLayout(null);
		/*
		 * Register the given view as the primary view, and get the transition
		 * system from the model.
		 */
		this.scalable = scalableComponent;
		component = scalableComponent.getComponent();
		/*
		 * Get some Slickerbox stuff, required by the Look+Feel of some objects.
		 */
		factory = SlickerFactory.instance();
		decorator = SlickerDecorator.instance();

		/*
		 * Create the scroll panel containing the primary view, and register the
		 * created adjustment and mouse listener.
		 */
		scroll = new JScrollPane(getComponent());
		/*
		 * Adjust Look+Feel of scrollbar to Slicker.
		 */
		decorator.decorate(scroll, Color.WHITE, Color.GRAY, Color.DARK_GRAY);
		/*
		 * Create a dashed border for the primary view.
		 */
		scroll.setBorder(new DashedBorder(Color.LIGHT_GRAY));

		/*
		 * Add primary view to the layered pane. The special panels are added to
		 * the drag layer, which keeps them on top even when the underlying
		 * primary view gets updated.
		 */
		add(scroll, JLayeredPane.DEFAULT_LAYER);

		this.addMouseMotionListener(this);
		getComponent().addMouseMotionListener(this);
		scalable.addUpdateListener(this);

		/*
		 * Register a component listener to handle resize events, as the bounds
		 * of many panels depend on the size of this panel.
		 */
		this.addComponentListener(new java.awt.event.ComponentListener() {
			public void componentHidden(ComponentEvent e) {
			}

			public void componentMoved(ComponentEvent e) {
			}

			public void componentShown(ComponentEvent e) {
			}

			public void componentResized(ComponentEvent e) {
				resize();
			}
		});

		this.scroll.addComponentListener(new ComponentListener() {

			public void componentShown(ComponentEvent e) {

			}

			public void componentResized(ComponentEvent e) {
				scroll.removeComponentListener(this);
				scalable.setScale(1);
				double rx = (scroll.getWidth() - scroll.getVerticalScrollBar().getWidth())
						/ scalable.getComponent().getPreferredSize().getWidth();
				double ry = (scroll.getHeight() - scroll.getHorizontalScrollBar().getHeight())
						/ scalable.getComponent().getPreferredSize().getHeight();
				scalable.setScale(Math.min(rx, ry));
			}

			public void componentMoved(ComponentEvent e) {

			}

			public void componentHidden(ComponentEvent e) {

			}
		});

		/*
		 * Wrap up.
		 */
		initialize();
		validate();
		repaint();
	}

	public final static int TAB_HEIGHT = 30;
	public final static int TAB_WIDTH = 120;

	/**
	 * Adds the interaction panel at the given location. Location is one of
	 * SwingConstants.NORTH, SwingConstants.SOUTH, SwingConstants.EAST, or
	 * SwingConstants.WEST
	 * 
	 * @param panel
	 * @param location
	 */
	public synchronized void addViewInteractionPanel(ViewInteractionPanel panel, int location) {
		panel.setScalableComponent(scalable);
		panel.setParent(this);

		JPanel panelOn = factory.createRoundedPanel(15, Color.LIGHT_GRAY);
		JPanel panelOff = factory.createRoundedPanel(15, Color.DARK_GRAY);
		panelOn.setLayout(null);
		panelOff.setLayout(null);

		panelOn.add(panel.getComponent());
		panelOn.setVisible(false);
		panelOn.setEnabled(false);
		panelOff.setVisible(true);
		panelOff.setEnabled(true);
		JLabel panelTitle = factory.createLabel(panel.getPanelName());
		panelTitle.setHorizontalTextPosition(SwingConstants.CENTER);
		panelTitle.setVerticalTextPosition(SwingConstants.CENTER);
		panelTitle.setForeground(Color.WHITE);
		panelTitle.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 16));
		panelOff.add(panelTitle);

		panels.put(panel, new Pair<JPanel, JPanel>(panelOn, panelOff));
		locations.put(panel, location);

		switch (location) {
			case SwingConstants.NORTH : {
				panelTitle.setBounds(5, 10, TAB_WIDTH - 15, TAB_HEIGHT);
				panelOn.setLocation(TAB_HEIGHT + 10 + north * TAB_WIDTH, -10);
				panel.getComponent().setLocation(10, 20);
				panelOff.setBounds(TAB_HEIGHT + 10 + north * TAB_WIDTH, -10, TAB_WIDTH - 5, TAB_HEIGHT + 10);
				north++;
				break;
			}
			case SwingConstants.EAST : {
				panelTitle.setBounds(0, 5, TAB_HEIGHT, TAB_WIDTH - 15);
				panelTitle.setUI(new VerticalLabelUI(true));
				panelOn.setLocation(getWidth() - TAB_HEIGHT, TAB_HEIGHT + 10 + east * TAB_WIDTH);
				panelOff.setBounds(getWidth() - TAB_HEIGHT, TAB_HEIGHT + 10 + east * TAB_WIDTH, TAB_HEIGHT + 10,
						TAB_WIDTH - 5);
				panel.getComponent().setLocation(10, 10);
				east++;
				break;
			}
			case SwingConstants.WEST : {
				panelTitle.setBounds(10, 5, TAB_HEIGHT, TAB_WIDTH - 15);
				panelTitle.setUI(new VerticalLabelUI(true));
				panelOn.setLocation(-10, TAB_HEIGHT + 10 + west * TAB_WIDTH);
				panelOff.setBounds(-10, TAB_HEIGHT + 10 + west * TAB_WIDTH, TAB_HEIGHT + 10, TAB_WIDTH - 5);
				panel.getComponent().setLocation(20, 10);
				west++;
				break;
			}
			default : {
				//SOUTH
				panelTitle.setBounds(5, 0, TAB_WIDTH - 15, TAB_HEIGHT);
				panelOn.setLocation(TAB_HEIGHT + 10 + south * TAB_WIDTH, getHeight() - TAB_HEIGHT);
				panelOff.setBounds(TAB_HEIGHT + 10 + south * TAB_WIDTH, getHeight() - TAB_HEIGHT, TAB_WIDTH - 5,
						TAB_HEIGHT + 10);
				panel.getComponent().setLocation(10, 10);
				south++;

			}
		}
		setSize(panel, panelOff, panelOn);
		setLocation(panel, panelOff, panelOn);

		add(panelOn, JLayeredPane.PALETTE_LAYER);
		add(panelOff, JLayeredPane.PALETTE_LAYER);
		panel.updated();
	}

	/**
	 * Remove a previously added interaction panel from the ScalableViewPanel.
	 * 
	 * This can be used to remove an interaction panel from the
	 * ScalableViewPanel. If the interaction panel does not exist, nothing will
	 * be removed.
	 * 
	 * @param panel
	 *            The panel that should be removed.
	 */
	public synchronized void removeViewInteractionPanel(ViewInteractionPanel panel) {

		//Remove the panelOn and panelOff panels from the pane.
		Pair<JPanel, JPanel> pair = panels.remove(panel);
		if (pair != null) {
			remove(pair.getFirst());
			remove(pair.getSecond());
		}

		//Modify the position counters to account for the removed interaction panels.
		Integer location = locations.remove(panel);
		if (location != null) {

			switch (location) {
				case SwingConstants.NORTH :
					north--;
					break;
				case SwingConstants.EAST :
					east--;
					break;
				case SwingConstants.SOUTH :
					south--;
					break;
				case SwingConstants.WEST :
					west--;
					break;
				default :
					System.err.println(""Unknown interaction panel location. No position counters have been updated."");
					break;
			}
		}

		//Repaint to get rid of the old panel tab pictures.
		repaint();
	}

	/**
	 * List all registered interaction panels and their locations.
	 * 
	 * @return Map of interaction panels and their locations.
	 */
	public Map<ViewInteractionPanel, Integer> getViewInteractionPanels() {
		return new HashMap<ViewInteractionPanel, Integer>(locations);
	}

	private boolean isChild(Component c, final Component parent) {
		if (c == parent) {
			return true;
		} else if (c.getParent() == null) {
			return false;
		} else {
			return (c.getParent() == parent) || isChild(c.getParent(), parent);
		}
	}

	public synchronized void mouseMoved(MouseEvent e) {
		Point p = e.getPoint();
		if (e.getComponent() == getComponent()) {
			Point p2 = scroll.getViewport().getViewPosition();
			p.setLocation(p.getX() - p2.getX() + TAB_HEIGHT, p.getY() - p2.getY() + TAB_HEIGHT);
		}
		Component c = findComponentAt(p.x, p.y);
		if (c == null) {
			return;
		}
		if (c == this || isChild(c, getComponent())) {
			turnPanelOff();
		} else {
			// walk through the off panels
			for (Entry<ViewInteractionPanel, Pair<JPanel, JPanel>> entry : panels.entrySet()) {
				JPanel panelOn = entry.getValue().getFirst();
				JPanel panelOff = entry.getValue().getSecond();
				ViewInteractionPanel panel = entry.getKey();
				if (panelOff.getBounds().contains(p)) {
					if (panelOff == c || isParentPanel(c, panelOff)) {

						setSize(entry.getKey(), panelOff, panelOn);
						setLocation(entry.getKey(), panelOff, panelOn);
						turnPanelOff();
						panel.willChangeVisibility(true);
						panelOn.setVisible(true);
						panelOn.setEnabled(true);
						panelOff.setVisible(false);
						panelOff.setEnabled(false);
						visiblePanel = entry.getKey();
					}
				}
			}
		}
	}

	private boolean isParentPanel(Component topmost, JPanel panel) {

		Container c = topmost.getParent();
		while (c != null) {

			if (c == panel) {
				return true;
			}

			c = c.getParent();
		}

		return false;
	}

	private void turnPanelOff() {
		if (visiblePanel != null) {
			JPanel panelOn = panels.get(visiblePanel).getFirst();
			JPanel panelOff = panels.get(visiblePanel).getSecond();
			visiblePanel.willChangeVisibility(false);
			panelOn.setVisible(false);
			panelOn.setEnabled(false);
			panelOff.setVisible(true);
			panelOff.setEnabled(true);
			visiblePanel = null;
		}

	}

	public void mouseDragged(MouseEvent e) {
		// ignore!

	}

	/**
	 * Adds a button to one of the positions on the screen indicated by the
	 * location parameter. Should be SwingConstants.NORTH_EAST,
	 * SwingConstants.SOUTH_EAST SwingConstants.NORTH_WEST,
	 * SwingConstants.SOUTH_WEST
	 * 
	 * @param label
	 * @param listener
	 * @param location
	 */
	public void addButton(JLabel label, ActionListener listener, int location) {
		JButton button = factory.createButton("""");
		label.setHorizontalTextPosition(SwingConstants.CENTER);
		label.setVerticalTextPosition(SwingConstants.CENTER);
		label.setHorizontalAlignment(SwingConstants.CENTER);
		label.setVerticalAlignment(SwingConstants.CENTER);
		label.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 18));
		label.setForeground(Color.WHITE);
		label.setBorder(BorderFactory.createEmptyBorder());
		label.setOpaque(false);

		button.setLayout(null);
		button.setBorder(BorderFactory.createEmptyBorder());
		button.add(label);
		button.setToolTipText(""Reposition the graph to the origin"");
		button.addActionListener(listener);

		label.setBounds(0, 0, TAB_HEIGHT - 5, TAB_HEIGHT - 5);

		switch (location) {
			case SwingConstants.NORTH_WEST :
				button.setBounds(0, 0, TAB_HEIGHT, TAB_HEIGHT);
				buttons[0] = button;
				break;
			case SwingConstants.NORTH_EAST :
				button.setBounds(0, getWidth() - TAB_HEIGHT, TAB_HEIGHT, TAB_HEIGHT);
				buttons[1] = button;
				break;
			case SwingConstants.SOUTH_EAST :
				button.setBounds(getHeight() - TAB_HEIGHT, getWidth() - TAB_HEIGHT, TAB_HEIGHT, TAB_HEIGHT);
				buttons[2] = button;
				break;
			default :
				// SOUTH_WEST
				button.setBounds(getHeight() - TAB_HEIGHT, 0, TAB_HEIGHT, TAB_HEIGHT);
				buttons[3] = button;
		}

		this.add(button, JLayeredPane.PALETTE_LAYER);

	}

	protected void initialize() {
		// empty implementation. Can be overridden by subclasses
	}

	public void setSize(ViewInteractionPanel panel, JPanel panelOff, JPanel panelOn) {
		double w = panel.getWidthInView();
		double h = panel.getHeightInView();
		if (w > 1) {
			// fixed width
			w += 20;
		} else {
			// relative width
			w *= scroll.getWidth();
		}
		if (h > 1) {
			// fixed height
			h += 20;
		} else {
			// relative height
			h *= scroll.getHeight();
		}
		w = Math.min(w, scroll.getWidth() - 2 * TAB_HEIGHT);
		h = Math.min(h, scroll.getHeight() - 2 * TAB_HEIGHT);

		panel.getComponent().setSize((int) w, (int) h);
		panelOn.invalidate();
	}

	public void setLocation(ViewInteractionPanel panel, JPanel panelOff, JPanel panelOn) {
		int x = panelOff.getLocation().x;
		int y = panelOff.getLocation().y;
		switch (locations.get(panel)) {
			case SwingConstants.SOUTH : {
				y = panelOff.getLocation().y - panel.getComponent().getHeight() + 10;
			}
				//$FALL-THROUGH$
			case SwingConstants.NORTH : {
				panelOn.setSize(panel.getComponent().getWidth() + 20, panel.getComponent().getHeight() + TAB_HEIGHT);
				break;
			}
			case SwingConstants.EAST : {
				x = panelOff.getLocation().x - panel.getComponent().getWidth() + 10;
			}
				//$FALL-THROUGH$
			default : {
				panelOn.setSize(panel.getComponent().getWidth() + TAB_HEIGHT, panel.getComponent().getHeight() + 20);
			}
		}
		if (x + panelOn.getWidth() > getWidth()) {
			x = Math.max(TAB_HEIGHT, getWidth() - panelOn.getWidth());
		}
		if (y + panelOn.getHeight() > getHeight()) {
			y = Math.max(TAB_HEIGHT, getHeight() - panelOn.getHeight());
		}
		panelOn.setLocation(x, y);
		panelOn.invalidate();
	}

	/**
	 * Resizes the panels base don the current size of the layered pane.
	 */
	private void resize() {
		/*
		 * Get the size of the layered pane.
		 */

		for (Entry<ViewInteractionPanel, Pair<JPanel, JPanel>> entry : panels.entrySet()) {
			JPanel panelOn = entry.getValue().getFirst();
			JPanel panelOff = entry.getValue().getSecond();
			ViewInteractionPanel panel = entry.getKey();

			if (locations.get(panel) == SwingConstants.EAST) {
				//east
				panelOn.setLocation(getWidth() - TAB_HEIGHT, panelOn.getLocation().y);
				panelOff.setBounds(getWidth() - TAB_HEIGHT, panelOff.getLocation().y, TAB_HEIGHT + 10, TAB_WIDTH - 5);
			} else if (locations.get(panel) == SwingConstants.SOUTH) {
				// south
				panelOn.setLocation(panelOn.getLocation().x, getHeight() - TAB_HEIGHT);
				panelOff.setBounds(panelOff.getLocation().x, getHeight() - TAB_HEIGHT, TAB_WIDTH - 5, TAB_HEIGHT + 10);
			}
			setSize(panel, panelOff, panelOn);
			setLocation(panel, panelOff, panelOn);
		}

		for (int i = 1; i < 3; i++) {
			if (buttons[i] == null) {
				continue;
			}
			buttons[i].setLocation(i > 1 ? getHeight() - TAB_HEIGHT : 0, i < 3 ? getWidth() - TAB_HEIGHT : 0);
		}

		normalBounds = new Rectangle(TAB_HEIGHT, TAB_HEIGHT, getWidth() - 2 * TAB_HEIGHT, getHeight() - 2 * TAB_HEIGHT);
		scroll.setBounds(normalBounds);

		updated();
		//		invalidate();

	}

	public JScrollBar getHorizontalScrollBar() {
		return scroll.getHorizontalScrollBar();
	}

	public JScrollBar getVerticalScrollBar() {
		return scroll.getVerticalScrollBar();
	}

	/**
	 * Returns the zoom factor of the primary view.
	 * 
	 * @return The zoom factor of the primary view.
	 */
	public double getScale() {
		return scalable.getScale();
	}

	/**
	 * Sets the zoom factor of the primary view to the given factor.
	 * 
	 * @param d
	 *            The given factor.
	 */
	public void setScale(double d) {
		double b = Math.max(d, 0.01);
		b = Math.min(b, MAX_ZOOM / 100.);
		scalable.setScale(b);
	}

	/**
	 * Clean up.
	 */
	public void cleanUp() {
		/*
		 * Clean up both views.
		 */
		if (getComponent() instanceof Cleanable) {
			((Cleanable) getComponent()).cleanUp();
		}
		scalable.removeUpdateListener(this);
		getComponent().removeMouseMotionListener(this);
	}

	/**
	 * Deals with change events.
	 */
	public void stateChanged(ChangeEvent e) {
		Object source = e.getSource();
		if (source instanceof JSlider) {
			/*
			 * Slider has been changed. Determine and set new zoom factor.
			 */
			scalable.setScale(((JSlider) source).getValue() / 100.0);
			getComponent().repaint();
			/*
			 * Update secondary view accordingly.
			 */
		}
	}

	/**
	 * Deals with garbage collection.
	 */
	@Override
	public void finalize() throws Throwable {
		try {
			/*
			 * We can now clean up.
			 */
			cleanUp();
		} finally {
			super.finalize();
		}
	}

	public void updated() {
		JComponent newComponent = scalable.getComponent();
		if (newComponent != getComponent()) {
			scroll.setViewportView(newComponent);
			if (getComponent() instanceof Cleanable) {
				((Cleanable) getComponent()).cleanUp();
			}
			getComponent().removeMouseMotionListener(this);

			component = newComponent;
			getComponent().addMouseMotionListener(this);
			invalidate();
		}
		for (ViewInteractionPanel panel : panels.keySet()) {
			// HV: Do not call setScalableComponent now, as it changes the originalAttributeMap of the scalable.
			//			panel.setScalableComponent(scalable);
			panel.updated();
		}
	}

	public JViewport getViewport() {
		return scroll.getViewport();
	}

	public void scaleToFit() {
		scalable.setScale(1);
		double rx = scroll.getViewport().getExtentSize().getWidth()
				/ scalable.getComponent().getPreferredSize().getWidth();
		double ry = scroll.getViewport().getExtentSize().getHeight()
				/ scalable.getComponent().getPreferredSize().getHeight();
		scalable.setScale(Math.min(rx, ry));
	}

	public JComponent getComponent() {
		return component;
	}

}
"
VerticalLabelUI.java,widgets-6.9.234,"package org.processmining.framework.util.ui.scalableview;

import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.geom.AffineTransform;

import javax.swing.Icon;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.plaf.basic.BasicLabelUI;

public class VerticalLabelUI extends BasicLabelUI {

	static {
		labelUI = new VerticalLabelUI(false);
	}

	protected boolean clockwise;

	public VerticalLabelUI(boolean clockwise) {
		super();
		this.clockwise = clockwise;
	}

	public Dimension getPreferredSize(JComponent c) {
		Dimension dim = super.getPreferredSize(c);
		return new Dimension(dim.height, dim.width);
	}

	private static Rectangle paintIconR = new Rectangle();
	private static Rectangle paintTextR = new Rectangle();
	private static Rectangle paintViewR = new Rectangle();
	private static Insets paintViewInsets = new Insets(0, 0, 0, 0);

	public void paint(Graphics g, JComponent c) {

		JLabel label = (JLabel) c;
		String text = label.getText();
		Icon icon = (label.isEnabled()) ? label.getIcon() : label
				.getDisabledIcon();

		if ((icon == null) && (text == null)) {
			return;
		}

		FontMetrics fm = g.getFontMetrics();
		paintViewInsets = c.getInsets(paintViewInsets);

		paintViewR.x = paintViewInsets.left;
		paintViewR.y = paintViewInsets.top;

		// Use inverted height & width
		paintViewR.height = c.getWidth()
				- (paintViewInsets.left + paintViewInsets.right);
		paintViewR.width = c.getHeight()
				- (paintViewInsets.top + paintViewInsets.bottom);

		paintIconR.x = paintIconR.y = paintIconR.width = paintIconR.height = 0;
		paintTextR.x = paintTextR.y = paintTextR.width = paintTextR.height = 0;

		String clippedText = layoutCL(label, fm, text, icon, paintViewR,
				paintIconR, paintTextR);

		Graphics2D g2 = (Graphics2D) g;
		AffineTransform tr = g2.getTransform();
		if (clockwise) {
			g2.rotate(Math.PI / 2);
			g2.translate(0, -c.getWidth());
		} else {
			g2.rotate(-Math.PI / 2);
			g2.translate(-c.getHeight(), 0);
		}

		if (icon != null) {
			icon.paintIcon(c, g, paintIconR.x, paintIconR.y);
		}

		if (text != null) {
			int textX = paintTextR.x;
			int textY = paintTextR.y + fm.getAscent();

			if (label.isEnabled()) {
				paintEnabledText(label, g, clippedText, textX, textY);
			} else {
				paintDisabledText(label, g, clippedText, textX, textY);
			}
		}

		g2.setTransform(tr);
	}
}
"
BorderPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BasicStroke;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;

import javax.swing.BorderFactory;
import javax.swing.JPanel;

/**
 * Panel which adds a border around its contents
 * 
 * @author mwesterg
 * 
 */
public class BorderPanel extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private final int borderWidth;

	private final int size;

	/**
	 * @param size
	 * @param borderWidth
	 */
	public BorderPanel(final int size, final int borderWidth) {
		super();
		this.size = size;
		this.borderWidth = borderWidth;
		setBorder(BorderFactory.createEmptyBorder(borderWidth, size, borderWidth, size));
	}

	@Override
	protected void paintComponent(final Graphics g) {
		final Graphics2D g2d = (Graphics2D) g.create();
		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		if (isOpaque()) {
			g2d.setColor(getBackground());
			g2d.fillRoundRect(1, 1, getWidth() - 3, getHeight() - 3, size * 2, size * 2);
		}
		if (borderWidth > 0) {
			g2d.setColor(getForeground());
			g2d.setStroke(new BasicStroke(borderWidth));
			g2d.drawRoundRect(borderWidth / 2, borderWidth / 2, getWidth() - borderWidth - 1, getHeight() - borderWidth
					- 1, size * 2, size * 2);
		}
	}
}
"
ColorScheme.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;

/**
 * Some nice color schemes for visualization. Mostly taken from colorbrewer2.org
 * under Apache 2.0 license.
 * 
 * @author F. Mannhardt
 *
 */
public enum ColorScheme {

	BLACK(new Color[] { Color.BLACK }, Color.BLACK),

	COLOR_BREWER_5CLASS_SET1(new Color[] { new Color(228, 26, 28), new Color(55, 126, 184), new Color(77, 175, 74),
			new Color(152, 78, 163), new Color(255, 127, 0) }, Color.GRAY), //

	COLOR_BREWER_9CLASS_SET1(new Color[] { new Color(228, 26, 28), new Color(55, 126, 184), new Color(77, 175, 74),
			new Color(152, 78, 163), new Color(255, 127, 0), new Color(255, 255, 51), new Color(166, 86, 40),
			new Color(247, 129, 191), new Color(153, 153, 153) }, Color.LIGHT_GRAY), //

	COLOR_BREWER_9CLASS_SET21(new Color[] { new Color(141, 211, 199), new Color(255, 255, 179),
			new Color(190, 186, 218), new Color(251, 128, 114), new Color(128, 177, 211), new Color(253, 180, 98),
			new Color(179, 222, 105), new Color(252, 205, 229), new Color(217, 217, 217) }, Color.LIGHT_GRAY), //

	COLOR_BREWER_12CLASS_PAIRED(new Color[] { new Color(166, 206, 227), new Color(31, 120, 180),
			new Color(178, 223, 138), new Color(51, 160, 44), new Color(251, 154, 153), new Color(227, 26, 28),
			new Color(253, 191, 111), new Color(255, 127, 0), new Color(202, 178, 214), new Color(106, 61, 154),
			new Color(255, 255, 153), new Color(177, 89, 40) }, Color.GRAY), //
	
	SEQ_PALETTE_YlOrRd(new Color[] {
			new Color(255, 255, 229), new Color(255, 255, 204), new Color(255, 237, 160), new Color(254, 217, 118), new Color(254, 178, 76),
			new Color(253, 141, 60), new Color(252, 78, 42), new Color(227, 26, 28), new Color(189, 0, 38),
			new Color(128, 0, 38)}, Color.GRAY);

	private final Color[] scheme;
	private final Color defaultColor;

	private ColorScheme(Color[] scheme, Color defaultColor) {
		this.scheme = scheme;
		this.defaultColor = defaultColor;
	}

	public Color[] getColors() {
		return scheme;
	}

	public Color getColor(int index) {
		return getColor(index, defaultColor);
	}

	public Color getColor(int index, Color defaultColor) {
		if (index >= scheme.length) {
			return defaultColor;
		}
		return scheme[index];
	}
	
	public Color getColorFromGradient(float factor) {
		return getColorFromGradient(factor, defaultColor);
	}
	
	public Color getColorFromGradient(float factor, Color defaultColor) {
		return getColorFromGradient(factor, scheme, defaultColor);
	}

	public static Color getColorFromGradient(float factor, Color[] colorScheme, Color defaultColor) {
		if (factor >= 1.0) {
			// Special case
			return defaultColor;
		}
		float bucketSize = 1.0f / colorScheme.length;
		int maxIndex = colorScheme.length-1;
		int minIndex = 0;
		int bucket = Math.min(maxIndex, Math.max(minIndex, (int) Math.floor(factor / bucketSize)));
		return colorScheme[bucket];
	}

}"
ColorSchemeLegend.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.text.MessageFormat;

import javax.swing.JComponent;

/**
 * Legend for a gradient-based color scheme.
 * 
 * @author F. Mannhardt
 *
 */
public class ColorSchemeLegend extends JComponent {

	private static final long serialVersionUID = 1L;

	private final Color[] colorPalette;
	protected final float bucketSize;

	private int textDistance = 1;
	private int tickHeight = 3;

	public ColorSchemeLegend(Color[] colorPalette) {
		super();
		this.colorPalette = colorPalette;
		this.bucketSize = 1.0f / colorPalette.length;
	}

	protected void paintComponent(Graphics g) {
		super.paintComponent(g);

		Dimension size = getSize();
		Graphics2D g2d = (Graphics2D) g;
		g2d.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 10));

		double barWidth = size.getWidth() / colorPalette.length;
		double barHeight = getBarHeight(g2d, size);

		for (int i = 0; i < colorPalette.length; i++) {
			Color color = colorPalette[i];
			g2d.setColor(color);
			double currentX = i * barWidth;
			g2d.fill(new Rectangle2D.Double(currentX, 0, barWidth, barHeight));
			g2d.setColor(getForeground());
			if (i != 0) {
				g2d.setColor(Color.BLACK);
				g2d.draw(new Line2D.Double(currentX, 0, currentX, barHeight + getTickHeight()));
				drawBarDesc(g2d, barHeight, i, currentX);
			}
			drawBucketDesc(g2d, barWidth, barHeight, i);
		}
		g2d.setColor(Color.BLACK);
		drawBucketDesc(g2d, barWidth, barHeight, colorPalette.length);
		g2d.draw(new Rectangle2D.Double(0, 0, size.getWidth() - 1, getBarHeight(g2d, size)));
	}

	private void drawBarDesc(Graphics2D g2d, double barHeight, int i, double currentX) {
		String barDesc = getBarDesc(i);
		int descWidth = g2d.getFontMetrics().stringWidth(barDesc);
		g2d.drawString(barDesc, (int) Math.ceil(currentX - (descWidth / 2.0)),
				(int) Math.ceil(barHeight + getTextBaseline(g2d)));
	}

	private void drawBucketDesc(Graphics2D g2d, double barWidth, double barHeight, int i) {
		String bucketDesc = getBucketDesc(i);
		if (bucketDesc != null) {
			int descWidth = g2d.getFontMetrics().stringWidth(bucketDesc);
			g2d.drawString(bucketDesc, (int) Math.ceil((i * barWidth) - (descWidth / 2.0) - (barWidth / 2.0)),
					(int) Math.ceil(barHeight + getTextBaseline(g2d)));
		}
	}

	protected String getBarDesc(int bucket) {
		float bucketStart = bucket * bucketSize;
		return MessageFormat.format(""{0,number,#.#}"", bucketStart);
	}

	protected String getBucketDesc(int bucket) {
		return null;
	}

	private double getBarHeight(Graphics2D g2d, Dimension size) {
		return size.getHeight() - getTextBaseline(g2d);
	}

	private int getTextBaseline(Graphics2D g2d) {
		return g2d.getFontMetrics().getAscent() + textDistance;
	}

	public int getTextDistance() {
		return textDistance;
	}

	public void setTextDistance(int textDistance) {
		this.textDistance = textDistance;
	}

	public int getTickHeight() {
		return tickHeight;
	}

	public void setTickHeight(int tickHeight) {
		this.tickHeight = tickHeight;
	}
}"
HeaderRenderer.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Component;
import java.awt.ComponentOrientation;

import javax.swing.BorderFactory;
import javax.swing.JTable;
import javax.swing.SwingConstants;
import javax.swing.UIManager;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.JTableHeader;

/**
 * Renderer for headers for tables
 * 
 * @author mwesterg
 * 
 */
public class HeaderRenderer extends DefaultTableCellRenderer {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * 
	 */
	public HeaderRenderer() {
		setHorizontalAlignment(SwingConstants.CENTER);
		setOpaque(true);

		// This call is needed because DefaultTableCellRenderer calls setBorder()
		// in its constructor, which is executed after updateUI()
		setBorder(BorderFactory.createEmptyBorder(0, 0, 10, 0));
	}

	/**
	 * @see javax.swing.table.DefaultTableCellRenderer#getTableCellRendererComponent(javax.swing.JTable,
	 *      java.lang.Object, boolean, boolean, int, int)
	 */
	@Override
	public Component getTableCellRendererComponent(final JTable table, final Object value, final boolean selected,
			final boolean focused, final int row, final int column) {
		final JTableHeader h = table != null ? table.getTableHeader() : null;

		if (h != null) {
			setEnabled(h.isEnabled());
			setComponentOrientation(h.getComponentOrientation());

			setForeground(h.getForeground());
			setBackground(h.getBackground());
			setFont(h.getFont());
		} else {
			/*
			 * Use sensible values instead of random leftover values from the
			 * last call
			 */
			setEnabled(true);
			setComponentOrientation(ComponentOrientation.UNKNOWN);

			setForeground(UIManager.getColor(""TableHeader.foreground""));
			setBackground(UIManager.getColor(""TableHeader.background""));
			setFont(UIManager.getFont(""TableHeader.font""));
		}

		setValue(value);

		return this;
	}

	/**
	 * @see javax.swing.table.DefaultTableCellRenderer#updateUI()
	 */
	@Override
	public void updateUI() {
		super.updateUI();
		setBorder(BorderFactory.createEmptyBorder(0, 0, 10, 0));
	}
}"
ChoiceQueryPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;

import javax.swing.BoxLayout;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMComboBox;

class ChoiceQueryPanel<T> extends JPanel {

	private static final long serialVersionUID = -6547392010448275699L;

	private final ProMComboBox<T> choiceField;

	public ChoiceQueryPanel(Iterable<T> choices) {
		super();
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		choiceField = new ProMComboBox<>(choices);
		choiceField.setPreferredSize(null);
		add(choiceField);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}
	
	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[] { ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;
	}

	@SuppressWarnings(""unchecked"")
	public T getResult() {
		return (T) choiceField.getModel().getSelectedItem();
	}

}"
FixedMappingQueryPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;
import java.awt.Dimension;
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;

import javax.swing.BoxLayout;
import javax.swing.DefaultCellEditor;
import javax.swing.JComboBox;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.table.DefaultTableModel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMTable;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.UnmodifiableIterator;

class FixedMappingQueryPanel<S,T> extends JPanel {

	private static final String NO_MAPPING = ""NONE"";

	private static final long serialVersionUID = 4946819373227598703L;

	private ProMTable mappingTable;
	private ImmutableList<S> sourceList;
	private ImmutableList<T> targetList;

	@SuppressWarnings(""serial"")
	public FixedMappingQueryPanel(String text, Iterable<S> sources, Iterable<T> targets, Map<S, T> defaultValues) {
		super();
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBackground(null);

		sourceList = ImmutableList.copyOf(sources);
		targetList = ImmutableList.copyOf(targets);

		DefaultTableModel tableModel = new DefaultTableModel(sourceList.size(), 2) {

			public boolean isCellEditable(int row, int column) {
				if (column == 0) {
					return false;
				}
				return super.isCellEditable(row, column);
			}

		};

		mappingTable = new ProMTable(tableModel);
		mappingTable.setPreferredSize(new Dimension(600, 400));
		mappingTable.setMaximumSize(null);
		mappingTable.setMinimumSize(null);
		mappingTable.getTableHeader().getColumnModel().getColumn(0).setHeaderValue(""Source"");
		mappingTable.getTableHeader().getColumnModel().getColumn(0).setPreferredWidth(200);
		mappingTable.getTableHeader().getColumnModel().getColumn(1).setHeaderValue(""Target"");
		mappingTable.getTableHeader().getColumnModel().getColumn(1).setPreferredWidth(200);

		mappingTable.getColumnModel().getColumn(1)
				.setCellEditor(new DefaultCellEditor(new JComboBox<T>(new Vector<>(targetList))) {

					protected void fireEditingStopped() {
						this.cancelCellEditing();
						super.fireEditingStopped();
					}

					protected void fireEditingCanceled() {
						super.fireEditingCanceled();
					}

				});

		int i = 0;
		for (S source : sourceList) {
			mappingTable.getTable().getModel().setValueAt(source, i++, 0);
		}

		for (i = 0; i < sourceList.size(); i++) {
			T defaultValue = defaultValues.get(sourceList.get(i));
			if (defaultValue != null) {
				mappingTable.getTable().getModel().setValueAt(defaultValue, i, 1);
			} else {
				mappingTable.getTable().getModel().setValueAt(null, i, 1);
			}
		}

		add(mappingTable);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}
	
	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[] { ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;
	}

	public Map<S, T> getResult() {
		Map<S, T> result = new HashMap<>();

		int i = 0;
		UnmodifiableIterator<S> iterator = sourceList.iterator();
		while (iterator.hasNext()) {
			S source = iterator.next();
			@SuppressWarnings(""unchecked"")
			T target = (T) mappingTable.getTable().getModel().getValueAt(i++, 1);
			if (!target.equals(null)) {
				result.put(source, target);
			}
		}

		return result;
	}

}"
FreeMappingQueryPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;
import java.awt.Dimension;
import java.util.HashMap;
import java.util.Map;

import javax.swing.BoxLayout;
import javax.swing.DefaultCellEditor;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.table.DefaultTableModel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMTable;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.UnmodifiableIterator;

class FreeMappingQueryPanel<T> extends JPanel {

	private static final String NO_MAPPING = ""NONE"";

	private static final long serialVersionUID = 4946819373227598703L;
	
	private ProMTable mappingTable;
	private ImmutableList<T> sourceList;

	@SuppressWarnings(""serial"")
	public FreeMappingQueryPanel(String text, Iterable<T> sources, Map<T, String> defaultValues) {
		super();
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBackground(null);

		sourceList = ImmutableList.copyOf(sources);
		
		DefaultTableModel tableModel = new DefaultTableModel(sourceList.size(), 2) {

			public boolean isCellEditable(int row, int column) {
				if (column == 0) {
					return false;
				}
				return super.isCellEditable(row, column);
			}
			
		};
		
		mappingTable = new ProMTable(tableModel);
		mappingTable.setPreferredSize(new Dimension(600, 400));
		mappingTable.setMaximumSize(null);
		mappingTable.setMinimumSize(null);
		mappingTable.getTableHeader().getColumnModel().getColumn(0).setHeaderValue(""Source"");
		mappingTable.getTableHeader().getColumnModel().getColumn(0).setPreferredWidth(200);
		mappingTable.getTableHeader().getColumnModel().getColumn(1).setHeaderValue(""Target"");
		mappingTable.getTableHeader().getColumnModel().getColumn(1).setPreferredWidth(200);
		
		mappingTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(new JTextField()) {

			protected void fireEditingStopped() {
				this.cancelCellEditing();
				super.fireEditingStopped();
			}

			protected void fireEditingCanceled() {
				super.fireEditingCanceled();
			}

		});
		

		int i = 0;
		for (T source: sourceList) {
			mappingTable.getTable().getModel().setValueAt(source, i++, 0);
		}
		
		for (i = 0; i < sourceList.size(); i++) {
			String defaultValue = defaultValues.get(sourceList.get(i));
			if (defaultValue != null) {
				mappingTable.getTable().getModel().setValueAt(defaultValue, i, 1);
			} else {
				mappingTable.getTable().getModel().setValueAt(NO_MAPPING, i, 1);	
			}			
		}
	
		add(mappingTable);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}
	
	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[] { ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;
	}

	public Map<T, String> getResult() {
		Map<T, String> result = new HashMap<>();
		
		int i = 0;
		UnmodifiableIterator<T> iterator = sourceList.iterator();
		while (iterator.hasNext()) {
			T source = iterator.next();
			String target = (String) mappingTable.getTable().getModel().getValueAt(i++, 1);
			if (!target.equals(NO_MAPPING)) {
				result.put(source, target);	
			}			
		}
		
		return result;
	}

}"
MultilineStringQueryPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;

import javax.swing.BoxLayout;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMTextArea;

public class MultilineStringQueryPanel extends JPanel {

	private static final long serialVersionUID = -8701706429341608153L;
	
	private final ProMTextArea textArea;
	
	public MultilineStringQueryPanel(String text) {
		super();
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		textArea = new ProMTextArea();
		if (text != null) {
			textArea.setText(text);
		}
		textArea.setPreferredSize(null);
		add(textArea);
	}

	public MultilineStringQueryPanel() {
		this(null);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}
	
	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[] { ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;
	}

	public String getResult() {
		return textArea.getText();
	}

	
}
"
MultipleChoiceQueryPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.BorderLayout;
import java.awt.Component;
import java.util.List;

import javax.swing.DefaultListModel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMList;

class MultipleChoiceQueryPanel<T> extends JPanel {

	private static final long serialVersionUID = -6547392010448275699L;

	private final ProMList<T> choiceField;

	public MultipleChoiceQueryPanel(String title, Iterable<T> choices) {
		super(new BorderLayout());
		DefaultListModel<T> listModel = new DefaultListModel<>();
		for (T c : choices) {
			listModel.addElement(c);
		}
		choiceField = new ProMList<>(title, listModel);
		choiceField.setPreferredSize(null);
		add(choiceField, BorderLayout.CENTER);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}

	public List<T> getResult() {
		return choiceField.getSelectedValuesList();
	}

	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[]{ ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;  
	}

}"
ProMUIHelper.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;
import java.awt.Dimension;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import javax.swing.JComponent;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;

import com.google.common.base.Throwables;
import com.google.common.collect.ImmutableMap;

/**
 * Commonly used functionality for the ProM UI as static helper methods. All
 * methods throw {@link UserCancelledException} when the user presses the cancel
 * button.
 * 
 * @author F. Mannhardt
 * 
 */
public class ProMUIHelper {

	/******************* ERROR / WARNING / INFO MESSAGES *****************/

	/**
	 * Displays an error message in a 'modal' pop-up using the global UI as
	 * parent JFrame.
	 * 
	 * @param context
	 * @param errorMessage
	 * @param errorTitle
	 */
	public static void showErrorMessage(UIPluginContext context, String errorMessage, String errorTitle) {
		Object[] options = { ""OK"" };

		JOptionPane.showOptionDialog(context.getGlobalContext().getUI(), createMessageBody(errorMessage), errorTitle,
				JOptionPane.PLAIN_MESSAGE, JOptionPane.ERROR_MESSAGE, null, options, options[0]);
	}

	/**
	 * Displays an error message in a 'modal' pop-up using a default JFrame.
	 * 
	 * @param errorMessage
	 * @param errorTitle
	 */
	public static void showErrorMessage(String errorMessage, String errorTitle) {
		Object[] options = { ""OK"" };
		JOptionPane.showOptionDialog(null, createMessageBody(errorMessage), errorTitle, JOptionPane.PLAIN_MESSAGE,
				JOptionPane.ERROR_MESSAGE, null, options, options[0]);
	}

	/**
	 * Displays an error message in a 'modal' pop-up using the specified
	 * Component as parent.
	 * 
	 * @param component
	 * @param errorMessage
	 * @param errorTitle
	 */
	public static void showErrorMessage(Component component, String errorMessage, String errorTitle) {
		Object[] options = { ""OK"" };
		JOptionPane.showOptionDialog(component, createMessageBody(errorMessage), errorTitle, JOptionPane.PLAIN_MESSAGE,
				JOptionPane.ERROR_MESSAGE, null, options, options[0]);
	}

	public static void showErrorMessage(Component component, String errorMessage, String errorTitle, Throwable e) {
		Object[] options = { ""OK"", ""Show Debug Information"" };
		int result = JOptionPane.showOptionDialog(component, createMessageBody(errorMessage), errorTitle,
				JOptionPane.PLAIN_MESSAGE, JOptionPane.ERROR_MESSAGE, null, options, options[0]);
		if (result == 1) {
			String[] optionsStacktrace = new String[] { ""OK"" };
			JOptionPane.showOptionDialog(component, createMessageBody(Throwables.getStackTraceAsString(e)),
					""Debug Information: "" + errorTitle, JOptionPane.PLAIN_MESSAGE, JOptionPane.ERROR_MESSAGE, null,
					optionsStacktrace, optionsStacktrace[0]);
		}
	}

	/**
	 * Displays an warning message in a 'modal' pop-up using the global UI as
	 * parent JFrame.
	 * 
	 * @param context
	 * @param warnMessage
	 * @param warnTitle
	 */
	public static void showWarningMessage(UIPluginContext context, String warnMessage, String warnTitle) {
		Object[] options = { ""OK"" };
		JOptionPane.showOptionDialog(context.getGlobalContext().getUI(), createMessageBody(warnMessage), warnTitle,
				JOptionPane.PLAIN_MESSAGE, JOptionPane.WARNING_MESSAGE, null, options, options[0]);
	}

	/**
	 * Displays an warning message in a 'modal' pop-up using a default JFrame.
	 * 
	 * @param warnMessage
	 * @param warnTitle
	 */
	public static void showWarningMessage(String warnMessage, String warnTitle) {
		Object[] options = { ""OK"" };
		JOptionPane.showOptionDialog(null, createMessageBody(warnMessage), warnTitle, JOptionPane.PLAIN_MESSAGE,
				JOptionPane.WARNING_MESSAGE, null, options, options[0]);
	}

	/**
	 * Displays an warning message in a 'modal' pop-up using using the specified
	 * Component as parent.
	 * 
	 * @param component
	 * @param warnMessage
	 * @param warnTitle
	 */
	public static void showWarningMessage(Component component, String warnMessage, String warnTitle) {
		Object[] options = { ""OK"" };
		JOptionPane.showOptionDialog(component, createMessageBody(warnMessage), warnTitle, JOptionPane.PLAIN_MESSAGE,
				JOptionPane.WARNING_MESSAGE, null, options, options[0]);
	}

	private static JComponent createMessageBody(String message) {
		JTextArea errorBody = new JTextArea(message);
		errorBody.setWrapStyleWord(true);
		errorBody.setLineWrap(true);
		return new JScrollPane(errorBody) {

			private static final long serialVersionUID = 1L;

			public Dimension getPreferredSize() {
				return new Dimension(480, 320);
			}

		};
	}

	/******************* QUERY DIALOGS *****************/

	/**
	 * Displays a configuration dialog asking the user to enter a String
	 * literal.
	 * 
	 * @param context
	 * @param queryCaption
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForString(UIPluginContext context, String queryCaption) throws UserCancelledException {
		return queryForString(context, queryCaption, null, null);
	}
	
	public static String queryForString(Component view, String queryCaption) throws UserCancelledException {
		return queryForString(view, queryCaption, null, null);
	}

	/**
	 * Displays a configuration dialog asking the user to enter a String literal
	 * 
	 * @param context
	 * @param queryCaption
	 * @param queryText
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForString(UIPluginContext context, String queryCaption, String queryText)
			throws UserCancelledException {
		return queryForString(context, queryCaption, queryText, null);
	}
	
	public static String queryForString(Component view, String queryCaption, String queryText)
			throws UserCancelledException {
		return queryForString(view, queryCaption, queryText, null);
	}

	/**
	 * Displays a configuration dialog asking the user to enter a String literal
	 * 
	 * @param context
	 * @param queryCaption
	 * @param queryText
	 * @param defaultValue
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForString(UIPluginContext context, String queryCaption, String queryText,
			String defaultValue) throws UserCancelledException {
		StringQueryPanel queryPanel = new StringQueryPanel(queryText, defaultValue);
		InteractionResult choice = queryPanel.getUserChoice(context, queryCaption);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}
	
	public static String queryForString(Component view, String queryCaption, String queryText,
			String defaultValue) throws UserCancelledException {
		StringQueryPanel queryPanel = new StringQueryPanel(queryText, defaultValue);
		InteractionResult choice = queryPanel.getUserChoice(view, queryCaption);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Displays a configuration dialog asking the user to enter a Integer, uses
	 * {@link Integer#parseInt(String)} to convert the user input.
	 * 
	 * @param context
	 * @param query
	 * @return
	 * @throws NumberFormatException
	 * @throws UserCancelledException
	 */
	public static int queryForInteger(UIPluginContext context, String query)
			throws NumberFormatException, UserCancelledException {
		return Integer.parseInt(queryForString(context, query));
	}
	
	public static int queryForInteger(Component view, String query)
			throws NumberFormatException, UserCancelledException {
		return Integer.parseInt(queryForString(view, query));
	}

	/**
	 * Displays a configuration dialog asking the user to enter a Float, uses
	 * {@link Float#parseFloat(String)} to convert the user input.
	 * 
	 * @param context
	 * @param query
	 * @return
	 * @throws NumberFormatException
	 * @throws UserCancelledException
	 */
	public static float queryForFloat(UIPluginContext context, String query)
			throws NumberFormatException, UserCancelledException {
		return Float.parseFloat(queryForString(context, query));
	}
	
	public static float queryForFloat(Component view, String query)
			throws NumberFormatException, UserCancelledException {
		return Float.parseFloat(queryForString(view, query));
	}

	/**
	 * Displays a configuration dialog asking the user to enter a Double, uses
	 * {@link Double#parseDouble(String)} to convert the user input.
	 * 
	 * @param context
	 * @param query
	 * @return
	 * @throws NumberFormatException
	 * @throws UserCancelledException
	 */
	public static double queryForDouble(UIPluginContext context, String query)
			throws NumberFormatException, UserCancelledException {
		return Double.parseDouble(queryForString(context, query));
	}
	
	public static double queryForDouble(Component view, String query)
			throws NumberFormatException, UserCancelledException {
		return Double.parseDouble(queryForString(view, query));
	}

	/**
	 * Displays a configuration dialog asking the user to select a double value
	 * between 0.0 and 1.0 (both inclusive). The default value is 1.0.
	 * 
	 * @param context
	 * @param query
	 * @return
	 * @throws NumberFormatException
	 * @throws UserCancelledException
	 */
	public static double queryForDoubleZeroOne(UIPluginContext context, String query) throws UserCancelledException {
		return queryForDouble(context, query, 0.0d, 1.0d, 1.0d);
	}
	
	public static double queryForDoubleZeroOne(Component view, String query) throws UserCancelledException {
		return queryForDouble(view, query, 0.0d, 1.0d, 1.0d);
	}

	/**
	 * Displays a configuration dialog asking the user to select a double value.
	 * 
	 * @param context
	 * @param query
	 * @return
	 * @throws UserCancelledException
	 */
	public static double queryForDouble(UIPluginContext context, String query, double min, double max,
			double defaultValue) throws UserCancelledException {
		SliderQueryPanel queryPanel = new SliderQueryPanel(query, min, max, defaultValue);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}
	
	public static double queryForDouble(Component view, String query, double min, double max,
			double defaultValue) throws UserCancelledException {
		SliderQueryPanel queryPanel = new SliderQueryPanel(query, min, max, defaultValue);
		InteractionResult choice = queryPanel.getUserChoice(view, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog asking the user to enter an ordered list of integers
	 * separated by comma.
	 * 
	 * @param context
	 * @param query
	 * @return
	 * @throws NumberFormatException
	 * @throws UserCancelledException
	 */
	public static int[] queryForIntArray(UIPluginContext context, String query)
			throws NumberFormatException, UserCancelledException {
		String result = queryForString(context, query);
		if (result != null && result.length() > 0) {
			String[] traceIndexArray = result.split("","");
			int[] traceIndexSet = new int[traceIndexArray.length];
			for (int i = 0; i < traceIndexArray.length; i++) {
				String singleTraceIndex = traceIndexArray[i];
				traceIndexSet[i] = Integer.parseInt(singleTraceIndex);
			}
			return traceIndexSet;
		} else {
			throw new NumberFormatException(""Invalid format, should be comma separated integers!"");
		}
	}

	/**
	 * Shows a dialog with a combo box containing the choices, and returns the
	 * selected value.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> T queryForObject(UIPluginContext context, String query, T[] choices)
			throws UserCancelledException {
		return queryForObject(context, query, Arrays.asList(choices));
	}
	
	public static <T> T queryForObject(Component view, String query, T[] choices)
			throws UserCancelledException {
		return queryForObject(view, query, Arrays.asList(choices));
	}

	/**
	 * 
	 * Shows a dialog with a combo box containing the choices, and returns the
	 * selected value.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> T queryForObject(UIPluginContext context, String query, Iterable<T> choices)
			throws UserCancelledException {
		ChoiceQueryPanel<T> queryPanel = new ChoiceQueryPanel<>(choices);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}
	
	public static <T> T queryForObject(Component view, String query, Iterable<T> choices)
			throws UserCancelledException {
		ChoiceQueryPanel<T> queryPanel = new ChoiceQueryPanel<>(choices);
		InteractionResult choice = queryPanel.getUserChoice(view, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog with a combo box containing the choices, and returns the
	 * selected value.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForString(UIPluginContext context, String query, String[] choices)
			throws UserCancelledException {
		return queryForString(context, query, Arrays.asList(choices));
	}
	
	public static String queryForString(Component view, String query, String[] choices)
			throws UserCancelledException {
		return queryForString(view, query, Arrays.asList(choices));
	}

	/**
	 * Shows a dialog with a combo box containing the choices, and returns the
	 * selected value.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForString(UIPluginContext context, String query, Iterable<String> choices)
			throws UserCancelledException {
		ChoiceQueryPanel<String> queryPanel = new ChoiceQueryPanel<>(choices);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}
	
	public static String queryForString(Component view, String query, Iterable<String> choices)
			throws UserCancelledException {
		ChoiceQueryPanel<String> queryPanel = new ChoiceQueryPanel<>(choices);
		InteractionResult choice = queryPanel.getUserChoice(view, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog with a multi-line text area, and returns the entered
	 * value.
	 * 
	 * @param context
	 * @param queryCaption
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForMultilineString(UIPluginContext context, String queryCaption)
			throws UserCancelledException {
		MultilineStringQueryPanel queryPanel = new MultilineStringQueryPanel();
		InteractionResult choice = queryPanel.getUserChoice(context, queryCaption);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog with a multi-line text area, and returns the entered
	 * value.
	 * 
	 * @param context
	 * @param queryCaption
	 *            that is shown on top of the dialog
	 * @param defaultText
	 *            that is shown in the text area
	 * @return
	 * @throws UserCancelledException
	 */
	public static String queryForMultilineString(UIPluginContext context, String queryCaption, String defaultText)
			throws UserCancelledException {
		MultilineStringQueryPanel queryPanel = new MultilineStringQueryPanel(defaultText);
		InteractionResult choice = queryPanel.getUserChoice(context, queryCaption);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog with a selection list that allow multi-selection.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> List<T> queryForObjects(UIPluginContext context, String query, T[] choices)
			throws UserCancelledException {
		return queryForObjects(context, query, Arrays.asList(choices));
	}
	
	public static <T> List<T> queryForObjects(Component view, String query, T[] choices)
			throws UserCancelledException {
		return queryForObjects(view, query, Arrays.asList(choices));
	}

	/**
	 * Shows a dialog with a selection list that allow multi-selection.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> List<T> queryForObjects(UIPluginContext context, String query, Iterable<T> choices)
			throws UserCancelledException {
		MultipleChoiceQueryPanel<T> queryPanel = new MultipleChoiceQueryPanel<>(query, choices);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	public static <T> List<T> queryForObjects(Component view, String query, Iterable<T> choices)
			throws UserCancelledException {
		MultipleChoiceQueryPanel<T> queryPanel = new MultipleChoiceQueryPanel<>(query, choices);
		InteractionResult choice = queryPanel.getUserChoice(view, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog with a selection list that allow multi-selection.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static List<String> queryForStrings(UIPluginContext context, String query, Iterable<String> choices)
			throws UserCancelledException {
		MultipleChoiceQueryPanel<String> queryPanel = new MultipleChoiceQueryPanel<>(query, choices);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	public static List<String> queryForStrings(Component view, String query, Iterable<String> choices)
			throws UserCancelledException {
		MultipleChoiceQueryPanel<String> queryPanel = new MultipleChoiceQueryPanel<>(query, choices);
		InteractionResult choice = queryPanel.getUserChoice(view, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog with a selection list that allow multi-selection.
	 * 
	 * @param context
	 * @param query
	 * @param choices
	 * @return
	 * @throws UserCancelledException
	 */
	public static List<String> queryForStrings(UIPluginContext context, String query, String[] choices)
			throws UserCancelledException {
		return queryForStrings(context, query, Arrays.asList(choices));
	}

	/**
	 * Shows a dialog to the user with a two-column table. The first column
	 * contains the supplied keys. In the second column the user can enter the
	 * desired values. The mapping is returned as a Map.
	 * 
	 * @param context
	 * @param query
	 * @param keys
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> Map<T, String> queryMapToString(UIPluginContext context, String query, Iterable<T> keys)
			throws UserCancelledException {
		FreeMappingQueryPanel<T> queryPanel = new FreeMappingQueryPanel<>(query, keys, ImmutableMap.<T, String>of());
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog to the user with a two-column table. The first column
	 * contains the supplied keys. In the second column the user can enter the
	 * desired values. The mapping is returned as a Map.
	 * 
	 * @param context
	 * @param query
	 * @param keys
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> Map<T, String> queryMapToString(UIPluginContext context, String query, T[] keys)
			throws UserCancelledException {
		return queryMapToString(context, query, Arrays.asList(keys));
	}

	/**
	 * Shows a dialog to the user with a two-column table. The first column
	 * contains the supplied keys. In the second column the user can enter the
	 * desired values. The mapping is returned as a Map.
	 * 
	 * @param context
	 * @param query
	 * @param keys
	 * @param defaultValues
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> Map<T, String> queryMapToString(UIPluginContext context, String query, Iterable<T> keys,
			Map<T, String> defaultValues) throws UserCancelledException {
		FreeMappingQueryPanel<T> queryPanel = new FreeMappingQueryPanel<>(query, keys, defaultValues);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

	/**
	 * Shows a dialog to the user with a two-column table. The first column
	 * contains the supplied keys. In the second column the user can enter the
	 * desired values. The mapping is returned as a Map.
	 * 
	 * @param context
	 * @param query
	 * @param keys
	 * @param defaultValues
	 * @return
	 * @throws UserCancelledException
	 */
	public static <T> Map<T, String> queryMapToString(UIPluginContext context, String query, T[] keys,
			Map<T, String> defaultValues) throws UserCancelledException {
		return queryMapToString(context, query, Arrays.asList(keys), defaultValues);
	}

	/**
	 * Shows a dialog to the user with a two-column table. The first column
	 * contains the supplied keys. In the second column the user can choose from
	 * a list of values. The mapping is returned as a Map.
	 * 
	 * @param context
	 * @param query
	 * @param keys
	 * @param values
	 * @return
	 * @throws UserCancelledException
	 */
	public static <S, T> Map<S, T> queryMapToObject(UIPluginContext context, String query, Iterable<S> keys,
			Iterable<T> values) throws UserCancelledException {
		return queryMapToObject(context, query, keys, values, ImmutableMap.<S, T>of());
	}

	/**
	 * Shows a dialog to the user with a two-column table. The first column
	 * contains the supplied keys. In the second column the user can choose from
	 * a list of values. The mapping is returned as a Map.
	 * 
	 * @param context
	 * @param query
	 * @param keys
	 * @param values
	 * @param defaultMap
	 * @return
	 * @throws UserCancelledException
	 */
	public static <S, T> Map<S, T> queryMapToObject(UIPluginContext context, String query, Iterable<S> keys,
			Iterable<T> values, Map<S, T> defaultMap) throws UserCancelledException {
		FixedMappingQueryPanel<S, T> queryPanel = new FixedMappingQueryPanel<S, T>(query, keys, values, defaultMap);
		InteractionResult choice = queryPanel.getUserChoice(context, query);
		if (choice == InteractionResult.FINISHED || choice == InteractionResult.CONTINUE) {
			return queryPanel.getResult();
		} else {
			throw new UserCancelledException();
		}
	}

}"
SliderQueryPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;

import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;

import com.fluxicon.slickerbox.components.NiceDoubleSlider;
import com.fluxicon.slickerbox.components.NiceSlider.Orientation;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class SliderQueryPanel extends JPanel {

	private static final long serialVersionUID = 1L;

	private final NiceDoubleSlider slider;

	public SliderQueryPanel(String queryText, double min, double max, double defaultValue) {
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		if (queryText != null) {
			add(new JLabel(queryText));
		}
		slider = SlickerFactory.instance().createNiceDoubleSlider(queryText, min, max, defaultValue,
				Orientation.HORIZONTAL);
		add(slider);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}

	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[] { ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;
	}

	public double getResult() {
		return slider.getValue();
	}

}
"
StringQueryPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.helper;

import java.awt.Component;

import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMTextField;

class StringQueryPanel extends JPanel {

	private static final long serialVersionUID = -6547392010448275699L;

	private final ProMTextField textField;
	
	public StringQueryPanel(String queryText, String defaultValue) {
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		if (queryText != null) {
			add(new JLabel(queryText));
		}
		if (defaultValue != null) {
			textField = new ProMTextField(defaultValue);	
		} else {
			textField = new ProMTextField();
		}
		textField.setPreferredSize(null);
		add(textField);
	}
	
	public StringQueryPanel(String text) {
		this(text, null);
	}

	public StringQueryPanel() {
		this(null);
	}

	public InteractionResult getUserChoice(UIPluginContext context, String query) {
		return context.showConfiguration(query, this);
	}
	
	public InteractionResult getUserChoice(Component view, String query) {
		String[] options = new String[] { ""Confirm"", ""Cancel"" };
		int result = JOptionPane.showOptionDialog(view, this, query, JOptionPane.DEFAULT_OPTION,
				JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
		return result == 0 ? InteractionResult.CONTINUE : InteractionResult.CANCEL;
	}

	public String getResult() {
		return textField.getText();
	}

}"
UserCancelledException.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.helper;

/**
 * Thrown by most methods in {@link ProMUIHelper} in case the user cancels an
 * operation.
 * 
 * @author F. Mannhardt
 * 
 */
public class UserCancelledException extends Exception {

	private static final long serialVersionUID = 1L;

	public UserCancelledException() {
		super(""User Cancelled"");
	}

	public UserCancelledException(String message, Throwable cause) {
		super(message, cause);
	}

	public UserCancelledException(String message) {
		super(message);
	}

	public UserCancelledException(Throwable cause) {
		super(cause);
	}

}
"
Inspector.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Frame;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsDevice.WindowTranslucency;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ContainerEvent;
import java.awt.event.ContainerListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JWindow;

import org.deckfour.uitopia.ui.components.ImageButton;

import com.fluxicon.slickerbox.components.SlickerTabbedPane;
import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * Inspector-style window. You should probably use an InspectorPanel instead of
 * this class directly.
 * 
 * @author mwesterg
 * 
 */
public abstract class Inspector extends JWindow {
	private static final Icon closed;
	private static final Image minimize;
	private static final Icon opened;
	private static final Image options;

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	static {
		Image i = new BufferedImage(9, 9, BufferedImage.TYPE_INT_ARGB);
		Graphics g = i.getGraphics();
		g.setColor(Color.RED);
		g.fillPolygon(new int[] { 0, 8, 0 }, new int[] { 0, 4, 8 }, 3);
		closed = new ImageIcon(i);

		i = new BufferedImage(9, 9, BufferedImage.TYPE_INT_ARGB);
		g = i.getGraphics();
		g.setColor(Color.LIGHT_GRAY);
		g.fillPolygon(new int[] { 0, 4, 8 }, new int[] { 0, 8, 0 }, 3);
		opened = new ImageIcon(i);

		minimize = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
		g = Inspector.minimize.getGraphics();
		Graphics2D g2d = (Graphics2D) g.create();
		g2d.setColor(WidgetColors.HEADER_COLOR);
		g2d.setStroke(new BasicStroke(3));
		g2d.drawArc(0, 0, 15, 15, 90, 270);
		g2d.drawLine(7, 8, 12, 3);
		g2d.setStroke(new BasicStroke(2));
		g2d.drawLine(5, 10, 5, 5);
		g2d.drawLine(5, 10, 10, 10);

		options = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
		g = Inspector.options.getGraphics();
		g2d = (Graphics2D) g.create();
		g2d.setColor(WidgetColors.HEADER_COLOR);
		g2d.setStroke(new BasicStroke(3));
		g2d.drawArc(0, 0, 15, 15, 110, 220);
		g2d.drawArc(8, 1, 7, 7, 90, 270);
		g2d.setStroke(new BasicStroke(4, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
		g2d.drawLine(5, 10, 8, 7);

		//g2d.setColor(Color.LIGHT_GRAY);
		//g2d.drawLine(15, 0, 11, 4);
	}
	private final JPanel buttons;
	private final JPanel main;
	private final JPanel settings;
	private final SlickerTabbedPane tabbedPane;

	/**
	 * @deprecated, use Inspector(Frame owner) instead.
	 */
	@Deprecated
	public Inspector() {
		this(null);
	}

	public Inspector(Frame owner) {
		super(owner);
		final MouseAdapter listener = new MouseAdapter() {
			private int x, y;

			@Override
			public void mouseDragged(final MouseEvent e) {
				setLocation(getLocation().x + e.getX() - x, getLocation().y + e.getY() - y);
			}

			@Override
			public void mousePressed(final MouseEvent e) {
				x = e.getX();
				y = e.getY();
			}
		};
		addMouseListener(listener);
		addMouseMotionListener(listener);
		setBackground(null);
		setFocusable(false);
		setMinimumSize(new Dimension(200, 50));
		setMaximumSize(new Dimension(200, 2000));
		setSize(200, 600);
		setAlwaysOnTop(true);
		//Toolkit.getDefaultToolkit().addAWTEventListener(new Fader(), AWTEvent.MOUSE_EVENT_MASK);
		settings = new BorderPanel(3, 3);
		settings.add(SlickerFactory.instance().createCheckBox(""Only one open group"", false));
		final JPanel padding = new JPanel(new BorderLayout());
		padding.setBorder(BorderFactory.createEmptyBorder(3, 3, 0, 3));
		padding.add(settings);
		padding.setOpaque(false);
		main = new JPanel(new BorderLayout());
		padding.setVisible(false);
		main.add(padding, BorderLayout.NORTH);
		main.setOpaque(false);
		tabbedPane = SlickerFactory.instance().createTabbedPane("""", Color.BLACK, Color.WHITE, Color.BLACK);
		final BorderPanel border = new BorderPanel(5, 5);
		border.setOpaque(true);
		border.setBackground(Color.LIGHT_GRAY);
		border.setLayout(new BorderLayout());
		main.add(tabbedPane);
		border.add(main);
		final JPanel header = new JPanel();
		header.setLayout(new BorderLayout());
		header.setOpaque(false);
		final LeftAlignedHeader headerText = new LeftAlignedHeader(""Inspector"");
		headerText.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));
		header.add(headerText);
		buttons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 2, 0));
		buttons.setOpaque(false);
		buttons.setBorder(BorderFactory.createEmptyBorder(2, 2, 0, 2));
		final ImageButton minimizeButton = new ImageButton(Inspector.minimize, Color.LIGHT_GRAY, Color.GRAY, 0);
		minimizeButton.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(final ActionEvent e) {
				setVisible(false);
				main.remove(tabbedPane);
				minimized(tabbedPane);
			}

		});
		buttons.add(minimizeButton);
		final ImageButton optionsButton = new ImageButton(Inspector.options, Color.LIGHT_GRAY, Color.GRAY, 0);
		optionsButton.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(final ActionEvent e) {
				padding.setVisible(!padding.isVisible());
				invalidate();
				repaint();
				pack();
			}
		});
		buttons.add(optionsButton);
		header.add(buttons, BorderLayout.EAST);
		border.add(header, BorderLayout.NORTH);
		border.setForeground(Color.BLACK);
		add(border);

		tabbedPane.setBackground(null);

		// EWEWEW! SlickerBox insists on setting a preferred size instead of minimum and maximum sizes, so for pack to work, we need to reset this
		tabbedPane.getComponent(0).setPreferredSize(null);
		// Another EW! SlickerBox provides a veryrudimentary event-system when tabs are switched (events are only passed before); this allows us to receive an event when a tab has been switched
		((Container) tabbedPane.getComponent(1)).addContainerListener(new ContainerListener() {

			@Override
			public void componentAdded(final ContainerEvent arg0) {
				pack();

			}

			@Override
			public void componentRemoved(final ContainerEvent arg0) {
			}
		});

		pack();
		//FM, Updated to Java 7 commands as explained here: https://docs.oracle.com/javase/tutorial/uiswing/misc/trans_shaped_windows.html
		if (getGraphicsConfiguration().getDevice().isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
			this.setBackground(new Color(0, 0, 0,1.0f));
			this.setOpacity(0.85f);
		}
	}

	/**
	 * @param tab
	 * @param header
	 * @param component
	 */
	public void addGroup(final JPanel tab, final String header, final JComponent component) {
		addGroup(tab, header, component, false);
	}

	/**
	 * @param tab
	 * @param header
	 * @param component
	 * @param open
	 */
	public void addGroup(final JPanel tab, final String header, final JComponent component, final boolean open) {
		final JPanel group = new JPanel();
		group.setBackground(Color.BLACK);
		group.setLayout(new BorderLayout());
		final JLabel headerComponent = new JLabel() {
			private static final long serialVersionUID = 1L;
			private Color c;

			@Override
			public void paintComponent(final Graphics g) {
				final Graphics2D g2d = (Graphics2D) g;
				g2d.setPaint(new GradientPaint(new Point(getWidth() / 2, getHeight()), c, new Point(getWidth(),
						getHeight()), Color.LIGHT_GRAY));
				g2d.fillRect(0, 0, getWidth(), getHeight());
				super.paintComponent(g);
			}

			@Override
			public void setBackground(final Color c) {
				this.c = c;
				super.setOpaque(false);
				super.setBackground(null);
			}
		};
		headerComponent.setBackground(Color.BLACK);
		headerComponent.setText(header);
		if (open) {
			headerComponent.setIcon(Inspector.opened);
		} else {
			headerComponent.setIcon(Inspector.closed);
		}
		headerComponent.setFont(headerComponent.getFont().deriveFont(Font.BOLD + Font.ITALIC));
		headerComponent.setForeground(Color.LIGHT_GRAY);
		group.add(headerComponent, BorderLayout.NORTH);

		final JPanel main = SlickerFactory.instance().createRoundedPanel(10, Color.LIGHT_GRAY);
		main.setLayout(new BorderLayout());
		main.add(component);
		if (open) {
			group.add(main);
		}
		headerComponent.addMouseListener(new MouseAdapter() {
			private boolean opened = open;

			@Override
			public void mouseClicked(final MouseEvent e) {
				if (opened) {
					headerComponent.setIcon(Inspector.closed);
					group.remove(main);
					opened = false;
				} else {
					headerComponent.setIcon(Inspector.opened);
					group.add(main);
					opened = true;
				}
				group.invalidate();
				group.validate();
				group.repaint();
				pack();
			}

			@Override
			public void mousePressed(final MouseEvent e) {
				headerComponent.setBackground(Color.GRAY);
				headerComponent.setForeground(Color.WHITE);
			}

			@Override
			public void mouseReleased(final MouseEvent e) {
				headerComponent.setBackground(Color.BLACK);
				headerComponent.setForeground(Color.LIGHT_GRAY);
			}
		});
		tab.add(group);
		invalidate();
		repaint();
		pack();
	}

	/**
	 * @param name
	 * @return
	 */
	public JPanel addTab(final String name) {
		final JPanel tab = new JPanel();
		tab.setLayout(new BoxLayout(tab, BoxLayout.Y_AXIS));
		tabbedPane.addTab(name, tab);
		return tab;
	}

	/**
	 * 
	 */
	public void restore() {
		if (tabbedPane.getParent() != null) {
			tabbedPane.getParent().remove(tabbedPane);
		}
		main.add(tabbedPane);
		setVisible(true);
		invalidate();
		repaint();
		pack();
	}

	abstract void minimized(SlickerTabbedPane tabbedPane);

}
"
InspectorPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Frame;
import java.awt.LayoutManager;
import java.awt.Point;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;

import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.JSplitPane;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.plugin.PluginContext;

import com.fluxicon.slickerbox.components.SlickerTabbedPane;

/**
 * Panel with an Inspector
 * 
 * @author mwesterg
 * 
 */
public class InspectorPanel extends ProMSplitPane {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private final JPanel info;
	private final Inspector inspector;
	private final JPanel main;
	private boolean moved;
	private final JPanel tabs;
	boolean minimized = false;

	/**
	 * @deprecated, use InspectorPanel(Frame owner) or InspectorPanel(PluginContext context) instead.
	 */
	@Deprecated
	public InspectorPanel() {
		this((Frame) null);
	}

	public InspectorPanel(PluginContext context) {
		this(context instanceof UIPluginContext ? ((UIPluginContext) context).getGlobalContext().getUI() : (Frame) null);
	}

	public InspectorPanel(Frame owner) {
		super(JSplitPane.VERTICAL_SPLIT);
		final JPanel tmp = new JPanel();
		tmp.setOpaque(false);
		tabs = new JPanel(new BorderLayout());
		tabs.setOpaque(false);
		setTopComponent(tmp);
		setBottomComponent(tabs);
		main = tmp;
		setOneTouchExpandable(true);
		setDividerSize(0);
		setResizeWeight(1.0);
		inspector = new Inspector(owner) {
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;

			@Override
			void minimized(final SlickerTabbedPane tabbedPane) {
				minimized = true;
				tabs.add(tabbedPane);
				setDividerSize(5);
				setDividerLocation(getHeight() - 100);
				tabs.validate();
				validate();
				repaint();
			}
		};
		info = inspector.addTab(""Info"");

		addComponentListener(new ComponentAdapter() {
			@Override
			public void componentResized(final ComponentEvent e) {
				resize();
			}
		});

		addAncestorListener(new AncestorListener() {
			@Override
			public void ancestorAdded(final AncestorEvent arg0) {
				if (!minimized) {
					inspector.setLocationByPlatform(false);
					inspector.setVisible(true);
					validate();
					InspectorPanel.this.requestFocus();
				}
			}

			@Override
			public void ancestorMoved(final AncestorEvent arg0) {

			}

			@Override
			public void ancestorRemoved(final AncestorEvent arg0) {
				if (!minimized) {
					inspector.setVisible(false);
				}
			}
		});

	}

	/**
	 * @see java.awt.Container#add(java.awt.Component)
	 */
	@Override
	public Component add(final Component c) {
		if (main != null) {
			main.add(c);
		} else {
			super.add(c);
		}
		return c;
	}

	/**
	 * @param header
	 * @param component
	 */
	public void addInfo(final String header, final JComponent component) {
		inspector.addGroup(info, header, component);
	}

	/**
	 * @see java.awt.Container#remove(java.awt.Component)
	 */
	@Override
	public void remove(final Component c) {
		if (main != null) {
			main.remove(c);
		} else {
			super.remove(c);
		}
	}

	/**
	 * 
	 */
	public void resize() {
		if (!moved) {
			final Point point = getLocationOnScreen();
			inspector.setLocation((int) (point.getX() + getWidth() - inspector.getWidth() - 8),
					(int) (point.getY() + 8));
			moved = true;
		}
	}

	/**
	 * @see java.awt.Container#setLayout(java.awt.LayoutManager)
	 */
	@Override
	public void setLayout(final LayoutManager layout) {
		if (main != null) {
			main.setLayout(layout);
		} else {
			super.setLayout(layout);
		}
	}

	/**
	 * @see java.awt.Container#validate()
	 */
	@Override
	public void validate() {
		super.validate();
		if (!minimized) {
			setDividerLocation(5000);
		}
	}

	/**
	 * @return the inspector
	 */
	protected Inspector getInspector() {
		return inspector;
	}

	@Override
	protected void rightClicked() {
		minimized = false;
		inspector.restore();
		setDividerSize(0);
		setDividerLocation(getHeight());
		tabs.validate();
		validate();
		repaint();
	}
}
"
LeftAlignedHeader.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;

/**
 * Header aligned to the left
 * 
 * @author mwesterg
 * 
 */
public class LeftAlignedHeader extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * @param title
	 */
	public LeftAlignedHeader(final String title) {
		final JLabel hLabel = new JLabel(title);
		hLabel.setOpaque(false);
		hLabel.setForeground(WidgetColors.HEADER_COLOR);
		hLabel.setFont(hLabel.getFont().deriveFont(15f));
		setBorder(BorderFactory.createEmptyBorder());
		setOpaque(false);
		setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
		add(hLabel);
		add(Box.createHorizontalGlue());
	}

}
"
CreateLogPlugin.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.logging;

import java.util.logging.Logger;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.annotations.UITopiaVariant;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.ui.widgets.ProMPropertiesPanel;
import org.processmining.framework.util.ui.widgets.ProMTextField;

/**
 * @author michael
 * 
 */
@Plugin(name = ""Create Fresh Log"", parameterLabels = {}, returnLabels = { ""Log"" }, returnTypes = { Loggable.class })
public class CreateLogPlugin {
	/**
	 * @param context
	 * @return
	 */
	@UITopiaVariant(affiliation = UITopiaVariant.EHV, author = ""M. Westergaard"", email = ""m.westergaard@tue.nl"")
	@PluginVariant(requiredParameterLabels = {})
	public static Loggable createLog(final UIPluginContext context) {
		final ProMPropertiesPanel panel = new ProMPropertiesPanel(null);
		final ProMTextField name = panel.addTextField(""Log Name"");
		if (context.showConfiguration(""New Log"", panel) == InteractionResult.CONTINUE) {
			return new Loggable() {
				transient Logger log = Logger.getLogger(name.getText());

				@Override
				public Logger getLogger() {
					return log;
				}
			};
		}
		context.getFutureResult(0).cancel(true);
		return null;
	}
}
"
Loggable.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.logging;

import java.util.logging.Logger;

/**
 * @author michael
 * 
 */
public interface Loggable {
	/**
	 * @return
	 */
	Logger getLogger();
}
"
LogViewer.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.logging;

import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;

import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JPanel;
import javax.swing.filechooser.FileFilter;

import org.processmining.contexts.uitopia.annotations.Visualizer;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.plugin.annotations.Plugin;
import org.processmining.framework.plugin.annotations.PluginVariant;
import org.processmining.framework.util.ui.widgets.ProMPropertiesPanel;
import org.processmining.framework.util.ui.widgets.ProMTextArea;

import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * 
 * @author mwesterg
 * 
 */
@Plugin(name = ""Show Log"", returnLabels = { ""Log Viewer"" }, returnTypes = { JComponent.class }, parameterLabels = { ""Loggable Object"" }, userAccessible = false)
@Visualizer
public class LogViewer {
	private static class LogHandler extends Handler {
		private final transient LogView view;

		public LogHandler(final LogView view) {
			this.view = view;
		}

		@Override
		public void close() throws SecurityException {
		}

		@Override
		public void flush() {
		}

		@Override
		public void publish(final LogRecord record) {
			if (view != null) {
				view.add(record);
			}
		}
	}

	private static class LogView extends ProMPropertiesPanel {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private JCheckBox details;
		@SuppressWarnings(""rawtypes"")
		private final JComboBox/* <Level> */level;
		private final ProMTextArea log;

		public LogView(final Logger logger) {
			super(""Log ("" + logger.getName() + "")"");

			level = addComboBox(""Logging level"", new Level[] { Level.OFF, Level.SEVERE, Level.WARNING, Level.INFO,
					Level.CONFIG, Level.FINE, Level.FINER, Level.FINEST, Level.ALL });
			level.setSelectedItem(Level.ALL);
			level.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					logger.setLevel((Level) level.getSelectedItem());
				}
			});

			details = addCheckBox(""Show details"", true);

			final JPanel panel = new JPanel();
			panel.setLayout(new BorderLayout());
			panel.setOpaque(false);
			add(panel);

			log = new ProMTextArea();
			log.setEditable(false);
			log.setTabSize(4);
			panel.add(log);

			final JPanel buttons = new JPanel();
			buttons.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));
			buttons.setOpaque(false);
			panel.add(buttons, BorderLayout.SOUTH);

			final JButton clearButton = SlickerFactory.instance().createButton(""Clear"");
			buttons.add(clearButton);

			clearButton.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					log.setText("""");
				}
			});

			final JButton saveButton = SlickerFactory.instance().createButton(""Save"");
			buttons.add(saveButton);

			saveButton.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					final String txt = log.getText();
					final JFileChooser chooser = new JFileChooser();
					chooser.setFileFilter(new FileFilter() {
						@Override
						public boolean accept(final File f) {
							return f.getName().toLowerCase().endsWith("".txt"");
						}

						@Override
						public String getDescription() {
							return ""Text files"";
						}
					});
					chooser.setSelectedFile(new File(""Log for "" + logger.getName() + "".txt""));
					if (chooser.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {
						FileWriter fileWriter;
						try {
							fileWriter = new FileWriter(chooser.getSelectedFile());
							final BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
							bufferedWriter.append(txt);
							bufferedWriter.close();
						} catch (final IOException _) {
						}
					}
				}
			});

		}

		public void add(final LogRecord record) {
			if (((Level) level.getSelectedItem()).intValue() <= record.getLevel().intValue()) {
				final StringBuilder message = new StringBuilder();
				boolean indent = false;
				if (details.isSelected()) {
					indent = true;
					message.append(LogViewer.format.format(new Date(record.getMillis())));
					message.append('\t');
					message.append(record.getLevel());
					message.append('\t');
					boolean addedClass = false;
					if (record.getSourceClassName() != null && !"""".equals(record.getSourceClassName())) {
						message.append(record.getSourceClassName());
						addedClass = true;
					}
					if (record.getSourceMethodName() != null && !"""".equals(record.getSourceMethodName())) {
						if (addedClass) {
							message.append('.');
						}
						message.append(record.getSourceMethodName());
					}
					message.append(""\n\t"");
				}
				message.append(record.getMessage());
				Throwable t = record.getThrown();
				while (t != null) {
					message.append(' ');
					message.append(t.getClass());
					message.append("": "");
					message.append(t.getMessage());
					for (final StackTraceElement ste : record.getThrown().getStackTrace()) {
						message.append('\n');
						if (indent) {
							message.append('\t');
						}
						message.append('\t');
						message.append(ste);
					}
					if (t.getCause() != t && t.getCause() != null) {
						t = t.getCause();
						message.append('\n');
						if (indent) {
							message.append('\t');
						}
						message.append(""Caused by"");
					} else {
						t = null;
					}
				}
				message.append('\n');
				log.append(message.toString());
				log.scrollToEnd();
			}
		}
	};

	private static final DateFormat format = new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss"");

	/**
	 * @param context
	 * @param service
	 * @return
	 */
	@PluginVariant(requiredParameterLabels = { 0 })
	public static JComponent visualize(final PluginContext context, final Loggable service) {
		final Logger logger = service.getLogger();
		logger.setLevel(Level.ALL);
		final LogView view = new LogView(logger);
		logger.addHandler(new LogHandler(view));
		return view;
	}

}
"
ProMLoggable.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.logging;

import java.util.logging.Logger;

/**
 * @author michael
 * 
 */
public final class ProMLoggable implements Loggable {
	private transient final Logger l;

	/**
	 * @param l
	 */
	public ProMLoggable(final Logger l) {
		this.l = l;
	}

	/**
	 * @see org.processmining.framework.util.ui.widgets.logging.Loggable#getLogger()
	 */
	@Override
	public Logger getLogger() {
		return l;
	}
}"
ProMAutoCompletingTextField.java,widgets-6.9.234,"/*
 * Adopted from Java Tutorials Code Examples
 * 
 * Copyright (c) 1995, 2008, Oracle and/or its affiliates. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * - Neither the name of Oracle or the names of its contributors may be used to
 * endorse or promote products derived from this software without specific prior
 * written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
package org.processmining.framework.util.ui.widgets;

import java.awt.event.ActionEvent;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.BadLocationException;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Ordering;

public class ProMAutoCompletingTextField extends ProMTextField {

	private static final long serialVersionUID = 3530217391302932937L;

	private final class DocumentListenerImpl implements DocumentListener {
		public void removeUpdate(DocumentEvent e) {
		}

		public void insertUpdate(DocumentEvent e) {
			if (e.getLength() != 1) {
				return;
			}

			try {
				int pos = e.getOffset();
				String content = e.getDocument().getText(0, pos + 1);

				int startIndex;
				for (startIndex = pos; startIndex >= 0; startIndex--) {
					if (isStopCharacter(content.charAt(startIndex))) {
						break;
					}
				}
				int charactersInWord = pos - startIndex;
				if (charactersInWord < 2) {
					// Too few chars
					return;
				}

				String prefix = e.getDocument().getText(startIndex + 1, e.getDocument().getLength());
				int wordIndex = Collections.binarySearch(getDictionary(), prefix);
				if (wordIndex < 0 && -wordIndex <= getDictionary().size()) {
					String match = getDictionary().get(-wordIndex - 1);
					if (match.startsWith(prefix)) {
						// A completion is found
						String completion = match.substring(pos - startIndex);
						// We cannot modify Document from within notification,
						// so we submit a task that does the change later
						SwingUtilities.invokeLater(new CompletionTask(completion, pos + 1));
					}
				} else {
					// Nothing found
					mode = Mode.INSERT;
				}
			} catch (BadLocationException e1) {
			}
		}

		public void changedUpdate(DocumentEvent e) {
		}
	}

	private static enum Mode {
		INSERT, COMPLETION
	};

	private class CompletionTask implements Runnable {

		String completion;
		int position;

		CompletionTask(String completion, int position) {
			this.completion = completion;
			this.position = position;
		}

		public void run() {
			try {
				getTextField().getDocument().insertString(position, completion, null);
				getTextField().setCaretPosition(position + completion.length());
				getTextField().moveCaretPosition(position);
				mode = Mode.COMPLETION;
			} catch (BadLocationException e) {
			}
		}
	}

	private class CommitAction extends AbstractAction {

		private static final long serialVersionUID = 98076970931098392L;

		public void actionPerformed(ActionEvent ev) {
			try {
				if (mode == Mode.COMPLETION) {
					int pos = getTextField().getSelectionEnd();
					getTextField().getDocument().insertString(pos, "" "", null);
					getTextField().setCaretPosition(pos + 1);
					mode = Mode.INSERT;
				} else {
					getTextField().replaceSelection("""");
					getTextField().postActionEvent();
				}
			} catch (BadLocationException e) {
			}
		}
	}

	private Mode mode = Mode.INSERT;

	private ImmutableList<String> dictionary = ImmutableList.of();
	private ImmutableSet<Character> stopCharacter = ImmutableSet.of('.', '\""', '=', '>', '<', '(', ')');

	public ProMAutoCompletingTextField() {
		super();
		init();
	}

	public ProMAutoCompletingTextField(String initial, String hint) {
		super(initial, hint);
		init();
	}

	public ProMAutoCompletingTextField(String initial) {
		super(initial);
		init();
	}

	private void init() {
		getTextField().getDocument().addDocumentListener(new DocumentListenerImpl());
		InputMap im = getTextField().getInputMap();
		ActionMap am = getTextField().getActionMap();
		im.put(KeyStroke.getKeyStroke(""ENTER""), ""commit"");
		am.put(""commit"", new CommitAction());
	}

	public ImmutableList<String> getDictionary() {
		return dictionary;
	}

	public void setDictionary(List<String> dictionary) {
		this.dictionary = Ordering.natural().immutableSortedCopy(dictionary);
	}

	public ImmutableSet<Character> getStopCharacter() {
		return stopCharacter;
	}

	protected boolean isStopCharacter(char c) {
		return stopCharacter.contains(c);
	}

	public void setStopCharacter(Set<Character> stopCharacter) {
		this.stopCharacter = ImmutableSet.copyOf(stopCharacter);
	}

}"
ProMCheckBoxWithComboBox.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;

/**
 * @author michael
 * @param <T>
 * 
 */
public class ProMCheckBoxWithComboBox<T> extends ProMCheckBoxWithPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 5157157777410895997L;

	private ProMComboBox<T> comboBox;

	/**
	 * @param checked
	 * @param hideIfNotChecked
	 * @param items
	 */
	public ProMCheckBoxWithComboBox(final boolean checked, final boolean hideIfNotChecked, final Iterable<T> items) {
		this(checked, hideIfNotChecked, ProMComboBox.toArray(items));
	}

	/**
	 * @param checked
	 * @param hideIfNotChecked
	 * @param items
	 */
	public ProMCheckBoxWithComboBox(final boolean checked, final boolean hideIfNotChecked, final Object[]... items) {
		super(checked, hideIfNotChecked);

		comboBox = new ProMComboBox<T>(items);
		getPanel().setLayout(new BorderLayout());
		getPanel().add(comboBox, BorderLayout.CENTER);

	}

	/**
	 * @param checked
	 * @param items
	 */
	public ProMCheckBoxWithComboBox(final boolean checked, final Iterable<T> items) {
		this(checked, true, items);
	}

	/**
	 * @param checked
	 * @param items
	 */
	public ProMCheckBoxWithComboBox(final boolean checked, final T[]... items) {
		this(checked, true, items);
	}

	/**
	 * @param items
	 */
	public ProMCheckBoxWithComboBox(final Iterable<T> items) {
		this(true, true, items);
	}

	/**
	 * @param items
	 */
	public ProMCheckBoxWithComboBox(final T[]... items) {
		this(true, true, items);
	}

	/**
	 * @return
	 */
	public ProMComboBox<T> getComboBox() {
		return comboBox;
	}

	/**
	 * @return
	 */
	public int getSelectedIndex() {
		return comboBox.getSelectedIndex();
	}

	/**
	 * @return
	 */
	public Object getSelectedItem() {
		return comboBox.getSelectedItem();
	}

	/**
	 * @param index
	 */
	public void setSelectedIndex(final int index) {
		comboBox.setSelectedIndex(index);
	}

	/**
	 * @param item
	 */
	public void setSelectedItem(final Object item) {
		comboBox.setSelectedItem(item);
	}
}
"
ProMCheckBoxWithPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JCheckBox;
import javax.swing.JPanel;

import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * @author michael
 * 
 */
public class ProMCheckBoxWithPanel extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1605514658715195558L;
	private final JCheckBox checkBox;
	private final JPanel panel;

	/**
	 * 
	 */
	public ProMCheckBoxWithPanel() {
		this(true, true);
	}

	/**
	 * @param checked
	 */
	public ProMCheckBoxWithPanel(final boolean checked) {
		this(checked, true);
	}

	/**
	 * @param checked
	 * @param hideIfNotChecked
	 */
	public ProMCheckBoxWithPanel(final boolean checked, final boolean hideIfNotChecked) {

		panel = new JPanel();
		checkBox = SlickerFactory.instance().createCheckBox("""", checked);

		if (hideIfNotChecked) {
			checkBox.addActionListener(new ActionListener() {

				@Override
				public void actionPerformed(final ActionEvent e) {
					toggleVisibility();
				}
			});
		}

		setLayout(new BorderLayout());
		setOpaque(false);

		checkBox.setPreferredSize(new Dimension(30, 30));
		checkBox.setMinimumSize(checkBox.getPreferredSize());
		checkBox.setMaximumSize(checkBox.getPreferredSize());

		//panel.setMinimumSize(new Dimension(600,30));
		panel.setPreferredSize(new Dimension(530, 30));

		this.add(checkBox, BorderLayout.WEST);
		this.add(panel, BorderLayout.EAST);
	}

	/**
	 * @return
	 */
	public JCheckBox getCheckBox() {
		return checkBox;
	}

	/**
	 * @return
	 */
	public boolean isSelected() {
		return checkBox.isSelected();
	}

	/**
	 * @param checked
	 */
	public void setSelected(final boolean checked) {
		checkBox.setSelected(checked);
	}

	private void toggleVisibility() {
		panel.setVisible(!panel.isVisible());
	}

	protected JPanel getPanel() {
		return panel;
	}
}
"
ProMCheckBoxWithTextField.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;

/**
 * @author michael
 * 
 */
public class ProMCheckBoxWithTextField extends ProMCheckBoxWithPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -3331182375174654223L;
	private final ProMTextField textField;

	/**
	 * 
	 */
	public ProMCheckBoxWithTextField() {
		this(true, true, """");
	}

	/**
	 * @param checked
	 * @param hideIfNotSelected
	 * @param text
	 */
	public ProMCheckBoxWithTextField(final boolean checked, final boolean hideIfNotSelected, final String text) {
		super(checked, hideIfNotSelected);

		textField = new ProMTextField(text);
		getPanel().setLayout(new BorderLayout());
		getPanel().add(textField, BorderLayout.CENTER);

	}

	/**
	 * @param checked
	 * @param text
	 */
	public ProMCheckBoxWithTextField(final boolean checked, final String text) {
		this(checked, true, text);
	}

	/**
	 * @param text
	 */
	public ProMCheckBoxWithTextField(final String text) {
		this(true, true, text);
	}

	/**
	 * @return
	 */
	public String getText() {
		return textField.getText();
	}

	/**
	 * @param text
	 */
	public void setText(final String text) {
		textField.setText(text);
	}

}
"
ProMCheckComboBox.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.util.ArrayList;

import csplugins.id.mapping.ui.CheckComboBox;

/**
 * @author michael
 * 
 */
public class ProMCheckComboBox extends CheckComboBox {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * @param <T>
	 * @param values
	 * @return
	 */
	public static <T> Object[] toArray(final Iterable<T> values) {
		final ArrayList<T> valueList = new ArrayList<T>();
		for (final T value : values) {
			valueList.add(value);
		}
		return valueList.toArray();
	}

	private final BorderPanel borderPanel;
	private final BorderPanel buttonPanel;

	/**
	 * @param <T>
	 * @param values
	 */
	public <T> ProMCheckComboBox(final Iterable<T> values) {
		this(ProMCheckComboBox.toArray(values));
	}

	/**
	 * @param values
	 */
	public ProMCheckComboBox(final Object[] values) {
		super(values);

		borderPanel = new BorderPanel(15, 3);
		borderPanel.setOpaque(true);
		borderPanel.setBackground(WidgetColors.COLOR_LIST_BG);
		borderPanel.setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		buttonPanel = new BorderPanel(15, 3);
		buttonPanel.setOpaque(true);
		buttonPanel.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		buttonPanel.setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		setOpaque(false);
		setBackground(WidgetColors.COLOR_LIST_BG);
		setForeground(WidgetColors.COLOR_LIST_FG);
		setMinimumSize(new Dimension(200, 30));
		setMaximumSize(new Dimension(1000, 30));
		setPreferredSize(new Dimension(1000, 30));

		//setUI(new ProMComboBoxUI(this));
	}

	/**
	 * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
	 */
	@Override
	public void paintComponent(final Graphics g) {
		final Rectangle bounds = getBounds();
		buttonPanel.setBounds(bounds);
		buttonPanel.paintComponent(g);
		final Dimension d = new Dimension();
		d.setSize(bounds.getWidth() - bounds.getHeight(), bounds.getHeight());
		bounds.setSize(d);
		borderPanel.setBounds(bounds);
		borderPanel.paintComponent(g);
		super.paintComponent(g);
	}
}
"
ProMComboBox.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.util.ArrayList;

import javax.swing.ComboBoxModel;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;

/**
 * @author michael
 * @param <E>
 * 
 */
@SuppressWarnings(""rawtypes"")
public class ProMComboBox<E> extends JComboBox/* <E> */{

	private static final long serialVersionUID = 1L;

	/**
	 * @param values
	 * @return
	 */
	public static <T> Object[] toArray(final Iterable<T> values) {
		final ArrayList<T> valueList = new ArrayList<T>();
		for (final T value : values) {
			valueList.add(value);
		}
		return valueList.toArray();
	}

	private final BorderPanel borderPanel;
	private final BorderPanel buttonPanel;
	
	@SuppressWarnings(""unchecked"")
	public ProMComboBox(final ComboBoxModel<E> model) {
		super(model);
		borderPanel = new BorderPanel(15, 3);
		borderPanel.setOpaque(true);
		borderPanel.setBackground(WidgetColors.COLOR_LIST_BG);
		borderPanel.setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		buttonPanel = new BorderPanel(15, 3);
		buttonPanel.setOpaque(true);
		buttonPanel.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		buttonPanel.setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		setOpaque(false);
		setBackground(WidgetColors.COLOR_LIST_BG);
		setForeground(WidgetColors.COLOR_LIST_FG);
		setMinimumSize(new Dimension(200, 30));
		setMaximumSize(new Dimension(1000, 30));
		setPreferredSize(new Dimension(1000, 30));

		setUI(new ProMComboBoxUI(this));
	}
	
	
	public ProMComboBox(final ComboBoxModel<E> model, boolean noSize) {
		this(model);
		resetSizes();
	}

	public ProMComboBox<E> resetSizes() {
		setPreferredSize(null);
		setMaximumSize(null);
		setMinimumSize(null);
		return this;
	}

	/**
	 * @param values
	 */
	public ProMComboBox(final Iterable<E> values) {
		this(ProMComboBox.toArray(values));
	}

	/**
	 * @param values
	 */
	@SuppressWarnings({ ""unchecked"" })
	public ProMComboBox(final Object[] values) {
		this(new DefaultComboBoxModel<E>((E[]) values));
	}

	/**
	 * @param values
	 */
	@SuppressWarnings(""unchecked"")
	public void addAllItems(final Iterable<E> values) {
		for (final E value : values) {
			addItem(value);
		}
	}

	/**
	 * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
	 */
	@Override
	public void paintComponent(final Graphics g) {
		if (!Boolean.TRUE.equals(getClientProperty(""JComboBox.isTableCellEditor""))) {
			final Rectangle bounds = getBounds();
			buttonPanel.setBounds(bounds);
			buttonPanel.paintComponent(g);
			final Dimension d = new Dimension();
			d.setSize(bounds.getWidth() - bounds.getHeight(), bounds.getHeight());
			bounds.setSize(d);
			borderPanel.setBounds(bounds);
			borderPanel.paintComponent(g);
		}
		super.paintComponent(g);
	}
}
"
ProMComboBoxPopup.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;
import java.awt.Graphics;

import javax.swing.BorderFactory;
import javax.swing.JComboBox;
import javax.swing.JScrollBar;
import javax.swing.ScrollPaneConstants;
import javax.swing.plaf.basic.BasicComboPopup;

import com.fluxicon.slickerbox.ui.SlickerScrollBarUI;

/**
 * @author michael
 * 
 */
public class ProMComboBoxPopup extends BasicComboPopup {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * @param combo
	 */
	public <E> ProMComboBoxPopup(@SuppressWarnings(""rawtypes"") final JComboBox/*
																			 * <E
																			 * >
																			 */combo) {
		super(combo);
		setBorder(BorderFactory.createLineBorder(WidgetColors.COLOR_ENCLOSURE_BG, 3));
		setOpaque(true);
		setBackground(WidgetColors.COLOR_LIST_BG);
	}

	/**
	 * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
	 */
	@Override
	public void paintComponent(final Graphics g) {
		super.paintComponent(g);
	}

	@Override
	protected void configureList() {
		super.configureList();
		list.setBackground(WidgetColors.COLOR_LIST_BG);
		list.setForeground(WidgetColors.COLOR_LIST_FG);
		list.setSelectionBackground(WidgetColors.COLOR_LIST_SELECTION_BG);
		list.setSelectionForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
	}

	@Override
	protected void configureScroller() {
		super.configureScroller();
		scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		final JScrollBar vBar = scroller.getVerticalScrollBar();
		vBar.setUI(new SlickerScrollBarUI(vBar, new Color(0, 0, 0, 0), new Color(160, 160, 160),
				WidgetColors.COLOR_NON_FOCUS, 4, 12));
		vBar.setOpaque(true);
		vBar.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
	}

}
"
ProMComboBoxTableCellEditor.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Arrays;
import java.util.Collection;

import javax.swing.AbstractCellEditor;
import javax.swing.JTable;
import javax.swing.table.TableCellEditor;

/**
 * @author michael
 * 
 * @param <T>
 */
public class ProMComboBoxTableCellEditor<T> extends AbstractCellEditor implements TableCellEditor {
	/**
		 * 
		 */
	private static final long serialVersionUID = 0;
	private T configured;
	protected ProMComboBox<T> comboBox;

	/**
	 * @param values
	 */
	public ProMComboBoxTableCellEditor(final Collection<T> values) {
		comboBox = new ProMComboBox<T>(values);
		comboBox.addActionListener(new ActionListener() {
			@Override
			@SuppressWarnings(""unchecked"")
			public void actionPerformed(final ActionEvent e) {
				setValue((T) comboBox.getSelectedItem());
			}
		});
	}

	/**
	 * @param values
	 */
	public ProMComboBoxTableCellEditor(final T... values) {
		this(Arrays.asList(values));
	}

	/**
	 * @see javax.swing.CellEditor#getCellEditorValue()
	 */
	@Override
	public Object getCellEditorValue() {
		return configured;
	}

	/**
	 * @see javax.swing.table.TableCellEditor#getTableCellEditorComponent(javax.swing.JTable,
	 *      java.lang.Object, boolean, int, int)
	 */
	@Override
	public ProMComboBox<T> getTableCellEditorComponent(final JTable table, final Object value,
			final boolean isSelected, final int row, final int column) {
		comboBox.setSelectedItem(value);
		return comboBox;
	}

	protected void setValue(final T value) {
		configured = value;
	}
}
"
ProMComboBoxUI.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Rectangle;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.SwingConstants;
import javax.swing.plaf.ComponentUI;
import javax.swing.plaf.basic.BasicArrowButton;
import javax.swing.plaf.basic.BasicComboBoxUI;
import javax.swing.plaf.basic.BasicComboPopup;
import javax.swing.plaf.basic.ComboPopup;

/**
 * @author michael
 * 
 */
public class ProMComboBoxUI extends BasicComboBoxUI {
	/**
	 * @param c
	 * @return
	 */
	@SuppressWarnings(""rawtypes"")
	public static ComponentUI createUI(final JComponent c) {
		return new ProMComboBoxUI((JComboBox/* <?> */) c);
	}

	@SuppressWarnings(""rawtypes"")
	private final JComboBox/* <?> */component;

	/**
	 * @param c
	 */
	@SuppressWarnings(""rawtypes"")
	public ProMComboBoxUI(final JComboBox/* <?> */c) {
		component = c;
	}

	/**
	 * @see javax.swing.plaf.basic.BasicComboBoxUI#configureArrowButton()
	 */
	@Override
	public void configureArrowButton() {
		super.configureArrowButton();
		arrowButton.setBorder(BorderFactory.createEmptyBorder());
	}

	/**
	 * @see javax.swing.plaf.basic.BasicComboBoxUI#paintCurrentValueBackground(java.awt.Graphics,
	 *      java.awt.Rectangle, boolean)
	 */
	@Override
	public void paintCurrentValueBackground(final Graphics g, final Rectangle bounds, final boolean hasFocus) {
	}

	@Override
	protected void configureEditor() {
		super.configureEditor();
		if (editor instanceof JComponent) {
			((JComponent) editor).setBorder(BorderFactory.createEmptyBorder());
			((JComponent) editor).setBackground(WidgetColors.COLOR_LIST_BG);
			((JComponent) editor).setForeground(WidgetColors.COLOR_LIST_FG);
		}
	}

	@Override
	protected JButton createArrowButton() {
		final JButton button = new BasicArrowButton(SwingConstants.SOUTH, WidgetColors.COLOR_ENCLOSURE_BG,
				WidgetColors.COLOR_ENCLOSURE_BG, WidgetColors.COLOR_LIST_FG, WidgetColors.COLOR_ENCLOSURE_BG);
		button.setName(""ComboBox.arrowButton"");
		return button;
	}

	@Override
	protected ComboPopup createPopup() {
		final BasicComboPopup result = new ProMComboBoxPopup(component);
		return result;
	}

	@Override
	protected void installDefaults() {
		super.installDefaults();
		comboBox.setBorder(BorderFactory.createEmptyBorder(5, 8, 5, 8));
	}

	@Override
	protected Rectangle rectangleForCurrentValue() {
		final int width = comboBox.getWidth();
		final int height = comboBox.getHeight();
		final Insets insets = getInsets();
		int buttonSize = height - (insets.top + insets.bottom);
		if (arrowButton != null) {
			buttonSize = arrowButton.getWidth();
		}
		return new Rectangle(insets.left + 3, insets.top - 1, width
				- (insets.left + insets.right + buttonSize + 3 + 3 + 10), height - (insets.top + insets.bottom) + 1);
	}

}
"
ProMComboBoxWithTextField.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.util.Collection;

import javax.swing.JPanel;

/**
 * @author michael
 * 
 */
public class ProMComboBoxWithTextField extends JPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 3750834515241351840L;
	private final ProMComboBox<?> comboBox;
	private final ProMTextField textField;

	/**
	 * @param items
	 */
	public ProMComboBoxWithTextField(final Collection<Object> items) {
		this(items.toArray());
	}

	/**
	 * @param items
	 * @param text
	 */
	public ProMComboBoxWithTextField(final Collection<Object> items, final String text) {
		this(items.toArray(), text);
	}

	/**
	 * @param items
	 */
	public ProMComboBoxWithTextField(final Object[] items) {
		this(items, """");
	}

	/**
	 * @param items
	 * @param text
	 */
	public ProMComboBoxWithTextField(final Object[] items, final String text) {

		comboBox = new ProMComboBox<Object>(items);
		textField = new ProMTextField(text);

		comboBox.setMinimumSize(new Dimension(50, 30));
		comboBox.setPreferredSize(new Dimension(150, 30));

		textField.setMinimumSize(new Dimension(50, 30));
		textField.setPreferredSize(new Dimension(250, 30));

		setLayout(new BorderLayout());
		setOpaque(false);

		this.add(comboBox, BorderLayout.WEST);
		this.add(textField, BorderLayout.EAST);
	}

	/**
	 * @return
	 */
	public ProMComboBox<?> getComboBox() {
		return comboBox;
	}

	/**
	 * @return
	 */
	public int getSelectedIndex() {
		return comboBox.getSelectedIndex();
	}

	/**
	 * @return
	 */
	public Object getSelectedItem() {
		return comboBox.getSelectedItem();
	}

	/**
	 * @return
	 */
	public String getText() {
		return textField.getText();
	}

	/**
	 * @return
	 */
	public ProMTextField getTextField() {
		return textField;
	}

	/**
	 * @param index
	 */
	public void setSelectedIndex(final int index) {
		comboBox.setSelectedIndex(index);
	}

	/**
	 * @param item
	 */
	public void setSelectedItem(final Object item) {
		comboBox.setSelectedItem(item);
	}

	/**
	 * @param text
	 */
	public void setText(final String text) {
		textField.setText(text);
	}

}
"
ProMComboCheckBox.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.util.Collection;

import csplugins.id.mapping.ui.CheckComboBox;

/**
 * @author Massimiliano de Leoni
 * 
 */
public class ProMComboCheckBox extends CheckComboBox {

	private static final long serialVersionUID = 1L;

	private BorderPanel borderPanel;
	private BorderPanel buttonPanel;

	public ProMComboCheckBox(@SuppressWarnings(""rawtypes"") Collection objs) {
		super(objs);
	}

	public ProMComboCheckBox(Object[] attributes, boolean selected) {
		super(attributes, selected);
		init();
	}

	public ProMComboCheckBox(String[] attributes, boolean selected) {
		super(attributes, selected);
		init();
	}

	private final void init() {
		borderPanel = new BorderPanel(15, 3);
		borderPanel.setOpaque(true);
		borderPanel.setBackground(WidgetColors.COLOR_LIST_BG);
		borderPanel.setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		buttonPanel = new BorderPanel(15, 3);
		buttonPanel.setOpaque(true);
		buttonPanel.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		buttonPanel.setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		setOpaque(false);
		setBackgroundNotSelected(WidgetColors.COLOR_LIST_BG);
		setForegroundNotSelected(WidgetColors.COLOR_LIST_FG);
		setBackgroundSelected(WidgetColors.COLOR_LIST_SELECTION_BG);
		setForegroundSelected(WidgetColors.COLOR_LIST_SELECTION_FG);
		setMinimumSize(new Dimension(200, 30));
		setMaximumSize(new Dimension(1000, 30));
		setPreferredSize(new Dimension(1000, 30));

		setUI(new ProMComboBoxUI(this));
	}

	@Override
	public void paintComponent(final Graphics g) {
		if (!Boolean.TRUE.equals(getClientProperty(""JComboBox.isTableCellEditor""))) {
			final Rectangle bounds = getBounds();
			buttonPanel.setBounds(bounds);
			buttonPanel.paintComponent(g);
			final Dimension d = new Dimension();
			d.setSize(bounds.getWidth() - bounds.getHeight(), bounds.getHeight());
			bounds.setSize(d);
			borderPanel.setBounds(bounds);
			borderPanel.paintComponent(g);
		}
		super.paintComponent(g);
	}
}
"
ProMHeaderPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Dimension;

import javax.swing.Box;
import javax.swing.BoxLayout;

import com.fluxicon.slickerbox.components.RoundedPanel;

/**
 * Panel with a header
 * 
 * @author mwesterg
 * 
 */
public class ProMHeaderPanel extends RoundedPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * @param title
	 */
	public ProMHeaderPanel(final String title) {
		super(15, 0, 3);
		setMinimumSize(new Dimension(200, 20));
		setMaximumSize(new Dimension(1000, 1000));
		setPreferredSize(new Dimension(200, 300));
		setBackground(WidgetColors.PROPERTIES_BACKGROUND);
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		if (title != null) {
			add(new LeftAlignedHeader(title));
			add(Box.createVerticalStrut(15));
		}
	}

}
"
ProMList.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.MouseListener;
import java.util.Arrays;
import java.util.List;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.ListModel;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingConstants;
import javax.swing.event.ListSelectionListener;

import com.fluxicon.slickerbox.components.RoundedPanel;

/**
 * List (JList) with SlickerBox L&F
 * 
 * @author mwesterg
 * @param <E>
 * 
 */
public class ProMList<E> extends RoundedPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	@SuppressWarnings(""rawtypes"")
	private final JList/* <E> */jList;

	/**
	 * @param title
	 */
	@SuppressWarnings(""rawtypes"")
	public ProMList(final String title) {
		super(10, 5, 0);
		jList = new JList/* <E> */();
		setup(title);
	}

	/**
	 * @param title
	 * @param providers
	 */
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	public ProMList(final String title, final ListModel/* <E> */providers) {
		super(10, 5, 0);
		jList = new JList/* <E> */(providers);
		setup(title);
	}

	/**
	 * @param l
	 */
	public void addListSelectionListener(final ListSelectionListener l) {
		jList.addListSelectionListener(l);
	}

	/**
	 * @see java.awt.Component#addMouseListener(java.awt.event.MouseListener)
	 */
	@Override
	public void addMouseListener(final MouseListener l) {
		jList.addMouseListener(l);
	}

	/**
	 * @return
	 */
	@Deprecated
	public Object[] getSelectedValues() {
		return jList.getSelectedValues();
	}

	/**
	 * @return
	 */
	@SuppressWarnings({ ""unchecked"", ""deprecation"" })
	public List<E> getSelectedValuesList() {
		// Major fuck you to Hudson using an antiquated version of Java
		try {
			return (List<E>) JList.class.getMethod(""getSelectedValuesList"").invoke(this);
		} catch (final Exception e) {
			return (List<E>) Arrays.asList(jList.getSelectedValues());
		}
	}

	/**
	 * @param l
	 */
	public void removeListSelectionListener(final ListSelectionListener l) {
		jList.removeListSelectionListener(l);
	}

	/**
	 * @see java.awt.Component#removeMouseListener(java.awt.event.MouseListener)
	 */
	@Override
	public void removeMouseListener(final MouseListener l) {
		jList.removeMouseListener(l);
	}

	/**
	 * @param index
	 */
	public void setSelectedIndex(final int index) {
		jList.setSelectedIndex(index);
	}

	public void setSelectedIndices(final int[] index) {
		jList.setSelectedIndices(index);
	}

	/**
	 * @param selectedValues
	 */
	public void setSelection(final Iterable<Object> selectedValues) {
		jList.clearSelection();
		for (final Object value : selectedValues) {
			jList.setSelectedValue(value, true);
		}
	}

	/**
	 * @param selectedValues
	 */
	public void setSelection(final Object... selectedValues) {
		jList.clearSelection();
		for (final Object value : selectedValues) {
			jList.setSelectedValue(value, true);
		}
	}

	/**
	 * @param selectionMode
	 */
	public void setSelectionMode(final int selectionMode) {
		jList.setSelectionMode(selectionMode);
	}
	
	@SuppressWarnings(""rawtypes"") // this class is still java 6 :(
	public JList getList() {
		return jList;
	}

	private void setup(final String title) {
		jList.setBackground(WidgetColors.COLOR_LIST_BG);
		jList.setForeground(WidgetColors.COLOR_LIST_FG);
		jList.setSelectionBackground(WidgetColors.COLOR_LIST_SELECTION_BG);
		jList.setSelectionForeground(WidgetColors.COLOR_LIST_SELECTION_FG);

		final ProMScrollPane scroller = new ProMScrollPane(jList);
		scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
		scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

		final JLabel providersLabel = new JLabel(title);
		providersLabel.setOpaque(false);
		providersLabel.setForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		providersLabel.setFont(providersLabel.getFont().deriveFont(13f));
		providersLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		providersLabel.setHorizontalAlignment(SwingConstants.CENTER);
		providersLabel.setHorizontalTextPosition(SwingConstants.CENTER);

		setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		add(providersLabel);
		add(Box.createVerticalStrut(8));
		add(scroller);
		setMinimumSize(new Dimension(200, 100));
		setMaximumSize(new Dimension(1000, 1000));
		setPreferredSize(new Dimension(1000, 200));
	}
}
"
ProMListSortableWithComboBox.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;
import java.awt.BorderLayout;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DragGestureEvent;
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragSource;
import java.awt.dnd.DragSourceDragEvent;
import java.awt.dnd.DragSourceDropEvent;
import java.awt.dnd.DragSourceEvent;
import java.awt.dnd.DragSourceListener;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.List;

import javax.swing.BoxLayout;
import javax.swing.ComboBoxModel;
import javax.swing.DefaultListModel;
import javax.swing.DropMode;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.ListModel;
import javax.swing.ScrollPaneConstants;
import javax.swing.TransferHandler;

import com.fluxicon.slickerbox.components.SlickerButton;


/**
 * JList with ProM look & feel with a {@link ProMComboBox} on top of it that
 * allows to add elements to the list.
 */
public class ProMListSortableWithComboBox<T> extends JPanel {

	private static class DragListenerImpl<T> implements DragSourceListener, DragGestureListener {

		private final JList<T> list;
		private final DragSource ds = new DragSource();

		public DragListenerImpl(JList<T> list) {
			this.list = list;
			ds.createDefaultDragGestureRecognizer(list, DnDConstants.ACTION_MOVE, this);
		}

		public void dragGestureRecognized(DragGestureEvent dge) {
			StringSelection transferable = new StringSelection(Integer.toString(list.getSelectedIndex()));
			ds.startDrag(dge, DragSource.DefaultCopyDrop, transferable, this);
		}

		public void dragEnter(DragSourceDragEvent dsde) {
		}

		public void dragExit(DragSourceEvent dse) {
		}

		public void dragOver(DragSourceDragEvent dsde) {
		}

		public void dragDropEnd(DragSourceDropEvent dsde) {
		}

		public void dropActionChanged(DragSourceDragEvent dsde) {
		}
	}

	private static class DropHandlerImpl<T> extends TransferHandler {

		private static final long serialVersionUID = -3468373344687124791L;

		private final DefaultListModel<T> listModel;

		public DropHandlerImpl(DefaultListModel<T> listModel) {
			this.listModel = listModel;
		}

		public boolean canImport(TransferHandler.TransferSupport support) {
			if (!support.isDataFlavorSupported(DataFlavor.stringFlavor)) {
				return false;
			}
			JList.DropLocation dl = (JList.DropLocation) support.getDropLocation();
			if (dl.getIndex() == -1) {
				return false;
			} else {
				return true;
			}
		}

		public boolean importData(TransferHandler.TransferSupport support) {
			if (!canImport(support)) {
				return false;
			}

			Transferable transferable = support.getTransferable();
			String indexString;
			try {
				indexString = (String) transferable.getTransferData(DataFlavor.stringFlavor);
			} catch (Exception e) {
				return false;
			}

			int sourceIndex = Integer.parseInt(indexString);
			JList.DropLocation dl = (JList.DropLocation) support.getDropLocation();
			int dropTargetIndex = dl.getIndex();
			T element = listModel.remove(sourceIndex);
			if (sourceIndex < dropTargetIndex) {
				listModel.insertElementAt(element, dropTargetIndex - 1);
			} else {
				listModel.insertElementAt(element, dropTargetIndex);
			}
			return true;
		}
	}

	private static final long serialVersionUID = -3989998064589278170L;

	private final JLabel selectedItemsText;
	private final JList<T> list;
	private final ProMComboBox<T> comboBox;
	private final DefaultListModel<T> listModel;
	private boolean isMultiSelection = false;
	
	public ProMListSortableWithComboBox(ComboBoxModel<T> comboBoxModel) {
		super();
		setOpaque(false);
		JPanel controlPanel = new JPanel();
		controlPanel.setOpaque(false);
		controlPanel.setLayout(new BorderLayout());
		comboBox = new ProMComboBox<>(comboBoxModel, true);
		comboBox.addActionListener(new ActionListener() {
			
			@SuppressWarnings(""unchecked"")
			public void actionPerformed(ActionEvent e) {
				if (!isMultiSelection) {
					listModel.clear();
					listModel.addElement((T) comboBox.getSelectedItem());
				}
			}
		});
		controlPanel.add(comboBox, BorderLayout.CENTER);
		
		JPanel buttonPanel = new JPanel();
		buttonPanel.setOpaque(false);
		buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));
		
		JButton addButton = new SlickerButton(""+"");
		addButton.setAlignmentY(CENTER_ALIGNMENT);
		addButton.addActionListener(new ActionListener() {
			
			@SuppressWarnings(""unchecked"")
			public void actionPerformed(ActionEvent e) {
				isMultiSelection = true;
				listModel.addElement((T) comboBox.getSelectedItem());
			}
		});
		buttonPanel.add(addButton);
		JButton removeButton = new SlickerButton(""-"");
		removeButton.setAlignmentY(CENTER_ALIGNMENT);
		removeButton.addActionListener(new ActionListener() {
			
			public void actionPerformed(ActionEvent e) {
				isMultiSelection = true;
				if (list.getSelectedIndex() == -1) {
					// Just remove the last one
					if (list.getModel().getSize() >= 1) {
						listModel.remove(list.getModel().getSize()-1);
					}
				} else {
					listModel.removeElement(list.getSelectedValue());	
				}				
			}
		});
		buttonPanel.add(removeButton);
		controlPanel.add(buttonPanel, BorderLayout.EAST);

		listModel = new DefaultListModel<>();
		list = new JList<>(listModel);
		list.addKeyListener(new KeyListener() {

			public void keyTyped(KeyEvent e) {
			}

			public void keyReleased(KeyEvent e) {
				if (e.getKeyCode() == KeyEvent.VK_DELETE || e.getKeyCode() == KeyEvent.VK_BACK_SPACE) {
					for (int i : list.getSelectedIndices()) {
						listModel.remove(i);
					}
				}
			}

			public void keyPressed(KeyEvent e) {
			}

		});
		list.setDragEnabled(true);
		list.setDropMode(DropMode.INSERT);
		list.setTransferHandler(new DropHandlerImpl<>(listModel));
		list.setBackground(WidgetColors.COLOR_LIST_BG);
		list.setForeground(WidgetColors.COLOR_LIST_FG);
		list.setSelectionBackground(WidgetColors.COLOR_LIST_SELECTION_BG);
		list.setSelectionForeground(WidgetColors.COLOR_LIST_SELECTION_FG);

		final ProMScrollPane scroller = new ProMScrollPane(list);
		scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);

		new DragListenerImpl<>(list);
		
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setOpaque(false);
		selectedItemsText = new JLabel(""Selected items"");
		getSelectedItemsText().setAlignmentX(CENTER_ALIGNMENT);
		topPanel.add(controlPanel, BorderLayout.CENTER);
		topPanel.add(getSelectedItemsText(), BorderLayout.SOUTH);
		
		setLayout(new BorderLayout());
		add(topPanel, BorderLayout.NORTH);
		add(scroller, BorderLayout.CENTER);
	}

	public JList<T> getList() {
		return list;
	}

	public ProMComboBox<T> getComboBox() {
		return comboBox;
	}

	/**
	 * @return the ordered elements currently in the {@link JList}
	 */
	public List<T> getElements() {
		ArrayList<T> elements = new ArrayList<>();
		for (int i = 0; i < listModel.getSize(); i++) {
			elements.add(listModel.get(i));
		}
		return elements;
	}

	public void addElement(T element) {
		listModel.addElement(element);
	}

	public ListModel<T> getListModel() {
		return listModel;
	}

	public JLabel getSelectedItemsText() {
		return selectedItemsText;
	}

}"
ProMPasswordField.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionListener;
import java.awt.event.FocusListener;
import java.awt.event.KeyListener;

import javax.swing.JPasswordField;
import javax.swing.text.Document;

import org.processmining.framework.util.ui.widgets.BorderPanel;
import org.processmining.framework.util.ui.widgets.WidgetColors;

/**
 * PasswordField with SlickerBox L&F
 * Built using the PromTextField as pattern
 * 
 * @author shernandez
 * 
 */
public class ProMPasswordField extends BorderPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private final JPasswordField passwordField;

	/**
	 * 
	 */
	public ProMPasswordField() {
		super(15, 3);
		setLayout(new BorderLayout());
		setOpaque(true);
		setBackground(WidgetColors.COLOR_LIST_BG);
		setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		passwordField = new JPasswordField();
		add(passwordField, BorderLayout.CENTER);
		passwordField.setBorder(null);
		passwordField.setOpaque(true);
		passwordField.setBackground(WidgetColors.COLOR_LIST_BG);
		passwordField.setForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		passwordField.setSelectionColor(WidgetColors.COLOR_LIST_SELECTION_BG);
		passwordField.setSelectedTextColor(WidgetColors.COLOR_LIST_SELECTION_FG);
		passwordField.setCaretColor(WidgetColors.COLOR_LIST_SELECTION_FG);
		setMinimumSize(new Dimension(200, 30));
		setMaximumSize(new Dimension(1000, 30));
		setPreferredSize(new Dimension(1000, 30));
	}

	/**
	 * @param initial
	 */
	public ProMPasswordField(final String initial) {
		this();
		setText(initial);
	}

	/**
	 * @param listener
	 */
	public void addActionListener(final ActionListener listener) {
		passwordField.addActionListener(listener);
	}

	/**
	 * @see java.awt.Component#addFocusListener(java.awt.event.FocusListener)
	 */
	@Override
	public void addFocusListener(final FocusListener listener) {
		passwordField.addFocusListener(listener);
	}

	/**
	 * @see java.awt.Component#addKeyListener(java.awt.event.KeyListener)
	 */
	@Override
	public void addKeyListener(final KeyListener listener) {
		passwordField.addKeyListener(listener);
	}

	/**
	 * @return
	 */
	public Document getDocument() {
		return passwordField.getDocument();
	}

	/**
	 * @return
	 */
	public String getText() {
		return passwordField.getText();
	}

	/**
	 * @param text
	 */
	public void insertText(final String text) {
		final int position = passwordField.getCaretPosition();
		passwordField.setText(passwordField.getText().substring(0, position) + text + passwordField.getText().substring(position));
	}

	/**
	 * @param listener
	 */
	public void removeActionListener(final ActionListener listener) {
		passwordField.removeActionListener(listener);
	}

	/**
	 * @see java.awt.Component#removeFocusListener(java.awt.event.FocusListener)
	 */
	@Override
	public void removeFocusListener(final FocusListener listener) {
		passwordField.removeFocusListener(listener);
	}

	/**
	 * @param editable
	 */
	public void setEditable(final boolean editable) {
		passwordField.setEditable(editable);
	}

	/**
	 * @param text
	 */
	public void setText(final String text) {
		passwordField.setText(text);
	}

	/**
	 * @param isOkay
	 */
	public void visualizeStatus(final boolean isOkay) {
		final Color bg = isOkay ? WidgetColors.COLOR_LIST_BG : WidgetColors.COLOR_LIST_SELECTION_BG;
		super.setBackground(bg);
		passwordField.setBackground(bg);
		getParent().invalidate();
		getParent().repaint();
	}
}
"
ProMPropertiesExpertModePanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.swing.JCheckBox;
import javax.swing.JComponent;

import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * A {@link ProMPropertiesPanel} with a switch that shows/hides a set of
 * 'expert' properties. Use {@link #addExpertProperty(JComponent)} to add these
 * 'expert' properties.
 * 
 * @author F. Mannhardt
 * 
 */
public class ProMPropertiesExpertModePanel extends ProMPropertiesPanel {

	private static final long serialVersionUID = -8333719879782883891L;

	private static String DEFAULT_EXPERT_MODE_TEXT = ""Show Expert Options"";
	private static final String EXPERT_MODE_HEADER = ""------------ EXPERT CONFIGURATION OPTIONS ------------"";

	private final List<JComponent> expertProperties;
	private JCheckBox expertSwitch;

	private boolean showExpertSwitch;
	private String expertPropertiesText;

	public ProMPropertiesExpertModePanel(final String title) {
		this(title, true, DEFAULT_EXPERT_MODE_TEXT);
	}

	public ProMPropertiesExpertModePanel(final String title, final boolean showExpertSwitch,
			final String expertSwitchText) {
		super(title);
		this.showExpertSwitch = showExpertSwitch;
		this.expertPropertiesText = expertSwitchText;
		this.expertProperties = new ArrayList<JComponent>();
	}

	public JCheckBox addCheckBox(final String name, final boolean value, final boolean isExpert) {
		final JCheckBox checkBox = SlickerFactory.instance().createCheckBox(null, value);
		return addProperty(name, checkBox, isExpert);
	}

	public ProMTextField addTextField(final String name, final String value, final boolean isExpertProperty) {
		return addProperty(name, new ProMTextField(value), isExpertProperty);
	}

	public <E> ProMComboBox<E> addComboBox(final String name, final Iterable<E> values, final boolean isExpertProperty) {
		return addProperty(name, new ProMComboBox<E>(values), isExpertProperty);
	}

	public <E> ProMComboBox<E> addComboBox(final String name, final E[] values, final boolean isExpertProperty) {
		return addProperty(name, new ProMComboBox<E>(values), isExpertProperty);
	}

	public <T extends JComponent> T addProperty(final String name, final T component, final boolean isExpertProperty) {
		if (isExpertProperty && showExpertSwitch && expertSwitch == null) {
			addExpertSwitch();
		}
		T c = super.addProperty(name, component);
		if (isExpertProperty) {
			addExpertProperty(c);
		}
		return c;
	}

	public void showExpertProperties() {
		for (JComponent c : getExpertProperties()) {
			c.setVisible(true);
		}
	}

	public void hideExpertProperties() {
		for (JComponent c : getExpertProperties()) {
			c.getParent().setVisible(false);
		}
	}

	public void toggleExpertPanel() {
		for (JComponent c : getExpertProperties()) {
			c.getParent().setVisible(!c.getParent().isVisible());
		}
	}

	/**
	 * @return {@link List} of all properties that are only visible in expert
	 *         mode
	 */
	public List<JComponent> getExpertProperties() {
		return Collections.unmodifiableList(expertProperties);
	}

	public void addExpertProperty(JComponent c) {
		expertProperties.add(c);
		// Hide component initially
		c.getParent().setVisible(false);
	}

	private void addExpertSwitch() {
		expertSwitch = addCheckBox(expertPropertiesText, false);
		expertSwitch.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				toggleExpertPanel();
			}
		});
		addProperty(null, SlickerFactory.instance().createLabel(EXPERT_MODE_HEADER), true);
	}

}
"
ProMPropertiesPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.AbstractButton;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.ScrollPaneConstants;
import javax.swing.text.JTextComponent;

import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * 
 * @author mwesterg
 * @author shernandez d.d. 20150602 add passwordfield
 * 
 */
public class ProMPropertiesPanel extends ProMHeaderPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	private boolean first = true;

	private final JPanel properties;

	/**
	 * @param title
	 */
	public ProMPropertiesPanel(final String title) {
		super(title);
		properties = new ProMScrollablePanel();
		properties.setOpaque(false);
		properties.setLayout(new BoxLayout(properties, BoxLayout.Y_AXIS));
		final ProMScrollPane scrollPane = new ProMScrollPane(properties);
		scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scrollPane.getViewport().setBackground(getBackground());
		add(scrollPane);
	}

	/**
	 * @param name
	 * @return
	 */
	public JCheckBox addCheckBox(final String name) {
		return addCheckBox(name, false);
	}

	/**
	 * @param name
	 * @param value
	 * @return
	 */
	public JCheckBox addCheckBox(final String name, final boolean value) {
		final JCheckBox checkBox = SlickerFactory.instance().createCheckBox(null, value);
		return addProperty(name, checkBox);
	}

	/**
	 * @param name
	 * @param values
	 * @return
	 */
	public <E> ProMComboBox<E> addComboBox(final String name, final E[] values) {
		return addProperty(name, new ProMComboBox<E>(values));
	}

	/**
	 * @param name
	 * @param values
	 * @return
	 */
	public <E> ProMComboBox<E> addComboBox(final String name, final Iterable<E> values) {
		return addProperty(name, new ProMComboBox<E>(values));
	}

	/**
	 * @param <T>
	 * @param name
	 * @param component
	 * @return
	 */
	public <T extends JComponent> T addProperty(final String name, final T component) {
		if (!first) {
			properties.add(Box.createVerticalStrut(3));
		} else {
			first = false;
		}
		properties.add(packInfo(name, component));
		return component;
	}

	/**
	 * @param name
	 * @return
	 */
	public ProMTextField addTextField(final String name) {
		return addTextField(name, """");
	}

	/**
	 * @param name
	 * @param value
	 * @return
	 */
	public ProMTextField addTextField(final String name, final String value) {
		final ProMTextField component = new ProMTextField();
		component.setText(value);
		return addProperty(name, component);
	}

	private Component findComponent(final Component component) {
		if (component instanceof AbstractButton) {
			return component;
		}
		if (component instanceof JTextComponent) {
			return component;
		}
		if (component instanceof Container) {
			for (final Component child : ((Container) component).getComponents()) {
				final Component result = findComponent(child);
				if (result != null) {
					return result;
				}
			}
		}
		return null;
	}

	private void installHighlighter(final Component component, final RoundedPanel target) {
		component.addMouseListener(new MouseListener() {
			@Override
			public void mouseClicked(final MouseEvent arg0) { /* ignore */
			}

			@Override
			public void mouseEntered(final MouseEvent arg0) {
				target.setBackground(new Color(60, 60, 60, 240));
				target.repaint();
			}

			@Override
			public void mouseExited(final MouseEvent arg0) {
				target.setBackground(new Color(60, 60, 60, 160));
				target.repaint();
			}

			@Override
			public void mousePressed(final MouseEvent arg0) { /* ignore */
			}

			@Override
			public void mouseReleased(final MouseEvent arg0) { /* ignore */
			}
		});
		if (component instanceof Container) {
			for (final Component child : ((Container) component).getComponents()) {
				installHighlighter(child, target);
			}
		}
	}

	protected RoundedPanel packInfo(final String name, final JComponent component) {
		final RoundedPanel packed = new RoundedPanel(10, 0, 0);
		packed.setBackground(new Color(60, 60, 60, 160));
		final RoundedPanel target = packed;
		final Component actualComponent = findComponent(component);
		packed.addMouseListener(new MouseListener() {
			@Override
			public void mouseClicked(final MouseEvent arg0) {
				if (actualComponent != null) {
					if (actualComponent instanceof AbstractButton) {
						final AbstractButton button = (AbstractButton) actualComponent;
						button.doClick();
					}
					if (actualComponent instanceof JTextComponent) {
						final JTextComponent text = (JTextComponent) actualComponent;
						if (text.isEnabled() && text.isEditable()) {
							text.selectAll();
						}
						text.grabFocus();
					}
				}
			}

			@Override
			public void mouseEntered(final MouseEvent arg0) {
				target.setBackground(new Color(60, 60, 60, 240));
				target.repaint();
			}

			@Override
			public void mouseExited(final MouseEvent arg0) {
				target.setBackground(new Color(60, 60, 60, 160));
				target.repaint();
			}

			@Override
			public void mousePressed(final MouseEvent arg0) { /* ignore */
			}

			@Override
			public void mouseReleased(final MouseEvent arg0) { /* ignore */
			}
		});
		installHighlighter(component, target);
		packed.setLayout(new BoxLayout(packed, BoxLayout.X_AXIS));
		final JLabel nameLabel = new JLabel(name);
		nameLabel.setOpaque(false);
		nameLabel.setForeground(WidgetColors.TEXT_COLOR);
		nameLabel.setFont(nameLabel.getFont().deriveFont(12f));
		nameLabel.setMinimumSize(new Dimension(150, 20));
		nameLabel.setMaximumSize(new Dimension(150, 1000));
		nameLabel.setPreferredSize(new Dimension(150, 30));

		packed.add(Box.createHorizontalStrut(5));
		packed.add(nameLabel);
		packed.add(Box.createHorizontalGlue());
		packed.add(component);
		packed.add(Box.createHorizontalStrut(5));
		packed.revalidate();
		return packed;
	}

	/**
	 * Adds a new password field
	 * 
	 * @param name
	 *            Name for the password field
	 * @return The new password field
	 */
	public ProMPasswordField addPasswordInputField(final String name) {
		return addPasswordInputField(name, """");
	}

	/**
	 * Adds a new password field
	 * 
	 * @param name
	 *            Name for the password field
	 * @param value
	 *            Value for the password field
	 * @return The new password field
	 */
	public ProMPasswordField addPasswordInputField(final String name, final String value) {
		final ProMPasswordField component = new ProMPasswordField();
		component.setText(value);
		return addProperty(name, component);
	}

}
"
ProMScrollablePanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Dimension;
import java.awt.Rectangle;

import javax.swing.JPanel;
import javax.swing.Scrollable;
import javax.swing.SwingConstants;

/**
 * @author michael
 * 
 */
public class ProMScrollablePanel extends JPanel implements Scrollable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * @see javax.swing.Scrollable#getPreferredScrollableViewportSize()
	 */
	@Override
	public Dimension getPreferredScrollableViewportSize() {
		return getPreferredSize();
	}

	/**
	 * @see javax.swing.Scrollable#getScrollableBlockIncrement(java.awt.Rectangle,
	 *      int, int)
	 */
	@Override
	public int getScrollableBlockIncrement(final Rectangle visibleRect, final int orientation, final int direction) {
		return orientation == SwingConstants.VERTICAL ? getParent().getHeight() : getParent().getWidth();
	}

	/**
	 * @see javax.swing.Scrollable#getScrollableTracksViewportHeight()
	 */
	@Override
	public boolean getScrollableTracksViewportHeight() {
		return false;
	}

	/**
	 * @see javax.swing.Scrollable#getScrollableTracksViewportWidth()
	 */
	@Override
	public boolean getScrollableTracksViewportWidth() {
		return true;
	}

	/**
	 * @see javax.swing.Scrollable#getScrollableUnitIncrement(java.awt.Rectangle,
	 *      int, int)
	 */
	@Override
	public int getScrollableUnitIncrement(final Rectangle visibleRect, final int orientation, final int direction) {
		final int hundredth = (orientation == SwingConstants.VERTICAL ? getParent().getHeight() / 100 : getParent()
				.getWidth()) / 100;
		return hundredth == 0 ? 1 : hundredth;
	}

}"
ProMScrollContainer.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.util.ArrayList;
import java.util.List;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;

/**
 * This class implements a Scroll Container. In the container, childs with a
 * minimize / maximize button can be added. In this way, one can group
 * properties.
 * 
 * Furthermore, childs can be added during run time.
 * 
 * @author jvdwerf
 * 
 */
public class ProMScrollContainer extends BorderPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -3112303906580355823L;

	private final List<ProMScrollContainerChild> children = new ArrayList<ProMScrollContainerChild>();

	private JPanel scrollablePanel;

	private JScrollPane scrollPane;

	/**
	 * 
	 */
	public ProMScrollContainer() {
		this(10, 10);

	}

	/**
	 * @param size
	 * @param borderWidth
	 */
	public ProMScrollContainer(final int size, final int borderWidth) {
		super(size, borderWidth);

		initComponents();
	}

	/**
	 * @param child
	 */
	public void addChild(final ProMScrollContainerChild child) {
		addChild(child, children.size());
	}

	/**
	 * @param child
	 * @param index
	 */
	public void addChild(final ProMScrollContainerChild child, final int index) {
		children.add(child);

		if (children.size() > 0) {
			scrollablePanel.add(Box.createVerticalStrut(3));
		}

		scrollablePanel.add(child, index);
		scrollablePanel.revalidate();

		revalidate();
	}

	/**
	 * 
	 */
	public void clearChildren() {
		for (final ProMScrollContainerChild child : children) {
			scrollablePanel.remove(child);
		}

		children.clear();

		revalidate();
	}

	/**
	 * @param i
	 * @return
	 */
	public ProMScrollContainerChild getChild(final int i) {
		return children.get(i);
	}

	/**
	 * @return
	 */
	public List<ProMScrollContainerChild> getChildren() {
		return children;
	}

	/**
	 * @param child
	 */
	public void removeChild(final ProMScrollContainerChild child) {
		scrollablePanel.remove(child);
		children.remove(child);

		revalidate();
	}

	/**
	 * @param show
	 */
	public void showScrollbar(final boolean show) {
		if (show) {
			scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
		} else {
			scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
		}
	}

	private void initComponents() {

		setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));

		setOpaque(true);
		setBackground(WidgetColors.COLOR_ENCLOSURE_BG);

		setLayout(new BorderLayout());

		scrollablePanel = new ProMScrollablePanel();
		scrollablePanel.setOpaque(true);
		scrollablePanel.setBackground(WidgetColors.COLOR_LIST_FG);
		scrollablePanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

		scrollablePanel.setLayout(new BoxLayout(scrollablePanel, BoxLayout.Y_AXIS));

		scrollPane = new ProMScrollPane(scrollablePanel);

		this.add(scrollPane, BorderLayout.CENTER);

		revalidate();
	}
}
"
ProMScrollContainerChild.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JPanel;

import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * Child that can be displayed in the ProMScrollContainer. To update the user
 * interface of a child, one can use the functions
 * 
 * - getTitlePanel() Returns the top panel to display a title of the child
 * 
 * - getContentPanel() Returns the panel in which one can add the real content.
 * This panel will be hidden when the min/max button is hit.
 * 
 * - setContentSize() Sets the size of the content panel when maximized.
 * 
 * @author jvdwerf
 * 
 */
public class ProMScrollContainerChild extends BorderPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = -81027020923152280L;

	private JPanel buttonPanel;
	private JPanel contentPanel;

	private int contentSize = 100;
	private JButton deleteButton;
	private JButton minimizeButton;

	private boolean minimized = false;

	private final ProMScrollContainer parent;

	private JPanel topContentPanel;

	private JPanel topPanel;

	/**
	 * @param parent
	 */
	public ProMScrollContainerChild(final ProMScrollContainer parent) {
		this(parent, false);
	}

	/**
	 * @param parent
	 * @param startminimized
	 */
	public ProMScrollContainerChild(final ProMScrollContainer parent, final boolean startminimized) {
		this(parent, startminimized, true);
	}

	/**
	 * @param parent
	 * @param startminimized
	 * @param addDeleteButton
	 */
	public ProMScrollContainerChild(final ProMScrollContainer parent, final boolean startminimized,
			final boolean addDeleteButton) {
		super(10, 10);
		this.parent = parent;
		initComponents(addDeleteButton);

		setMinimized(startminimized);
	}

	/**
	 * @return
	 */
	public JPanel getContentPanel() {
		return contentPanel;
	}

	/**
	 * @return
	 */
	public int getContentSize() {
		return contentSize;
	}

	/**
	 * @return
	 */
	public JPanel getTitlePanel() {
		return topContentPanel;
	}

	/**
	 * @return
	 */
	public boolean isMinimized() {
		return minimized;
	}

	/**
	 * @see javax.swing.JComponent#revalidate()
	 */
	@Override
	public void revalidate() {
		super.revalidate();

		if (parent != null) {
			parent.revalidate();
		}
	}

	/**
	 * @param size
	 */
	public void setContentSize(final Dimension size) {
		//// lelijk :-S
		setContentSize((int) size.getHeight());
	}

	/**
	 * @param minimalContentSize
	 */
	public void setContentSize(final int minimalContentSize) {
		contentSize = minimalContentSize;

		updateHeights();
	}

	/**
	 * @param minimized
	 */
	public void setMinimized(final boolean minimized) {
		this.minimized = minimized;

		if (contentPanel != null && minimizeButton != null) {
			if (isMinimized()) {
				contentPanel.setVisible(false);
				minimizeButton.setText(""+"");
			} else {
				contentPanel.setVisible(true);
				minimizeButton.setText(""-"");
			}
		}

		revalidate();
	}

	private void initComponents(final boolean addDeleteButton) {

		setLayout(new BorderLayout());
		setOpaque(true);
		setBackground(WidgetColors.COLOR_LIST_BG);
		//this.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));

		topPanel = new JPanel();
		topPanel.setLayout(new BorderLayout());
		topPanel.setOpaque(false);

		topContentPanel = new JPanel();
		topContentPanel.setLayout(new BorderLayout());
		topContentPanel.setOpaque(false);

		buttonPanel = new JPanel();
		buttonPanel.setLayout(new BorderLayout());
		buttonPanel.setOpaque(false);

		topPanel.add(topContentPanel, BorderLayout.WEST);

		minimizeButton = SlickerFactory.instance().createButton(""-"");
		minimizeButton.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(final ActionEvent e) {
				toggleMinimized();
			}
		});

		if (addDeleteButton) {
			deleteButton = SlickerFactory.instance().createButton(""x"");
			deleteButton.addActionListener(new ActionListener() {

				@Override
				public void actionPerformed(final ActionEvent e) {
					removeMe();
				}
			});

			buttonPanel.add(deleteButton, BorderLayout.WEST);
		}

		buttonPanel.add(minimizeButton, BorderLayout.EAST);

		topPanel.add(buttonPanel, BorderLayout.EAST);

		this.add(topPanel, BorderLayout.NORTH);

		contentPanel = SlickerFactory.instance().createRoundedPanel(8, WidgetColors.COLOR_LIST_FG);
		contentPanel.setLayout(new BorderLayout());

		updateHeights();

		this.add(contentPanel, BorderLayout.CENTER);

	}

	private void removeMe() {
		parent.removeChild(this);
	}

	private void toggleMinimized() {
		setMinimized(!isMinimized());
	}

	private void updateHeights() {
		if (contentSize > contentPanel.getMaximumSize().getHeight()) {
			contentPanel.setMaximumSize(new Dimension(100, getContentSize()));
		}

		contentPanel.setPreferredSize(new Dimension(100, getContentSize()));
		contentPanel.setSize(new Dimension(100, getContentSize()));

		revalidate();

	}

}
"
ProMScrollPane.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;

import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;

import com.fluxicon.slickerbox.ui.SlickerScrollBarUI;

/**
 * @author michael
 * 
 */
public class ProMScrollPane extends JScrollPane {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * @param component
	 */
	public ProMScrollPane(final JComponent component) {
		super(component);
		setOpaque(true);
		setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		setBorder(BorderFactory.createEmptyBorder());
		setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		JScrollBar vBar = getVerticalScrollBar();
		vBar.setUI(new SlickerScrollBarUI(vBar, new Color(0, 0, 0, 0), new Color(160, 160, 160),
				WidgetColors.COLOR_NON_FOCUS, 4, 12));
		vBar.setOpaque(true);
		vBar.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		vBar = getHorizontalScrollBar();
		vBar.setUI(new SlickerScrollBarUI(vBar, new Color(0, 0, 0, 0), new Color(160, 160, 160),
				WidgetColors.COLOR_NON_FOCUS, 4, 12));
		vBar.setOpaque(true);
		vBar.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
	}

}
"
ProMSplitPane.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.JSplitPane;
import javax.swing.border.Border;
import javax.swing.plaf.basic.BasicSplitPaneDivider;
import javax.swing.plaf.basic.BasicSplitPaneUI;

import com.fluxicon.slickerbox.components.RoundedPanel;

/**
 * @author michael
 * 
 */
public class ProMSplitPane extends BorderPanel {
	private static class ImprovedSplitPaneDivider extends BasicSplitPaneDivider {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;

		private ImprovedSplitPaneDivider(final BasicSplitPaneUI ui) {
			super(ui);
		}

		@Override
		public void paint(final Graphics g) {
			g.setColor(getBackground());
			g.fillRect(0, 0, getWidth(), getHeight());
			paintComponents(g);
		}

		@Override
		protected JButton createLeftOneTouchButton() {
			final JButton b = new JButton() {
				/**
				 * 
				 */
				private static final long serialVersionUID = 1L;

				// Don't want the button to participate in focus traversable.
				@Override
				@Deprecated
				public boolean isFocusTraversable() {
					return false;
				}

				@Override
				public void paint(final Graphics g) {
					if (splitPane != null) {
						final int[] xs = new int[3];
						final int[] ys = new int[3];
						int blockSize;

						// Fill the background first ...
						g.setColor(ImprovedSplitPaneDivider.this.getBackground());
						g.fillRect(0, 0, getWidth(), getHeight());

						// ... then draw the arrow.
						g.setColor(ImprovedSplitPaneDivider.this.getForeground());
						if (orientation == JSplitPane.VERTICAL_SPLIT) {
							blockSize = Math.min(getHeight(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = blockSize;
							xs[1] = 0;
							xs[2] = blockSize << 1;
							ys[0] = 0;
							ys[1] = ys[2] = blockSize;
							g.drawPolygon(xs, ys, 3); // Little trick to make the
							// arrows of equal size
						} else {
							blockSize = Math.min(getWidth(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = xs[2] = blockSize;
							xs[1] = 0;
							ys[0] = 0;
							ys[1] = blockSize;
							ys[2] = blockSize << 1;
						}
						g.fillPolygon(xs, ys, 3);
					}
				}

				@Override
				public void setBorder(final Border b) {
				}
			};
			b.setMinimumSize(new Dimension(BasicSplitPaneDivider.ONE_TOUCH_SIZE, BasicSplitPaneDivider.ONE_TOUCH_SIZE));
			b.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			b.setFocusPainted(false);
			b.setBorderPainted(false);
			b.setRequestFocusEnabled(false);
			b.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					leftClicked();
				}
			});
			return b;
		}

		/**
		 * Creates and return an instance of JButton that can be used to
		 * collapse the right component in the split pane.
		 */
		@Override
		protected JButton createRightOneTouchButton() {
			final JButton b = new JButton() {
				/**
				 * 
				 */
				private static final long serialVersionUID = 1L;

				// Don't want the button to participate in focus traversable.
				@Override
				@Deprecated
				public boolean isFocusTraversable() {
					return false;
				}

				@Override
				public void paint(final Graphics g) {
					if (splitPane != null) {
						final int[] xs = new int[3];
						final int[] ys = new int[3];
						int blockSize;

						// Fill the background first ...
						g.setColor(ImprovedSplitPaneDivider.this.getBackground());
						g.fillRect(0, 0, getWidth(), getHeight());

						// ... then draw the arrow.
						if (orientation == JSplitPane.VERTICAL_SPLIT) {
							blockSize = Math.min(getHeight(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = blockSize;
							xs[1] = blockSize << 1;
							xs[2] = 0;
							ys[0] = blockSize;
							ys[1] = ys[2] = 0;
						} else {
							blockSize = Math.min(getWidth(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = xs[2] = 0;
							xs[1] = blockSize;
							ys[0] = 0;
							ys[1] = blockSize;
							ys[2] = blockSize << 1;
						}
						g.setColor(ImprovedSplitPaneDivider.this.getForeground());
						g.fillPolygon(xs, ys, 3);
					}
				}

				@Override
				public void setBorder(final Border border) {
				}
			};
			b.setMinimumSize(new Dimension(BasicSplitPaneDivider.ONE_TOUCH_SIZE, BasicSplitPaneDivider.ONE_TOUCH_SIZE));
			b.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			b.setFocusPainted(false);
			b.setBorderPainted(false);
			b.setRequestFocusEnabled(false);
			b.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					rightClicked();
				}
			});
			return b;
		}

		protected void leftClicked() {

		}

		protected void rightClicked() {

		}
	}

	/**
	 * 
	 */
	public static final int HORIZONTAL_SPLIT = JSplitPane.HORIZONTAL_SPLIT;
	/**
	 * 
	 */
	public static final int VERTICAL_SPLIT = JSplitPane.VERTICAL_SPLIT;

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	JSplitPane split;
	JPanel top, bottom;

	/**
	 * 
	 */
	public ProMSplitPane() {
		this(ProMSplitPane.HORIZONTAL_SPLIT);
	}

	/**
	 * @param split
	 */
	public ProMSplitPane(final int split) {
		super(5, 5);
		setLayout(new BorderLayout());
		setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		setOpaque(true);
		top = new RoundedPanel(10);
		top.setLayout(new BorderLayout());
		top.setBackground(Color.LIGHT_GRAY);
		top.setOpaque(true);
		bottom = new RoundedPanel(10);
		bottom.setLayout(new BorderLayout());
		bottom.setBackground(Color.LIGHT_GRAY);
		bottom.setOpaque(true);
		this.split = new JSplitPane(split, true);
		this.split.setLeftComponent(top);
		this.split.setRightComponent(bottom);
		this.split.setBorder(BorderFactory.createEmptyBorder());
		this.split.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		this.split.setOpaque(true);
		this.split.setUI(new BasicSplitPaneUI() {
			@Override
			public BasicSplitPaneDivider createDefaultDivider() {
				final BasicSplitPaneDivider divider = new ImprovedSplitPaneDivider(this) {
					/**
					 * 
					 */
					private static final long serialVersionUID = 1L;

					@Override
					public void leftClicked() {
						ProMSplitPane.this.leftClicked();
					}

					@Override
					public void rightClicked() {
						ProMSplitPane.this.rightClicked();
					}
				};
				divider.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
				divider.setForeground(Color.LIGHT_GRAY);
				return divider;
			}
		});
		add(this.split);
	}

	/**
	 * @param c
	 */
	public void setBottomComponent(final Component c) {
		bottom.removeAll();
		bottom.add(c);
		validate();
	}

	/**
	 * @param d
	 */
	public void setDividerLocation(final double d) {
		split.setDividerLocation(d);

	}

	/**
	 * @param location
	 */
	public void setDividerLocation(final int location) {
		split.setDividerLocation(location);
	}

	/**
	 * @param size
	 */
	public void setDividerSize(final int size) {
		split.setDividerSize(size);
	}

	/**
	 * @param c
	 */
	public void setLeftComponent(final Component c) {
		setTopComponent(c);
	}

	/**
	 * @param expandable
	 */
	public void setOneTouchExpandable(final boolean expandable) {
		split.setOneTouchExpandable(expandable);
	}

	/**
	 * @param d
	 */
	public void setResizeWeight(final double d) {
		split.setResizeWeight(d);
	}

	/**
	 * @param c
	 */
	public void setRightComponent(final Component c) {
		setBottomComponent(c);
	}

	/**
	 * @param c
	 */
	public void setTopComponent(final Component c) {
		top.removeAll();
		top.add(c);
		validate();
	}

	protected void leftClicked() {

	}

	protected void rightClicked() {

	}
}
"
ProMTable.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Point;
import java.awt.event.MouseListener;
import java.util.Arrays;
import java.util.Comparator;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.RowSorter;
import javax.swing.SortOrder;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;
import javax.swing.table.TableRowSorter;

import com.fluxicon.slickerbox.components.RoundedPanel;

/**
 * Table with SlickerBox L&F
 * 
 * @author mwesterg
 * 
 */
public class ProMTable extends RoundedPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private final JTable table;

	/**
	 * @param model
	 */
	public ProMTable(final TableModel model) {
		this(model, null);
	}

	/**
	 * @param model
	 * @param columnModel
	 */
	public ProMTable(final TableModel model, final TableColumnModel columnModel) {
		super(10, 5, 0);

		table = createTable(model, columnModel);
		table.setBackground(WidgetColors.COLOR_LIST_BG);
		table.setForeground(WidgetColors.COLOR_LIST_FG);
		table.setSelectionBackground(WidgetColors.COLOR_LIST_SELECTION_BG);
		table.setSelectionForeground(WidgetColors.COLOR_LIST_SELECTION_FG);

		final ProMScrollPane scroller = new ProMScrollPane(table);

		table.getTableHeader().setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		table.getTableHeader().setOpaque(false);
		table.getTableHeader().setForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		table.getTableHeader().setBorder(BorderFactory.createEmptyBorder());
		table.getTableHeader().setFont(table.getTableHeader().getFont().deriveFont(13f).deriveFont(Font.BOLD));
		table.getTableHeader().setAlignmentX(Component.CENTER_ALIGNMENT);
		table.setShowHorizontalLines(false);
		table.setGridColor(WidgetColors.COLOR_ENCLOSURE_BG);
		table.setFont(table.getFont().deriveFont(Font.BOLD));

		scroller.getViewport().setBackground(WidgetColors.COLOR_LIST_BG);
		table.getTableHeader().setDefaultRenderer(new HeaderRenderer());

		setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		setLayout(new BorderLayout());
		setMinimumSize(new Dimension(200, 100));
		setMaximumSize(new Dimension(1000, 1000));
		setPreferredSize(new Dimension(1000, 200));
		add(Box.createHorizontalStrut(5), BorderLayout.WEST);
		add(scroller, BorderLayout.CENTER);
		add(Box.createHorizontalStrut(5), BorderLayout.EAST);

		table.setColumnSelectionAllowed(false);
		table.setAutoResizeMode(JTable.AUTO_RESIZE_NEXT_COLUMN);
	}

	/**
	 * @see java.awt.Component#addMouseListener(java.awt.event.MouseListener)
	 */
	@Override
	public void addMouseListener(final MouseListener l) {
		table.addMouseListener(l);
	}

	/**
	 * @param from
	 * @param to
	 */
	public void addRowSelectionInterval(final int from, final int to) {
		table.addRowSelectionInterval(from, to);
	}

	/**
	 * 
	 */
	public void clearSelection() {
		table.clearSelection();
	}

	/**
	 * @param point
	 * @return
	 */
	public int columnAtPoint(final Point point) {
		return table.columnAtPoint(point);
	}

	/**
	 * @param row
	 * @param col
	 * @return
	 */
	public TableCellEditor getCellEditor(final int row, final int col) {
		return table.getCellEditor(row, col);
	}

	/**
	 * @return
	 */
	public TableColumnModel getColumnModel() {
		return table.getColumnModel();
	}

	/**
	 * @return
	 */
	public boolean getColumnSelectionAllowed() {
		return table.getColumnSelectionAllowed();
	}

	/**
	 * @return
	 */
	public boolean getRowSelectionAllowed() {
		return table.getRowSelectionAllowed();
	}

	/**
	 * @return
	 */
	public RowSorter<? extends TableModel> getRowSorter() {
		return table.getRowSorter();
	}

	/**
	 * @return
	 */
	public int getSelectedColumn() {
		return table.getSelectedColumn();
	}

	/**
	 * @return
	 */
	public int getSelectedRow() {
		return table.getSelectedRow();
	}

	/**
	 * @return
	 */
	public ListSelectionModel getSelectionModel() {
		return table.getSelectionModel();
	}

	/**
	 * @return
	 */
	public JTable getTable() {
		return table;
	}

	/**
	 * @return
	 */
	public JTableHeader getTableHeader() {
		return table.getTableHeader();
	}

	/**
	 * @param row
	 * @param column
	 * @return
	 */
	public Object getValueAt(final int row, final int column) {
		return table.getValueAt(row, column);
	}

	/**
	 * @see java.awt.Component#removeMouseListener(java.awt.event.MouseListener)
	 */
	@Override
	public void removeMouseListener(final MouseListener l) {
		table.removeMouseListener(l);
	}

	/**
	 * @param point
	 * @return
	 */
	public int rowAtPoint(final Point point) {
		return table.rowAtPoint(point);
	}

	/**
	 * @param create
	 */
	public void setAutoCreateRowSorter(final boolean create) {
		table.setAutoCreateRowSorter(create);
	}

	/**
	 * @param mode
	 */
	public void setAutoResizeMode(final int mode) {
		table.setAutoResizeMode(mode);
	}

	/**
	 * @param allowed
	 */
	public void setColumnSelectionAllowed(final boolean allowed) {
		table.setColumnSelectionAllowed(allowed);
	}

	/**
	 * @param column
	 * @param width
	 */
	public void setPreferredWidth(final int column, final int width) {
		table.getColumnModel().getColumn(column).setPreferredWidth(width);
	}

	/**
	 * @param allowed
	 */
	public void setRowSelectionAllowed(final boolean allowed) {
		table.setRowSelectionAllowed(allowed);
	}

	/**
	 * @param column
	 * @param comparator
	 */
	public void setRowSorter(final int column, final Comparator<?> comparator) {
		final TableRowSorter<TableModel> sorter = new TableRowSorter<TableModel>(table.getModel());
		sorter.setSortsOnUpdates(true);
		sorter.setComparator(column, null);
		setRowSorter(sorter);
		sorter.setSortKeys(Arrays.asList(new RowSorter.SortKey(column, SortOrder.ASCENDING)));
	}

	/**
	 * @param sorter
	 */
	public void setRowSorter(final RowSorter<? extends TableModel> sorter) {
		table.setRowSorter(sorter);
	}

	/**
	 * @param sorter
	 */
	public void setRowSorter(final TableRowSorter<? extends TableModel> sorter) {
		table.setRowSorter(sorter);
		sorter.sort();
	}

	/**
	 * @param mode
	 */
	public void setSelectionMode(final int mode) {
		table.setSelectionMode(mode);
	}

	protected JTable createTable(final TableModel model, final TableColumnModel columnModel) {
		return new JTable(model, columnModel);
	}

}"
ProMTableWithoutPanel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.Enumeration;

import javax.swing.DefaultCellEditor;
import javax.swing.JPanel;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;

/**
 * Adapted from {@link ProMTable}, but without a surrounding {@link JPanel}.
 * 
 * @author F. Mannhardt
 *
 */
public class ProMTableWithoutPanel extends JTable {

	private static final long serialVersionUID = 9039927753456671146L;
	
	public ProMTableWithoutPanel(TableModel model, TableColumnModel columnModel) {
		super(model, columnModel);
		setup();
	}

	public ProMTableWithoutPanel(TableModel model) {
		super(model);
		setup();
	}

	@SuppressWarnings(""serial"")
	private void setup() {
		setBackground(WidgetColors.COLOR_LIST_BG);
		setForeground(WidgetColors.COLOR_LIST_FG);
		setSelectionBackground(WidgetColors.COLOR_LIST_SELECTION_BG);
		setSelectionForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		setGridColor(WidgetColors.COLOR_ENCLOSURE_BG);
		setFont(getFont().deriveFont(Font.BOLD));
		
		getTableHeader().setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		getTableHeader().setOpaque(true);
		getTableHeader().setForeground(Color.WHITE);
		getTableHeader().setFont(getTableHeader().getFont().deriveFont(13f).deriveFont(Font.BOLD));
		getTableHeader().setReorderingAllowed(false);
		DefaultTableCellRenderer cellRenderer = new DefaultTableCellRenderer() {

			public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
					boolean hasFocus, int row, int column) {
				Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
				if (!isSelected) {
					c.setBackground(table.getBackground());
					c.setForeground(table.getForeground());
				}
				return c;
			}

		};
		
		Enumeration<TableColumn> columns = getColumnModel().getColumns();
		while (columns.hasMoreElements()) {
			final TableColumn column = columns.nextElement();
			column.setPreferredWidth(200);
			column.setCellRenderer(cellRenderer);
			column.setCellEditor(new DefaultCellEditor(new JTextField()) {

				protected void fireEditingStopped() {
					this.cancelCellEditing();
					super.fireEditingStopped();
				}

				protected void fireEditingCanceled() {
					super.fireEditingCanceled();
				}

			});
		}
		
		setColumnSelectionAllowed(false);		
		setShowHorizontalLines(false);

		setMinimumSize(null);
		setMaximumSize(null);
		setPreferredSize(null);
		setBackground(null);
		setForeground(null);
		setOpaque(false);
		setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
	}

}
"
ProMTextArea.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Dimension;

import javax.swing.Box;
import javax.swing.JTextArea;

import com.fluxicon.slickerbox.components.RoundedPanel;

/**
 * TextAres with SlickerBox L&F
 * 
 * @author mwesterg
 * 
 */
public class ProMTextArea extends RoundedPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private final JTextArea textArea;

	/**
	 * 
	 */
	public ProMTextArea() {
		super(10, 5, 0);
		textArea = new JTextArea();
		final ProMScrollPane logarea = new ProMScrollPane(textArea);
		textArea.setOpaque(true);
		textArea.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		textArea.setForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		textArea.setSelectedTextColor(WidgetColors.COLOR_LIST_SELECTION_FG);
		textArea.setSelectionColor(WidgetColors.COLOR_LIST_SELECTION_BG);
		textArea.setCaretColor(WidgetColors.COLOR_LIST_SELECTION_FG);

		setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		setLayout(new BorderLayout());
		setMinimumSize(new Dimension(200, 100));
		setMaximumSize(new Dimension(1000, 1000));
		setPreferredSize(new Dimension(1000, 200));

		add(Box.createHorizontalStrut(5), BorderLayout.WEST);
		add(logarea, BorderLayout.CENTER);
		add(Box.createHorizontalStrut(5), BorderLayout.EAST);
	}

	/**
	 * @param editable
	 */
	public ProMTextArea(final boolean editable) {
		this();
		if (!editable) {
			setEditable(false);
			setLineWrap(true);
		}
	}

	/**
	 * @param text
	 */
	public void append(final String text) {
		textArea.append(text);
	}

	/**
	 * @return
	 */
	public int getLength() {
		return textArea.getDocument().getLength();
	}

	/**
	 * @return
	 */
	public boolean getLineWrap() {
		return textArea.getLineWrap();
	}

	/**
	 * @return
	 */
	public int getTabSize() {
		return textArea.getTabSize();
	}

	/**
	 * @return
	 */
	public String getText() {
		return textArea.getText();
	}

	/**
	 * 
	 */
	public void scrollToEnd() {
		setCaretPosition(getLength());
	}

	/**
	 * 
	 */
	public void selectAll() {
		textArea.selectAll();
	}

	/**
	 * @param position
	 */
	public void setCaretPosition(final int position) {
		textArea.setCaretPosition(position);
	}

	/**
	 * @param editable
	 */
	public void setEditable(final boolean editable) {
		textArea.setEditable(editable);
	}

	/**
	 * @param wrap
	 */
	public void setLineWrap(final boolean wrap) {
		textArea.setLineWrap(wrap);
		textArea.setWrapStyleWord(wrap);
	}

	/**
	 * @param size
	 */
	public void setTabSize(final int size) {
		textArea.setTabSize(size);
	}

	/**
	 * @param text
	 */
	public void setText(final String text) {
		textArea.setText(text);
	}

	public JTextArea getTextArea() {
		return textArea;
	}
}
"
ProMTextField.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Insets;
import java.awt.RenderingHints;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyListener;

import javax.swing.JTextField;
import javax.swing.text.Document;

/**
 * TextField with SlickerBox L&F
 * 
 * @author mwesterg
 * @author F. Mannhardt (hints & expose underlying {@link JTextField})
 * 
 */
public class ProMTextField extends BorderPanel {

	private final class JTextFieldWithHint extends JTextField implements FocusListener {
		
		private static final long serialVersionUID = -4392477239934637206L;
		
		private String hint;
		private boolean hintVisible = true;

		public JTextFieldWithHint() {
			super();
			super.addFocusListener(this);
		}

		@Override
		public void focusGained(FocusEvent e) {
			hintVisible = false;
			repaint();
		}

		@Override
		public void focusLost(FocusEvent e) {
			hintVisible = true;
			repaint();
		}

		public void setHint(String hint) {
			this.hint = hint;
		}
		
		@Override
	    public void paint(Graphics g) {
	        super.paint(g);
	        if (getText().length() == 0 && hintVisible && hint != null && !hint.isEmpty()) {
	            int h = getHeight();
	            ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
	            Insets ins = getInsets();
	            FontMetrics fm = g.getFontMetrics();
	            int c0 = getBackground().getRGB();
	            int c1 = getForeground().getRGB();
	            int m = 0xfefefefe;
	            int c2 = ((c0 & m) >>> 1) + ((c1 & m) >>> 1);
	            g.setColor(new Color(c2, true));
	            g.drawString(hint, ins.left, h / 2 + fm.getAscent() / 2 - 2);
	        }
	    }

	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	private final JTextFieldWithHint textField;
	
	/**
	 * 
	 */
	public ProMTextField() {
		super(15, 3);
		setLayout(new BorderLayout());
		setOpaque(true);
		setBackground(WidgetColors.COLOR_LIST_BG);
		setForeground(WidgetColors.COLOR_ENCLOSURE_BG);
		textField = new JTextFieldWithHint();
		add(textField, BorderLayout.CENTER);
		textField.setBorder(null);
		textField.setOpaque(true);
		textField.setBackground(WidgetColors.COLOR_LIST_BG);
		textField.setForeground(WidgetColors.COLOR_LIST_SELECTION_FG);
		textField.setSelectionColor(WidgetColors.COLOR_LIST_SELECTION_BG);
		textField.setSelectedTextColor(WidgetColors.COLOR_LIST_SELECTION_FG);
		textField.setCaretColor(WidgetColors.COLOR_LIST_SELECTION_FG);
		setMinimumSize(new Dimension(200, 30));
		setMaximumSize(new Dimension(1000, 30));
		setPreferredSize(new Dimension(1000, 30));
	}

	/**
	 * @param initial
	 */
	public ProMTextField(final String initial) {
		this();
		setText(initial);
	}

	/**
	 * @param initial
	 * @param hint
	 *            displayed in light gray font
	 */
	public ProMTextField(final String initial, final String hint) {
		this();
		setText(initial);
		setHint(hint);
	}

	/**
	 * @param listener
	 */
	public void addActionListener(final ActionListener listener) {
		textField.addActionListener(listener);
	}

	/**
	 * @see java.awt.Component#addFocusListener(java.awt.event.FocusListener)
	 */
	@Override
	public void addFocusListener(final FocusListener listener) {
		textField.addFocusListener(listener);
	}

	/**
	 * @see java.awt.Component#addKeyListener(java.awt.event.KeyListener)
	 */
	@Override
	public void addKeyListener(final KeyListener listener) {
		textField.addKeyListener(listener);
	}

	/**
	 * @return
	 */
	public Document getDocument() {
		return textField.getDocument();
	}

	/**
	 * @return
	 */
	public String getText() {
		return textField.getText();
	}

	/**
	 * @param text
	 */
	public void insertText(final String text) {
		final int position = textField.getCaretPosition();
		textField.setText(textField.getText().substring(0, position) + text + textField.getText().substring(position));
	}

	/**
	 * @param listener
	 */
	public void removeActionListener(final ActionListener listener) {
		textField.removeActionListener(listener);
	}

	/**
	 * @see java.awt.Component#removeFocusListener(java.awt.event.FocusListener)
	 */
	@Override
	public void removeFocusListener(final FocusListener listener) {
		textField.removeFocusListener(listener);
	}

	/**
	 * @param editable
	 */
	public void setEditable(final boolean editable) {
		textField.setEditable(editable);
	}

	/**
	 * @param text
	 */
	public void setText(final String text) {
		textField.setText(text);
	}

	/**
	 * @param isOkay
	 */
	public void visualizeStatus(final boolean isOkay) {
		final Color bg = isOkay ? WidgetColors.COLOR_LIST_BG : WidgetColors.COLOR_LIST_SELECTION_BG;
		super.setBackground(bg);
		textField.setBackground(bg);
		getParent().invalidate();
		getParent().repaint();
	}

	/**
	 * @return get underlying {@link JTextField}
	 */
	public JTextField getTextField() {
		return textField;
	}

	/**
	 * @param hint
	 *            gray text that appears when text field is empty
	 */
	public void setHint(String hint) {
		textField.setHint(hint);
	}

}
"
ProMTitledScrollContainerChild.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.BorderLayout;

/**
 * @author michael
 * 
 */
public class ProMTitledScrollContainerChild extends ProMScrollContainerChild {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1497690974696615552L;

	private final String title;

	/**
	 * @param title
	 * @param parent
	 */
	public ProMTitledScrollContainerChild(final String title, final ProMScrollContainer parent) {
		this(title, parent, false);
	}

	/**
	 * @param title
	 * @param parent
	 * @param minimized
	 */
	public ProMTitledScrollContainerChild(final String title, final ProMScrollContainer parent, final boolean minimized) {
		super(parent, minimized);

		this.title = title;

		initialize();
	}

	/**
	 * @return
	 */
	public String getTitle() {
		return title;
	}

	private void initialize() {
		final LeftAlignedHeader header = new LeftAlignedHeader(getTitle());

		getTitlePanel().setLayout(new BorderLayout());
		getTitlePanel().setBackground(WidgetColors.PROPERTIES_BACKGROUND);
		getTitlePanel().add(header);

	}

}
"
DetailView.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.traceview.masterdetail;

import java.util.Comparator;

import javax.swing.JComponent;

import org.processmining.framework.util.ui.widgets.traceview.ProMTraceList;

public interface DetailView<T> {
	
	JComponent getDetailComponent();
	
	ProMTraceList<T> getDetailList();

	Comparator<T> getSortOrder();

}
"
MasterView.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.traceview.masterdetail;

import java.util.Collection;

import javax.swing.JComponent;

import org.processmining.framework.util.ui.widgets.traceview.ProMTraceList;

public interface MasterView<M, D> {
	
	JComponent getMasterComponent();
	
	ProMTraceList<M> getMasterList();
	
	Collection<D> getDetailElements(M element);

}
"
ProMTraceListMasterDetail.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.traceview.masterdetail;

import java.awt.BorderLayout;
import java.awt.HeadlessException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.ExecutionException;

import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.ListModel;
import javax.swing.SwingWorker;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.ui.widgets.ProMSplitPane;
import org.processmining.framework.util.ui.widgets.traceview.model.SortableListModel;

public class ProMTraceListMasterDetail<M, D> extends JPanel {

	private static final long serialVersionUID = -289071473358339232L;

	private final MasterView<M, D> masterView;
	private final DetailView<D> detailView;
	private final TransparentSplitPane splitPane;

	private boolean doUpdates = true;

	public ProMTraceListMasterDetail(final MasterView<M, D> masterView, final DetailView<D> detailView) {
		super();
		this.masterView = masterView;
		this.detailView = detailView;

		masterView.getMasterList().addTraceSelectionListener(new ListSelectionListener() {

			public void valueChanged(ListSelectionEvent e) {
				if (e.getValueIsAdjusting() || !doUpdates) {
					return;
				}

				final JList<M> list = masterView.getMasterList().getList();
				final int[] selectedTraces = list.getSelectedIndices();

				onBeforeUpdate(selectedTraces);

				SwingWorker<Collection<D>, Object> bgWorker = new SwingWorker<Collection<D>, Object>() {

					@Override
					public Collection<D> doInBackground() {
						List<D> detailedCollection = new ArrayList<D>();
						for (int index : selectedTraces) {
							if (index < list.getModel().getSize()) {
								Collection<D> detailElements = masterView
										.getDetailElements(list.getModel().getElementAt(index));
								detailedCollection.addAll(detailElements);
							}
						}
						return detailedCollection;
					}

					@Override
					protected void done() {
						detailView.getDetailList().clear();
						detailView.getDetailList().getList().getSelectionModel().clearSelection();
						try {
							detailView.getDetailList().addAll(get());
							if (detailView.getSortOrder() != null) {
								ListModel<D> listModel = detailView.getDetailList().getListModel();
								if (listModel instanceof SortableListModel) {
									((SortableListModel<D>) listModel).sort(detailView.getSortOrder());
								}
							}
							onAfterUpdate();
						} catch (ExecutionException e) {
							JOptionPane.showMessageDialog(ProMTraceListMasterDetail.this,
									""Error loading detail elements "" + e.getMessage(), ""Loading error"",
									JOptionPane.ERROR_MESSAGE);
						} catch (InterruptedException e) {
							JOptionPane.showMessageDialog(ProMTraceListMasterDetail.this,
									""Error loading detail elements "" + e.getMessage(), ""Loading error"",
									JOptionPane.ERROR_MESSAGE);
						} catch (HeadlessException e) {
							JOptionPane.showMessageDialog(ProMTraceListMasterDetail.this,
									""Error loading detail elements "" + e.getMessage(), ""Loading error"",
									JOptionPane.ERROR_MESSAGE);
						}
					}

				};
				bgWorker.execute();
			}

		});

		setBackground(null);
		setForeground(null);
		setOpaque(false);
		setLayout(new BorderLayout());
		splitPane = createSplitPane();
		splitPane.setLeftComponent(masterView.getMasterComponent());
		splitPane.setRightComponent(detailView.getDetailComponent());
		splitPane.setResizeWeight(1.0d);
		splitPane.setOneTouchExpandable(true);
		add(splitPane, BorderLayout.CENTER);
	}

	protected TransparentSplitPane createSplitPane() {
		return new TransparentSplitPane(ProMSplitPane.HORIZONTAL_SPLIT);
	}

	public MasterView<M, D> getMasterView() {
		return masterView;
	}

	public DetailView<D> getDetailView() {
		return detailView;
	}

	public TransparentSplitPane getSplitPane() {
		return splitPane;
	}

	public void disableDetailUpdates() {
		doUpdates = false;
	}

	public void enableDetailUpdates() {
		doUpdates = true;
	}

	protected void onBeforeUpdate(int[] selectedIndicies) {
		detailView.getDetailList().beforeUpdate();
	}

	private void onAfterUpdate() {
		detailView.getDetailList().afterUpdate();
	}

}
"
TransparentSplitPane.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.traceview.masterdetail;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.JSplitPane;
import javax.swing.border.Border;
import javax.swing.plaf.basic.BasicSplitPaneDivider;
import javax.swing.plaf.basic.BasicSplitPaneUI;

import org.processmining.framework.util.ui.widgets.WidgetColors;

public class TransparentSplitPane extends JPanel {

	private static final long serialVersionUID = 1L;

	private static class ImprovedSplitPaneDivider extends BasicSplitPaneDivider {
		/**
			 * 
			 */
		private static final long serialVersionUID = 1L;

		private ImprovedSplitPaneDivider(final BasicSplitPaneUI ui) {
			super(ui);
		}

		@Override
		public void paint(final Graphics g) {
			g.setColor(getBackground());
			g.fillRect(0, 0, getWidth(), getHeight());
			paintComponents(g);
		}

		@Override
		protected JButton createLeftOneTouchButton() {
			final JButton b = new JButton() {
				/**
					 * 
					 */
				private static final long serialVersionUID = 1L;

				// Don't want the button to participate in focus traversable.
				@Override
				@Deprecated
				public boolean isFocusTraversable() {
					return false;
				}

				@Override
				public void paint(final Graphics g) {
					if (splitPane != null) {
						final int[] xs = new int[3];
						final int[] ys = new int[3];
						int blockSize;

						// Fill the background first ...
						g.setColor(ImprovedSplitPaneDivider.this.getBackground());
						g.fillRect(0, 0, getWidth(), getHeight());

						// ... then draw the arrow.
						g.setColor(ImprovedSplitPaneDivider.this.getForeground());
						if (orientation == JSplitPane.VERTICAL_SPLIT) {
							blockSize = Math.min(getHeight(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = blockSize;
							xs[1] = 0;
							xs[2] = blockSize << 1;
							ys[0] = 0;
							ys[1] = ys[2] = blockSize;
							g.drawPolygon(xs, ys, 3); // Little trick to make the
							// arrows of equal size
						} else {
							blockSize = Math.min(getWidth(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = xs[2] = blockSize;
							xs[1] = 0;
							ys[0] = 0;
							ys[1] = blockSize;
							ys[2] = blockSize << 1;
						}
						g.fillPolygon(xs, ys, 3);
					}
				}

				@Override
				public void setBorder(final Border b) {
				}
			};
			b.setMinimumSize(new Dimension(BasicSplitPaneDivider.ONE_TOUCH_SIZE, BasicSplitPaneDivider.ONE_TOUCH_SIZE));
			b.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			b.setFocusPainted(false);
			b.setBorderPainted(false);
			b.setRequestFocusEnabled(false);
			b.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					leftClicked();
				}
			});
			return b;
		}

		/**
		 * Creates and return an instance of JButton that can be used to
		 * collapse the right component in the split pane.
		 */
		@Override
		protected JButton createRightOneTouchButton() {
			final JButton b = new JButton() {
				/**
					 * 
					 */
				private static final long serialVersionUID = 1L;

				// Don't want the button to participate in focus traversable.
				@Override
				@Deprecated
				public boolean isFocusTraversable() {
					return false;
				}

				@Override
				public void paint(final Graphics g) {
					if (splitPane != null) {
						final int[] xs = new int[3];
						final int[] ys = new int[3];
						int blockSize;

						// Fill the background first ...
						g.setColor(ImprovedSplitPaneDivider.this.getBackground());
						g.fillRect(0, 0, getWidth(), getHeight());

						// ... then draw the arrow.
						if (orientation == JSplitPane.VERTICAL_SPLIT) {
							blockSize = Math.min(getHeight(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = blockSize;
							xs[1] = blockSize << 1;
							xs[2] = 0;
							ys[0] = blockSize;
							ys[1] = ys[2] = 0;
						} else {
							blockSize = Math.min(getWidth(), BasicSplitPaneDivider.ONE_TOUCH_SIZE);
							xs[0] = xs[2] = 0;
							xs[1] = blockSize;
							ys[0] = 0;
							ys[1] = blockSize;
							ys[2] = blockSize << 1;
						}
						g.setColor(ImprovedSplitPaneDivider.this.getForeground());
						g.fillPolygon(xs, ys, 3);
					}
				}

				@Override
				public void setBorder(final Border border) {
				}
			};
			b.setMinimumSize(new Dimension(BasicSplitPaneDivider.ONE_TOUCH_SIZE, BasicSplitPaneDivider.ONE_TOUCH_SIZE));
			b.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			b.setFocusPainted(false);
			b.setBorderPainted(false);
			b.setRequestFocusEnabled(false);
			b.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed(final ActionEvent e) {
					rightClicked();
				}
			});
			return b;
		}

		protected void leftClicked() {

		}

		protected void rightClicked() {

		}
	}

	public static final int HORIZONTAL_SPLIT = JSplitPane.HORIZONTAL_SPLIT;
	public static final int VERTICAL_SPLIT = JSplitPane.VERTICAL_SPLIT;

	private JSplitPane split;
	private JPanel top, bottom;

	/**
		 * 
		 */
	public TransparentSplitPane() {
		this(TransparentSplitPane.HORIZONTAL_SPLIT);
	}

	/**
	 * @param split
	 */
	public TransparentSplitPane(final int split) {
		super(new BorderLayout());
		setOpaque(true);
		//setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		//setForeground(WidgetColors.COLOR_ENCLOSURE_BG);		
		top = new JPanel();
		top.setLayout(new BorderLayout());
		//top.setBackground(Color.LIGHT_GRAY);
		top.setOpaque(false);
		bottom = new JPanel();
		bottom.setLayout(new BorderLayout());
		//bottom.setBackground(Color.LIGHT_GRAY);
		bottom.setOpaque(false);
		this.split = new JSplitPane(split, true);
		this.split.setLeftComponent(top);
		this.split.setRightComponent(bottom);
		this.split.setBorder(BorderFactory.createEmptyBorder());
		this.split.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
		this.split.setOpaque(false);
		this.split.setUI(new BasicSplitPaneUI() {
			@Override
			public BasicSplitPaneDivider createDefaultDivider() {
				final BasicSplitPaneDivider divider = new ImprovedSplitPaneDivider(this) {
					/**
						 * 
						 */
					private static final long serialVersionUID = 1L;

					@Override
					public void leftClicked() {
						TransparentSplitPane.this.leftClicked();
					}

					@Override
					public void rightClicked() {
						TransparentSplitPane.this.rightClicked();
					}
				};
				divider.setBackground(WidgetColors.COLOR_ENCLOSURE_BG);
				divider.setForeground(Color.LIGHT_GRAY);
				return divider;
			}
		});
		add(this.split);
	}

	/**
	 * @param c
	 */
	public void setBottomComponent(final Component c) {
		bottom.removeAll();
		bottom.add(c);
		validate();
	}

	/**
	 * @param d
	 */
	public void setDividerLocation(final double d) {
		split.setDividerLocation(d);

	}

	/**
	 * @param location
	 */
	public void setDividerLocation(final int location) {
		split.setDividerLocation(location);
	}

	/**
	 * @param size
	 */
	public void setDividerSize(final int size) {
		split.setDividerSize(size);
	}

	/**
	 * @param c
	 */
	public void setLeftComponent(final Component c) {
		setTopComponent(c);
	}

	/**
	 * @param expandable
	 */
	public void setOneTouchExpandable(final boolean expandable) {
		split.setOneTouchExpandable(expandable);
	}

	/**
	 * @param d
	 */
	public void setResizeWeight(final double d) {
		split.setResizeWeight(d);
	}

	/**
	 * @param c
	 */
	public void setRightComponent(final Component c) {
		setBottomComponent(c);
	}

	/**
	 * @param c
	 */
	public void setTopComponent(final Component c) {
		top.removeAll();
		top.add(c);
		validate();
	}

	protected void leftClicked() {

	}

	protected void rightClicked() {

	}

	public void setForeground(Color fg) {
		super.setForeground(fg);
		if (top != null) {
			top.setForeground(fg);
		}
		if (bottom != null) {
			bottom.setForeground(fg);
		}
	}

	public void setBackground(Color bg) {
		super.setBackground(bg);
		// Workaround because setOpaque -> false does not work for some reason
		if (top != null) {
			top.setBackground(bg);
		}
		if (bottom != null) {
			bottom.setBackground(bg);
		}
	}

}
"
FilteredListModel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.traceview.model;

import javax.swing.ListModel;

import org.processmining.framework.util.ui.widgets.traceview.model.FilteredListModelImpl.ListModelFilter;

public interface FilteredListModel<E> {

	void filter(ListModelFilter<E> filter);

	ListModel<E> getUnfilteredListModel();

}
"
FilteredListModelImpl.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.traceview.model;

import java.util.ArrayList;
import java.util.List;

import javax.swing.AbstractListModel;
import javax.swing.ListModel;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;

/**
 * Provides a filtered {@link ListModel} based on a supplied
 * {@link ListModelFilter}.
 * 
 * @author F.Mannhardt
 *
 * @param <E>
 */
public final class FilteredListModelImpl<T extends ListModel<E>, E> extends AbstractListModel<E>
		implements FilteredListModel<E> {

	private static final long serialVersionUID = -5708650645208821099L;

	public static interface ListModelFilter<E> {
		boolean accept(E e);
	}

	private ListModelFilter<E> currentFilter;
	private final T originalListModel;
	private final List<Integer> visibleElements = new ArrayList<Integer>();

	public FilteredListModelImpl(T source) {
		originalListModel = source;
		getUnfilteredListModel().addListDataListener(new ListDataListener() {
			public void intervalRemoved(ListDataEvent e) {
				boolean changed = doFilter();
				if (!changed) {
					fireIntervalRemoved(e.getSource(), e.getIndex0(), e.getIndex1());
				}
			}

			public void intervalAdded(ListDataEvent e) {
				boolean changed = doFilter();
				if (!changed) {
					fireIntervalAdded(e.getSource(), e.getIndex0(), e.getIndex1());
				}
			}

			public void contentsChanged(ListDataEvent e) {
				boolean changed = doFilter();
				if (!changed) {
					fireContentsChanged(e.getSource(), e.getIndex0(), e.getIndex1());
				}
			}
		});
	}

	public T getUnfilteredListModel() {
		return originalListModel;
	}

	public void filter(ListModelFilter<E> f) {
		currentFilter = f;
		doFilter();
	}

	protected boolean doFilter() {
		ListModelFilter<E> f = currentFilter;
		if (f != null) {
			visibleElements.clear();
			int count = getUnfilteredListModel().getSize();
			for (int i = 0; i < count; i++) {
				if (f.accept(getUnfilteredListModel().getElementAt(i))) {
					visibleElements.add(i);
				}
			}
			fireContentsChanged(this, 0, getSize() - 1);
			return true;
		}
		return false;
	}

	@Override
	public int getSize() {
		return (currentFilter != null) ? visibleElements.size() : getUnfilteredListModel().getSize();
	}

	@Override
	public E getElementAt(int index) {
		return (currentFilter != null) ? getUnfilteredListModel().getElementAt(visibleElements.get(index))
				: getUnfilteredListModel().getElementAt(index);
	}

}"
MutableListModel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.traceview.model;

import javax.swing.ListModel;

public interface MutableListModel<T> extends ListModel<T> {

	boolean add(T element);
	
	boolean addAll(Iterable<T> elements);

	void clear();
	
}
"
SortableListModel.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.traceview.model;

import java.util.Comparator;

public interface SortableListModel<T> extends MutableListModel<T> {

	void sort(Comparator<T> comparator);
	
}
"
SortableListModelImpl.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.traceview.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import javax.swing.AbstractListModel;
import javax.swing.JList;
import javax.swing.ListModel;

/**
 * Provides a sorted {@link ListModel} based on an {@link ArrayList} for use
 * with a {@link JList}.
 * 
 * @author F. Mannhardt
 *
 * @param <T>
 */
public final class SortableListModelImpl<T> extends AbstractListModel<T> implements SortableListModel<T> {

	private static final long serialVersionUID = -8658365206622116891L;

	private final List<T> sortedList;

	public SortableListModelImpl() {
		this(Collections.<T>emptyList());
	}

	public SortableListModelImpl(Collection<T> traces) {
		super();
		this.sortedList = new ArrayList<T>(traces);
	}

	public int getSize() {
		return sortedList.size();
	}

	public T getElementAt(int index) {
		return sortedList.get(index);
	}

	public boolean add(T element) {
		if (sortedList.add(element)) {
			fireIntervalAdded(this, sortedList.size(), sortedList.size());
			return true;
		} else {
			return false;
		}
	}

	public boolean addAll(Iterable<T> elements) {
		final int sizeBefore = sortedList.size();
		boolean hasAdded = false;
		if (elements instanceof Collection) {
			hasAdded = sortedList.addAll((Collection<T>) elements);
		} else {
			for (T item : elements) {
				// Side-effect is adding the element 
				hasAdded = sortedList.add(item) || hasAdded;
			}
		}
		if (hasAdded) {
			fireIntervalAdded(this, sizeBefore + 1, sortedList.size());
			return true;
		}
		return false;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.processmining.framework.util.ui.widgets.traceview.SortableListModel#
	 * sort(java.util.Comparator)
	 */
	public void sort(Comparator<T> comparator) {
		Collections.sort(sortedList, comparator);
		fireContentsChanged(this, 0, sortedList.size());
	}

	public void clear() {
		sortedList.clear();
		fireIntervalRemoved(this, 0, sortedList.size());
	}

}"
ProMTraceList.java,widgets-6.9.234,"/*
 * Copyright (c) 2014 F. Mannhardt (f.mannhardt@tue.nl)
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package org.processmining.framework.util.ui.widgets.traceview;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.EventListener;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import javax.swing.ListCellRenderer;
import javax.swing.ListModel;
import javax.swing.event.ListSelectionListener;

import org.freehep.graphics2d.VectorGraphics;
import org.freehep.graphicsio.MultiPageDocument;
import org.freehep.graphicsio.PageConstants;
import org.freehep.graphicsio.VectorGraphicsIO;
import org.freehep.graphicsio.emf.EMFGraphics2D;
import org.freehep.graphicsio.pdf.PDFGraphics2D;
import org.freehep.graphicsio.ps.EPSGraphics2D;
import org.freehep.graphicsio.svg.SVGGraphics2D;
import org.processmining.framework.util.ui.widgets.ProMScrollPane;
import org.processmining.framework.util.ui.widgets.traceview.ProMTraceView.DefaultEvent;
import org.processmining.framework.util.ui.widgets.traceview.ProMTraceView.DefaultTrace;
import org.processmining.framework.util.ui.widgets.traceview.ProMTraceView.Event;
import org.processmining.framework.util.ui.widgets.traceview.ProMTraceView.Trace;
import org.processmining.framework.util.ui.widgets.traceview.model.FilteredListModel;
import org.processmining.framework.util.ui.widgets.traceview.model.FilteredListModelImpl;
import org.processmining.framework.util.ui.widgets.traceview.model.FilteredListModelImpl.ListModelFilter;
import org.processmining.framework.util.ui.widgets.traceview.model.MutableListModel;
import org.processmining.framework.util.ui.widgets.traceview.model.SortableListModel;
import org.processmining.framework.util.ui.widgets.traceview.model.SortableListModelImpl;

import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * A {@link JPanel} that displays a list of arbitrary objects that are
 * visualized as ""wedges"" using {@link ProMTraceView}. It uses a {@link JList}
 * under the hood, which can be accessed directly using {@link #getList()}.
 * <p>
 * To use this component you need to create a {@link TraceBuilder} that takes
 * any of your objects and returns a {@link Trace} of {@link Event}s. This
 * conversion happens on-the-fly and only for the objects that are currently
 * shown to the user. Therefore, the performance overhead should be small.
 * <p>
 * There are default implementations {@link DefaultTrace} and
 * {@link DefaultEvent} available for convenience. If your class already
 * implements {@link Trace}, then use the provided {@link NoOpTraceBuilder}.
 * <p>
 * It is possible to sort and filter the list by using an appropriate
 * {@link ListModel}. Such as {@link SortableListModelImpl} or
 * {@link FilteredListModelImpl}.
 * <p>
 * It is also possible to listen for click, selection and mouse movement events
 * on an element of the list by using
 * {@link #addTraceClickListener(ClickListener)}.
 * {@link #addTraceSelectionListener(ListSelectionListener)}, as well as
 * {@link #addTraceMoveListener(MoveListener)}.
 * 
 * @author F. Mannhardt
 * 
 * @param <T>
 *            the class of objects that are to be visualized
 */
public class ProMTraceList<T> extends JPanel {

	public interface ClickListener<T> extends EventListener {

		/**
		 * Event that the user has double clicked on a trace.
		 * 
		 * @param trace
		 *            the object that has been clicked on
		 * @param traceIndex
		 *            the index of the trace in the list
		 * @param eventIndex
		 *            the index of the event that has been clicked on or -1 in
		 *            case not event was below the mouse pointer
		 * @param e
		 *            the original {@link MouseEvent}
		 */
		public void traceMouseDoubleClicked(T trace, int traceIndex, int eventIndex, MouseEvent e);

		/**
		 * Event that the user has clicked on a trace.
		 * 
		 * @param trace
		 *            the object that has been clicked on
		 * @param traceIndex
		 *            the index of the trace in the list
		 * @param eventIndex
		 *            the index of the event that has been clicked on or -1 in
		 *            case not event was below the mouse pointer
		 * @param e
		 *            the original {@link MouseEvent}
		 */
		public void traceMouseClicked(T trace, int traceIndex, int eventIndex, MouseEvent e);

	}

	public interface MoveListener<T> extends EventListener {

		/**
		 * Event that the user has moved the mouse over a trace.
		 * 
		 * @param trace
		 *            the object that has been moved over
		 * @param traceIndex
		 *            the index of the trace in the list
		 * @param eventIndex
		 *            the index of the event or -1 in case no event was below
		 *            the mouse pointer
		 * @param e
		 *            the original {@link MouseEvent}
		 */
		public void traceMouseMoved(T trace, int traceIndex, int eventIndex, MouseEvent e);

	}

	/**
	 * Builds {@link Trace} objects for object of class T.
	 * 
	 * @author F. Mannhardt
	 * 
	 * @param <T>
	 *            class of object that is converted to a {@link Trace}
	 */
	public interface TraceBuilder<T> {

		/**
		 * @param element
		 * @return a {@link Trace}
		 */
		Trace<? extends Event> build(T element);

	}

	/**
	 * Can be used to override the default coloring of an {@link Event} based on
	 * some other information. If only one of the colors needs to be overridden,
	 * please use {@link DefaultWedgeBuilder}.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public interface WedgeBuilder {

		Color buildNameColor(Trace<? extends Event> trace);

		Color buildInfoColor(Trace<? extends Event> trace);

		Color buildWedgeColor(Trace<? extends Event> trace, Event event);

		Integer assignWedgeGap(Trace<? extends Event> trace, Event event);

		Stroke buildBorderStroke(Trace<? extends Event> trace, Event event);

		Color buildBorderColor(Trace<? extends Event> trace, Event event);

		Color buildLabelColor(Trace<? extends Event> trace, Event event);

		Color buildTopLabelColor(Trace<? extends Event> trace, Event event);

		Color buildBottomLabelColor(Trace<? extends Event> trace, Event event);

		Color buildBottom2LabelColor(Trace<? extends Event> trace, Event event);

	}

	/**
	 * {@link WedgeBuilder} that simply returns the original color of an
	 * {@link Event}. Override single methods to change the color.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static class DefaultWedgeBuilder implements WedgeBuilder {

		public Color buildWedgeColor(Trace<? extends Event> trace, Event event) {
			return event.getWedgeColor();
		}

		public Color buildLabelColor(Trace<? extends Event> trace, Event event) {
			return event.getLabelColor();
		}

		public Color buildTopLabelColor(Trace<? extends Event> trace, Event event) {
			return event.getTopLabelColor();
		}

		public Color buildBottomLabelColor(Trace<? extends Event> trace, Event event) {
			return event.getBottomLabelColor();
		}

		public Color buildBottom2LabelColor(Trace<? extends Event> trace, Event event) {
			return event.getBottomLabel2Color();
		}

		public Color buildBorderColor(Trace<? extends Event> trace, Event event) {
			return event.getBorderColor();
		}

		public Integer assignWedgeGap(Trace<? extends Event> trace, Event event) {
			return null;
		}

		public Stroke buildBorderStroke(Trace<? extends Event> trace, Event e) {
			return null;
		}

		public Color buildNameColor(Trace<? extends Event> trace) {
			return trace.getNameColor();
		}

		public Color buildInfoColor(Trace<? extends Event> trace) {
			return trace.getInfoColor();
		}

	}

	/**
	 * {@link WedgeBuilder} that delegates all methods to another
	 * {@link WedgeBuilder}.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static class DelegateWedgeBuilder extends DefaultWedgeBuilder {

		private final WedgeBuilder wedgeBuilder;

		public DelegateWedgeBuilder(WedgeBuilder wedgeBuilder) {
			this.wedgeBuilder = wedgeBuilder;
		}

		public Color buildWedgeColor(Trace<? extends Event> trace, Event event) {
			Color color = wedgeBuilder.buildWedgeColor(trace, event);
			if (color != null) {
				return color;
			}
			return super.buildWedgeColor(trace, event);
		}

		public Color buildLabelColor(Trace<? extends Event> trace, Event event) {
			Color color = wedgeBuilder.buildLabelColor(trace, event);
			if (color != null) {
				return color;
			}
			return super.buildLabelColor(trace, event);
		}

		public Color buildTopLabelColor(Trace<? extends Event> trace, Event event) {
			Color color = wedgeBuilder.buildTopLabelColor(trace, event);
			if (color != null) {
				return color;
			}
			return super.buildTopLabelColor(trace, event);
		}

		public Color buildBottomLabelColor(Trace<? extends Event> trace, Event event) {
			Color color = wedgeBuilder.buildBottomLabelColor(trace, event);
			if (color != null) {
				return color;
			}
			return super.buildBottomLabelColor(trace, event);
		}

		public Color buildBottom2LabelColor(Trace<? extends Event> trace, Event event) {
			Color color = wedgeBuilder.buildBottom2LabelColor(trace, event);
			if (color != null) {
				return color;
			}
			return super.buildBottom2LabelColor(trace, event);
		}

		public Color buildBorderColor(Trace<? extends Event> trace, Event event) {
			Color color = wedgeBuilder.buildBorderColor(trace, event);
			if (color != null) {
				return color;
			}
			return super.buildBorderColor(trace, event);
		}

		public Integer assignWedgeGap(Trace<? extends Event> trace, Event event) {
			Integer wedgeGap = wedgeBuilder.assignWedgeGap(trace, event);
			if (wedgeGap != null) {
				return wedgeGap;
			}
			return super.assignWedgeGap(trace, event);
		}

		public Stroke buildBorderStroke(Trace<? extends Event> trace, Event e) {
			Stroke wedgeStroke = wedgeBuilder.buildBorderStroke(trace, e);
			if (wedgeStroke != null) {
				return wedgeStroke;
			}
			return super.buildBorderStroke(trace, e);
		}

		public Color buildNameColor(Trace<? extends Event> trace) {
			Color color = wedgeBuilder.buildNameColor(trace);
			if (color != null) {
				return color;
			}
			return super.buildNameColor(trace);
		}

		public Color buildInfoColor(Trace<? extends Event> trace) {
			Color color = wedgeBuilder.buildInfoColor(trace);
			if (color != null) {
				return color;
			}
			return super.buildInfoColor(trace);
		}

	}

	/**
	 * TraceBuilder that just returns a class, which already implements
	 * {@link Trace}.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static class NoOpTraceBuilder<T extends Event> implements TraceBuilder<Trace<T>> {

		public Trace<? extends Event> build(Trace<T> e) {
			return e;
		}

	}

	private static final Font DEFAULT_FONT = new Font(null, Font.PLAIN, 10);

	private final static class ProMTraceListMouseAdapter<T> extends MouseAdapter {

		private final Set<ClickListener<T>> clickListener;
		private final Set<MoveListener<T>> moveListener;
		private final JList<T> list;
		private ProMTraceViewCellRenderer<T> cellRenderer;

		private ProMTraceListMouseAdapter(JList<T> list, ProMTraceViewCellRenderer<T> cellRenderer,
				Set<ClickListener<T>> clickListener, Set<MoveListener<T>> moveListener) {
			super();
			this.list = list;
			this.cellRenderer = cellRenderer;
			this.clickListener = clickListener;
			this.moveListener = moveListener;
		}

		public void mouseClicked(MouseEvent e) {

			if (!clickListener.isEmpty()) {
				final int traceIndex = getTraceIndex(e);
				if (traceIndex != -1) {
					final T trace = list.getModel().getElementAt(traceIndex);
					final int eventIndex = getEventIndex(traceIndex, trace, e);

					for (ClickListener<T> listener : clickListener) {
						if (e.getClickCount() == 2) {
							listener.traceMouseDoubleClicked(trace, traceIndex, eventIndex, e);
						} else if (e.getClickCount() == 1) {
							listener.traceMouseClicked(trace, traceIndex, eventIndex, e);
						}
					}
				}
			}
		}

		public void mouseMoved(MouseEvent e) {

			if (!moveListener.isEmpty()) {
				final int traceIndex = getTraceIndex(e);
				if (traceIndex != -1) {
					final T trace = list.getModel().getElementAt(traceIndex);
					final int eventIndex = getEventIndex(traceIndex, trace, e);

					for (MoveListener<T> listener : moveListener) {
						listener.traceMouseMoved(trace, traceIndex, eventIndex, e);
					}
				}
			}
		}

		private int getEventIndex(int traceIndex, T trace, MouseEvent e) {
			return cellRenderer.translateToEventIndex(e.getPoint(), trace, list.isSelectedIndex(traceIndex));
		}

		private int getTraceIndex(MouseEvent e) {
			Rectangle r = list.getCellBounds(0, list.getLastVisibleIndex());
			if (r != null && r.contains(e.getPoint())) {
				return list.locationToIndex(e.getPoint());
			}
			return -1;
		}

	}

	/**
	 * The {@link ListCellRenderer} used to paint the objects.
	 * 
	 * @author F. Mannhardt
	 * 
	 * @param <T>
	 */
	private final static class ProMTraceViewCellRenderer<E> extends ProMTraceView implements ListCellRenderer<E> {

		private static final long serialVersionUID = -2495069999724478333L;

		private TraceBuilder<E> traceBuilder;
		private E currentValue;
		private int fixedWidthLimit = DEFAULT_FIXED_WIDTH_TRACE_COUNT;

		private final ListModel<E> listModel;

		public ProMTraceViewCellRenderer(ListModel<E> listModel, TraceBuilder<E> traceBuilder, Font defaultFont,
				boolean hasLabels) {
			super(defaultFont, hasLabels);
			this.listModel = listModel;
			setTraceBuilder(traceBuilder);
			setOpaque(false);
		}

		@Override
		public Component getListCellRendererComponent(JList<? extends E> list, E value, int index, boolean isSelected,
				boolean cellHasFocus) {
			if (value != currentValue) {
				setTrace(getTraceBuilder().build(value));
				updatePreferredSize();
			}
			currentValue = value;
			setSelected(isSelected);
			setForeground(list.getForeground());
			return this;
		}

		public int translateToEventIndex(Point point, E value, boolean isSelected) {
			if (value != currentValue) {
				setTrace(getTraceBuilder().build(value));
				updatePreferredSize();
			}
			currentValue = value;
			setSelected(isSelected);
			return translateToEventIndex(point);
		}

		public int translateToDetailedEventIndex(Point point, E value, boolean isSelected) {
			if (value != currentValue) {
				setTrace(getTraceBuilder().build(value));
				updatePreferredSize();
			}
			currentValue = value;
			setSelected(isSelected);
			return translateToDetailedEventIndex(point);
		}

		public TraceBuilder<E> getTraceBuilder() {
			return traceBuilder;
		}

		public void setTraceBuilder(TraceBuilder<E> traceBuilder) {
			this.currentValue = null;
			this.traceBuilder = traceBuilder;
		}

		public int getFixedWidthLimit() {
			return fixedWidthLimit;
		}

		public void setFixedWidthLimit(int fixedWidthLimit) {
			this.currentValue = null;
			this.fixedWidthLimit = fixedWidthLimit;
		}

		@Override
		public int getFixedWedgeWidth() {
			// listModel might be have been initialized yet
			if (listModel != null && listModel.getSize() > getFixedWidthLimit()) {
				// Override the wedge width, either with max width or the preset fixed width
				return super.getFixedWedgeWidth() == -1 ? getMaxWedgeWidth() : super.getFixedWedgeWidth();
			} else {
				// Return the normal setting
				return super.getFixedWedgeWidth();
			}
		}

		@Override
		public int getFixedInfoWidth() {
			// listModel might be have been initialized yet
			if (listModel != null && listModel.getSize() > getFixedWidthLimit()) {
				// Override the info width, either with max width or the preset fixed width
				return super.getFixedInfoWidth() == -1 ? getMaxInfoWidth() : super.getFixedInfoWidth();
			} else {
				// Return the normal setting
				return super.getFixedInfoWidth();
			}
		}

		@Override
		public String getToolTipText(MouseEvent e) {
			int event = translateToDetailedEventIndex(e.getPoint(), currentValue, isSelected());
			if (event != -1) {
				Trace<?> tr = traceBuilder.build(currentValue);
				if (event == -2) {
					return ""<html>"" + n(tr.getName()) + ""<br>"" + n(tr.getInfo()) + ""</html>"";
				} else if (event >= 0) {
					for (Iterator<? extends Event> it = tr.iterator(); it.hasNext();) {
						Event ev = it.next();
						if (event == 0) {
							return ""<html>"" + n(ev.getTopLabel()) + ""<br>"" + n(ev.getLabel()) + ""<br>""
									+ n(ev.getBottomLabel()) + ""<br>"" + n(ev.getBottomLabel2()) + ""</html>"";
						}
						event--;
					}
				}
			}
			return null;
		}

		private String n(Object x) {
			return x == null ? """" : x.toString();
		}
	}

	private static final long serialVersionUID = -8729322696443726936L;

	public static final int DEFAULT_FIXED_WIDTH_TRACE_COUNT = 50000;

	private final ListModel<T> listModel;
	private final JList<T> jList;
	private final ProMTraceViewCellRenderer<T> cellRenderer;
	private final boolean hasLabels;

	private final JScrollPane scrollPane;

	private transient CopyOnWriteArraySet<ClickListener<T>> clickListener = new CopyOnWriteArraySet<ClickListener<T>>();
	private transient CopyOnWriteArraySet<MoveListener<T>> moveListener = new CopyOnWriteArraySet<MoveListener<T>>();

	private JProgressBar progressBar;

	private JPanel toolbar;
	private JButton selectAll;
	private JButton deselectAll;

	/**
	 * Creates an empty {@link ProMTraceList}
	 * 
	 * @param traceBuilder
	 */
	public ProMTraceList(TraceBuilder<T> traceBuilder) {
		this(Collections.<T>emptyList(), traceBuilder);
	}

	/**
	 * Creates a filterable and sortable {@link ProMTraceList} from the supplied
	 * {@link Collection} of objects
	 * 
	 * @param traces
	 * @param traceBuilder
	 */
	public ProMTraceList(Collection<T> traces, TraceBuilder<T> traceBuilder) {
		this(traces, traceBuilder, DEFAULT_FONT);
	}

	/**
	 * Creates a filterable and sortable {@link ProMTraceList} from the supplied
	 * {@link Collection} of objects
	 * 
	 * @param traces
	 * @param traceBuilder
	 * @param labelFont
	 */
	public ProMTraceList(Collection<T> traces, TraceBuilder<T> traceBuilder, Font labelFont) {
		this(traces, traceBuilder, null, labelFont);
	}

	/**
	 * Creates a filterable and sortable {@link ProMTraceList} from the supplied
	 * {@link Collection} of objects
	 * 
	 * @param traces
	 * @param traceBuilder
	 * @param labelFont
	 * @param hasLabels
	 */
	public ProMTraceList(Collection<T> traces, TraceBuilder<T> traceBuilder, Font labelFont, boolean hasLabels) {
		this(traces, traceBuilder, null, labelFont, hasLabels);
	}

	/**
	 * Creates a filterable and sortable {@link ProMTraceList} from the supplied
	 * {@link Collection} of objects
	 * 
	 * @param traces
	 * @param traceBuilder
	 * @param order
	 */
	public ProMTraceList(Collection<T> traces, TraceBuilder<T> traceBuilder, Comparator<T> order) {
		this(traces, traceBuilder, order, DEFAULT_FONT);
	}

	public ProMTraceList(Collection<T> traces, TraceBuilder<T> traceBuilder, Comparator<T> order, Font labelFont) {
		this(traces, traceBuilder, order, labelFont, true);
	}

	/**
	 * Creates a filterable and sortable {@link ProMTraceList} from the supplied
	 * {@link Collection} of objects
	 * 
	 * @param traces
	 * @param traceBuilder
	 * @param order
	 * @param labelFont
	 * @param hasLabels
	 */
	public ProMTraceList(Collection<T> traces, TraceBuilder<T> traceBuilder, Comparator<T> order, Font labelFont,
			boolean hasLabels) {
		this(new FilteredListModelImpl<>(new SortableListModelImpl<>(traces)), traceBuilder, labelFont, hasLabels);
		if (order != null) {
			sort(order);
		}
	}

	/**
	 * Creates a {@link ProMTraceList} from the supplied {@link ListModel}, if
	 * you want your list to be sortable and filterable your {@link ListModel}
	 * needs to implement {@link FilteredListModel} and
	 * {@link SortableListModel}.
	 * 
	 * @param traceModel
	 * @param traceBuilder
	 */
	public ProMTraceList(ListModel<T> traceModel, TraceBuilder<T> traceBuilder) {
		this(traceModel, traceBuilder, DEFAULT_FONT);
	}

	public ProMTraceList(ListModel<T> traceModel, TraceBuilder<T> traceBuilder, Font labelFont) {
		this(traceModel, traceBuilder, labelFont, true);
	}

	/**
	 * Creates a {@link ProMTraceList} from the supplied {@link ListModel}, if
	 * you want your list to be sortable and filterable your {@link ListModel}
	 * needs to implement {@link FilteredListModel} and
	 * {@link SortableListModel}.
	 * 
	 * @param traces
	 * @param traceBuilder
	 * @param labelFont
	 *            to be used
	 * @param whether
	 *            there should be space for labels
	 */
	public ProMTraceList(ListModel<T> listModel, TraceBuilder<T> traceBuilder, Font labelFont, boolean hasLabels) {
		this.listModel = listModel;
		this.hasLabels = hasLabels;
		this.cellRenderer = new ProMTraceViewCellRenderer<T>(listModel, traceBuilder, labelFont, hasLabels);
		setFont(labelFont);

		jList = new JList<T>(listModel);
		jList.setFixedCellHeight((int) cellRenderer.getPreferredSize().getHeight());
		jList.setOpaque(false);
		jList.setForeground(null);
		jList.setBackground(null);
		jList.setCellRenderer(cellRenderer);

		ProMTraceListMouseAdapter<T> mouseAdapter = new ProMTraceListMouseAdapter<T>(jList, cellRenderer, clickListener,
				moveListener);
		jList.addMouseListener(mouseAdapter);
		jList.addMouseMotionListener(mouseAdapter);

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setOpaque(false);
		setForeground(null);
		setBackground(null);

		toolbar = new JPanel();
		toolbar.setMaximumSize(new Dimension(Short.MAX_VALUE, 30));
		toolbar.setOpaque(false);
		toolbar.setForeground(null);
		toolbar.setBackground(null);
		toolbar.setVisible(false);
		toolbar.setLayout(new BoxLayout(toolbar, BoxLayout.X_AXIS));
		selectAll = SlickerFactory.instance().createButton(""Select all"");
		selectAll.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				jList.setSelectionInterval(0, jList.getModel().getSize() - 1);
			}
		});
		toolbar.add(selectAll);
		toolbar.add(Box.createHorizontalStrut(5));
		deselectAll = SlickerFactory.instance().createButton(""Deselect all"");
		deselectAll.addActionListener(new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				jList.clearSelection();
			}
		});
		toolbar.add(deselectAll);
		toolbar.add(Box.createGlue());

		scrollPane = new ProMScrollPane(jList);
		scrollPane.setOpaque(false);
		scrollPane.setForeground(null);
		scrollPane.setBackground(null);
		scrollPane.getViewport().setOpaque(false);
		scrollPane.getViewport().setForeground(null);
		scrollPane.getViewport().setBackground(null);

		progressBar = new JProgressBar();
		progressBar.setIndeterminate(true);
		progressBar.setString(""Loading ..."");
		progressBar.setStringPainted(true);

		add(toolbar, BorderLayout.NORTH);
		add(scrollPane, BorderLayout.CENTER);
	}

	public void addTraceSelectionListener(ListSelectionListener l) {
		jList.addListSelectionListener(l);
	}

	public void removeTraceSelectionListener(ListSelectionListener l) {
		jList.removeListSelectionListener(l);
	}

	public void addTraceClickListener(ClickListener<T> l) {
		clickListener.add(l);
	}

	public void removeTraceClickListener(ClickListener<T> l) {
		clickListener.remove(l);
	}

	public void addTraceMoveListener(MoveListener<T> l) {
		moveListener.add(l);
	}

	public void removeTraceMoveListener(MoveListener<T> l) {
		moveListener.remove(l);
	}

	/**
	 * @return the underlying {@link JList}
	 */
	public JList<T> getList() {
		return jList;
	}

	/**
	 * @return the underlying {@link JScrollPane}
	 */
	public JScrollPane getScrollPane() {
		return scrollPane;
	}

	/**
	 * @return the underlying {@link ListModel}
	 */
	public ListModel<T> getListModel() {
		return listModel;
	}

	/****************************************************************************
	 * Methods for special ListModels, mainly here for legacy reasons. Better to
	 * use ListModel directly!
	 ****************************************************************************/

	/**
	 * Adds the element to this view. Please note your {@link ListModel} needs
	 * to implement {@link MutableListModel} otherwise an
	 * {@link UnsupportedOperationException} will be thrown.
	 * 
	 * @param element
	 * @throws UnsupportedOperationException
	 *             in case the ListModel is not mutable
	 */
	public void add(T element) {
		if (listModel instanceof FilteredListModel) {
			@SuppressWarnings(""unchecked"")
			FilteredListModel<T> filteredListModel = (FilteredListModel<T>) listModel;
			((SortableListModel<T>) filteredListModel.getUnfilteredListModel()).add(element);
		} else if (listModel instanceof MutableListModel) {
			((MutableListModel<T>) listModel).add(element);
		} else {
			throw new UnsupportedOperationException(
					""ListModel does not implement MutableListModel, please add data directly to the ListModel you supplied!"");
		}
	}

	/**
	 * Adds the elements to this view. Please note your {@link ListModel} needs
	 * to implement {@link MutableListModel} otherwise an
	 * {@link UnsupportedOperationException} will be thrown.
	 * 
	 * @param elements
	 * @throws UnsupportedOperationException
	 *             in case the ListModel is not mutable
	 */
	public void addAll(Iterable<T> elements) {
		if (listModel instanceof FilteredListModel) {
			@SuppressWarnings(""unchecked"")
			FilteredListModel<T> filteredListModel = (FilteredListModel<T>) listModel;
			((MutableListModel<T>) filteredListModel.getUnfilteredListModel()).addAll(elements);
		} else if (listModel instanceof MutableListModel) {
			((MutableListModel<T>) listModel).addAll(elements);
		} else {
			throw new UnsupportedOperationException(
					""ListModel does not implement MutableListModel, please add data directly to the ListModel you supplied!"");
		}
	}

	/**
	 * Clears the underlying data structure {@link #getListModel()}.
	 * 
	 * @throws UnsupportedOperationException
	 *             in case the ListModel is not mutable
	 */
	public void clear() {
		if (listModel instanceof FilteredListModel) {
			@SuppressWarnings(""unchecked"")
			FilteredListModel<T> filteredListModel = (FilteredListModel<T>) listModel;
			((MutableListModel<T>) filteredListModel.getUnfilteredListModel()).clear();
		} else if (listModel instanceof MutableListModel) {
			((MutableListModel<T>) listModel).clear();
		} else {
			throw new UnsupportedOperationException(
					""ListModel does not implement MutableListModel, please clear your data directly in the ListModel you supplied!"");
		}
	}

	public void sort(Comparator<T> sortOrder) {
		if (listModel instanceof FilteredListModel) {
			@SuppressWarnings(""unchecked"")
			FilteredListModel<T> filteredListModel = (FilteredListModel<T>) listModel;
			((SortableListModel<T>) filteredListModel.getUnfilteredListModel()).sort(sortOrder);
		} else if (listModel instanceof SortableListModel) {
			((SortableListModel<T>) listModel).sort(sortOrder);
		} else {
			throw new UnsupportedOperationException(
					""ListModel does not implement SortableListModel, please sort your data directly in the ListModel you supplied!"");
		}
	}

	@SuppressWarnings(""unchecked"")
	public void filter(ListModelFilter<T> filter) {
		if (listModel instanceof FilteredListModel) {
			((FilteredListModel<T>) listModel).filter(filter);
		} else {
			throw new UnsupportedOperationException(
					""ListModel does not implement FilteredListModel, please filter your data directly in the ListModel you supplied!"");
		}
	}

	/*********************************************************/

	/**
	 * Set the factor by which the color of the unselected traces is modified.
	 * For example, 1.0 will result in no change and 0.5 will darken the color.
	 * 
	 * @param attenuationFactor
	 *            non-negative factor
	 */
	public void setAttenuationFactor(float attenuationFactor) {
		cellRenderer.setAttenuationFactor(attenuationFactor);
	}

	public float getAttenuationFactor() {
		return cellRenderer.getAttenuationFactor();
	}

	public WedgeBuilder getWedgeBuilder() {
		return cellRenderer.getWedgeBuilder();
	}

	/**
	 * Use a {@link WedgeBuilder} to dynamically override the color of an
	 * {@link Event}. Use {@link DefaultWedgeBuilder}, if you only want to
	 * override a certain color.
	 * 
	 * @param wedgeBuilder
	 *            that overrides the default color of an event
	 */
	public void setWedgeBuilder(WedgeBuilder wedgeBuilder) {
		if (wedgeBuilder == null) {
			cellRenderer.setWedgeBuilder(new DefaultWedgeBuilder());
		} else {
			cellRenderer.setWedgeBuilder(new DelegateWedgeBuilder(wedgeBuilder));
		}
	}

	public int getMaxWedgeWidth() {
		return cellRenderer.getMaxWedgeWidth();
	}

	/**
	 * Set the maximum width (in pixel) of a single ""event wedge"".
	 * 
	 * @param maxWidth
	 */
	public void setMaxWedgeWidth(int maxWidth) {
		cellRenderer.setMaxWedgeWidth(maxWidth);
	}

	public int getMaxInfoWidth() {
		return cellRenderer.getMaxInfoWidth();
	}

	/**
	 * Set the maximum width (in pixel) of the trace info area.
	 * 
	 * @param maxWidth
	 */
	public void setMaxInfoWidth(int maxWidth) {
		cellRenderer.setMaxInfoWidth(maxWidth);
	}

	/**
	 * Set the fixed width (in pixel) of a single ""event wedge"". Set to -1 to
	 * enable dynamic sizing (slower) according to the length of labels.
	 * 
	 * @param fixedWidth
	 */
	public void setFixedWedgeWidth(int fixedWidth) {
		cellRenderer.setFixedWedgeWidth(fixedWidth);
	}

	/**
	 * Set the fixed width (in pixel) of the trace info area. Set to -1 to
	 * enable dynamic sizing (slower) according to the length of labels.
	 * 
	 * @param fixedWidth
	 */
	public void setFixedInfoWidth(int fixedWidth) {
		cellRenderer.setFixedInfoWidth(fixedWidth);
	}

	public int getFixedWedgeLimit() {
		return cellRenderer.getFixedWidthLimit();
	}

	/**
	 * Changes the built-in limit of events per trace that is used to determine
	 * when to switch to fixed size wedge width for performance reasons.
	 * 
	 * @param fixedWedgeLimit
	 */
	public void setFixedWedgeLimit(int fixedWedgeLimit) {
		cellRenderer.setFixedWidthLimit(fixedWedgeLimit);
	}

	public int getCollapsedLabelLength() {
		return cellRenderer.getCollapsedLabelLength();
	}

	/**
	 * Set the length of the label shown in a collapsed event, in an unselected
	 * trace.
	 * 
	 * @param collapsedLabelLength
	 */
	public void setCollapsedLabelLength(int collapsedLabelLength) {
		cellRenderer.setCollapsedLabelLength(collapsedLabelLength);
	}

	public Stroke getWedgeStroke() {
		return cellRenderer.getWedgeStroke();
	}

	/**
	 * @param wedgeStroke
	 *            the default {@link Stroke} that the wedges border is painted
	 *            with
	 */
	public void setWedgeStroke(Stroke wedgeStroke) {
		cellRenderer.setWedgeStroke(wedgeStroke);
	}

	public int getWedgeGap() {
		return cellRenderer.getWedgeGap();
	}

	/**
	 * @param wedgeGap
	 *            sets the default gap between two event wedges
	 */
	public void setWedgeGap(int wedgeGap) {
		cellRenderer.setWedgeGap(wedgeGap);
	}

	public TraceBuilder<T> getTraceBuilder() {
		return cellRenderer.getTraceBuilder();
	}

	/**
	 * @param traceBuilder
	 *            that is used to create traces out of the input objects
	 */
	public void setTraceBuilder(TraceBuilder<T> traceBuilder) {
		cellRenderer.setTraceBuilder(traceBuilder);
	}

	public void beforeUpdate() {
		setEnabled(false);
		remove(scrollPane);
		add(progressBar, BorderLayout.CENTER);
		validate();
	}

	public void afterUpdate() {
		remove(progressBar);
		add(scrollPane, BorderLayout.CENTER);
		validate();
		setEnabled(true);
	}

	public void showToolbar() {
		toolbar.setVisible(true);
	}

	public void hideToolbar() {
		toolbar.setVisible(false);
	}

	public JPanel getToolbar() {
		return toolbar;
	}

	public void setToolbar(JPanel toolbar) {
		this.toolbar = toolbar;
	}

	/********* Printing/Saving methods ********/

	private interface GraphicsExporterFactory {

		Graphics2D newGraphicsIO(Dimension pageDimension) throws FileNotFoundException, IOException;

	}

	/**
	 * Saves the list content as PDF
	 * 
	 * @param pdfTitle
	 * @param file
	 * @param graphicsExporter
	 * @throws IOException
	 */
	public static <T> void saveAsPDF(ProMTraceList<T> traceList, final String pdfTitle, final File file)
			throws IOException {
		saveUsing(new GraphicsExporterFactory() {

			public VectorGraphicsIO newGraphicsIO(Dimension pageDimension) throws FileNotFoundException {
				PDFGraphics2D vectorGraphicsIO = new PDFGraphics2D(file, pageDimension);
				vectorGraphicsIO.setMultiPage(true);
				Properties p = new Properties();
				p.setProperty(PDFGraphics2D.PAGE_SIZE, PageConstants.A4);
				p.setProperty(PDFGraphics2D.ORIENTATION, PageConstants.LANDSCAPE);
				p.setProperty(PDFGraphics2D.TITLE, pdfTitle != null ? pdfTitle : ""Trace Variants"");
				p.setProperty(PDFGraphics2D.COMPRESS, ""true"");
				p.setProperty(PDFGraphics2D.FIT_TO_PAGE, ""true"");
				p.setProperty(PDFGraphics2D.TEXT_AS_SHAPES, ""false"");
				vectorGraphicsIO.setProperties(p);
				return vectorGraphicsIO;
			}
		}, traceList);
	}

	/**
	 * Saves the list content as EMF
	 * 
	 * @param file
	 * @param graphicsExporter
	 * @throws IOException
	 */
	public static <T> void saveAsEMF(ProMTraceList<T> traceList, final File file) throws IOException {
		saveUsing(new GraphicsExporterFactory() {

			public VectorGraphicsIO newGraphicsIO(Dimension pageDimension) throws FileNotFoundException {
				return new EMFGraphics2D(file, pageDimension);
			}
		}, traceList);
	}

	/**
	 * Saves the list content as PS
	 * 
	 * @param file
	 * @param graphicsExporter
	 * @throws IOException
	 */
	public static <T> void saveAsEPS(ProMTraceList<T> traceList, final File file) throws IOException {
		saveUsing(new GraphicsExporterFactory() {

			public VectorGraphicsIO newGraphicsIO(Dimension pageDimension) throws FileNotFoundException {
				EPSGraphics2D g = new EPSGraphics2D(file, pageDimension);
				Properties p = new Properties(EPSGraphics2D.getDefaultProperties());
				p.setProperty(EPSGraphics2D.PAGE_SIZE, EPSGraphics2D.CUSTOM_PAGE_SIZE);
				p.setProperty(EPSGraphics2D.PAGE_MARGINS, ""0, 0, 0, 0"");
				p.setProperty(EPSGraphics2D.TEXT_AS_SHAPES, ""false"");
				p.put(EPSGraphics2D.CUSTOM_PAGE_SIZE, pageDimension.width + "", "" + pageDimension.height);
				g.setProperties(p);
				return g;
			}
		}, traceList);
	}

	public static <T> void saveAsSVG(ProMTraceList<T> traceList, final File file) throws IOException {
		saveUsing(new GraphicsExporterFactory() {

			public VectorGraphicsIO newGraphicsIO(Dimension pageDimension) throws IOException {
				SVGGraphics2D g = new SVGGraphics2D(file, pageDimension);
				Properties properties = new Properties(SVGGraphics2D.getDefaultProperties());
				properties.setProperty(SVGGraphics2D.TEXT_AS_SHAPES, ""false"");
				g.setProperties(properties);
				return g;
			}
		}, traceList);
	}

	/**
	 * Saves the list content as PDF
	 * 
	 * @param pdfTitle
	 * @param file
	 * @throws IOException
	 */
	public static <T> void saveUsing(GraphicsExporterFactory graphicsExporter, ProMTraceList<T> traceList)
			throws IOException {

		List<T> currentElements = new ArrayList<>();
		for (int i = 0; i < traceList.getListModel().getSize(); i++) {
			currentElements.add(traceList.getListModel().getElementAt(i));
		}

		ProMTraceList<T> listForPrinting = new ProMTraceList<>(currentElements, traceList.getTraceBuilder(),
				traceList.getFont(), traceList.hasLabels());
		listForPrinting.setBackground(traceList.getBackground());
		listForPrinting.setForeground(traceList.getForeground());
		listForPrinting.setAttenuationFactor(traceList.getAttenuationFactor());
		listForPrinting.setWedgeBuilder(traceList.getWedgeBuilder());
		listForPrinting.setWedgeGap(traceList.getWedgeGap());
		listForPrinting.setWedgeStroke(traceList.getWedgeStroke());
		listForPrinting.setOpaque(true);

		JFrame printFrame = new JFrame();

		try {

			JList<T> list = listForPrinting.getList();

			printFrame.add(list);
			printFrame.pack();

			Dimension pageDimension = new Dimension(list.getWidth(), list.getHeight());

			Graphics2D graphicsIO = graphicsExporter.newGraphicsIO(pageDimension);

			if (graphicsIO instanceof VectorGraphicsIO) {
				((VectorGraphics) graphicsIO).startExport();
			}

			if (graphicsIO instanceof MultiPageDocument) {

				int tracesPerPage = 10;
				int pageCount = Math.max(1, currentElements.size() / tracesPerPage);
				int currentStartIndex = 0;

				for (int i = 0; i < pageCount; i++) {

					List<T> pageTraces = currentElements.subList(currentStartIndex,
							Math.min(currentStartIndex + tracesPerPage, currentElements.size()));

					listForPrinting.clear();
					listForPrinting.addAll(pageTraces);
					printFrame.pack();

					pageDimension = new Dimension(listForPrinting.getList().getWidth(), list.getHeight());

					((MultiPageDocument) graphicsIO).openPage(pageDimension, ""Page "" + i);
					list.print(graphicsIO);
					((MultiPageDocument) graphicsIO).closePage();

					currentStartIndex = currentStartIndex + tracesPerPage;
				}
			} else {
				list.print(graphicsIO);
			}

			if (graphicsIO instanceof VectorGraphicsIO) {
				((VectorGraphics) graphicsIO).endExport();
			}

		} finally {
			printFrame.dispose();
		}
	}

	public JButton getSelectAllButton() {
		return selectAll;
	}

	public JButton getDeselectAllButton() {
		return deselectAll;
	}

	public boolean hasLabels() {
		return hasLabels;
	}

}"
ProMTraceView.java,widgets-6.9.234,"/*
 * Copyright (c) 2014 F. Mannhardt (f.mannhardt@tue.nl) Original Copyright for
 * the 'wedge' drawing code Copyright (c) 2007 Christian W. Guenther
 * (christian@deckfour.org)
 * 
 * LICENSE:
 * 
 * This code is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 */
package org.processmining.framework.util.ui.widgets.traceview;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Stroke;
import java.awt.event.MouseListener;
import java.awt.font.LineBreakMeasurer;
import java.awt.font.TextAttribute;
import java.awt.font.TextLayout;
import java.text.AttributedString;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javax.swing.JComponent;
import javax.swing.JList;
import javax.swing.ListCellRenderer;

import org.processmining.framework.util.ui.widgets.traceview.ProMTraceList.DefaultWedgeBuilder;
import org.processmining.framework.util.ui.widgets.traceview.ProMTraceList.WedgeBuilder;

import com.google.common.collect.ForwardingList;

/**
 * Displays a {@link Trace} of {@link Event}s as a sequence of wedges. This
 * implementation is similar to the class TraceView in the LogDialog package,
 * but it neither allows nor relies on {@link MouseListener}, so it may be used
 * as a rubber stamp in a {@link ListCellRenderer} of {@link JList}.
 * 
 * @author F. Mannhardt
 * 
 */
public class ProMTraceView extends JComponent {

	/**
	 * A Trace is just a sequence of events.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static interface Trace<T extends Event> extends Iterable<T> {

		/**
		 * @return name of the trace that is displayed in front of it
		 */
		String getName();

		/**
		 * @return the text color of the name label
		 */
		Color getNameColor();

		/**
		 * @return extra information about the trace that is displayed below the
		 *         name
		 */
		String getInfo();

		/**
		 * @return the text color of the info label
		 */
		Color getInfoColor();

	}

	/**
	 * An Event with labels and colors. It is safe for methods to return NULL.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static interface Event {

		/**
		 * @return the color of the wedge
		 */
		Color getWedgeColor();

		/**
		 * @return the color of the border
		 */
		Color getBorderColor();

		/**
		 * @return the label of this event
		 */
		String getLabel();

		/**
		 * @return the text color of the label
		 */
		Color getLabelColor();

		/**
		 * @return label that is displayed on top of the event
		 */
		String getTopLabel();

		/**
		 * @return the text color of the top label
		 */
		Color getTopLabelColor();

		/**
		 * @return label that is displayed in the first row below of the event
		 */
		String getBottomLabel();

		/**
		 * @return the text color of the bottom label
		 */
		Color getBottomLabelColor();

		/**
		 * @return label that is displayed in the second row below of the event
		 */
		String getBottomLabel2();

		/**
		 * @return the text color of the second bottom label
		 */
		Color getBottomLabel2Color();

	}

	public static interface SplittedEvent extends Event {

		String getUpperLabel();

		Color getUpperColor();

		String getLowerLabel();

		Color getLowerColor();

	}

	public static interface ExtendedEvent extends Event {

		Color getExtendedColor();

		String getExtendedLabel();

	}

	/**
	 * An abstract implementation of the {@link Trace} interface. This class
	 * provides an empty list, please override the {@link #delegate()} method to
	 * provide your own list.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public abstract static class AbstractTrace<T extends Event> extends ForwardingList<T> implements Trace<T> {

		public String getName() {
			return EMPTY_LABEL;
		}

		public String getInfo() {
			return EMPTY_LABEL;
		}

		public Color getNameColor() {
			return null;
		}

		public Color getInfoColor() {
			return null;
		}

		protected List<T> delegate() {
			return Collections.emptyList();
		}

	}

	/**
	 * An abstract implementation of {@link Event} that returns an empty event.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public abstract static class AbstractEvent implements Event {

		public String getLabel() {
			return EMPTY_LABEL;
		}

		public Color getWedgeColor() {
			return DEFAULT_COLOR;
		}

		public String getTopLabel() {
			return EMPTY_LABEL;
		}

		public String getBottomLabel() {
			return EMPTY_LABEL;
		}

		public String getBottomLabel2() {
			return EMPTY_LABEL;
		}

		public Color getLabelColor() {
			return null;
		}

		public Color getTopLabelColor() {
			return null;
		}

		public Color getBottomLabelColor() {
			return null;
		}

		public Color getBottomLabel2Color() {
			return null;
		}

		public Color getBorderColor() {
			return DEFAULT_BORDER_COLOR;
		}

	}

	/**
	 * A default implementation of the {@link Trace} interface.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static class DefaultTrace<T extends Event> extends AbstractTrace<T> {

		private List<T> list;

		private String name;
		private String info;

		public DefaultTrace() {
			this(EMPTY_LABEL, EMPTY_LABEL);
		}

		public DefaultTrace(String name, String info) {
			this(name, info, 16);
		}

		public DefaultTrace(String name, String info, int initialCapacity) {
			super();
			this.list = new ArrayList<T>(initialCapacity);
			this.name = name;
			this.info = info;
		}

		protected List<T> delegate() {
			return list;
		}

		public String getName() {
			return name;
		}

		public String getInfo() {
			return info;
		}

	}

	/**
	 * A default implementation of the {@link Event} interface.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static class DefaultEvent extends AbstractEvent {

		private final Color color;
		private final String label;
		private final String topLabel;
		private final String bottomLabel;
		private final String bottomLabel2;

		public DefaultEvent() {
			this(DEFAULT_COLOR, EMPTY_LABEL, EMPTY_LABEL, EMPTY_LABEL, EMPTY_LABEL);
		}

		public DefaultEvent(String label) {
			this(DEFAULT_COLOR, label);
		}

		public DefaultEvent(Color color, String label) {
			this(color, label, EMPTY_LABEL, EMPTY_LABEL, EMPTY_LABEL);
		}

		public DefaultEvent(Color color, String label, String topLabel, String bottomLabel, String bottomLabel2) {
			super();
			this.color = color;
			this.label = label;
			this.topLabel = topLabel;
			this.bottomLabel = bottomLabel;
			this.bottomLabel2 = bottomLabel2;
		}

		public String getLabel() {
			return label;
		}

		public Color getWedgeColor() {
			return color;
		}

		public String getTopLabel() {
			return topLabel;
		}

		public String getBottomLabel() {
			return bottomLabel;
		}

		public String getBottomLabel2() {
			return bottomLabel2;
		}

		public Color getBorderColor() {
			return null;
		}

	}

	/**
	 * Abstract base class for {@link SplittedEvent}.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static abstract class AbstractSplittedEvent extends AbstractEvent implements SplittedEvent {

		public String getUpperLabel() {
			return getLabel();
		}

		public Color getUpperColor() {
			return getWedgeColor();
		}

		public String getLowerLabel() {
			return getLabel();
		}

		public Color getLowerColor() {
			return getWedgeColor();
		}

	}

	/**
	 * Default implementation of {@link SplittedEvent}.
	 * 
	 * @author F. Mannhardt
	 * 
	 */
	public static class DefaultSplittedEvent extends DefaultEvent implements SplittedEvent {

		private String upperLabel;
		private String lowerLabel;
		private Color upperColor;
		private Color lowerColor;

		public DefaultSplittedEvent(Color upperColor, String upperLabel, Color lowerColor, String lowerLabel) {
			super();
			this.upperColor = upperColor;
			this.upperLabel = upperLabel;
			this.lowerColor = lowerColor;
			this.lowerLabel = lowerLabel;
		}

		public DefaultSplittedEvent(Color upperColor, String upperLabel, Color lowerColor, String lowerLabel,
				String topLabel, String bottomLabel, String bottomLabel2) {
			super(null, null, topLabel, bottomLabel, bottomLabel2);
			this.upperColor = upperColor;
			this.upperLabel = upperLabel;
			this.lowerColor = lowerColor;
			this.lowerLabel = lowerLabel;
		}

		@Override
		public String getUpperLabel() {
			return upperLabel;
		}

		@Override
		public Color getUpperColor() {
			return upperColor;
		}

		@Override
		public String getLowerLabel() {
			return lowerLabel;
		}

		@Override
		public Color getLowerColor() {
			return lowerColor;
		}

	}

	public static abstract class AbstractExtendedEvent extends AbstractEvent implements ExtendedEvent {

		public Color getExtendedColor() {
			return null;
		}

		public String getExtendedLabel() {
			return null;
		}

	}

	private static final long serialVersionUID = -2403943214348555300L;

	public static final String EMPTY_LABEL = new String();

	private static final Color DEFAULT_COLOR = Color.LIGHT_GRAY;
	private static final Color DEFAULT_BORDER_COLOR = Color.BLACK;

	private static final int WEDGE_HEIGHT = 40;
	private static final int MINIMUM_WEDGE_WIDTH = 15;

	private static final int ELEMENT_TRI_OFFSET = 6;
	private static final int ELEMENT_X_OFFSET = 5;

	private static final int LABEL_Y_OFFSET = 1;
	private static final int LABEL_X_OFFSET = 9;

	private static final int TOP_LABEL_Y_OFFSET = 0;
	private static final int TOP_LABEL_X_OFFSET = 5;

	private static final int BOTTOM_LABEL_Y_OFFSET = 0;
	private static final int BOTTOM_LABEL_X_OFFSET = 5;

	private static final int NAME_INFO_X_OFFSET = 2;

	private static final String ABBREVIATION_SUFFIX = ""..."";

	private final int elementHeight;
	private final int halfElementHeight;
	private final Font defaultFont;

	private Dimension cachedPreferredSize;

	private int maxInfoWidth = 85;
	private int fixedInfoWidth = -1;

	private int maxWedgeWidth = 130;
	private int fixedWedgeWidth = -1;

	private int collapsedLabelLength = 3;
	private int wedgeGap = 0;

	private float attenuationFactor = 0.9f;
	private Stroke wedgeStroke = new BasicStroke();

	private Trace<? extends Event> trace;
	private boolean isSelected;

	private WedgeBuilder wedgeBuilder;

	private FontMetrics fontMetric;

	/**
	 * Creates a new instance of {@link ProMTraceView} that paints a
	 * {@link Trace} consisting of {@link Event}'s. You need to call the method
	 * {@link #setTrace(Trace, boolean)} to actually display something. That is
	 * because this class is used together with {@link JList} and, therefore,
	 * the displayed {@link Trace} needs to be changeable.
	 */
	public ProMTraceView() {
		this(new Font(Font.SANS_SERIF, Font.PLAIN, 10));
	}

	public ProMTraceView(Font font) {
		this(font, true);
	}

	/**
	 * Creates a new instance of {@link ProMTraceView} that paints a
	 * {@link Trace} consisting of {@link Event}'s. You need to call the method
	 * {@link #setTrace(Trace, boolean)} to actually display something. That is
	 * because this class is used together with {@link JList} and, therefore,
	 * the displayed {@link Trace} needs to be changeable.
	 * 
	 * @param colorBuilder
	 * 
	 * @param font
	 *            the font to be used
	 * @param hasLabels
	 *            whether the wedge has labels
	 */
	public ProMTraceView(Font font, boolean hasLabels) {
		this.setWedgeBuilder(new DefaultWedgeBuilder());
		this.isSelected = false;
		this.defaultFont = font;
		this.trace = new DefaultTrace<Event>();
		this.fontMetric = getFontMetrics(getDefaultFont());
		if (hasLabels) {
			this.elementHeight = 40 + fontMetric.getHeight() * 3 + 5;
		} else {
			this.elementHeight = 40 + 25;
		}
		this.halfElementHeight = elementHeight / 2;
		updatePreferredSize();
		setDoubleBuffered(true);
		setOpaque(false);
	}

	public boolean isOpaque() {
		return false;
	}

	/**
	 * Updates the currently displayed trace
	 * 
	 * @param trace
	 */
	public void setTrace(Trace<? extends Event> trace) {
		this.trace = trace;
	}

	/**
	 * Updates the selection status of the currently displayed trace
	 * 
	 * @param isSelected
	 */
	public void setSelected(boolean isSelected) {
		this.isSelected = isSelected;
	}
	
	public boolean isSelected() {
		return isSelected;
	}

	public Trace<? extends Event> getTrace() {
		return trace;
	}

	public void updatePreferredSize() {
		this.cachedPreferredSize = calcPreferredSize();
	}

	public void updatePreferredSize(Dimension size) {
		this.cachedPreferredSize = size;
	}

	protected void paintChildren(Graphics g) {
		// No op
	}

	protected void paintBorder(Graphics g) {
		//No op
	}

	protected void printComponent(Graphics g) {
		boolean wasSelected = isSelected;
		try {
			isSelected = true;
			super.printComponent(g);
		} finally {
			isSelected = wasSelected;
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
	 */
	@Override
	protected void paintComponent(Graphics g) {

		Iterator<? extends Event> iterator = trace.iterator();

		if (iterator.hasNext()) {
			Graphics2D g2d = (Graphics2D) g;
			g2d.setFont(getDefaultFont());
			g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
			g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);

			FontMetrics fontMetrics = g2d.getFontMetrics();
			int fontHeight = fontMetrics.getHeight();
			int nameInfoWidth = getNameInfoWidth(fontMetrics);

			Dimension preferredSize = getPreferredSize();
			Rectangle visibleRegion = g.getClipBounds();
			Rectangle completeRegion = new Rectangle(preferredSize.width, preferredSize.height);

			int wedgeYOffset = fontHeight + TOP_LABEL_Y_OFFSET;
			int y = completeRegion.y + wedgeYOffset + 2;
			int x = completeRegion.x;

			// draw name / info			
			x += NAME_INFO_X_OFFSET;

			if (isInVisibleRegion(visibleRegion, x, nameInfoWidth + 2 * NAME_INFO_X_OFFSET)) {
				if (!isEmpty(trace.getInfo()) && !isEmpty(trace.getName())) {
					drawTraceLabel(g2d, x, y + fontHeight, wedgeBuilder.buildNameColor(trace), trace.getName());
					drawTraceLabel(g2d, x, y + 2 * fontHeight, wedgeBuilder.buildInfoColor(trace), trace.getInfo());
				} else if (!isEmpty(trace.getName())) {
					drawTraceLabel(g2d, x, (int) (y + 1.5 * fontHeight), wedgeBuilder.buildNameColor(trace),
							trace.getName());
				}
			}

			// draw events			
			x += NAME_INFO_X_OFFSET;
			x += nameInfoWidth;
			x += ELEMENT_X_OFFSET;

			boolean hasPainted = false;

			while (iterator.hasNext()) {
				Event e = iterator.next();

				// position & wedge width calculations
				int currentEventWidth;
				int wedgeGap = getWedgeGap(trace, e);
				if (isSelected) {
					currentEventWidth = getExpandedEventWidth(e, fontMetrics);
				} else {
					currentEventWidth = getCollapsedEventWidth(e, fontMetrics);
				}

				// check if we should paint
				if (isInVisibleRegion(visibleRegion, x, currentEventWidth + wedgeGap)) {

					// color & stroke
					Color color = nullSafeColor(wedgeBuilder.buildWedgeColor(trace, e));
					Color strokeColor = nullSafeColor(wedgeBuilder.buildBorderColor(trace, e));
					Stroke stroke = getWedgeStroke(trace, e);

					// actual painting
					if (isSelected) {
						drawEventWedge(g2d, e, color, strokeColor, stroke, x, wedgeYOffset, currentEventWidth,
								WEDGE_HEIGHT, isSelected);

						if (e instanceof SplittedEvent) {
							SplittedEvent splittedEvent = (SplittedEvent) e;
							if (!isEmpty(splittedEvent.getUpperLabel())) {
								drawFullLabel(g2d, wedgeBuilder.buildLabelColor(trace, e), color,
										splittedEvent.getUpperLabel(), x, wedgeYOffset, currentEventWidth,
										halfElementHeight);
							}
							if (!isEmpty(splittedEvent.getLowerLabel())) {
								drawFullLabel(g2d, wedgeBuilder.buildLabelColor(trace, e), color,
										splittedEvent.getLowerLabel(), x,
										wedgeYOffset + 2 * fontMetrics.getAscent() - 2, currentEventWidth,
										halfElementHeight);
							}
						} else {
							if (!isEmpty(e.getLabel())) {
								drawFullLabel(g2d, wedgeBuilder.buildLabelColor(trace, e), color, e.getLabel(), x,
										wedgeYOffset, currentEventWidth, elementHeight);
							}
						}

						if (e instanceof ExtendedEvent) {
							ExtendedEvent extendedEvent = (ExtendedEvent) e;
							drawExtendedInfo(g2d, extendedEvent.getExtendedColor(), extendedEvent.getExtendedLabel(), x,
									TOP_LABEL_Y_OFFSET, currentEventWidth);
						}

						if (!isEmpty(e.getTopLabel()) && !(e instanceof ExtendedEvent)) {
							drawExtraLabel(g2d, wedgeBuilder.buildTopLabelColor(trace, e), e.getTopLabel(),
									x + TOP_LABEL_X_OFFSET, TOP_LABEL_Y_OFFSET, currentEventWidth);
						}
						if (!isEmpty(e.getBottomLabel())) {
							drawExtraLabel(g2d, wedgeBuilder.buildBottomLabelColor(trace, e), e.getBottomLabel(),
									x + BOTTOM_LABEL_X_OFFSET, BOTTOM_LABEL_Y_OFFSET + WEDGE_HEIGHT + wedgeYOffset,
									currentEventWidth);
						}
						if (!isEmpty(e.getBottomLabel2())) {
							drawExtraLabel(g2d, wedgeBuilder.buildBottom2LabelColor(trace, e), e.getBottomLabel2(),
									x + BOTTOM_LABEL_X_OFFSET,
									BOTTOM_LABEL_Y_OFFSET + WEDGE_HEIGHT + wedgeYOffset + fontHeight,
									currentEventWidth);
						}
					} else {
						drawEventWedge(g2d, e, color, strokeColor, stroke, x, wedgeYOffset, currentEventWidth,
								WEDGE_HEIGHT, isSelected);

						if (e instanceof SplittedEvent) {
							SplittedEvent splittedEvent = (SplittedEvent) e;
							if (!isEmpty(splittedEvent.getUpperLabel())) {
								drawCollapsedLabel(g2d, wedgeBuilder.buildLabelColor(trace, e), color,
										splittedEvent.getUpperLabel(), x, wedgeYOffset + fontMetrics.getAscent());
							}
							if (!isEmpty(splittedEvent.getLowerLabel())) {
								drawCollapsedLabel(g2d, wedgeBuilder.buildLabelColor(trace, e), color,
										splittedEvent.getLowerLabel(), x,
										wedgeYOffset + 3 * fontMetrics.getAscent() - 2);
							}
						} else {
							if (!isEmpty(e.getLabel())) {
								drawCollapsedLabel(g2d, wedgeBuilder.buildLabelColor(trace, e), color, e.getLabel(), x,
										wedgeYOffset + (WEDGE_HEIGHT / 2) + (int) (fontMetrics.getAscent() / 1.5f)
												- fontMetrics.getLeading() - fontMetrics.getDescent());
							}
						}

						if (e instanceof ExtendedEvent) {
							ExtendedEvent extendedEvent = (ExtendedEvent) e;
							drawCollapseExtendedInfo(g2d, extendedEvent.getExtendedColor(),
									extendedEvent.getExtendedLabel(), x, TOP_LABEL_Y_OFFSET, currentEventWidth);
						}

					}

					hasPainted = true;

				} else {
					if (hasPainted) {
						break;
					}
				}

				x += currentEventWidth + wedgeGap;
			}
		}
	}

	private static boolean isInVisibleRegion(Rectangle visibleRegion, int x, int elementWidth) {
		int partlyVisibleHorizon = elementWidth;
		int startX = visibleRegion.x;
		int endX = visibleRegion.x + visibleRegion.width;
		return x + partlyVisibleHorizon > startX && x - partlyVisibleHorizon < endX;
	}

	protected final int translateToEventIndex(Point point) {
		Iterator<? extends Event> iterator = trace.iterator();
		FontMetrics fontMetrics = getFontMetrics(getDefaultFont());
		int offsetX = NAME_INFO_X_OFFSET + getNameInfoWidth(fontMetrics) + ELEMENT_X_OFFSET + ELEMENT_TRI_OFFSET;
		int currentX = offsetX;
		int lastX = offsetX;
		int currentEventIndex = 0;
		while (iterator.hasNext() && point.getX() > currentX) {
			Event e = iterator.next();
			if (isSelected) {
				currentX += getExpandedEventWidth(e, fontMetrics);
			} else {
				currentX += getCollapsedEventWidth(e, fontMetrics);
			}
			if (point.getX() > lastX && point.getX() < currentX) {
				return currentEventIndex;
			}
			currentX += getWedgeGap(trace, e);
			lastX = currentX;
			currentEventIndex++;
		}
		return -1;
	}

	/**
	 * 
	 * @param point
	 * @return positive: event index; -1: out of trace; -2: name of trace
	 */
	protected final int translateToDetailedEventIndex(Point point) {
		Iterator<? extends Event> iterator = trace.iterator();
		FontMetrics fontMetrics = getFontMetrics(getDefaultFont());
		int offsetX = NAME_INFO_X_OFFSET + getNameInfoWidth(fontMetrics) + ELEMENT_X_OFFSET + ELEMENT_TRI_OFFSET;
		int currentX = offsetX;
		int lastX = offsetX;
		int currentEventIndex = 0;
		if (point.getX() <= currentX) {
			return -2;
		}
		while (iterator.hasNext() && point.getX() > currentX) {
			Event e = iterator.next();
			if (isSelected) {
				currentX += getExpandedEventWidth(e, fontMetrics);
			} else {
				currentX += getCollapsedEventWidth(e, fontMetrics);
			}
			if (point.getX() > lastX && point.getX() < currentX) {
				return currentEventIndex;
			}
			currentX += getWedgeGap(trace, e);
			lastX = currentX;
			currentEventIndex++;
		}
		return -1;
	}

	private Stroke getWedgeStroke(Trace<? extends Event> trace, Event e) {
		Stroke stroke = wedgeBuilder.buildBorderStroke(trace, e);
		if (stroke != null) {
			return stroke;
		}
		return wedgeStroke;
	}

	private int getWedgeGap(Trace<? extends Event> trace, Event e) {
		Integer gap = wedgeBuilder.assignWedgeGap(trace, e);
		if (gap != null) {
			return gap;
		}
		return this.wedgeGap;
	}

	private static boolean isEmpty(String s) {
		return s == null || s == EMPTY_LABEL || s.isEmpty();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#getMaximumSize()
	 */
	public Dimension getMaximumSize() {
		return new Dimension(Integer.MAX_VALUE, elementHeight);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#getMinimumSize()
	 */
	public Dimension getMinimumSize() {
		return getPreferredSize();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.swing.JComponent#getPreferredSize()
	 */
	public Dimension getPreferredSize() {
		return cachedPreferredSize;
	}

	private final Dimension calcPreferredSize() {
		FontMetrics fontMetrics = fontMetric;
		int nameWidth = NAME_INFO_X_OFFSET + getNameInfoWidth(fontMetrics);
		int traceWidth = ELEMENT_X_OFFSET + ELEMENT_TRI_OFFSET + getSelectedTraceWidth(fontMetrics);
		return new Dimension(nameWidth + traceWidth + 5, elementHeight); // do not know where the 5 comes from
	}

	private int getNameInfoWidth(FontMetrics metrics) {
		if (getFixedInfoWidth() != -1) {
			return getFixedInfoWidth();
		} else {
			return Math.min(getMaxInfoWidth(),
					Math.max(nullSafeWidth(metrics, trace.getName()), nullSafeWidth(metrics, trace.getInfo())));
		}
	}

	private final int getSelectedTraceWidth(FontMetrics metrics) {
		if (getFixedWedgeWidth() != -1) {
			if (trace instanceof Collection) {
				return (getFixedWedgeWidth() + wedgeGap) * ((Collection<?>) trace).size();
			} else {
				Iterator<? extends Event> iterator = trace.iterator();
				if (iterator.hasNext()) {
					int width = 0;
					for (; iterator.hasNext();) {
						iterator.next();
						width += getFixedWedgeWidth();
						width += wedgeGap;
					}
					return width;
				} else {
					return MINIMUM_WEDGE_WIDTH;
				}
			}
		} else {
			Iterator<? extends Event> iterator = trace.iterator();
			if (iterator.hasNext()) {
				int width = 0;
				for (; iterator.hasNext();) {
					Event e = iterator.next();
					width += getExpandedEventWidth(e, metrics);
					width += getWedgeGap(trace, e);
				}
				return width;
			} else {
				return MINIMUM_WEDGE_WIDTH;
			}
		}
	}

	private final int getExpandedEventWidth(final Event e, FontMetrics metrics) {
		if (getFixedWedgeWidth() != -1) {
			return Math.max(getFixedWedgeWidth(), MINIMUM_WEDGE_WIDTH);
		} else {
			int width = nullSafeWidth(metrics, e.getLabel()) + LABEL_X_OFFSET;
			width = Math.max(width, nullSafeWidth(metrics, e.getTopLabel()) + BOTTOM_LABEL_X_OFFSET);
			width = Math.max(width, nullSafeWidth(metrics, e.getBottomLabel()) + BOTTOM_LABEL_X_OFFSET);
			width = Math.max(width, nullSafeWidth(metrics, e.getBottomLabel2()) + BOTTOM_LABEL_X_OFFSET);

			if (e instanceof SplittedEvent) {
				width = Math.max(width, nullSafeWidth(metrics, ((SplittedEvent) e).getUpperLabel()) + LABEL_X_OFFSET);
				width = Math.max(width, nullSafeWidth(metrics, ((SplittedEvent) e).getLowerLabel()) + LABEL_X_OFFSET);
			}

			return Math.max(Math.min(maxWedgeWidth, width), MINIMUM_WEDGE_WIDTH);
		}
	}

	private int getCollapsedEventWidth(Event e, FontMetrics metrics) {
		int width = Math.max(MINIMUM_WEDGE_WIDTH, nullSafeWidth(metrics, shortenLabel(e.getLabel()) + LABEL_X_OFFSET));
		if (e instanceof SplittedEvent) {
			width = Math.max(width,
					nullSafeWidth(metrics, shortenLabel(((SplittedEvent) e).getUpperLabel())) + LABEL_X_OFFSET);
			width = Math.max(width,
					nullSafeWidth(metrics, shortenLabel(((SplittedEvent) e).getLowerLabel())) + LABEL_X_OFFSET);
		}
		return width;
	}

	private void drawCollapseExtendedInfo(Graphics2D g2d, Color extendedColor, String extendedLabel, int x, int y,
			int width) {
		if (extendedColor != null) {
			g2d.setColor(extendedColor);
			g2d.fillRect(x, y, width, g2d.getFontMetrics().getHeight() - 4);
			g2d.setColor(Color.BLACK);
			g2d.drawRect(x, y, width, g2d.getFontMetrics().getHeight() - 4);
			g2d.setColor(determineFontColor(getForeground(), extendedColor));
		}

		if (extendedLabel != null) {
			g2d.setFont(g2d.getFont().deriveFont(g2d.getFont().getSize() - 2.0f));
			try {
				FontMetrics fontMetrics = g2d.getFontMetrics();
				g2d.setColor(determineFontColor(getForeground(), extendedColor));
				if (fontMetrics.stringWidth(extendedLabel) <= width) {
					g2d.drawString(extendedLabel, x, y + fontMetrics.getAscent());
				} else {
					char[] charArray = extendedLabel.toCharArray();
					int cutoffPoint = extendedLabel.length();
					for (int i = extendedLabel.length(); i > 0; i--) {
						if (fontMetrics.charsWidth(charArray, 0, i) <= width) {
							cutoffPoint = i;
							break;
						}
					}
					g2d.drawString(extendedLabel.substring(0, Math.max(0, cutoffPoint - 3)).concat(ABBREVIATION_SUFFIX),
							x, y + fontMetrics.getAscent());
				}
			} finally {
				g2d.setFont(g2d.getFont().deriveFont(g2d.getFont().getSize() + 2.0f));
			}
		}
	}

	private void drawExtendedInfo(Graphics2D g2d, Color extendedColor, String extendedLabel, int x, int y, int width) {
		if (extendedColor != null) {
			g2d.setColor(extendedColor);
			g2d.fillRect(x, y, width, g2d.getFontMetrics().getHeight() - 4);
			g2d.setColor(Color.BLACK);
			g2d.drawRect(x, y, width, g2d.getFontMetrics().getHeight() - 4);
			g2d.setColor(determineFontColor(getForeground(), extendedColor));
		}

		if (extendedLabel != null) {
			g2d.setFont(g2d.getFont().deriveFont(g2d.getFont().getSize() - 2.0f));
			try {
				FontMetrics fontMetrics = g2d.getFontMetrics();
				if (fontMetrics.stringWidth(extendedLabel) <= width) {
					g2d.drawString(extendedLabel, x, y + fontMetrics.getAscent());
				} else {
					char[] charArray = extendedLabel.toCharArray();
					int cutoffPoint = extendedLabel.length();
					for (int i = extendedLabel.length(); i > 0; i--) {
						if (fontMetrics.charsWidth(charArray, 0, i) <= width) {
							cutoffPoint = i;
							break;
						}
					}
					g2d.drawString(extendedLabel.substring(0, Math.max(0, cutoffPoint - 3)).concat(ABBREVIATION_SUFFIX),
							x, y + fontMetrics.getAscent());
				}
			} finally {
				g2d.setFont(g2d.getFont().deriveFont(g2d.getFont().getSize() + 2.0f));
			}
		}
	}

	private final void drawEventWedge(final Graphics2D g, Event e, final Color color, final Color strokeColor,
			Stroke wedgeStroke, int x, int y, int width, int height, boolean isSelected) {

		int midPointBX = x + ELEMENT_TRI_OFFSET;
		int midPointAX = x + width + ELEMENT_TRI_OFFSET;
		int midPointY = y + (height / 2);
		int endPointX = x + width;
		int endPointY = y + height;

		if (e instanceof SplittedEvent) {
			SplittedEvent splittedEvent = (SplittedEvent) e;

			int[] xUpper = new int[] { x, endPointX, midPointAX, midPointBX };
			int[] yUpper = new int[] { y, y, midPointY, midPointY };

			g.setColor(isSelected ? splittedEvent.getUpperColor() : attenuateColor(splittedEvent.getUpperColor()));
			g.fillPolygon(xUpper, yUpper, 4);

			int[] xLower = new int[] { midPointBX, x, endPointX, midPointAX };
			int[] yLower = new int[] { midPointY, endPointY, endPointY, midPointY };

			g.setColor(isSelected ? splittedEvent.getLowerColor() : attenuateColor(splittedEvent.getLowerColor()));
			g.fillPolygon(xLower, yLower, 4);

		} else {

			int[] xCoords = new int[] { x, endPointX, midPointAX, endPointX, x, midPointBX };
			int[] yCoords = new int[] { y, y, midPointY, endPointY, endPointY, midPointY };

			g.setColor(isSelected ? color : attenuateColor(color));
			g.fillPolygon(xCoords, yCoords, 6);
		}

		g.setColor(strokeColor);

		Stroke oldStroke = g.getStroke();
		try {
			g.setStroke(wedgeStroke);

			// Start Wedge
			g.drawPolyline(new int[] { x, midPointBX, x }, new int[] { y, midPointY, endPointY }, 3);
			// End Wedge
			g.drawPolyline(new int[] { endPointX, midPointAX, endPointX }, new int[] { y, midPointY, endPointY }, 3);

			// Upper line
			g.drawLine(x, y, endPointX, y);
			// Lower line
			g.drawLine(x, endPointY, endPointX, endPointY);
		} finally {
			g.setStroke(oldStroke);
		}
	}

	private final void drawTraceLabel(Graphics2D g2d, int x, int y, Color color, String label) {
		g2d.setColor(color == null ? getForeground() : color);

		FontMetrics fontMetrics = g2d.getFontMetrics();
		int wedgeWidth = getNameInfoWidth(fontMetrics);
		if (wedgeWidth != -1) {
			if (fontMetrics.stringWidth(label) <= wedgeWidth) {
				g2d.drawString(label, x, y);
			} else {
				char[] charArray = label.toCharArray();
				int cutoffPoint = label.length();
				for (int i = label.length(); i > 0; i--) {
					if (fontMetrics.charsWidth(charArray, 0, i) <= wedgeWidth) {
						cutoffPoint = i;
						break;
					}
				}
				g2d.drawString(label.substring(0, Math.max(0, cutoffPoint - 3)).concat(ABBREVIATION_SUFFIX), x, y);
			}
		} else {
			g2d.drawString(label, x, y);
		}

	}

	private final void drawCollapsedLabel(final Graphics2D g, Color textColor, Color bgColor, final String label, int x,
			int y) {
		String shortenLabel = shortenLabel(label);
		if (shortenLabel != null) {
			g.setColor(determineFontColor(textColor, bgColor));
			g.drawString(shortenLabel, x + LABEL_X_OFFSET, y + LABEL_Y_OFFSET);
		}
	}

	private String shortenLabel(final String label) {
		if (label != null) {
			return label.substring(0, Math.min(collapsedLabelLength, label.length()));
		} else {
			return null;
		}
	}

	private final void drawFullLabel(final Graphics2D g, final Color textColor, final Color bgColor, final String label,
			int x, int y, int width, int maxHeight) {

		g.setColor(determineFontColor(textColor, bgColor));
		int wrappingWidth = width - LABEL_X_OFFSET;

		FontMetrics fontMetrics = g.getFontMetrics();
		if (fontMetrics.stringWidth(label) <= wrappingWidth) {
			// Shortcut the expensive text wrapping
			if (maxHeight == elementHeight) {
				// somehow get it centered (try and error calculation)
				g.drawString(label, x + LABEL_X_OFFSET, y + (WEDGE_HEIGHT / 2) + (fontMetrics.getAscent() / 2));
			} else {
				g.drawString(label, x + LABEL_X_OFFSET, y + LABEL_Y_OFFSET + fontMetrics.getAscent());
			}
		} else {
			AttributedString attributedString = new AttributedString(label);
			attributedString.addAttribute(TextAttribute.FONT, g.getFont());
			LineBreakMeasurer breakMeasure = new LineBreakMeasurer(attributedString.getIterator(),
					g.getFontRenderContext());

			int labelX = x + LABEL_X_OFFSET;
			int labelY = y + LABEL_Y_OFFSET;

			while (breakMeasure.getPosition() < label.length()) {

				int positionBefore = breakMeasure.getPosition();
				int positionAfter = breakMeasure.nextOffset(wrappingWidth);

				TextLayout layout = breakMeasure.nextLayout(wrappingWidth);
				float textHeight = layout.getDescent() + layout.getLeading() + layout.getAscent();

				if ((labelY + (4 * textHeight)) > maxHeight) {
					// Last Row				
					String shortenedLastRow = label
							.substring(positionBefore, Math.max(positionBefore, positionAfter - 3))
							.concat(ABBREVIATION_SUFFIX);
					AttributedString attrLastRow = new AttributedString(shortenedLastRow);
					attrLastRow.addAttribute(TextAttribute.FONT, g.getFont());
					TextLayout lastRowLayout = new TextLayout(attrLastRow.getIterator(), g.getFontRenderContext());
					float dx = lastRowLayout.isLeftToRight() ? 0 : (wrappingWidth - lastRowLayout.getAdvance());
					lastRowLayout.draw(g, labelX + dx, labelY + lastRowLayout.getAscent());
					break;
				}

				labelY += layout.getAscent();
				float dx = layout.isLeftToRight() ? 0 : (wrappingWidth - layout.getAdvance());
				layout.draw(g, labelX + dx, labelY);
				labelY += layout.getDescent() + layout.getLeading();
			}
		}

	}

	private void drawExtraLabel(Graphics2D g, Color color, String label, int x, int y, int width) {
		g.setColor(color != null ? color : getForeground());

		FontMetrics fontMetrics = g.getFontMetrics();
		if (fontMetrics.stringWidth(label) <= width) {
			g.drawString(label, x, y + fontMetrics.getAscent());
		} else {
			char[] charArray = label.toCharArray();
			int cutoffPoint = label.length();
			for (int i = label.length(); i > 0; i--) {
				if (fontMetrics.charsWidth(charArray, 0, i) <= width) {
					cutoffPoint = i;
					break;
				}
			}
			g.drawString(label.substring(0, Math.max(0, cutoffPoint - 3)).concat(ABBREVIATION_SUFFIX), x,
					y + fontMetrics.getAscent());
		}
	}

	private final Color attenuateColor(final Color c) {
		float[] hsb = Color.RGBtoHSB(c.getRed(), c.getGreen(), c.getBlue(), null);
		hsb[2] = hsb[2] * getAttenuationFactor();
		return new Color(Color.HSBtoRGB(hsb[0], hsb[1], hsb[2]));
	}

	private static final Color determineFontColor(final Color textColor, final Color bgColor) {
		if (textColor == null) {
			double val = Math.sqrt(.299 * Math.pow(bgColor.getRed(), 2) + .587 * Math.pow(bgColor.getGreen(), 2)
					+ .114 * Math.pow(bgColor.getBlue(), 2));
			return (val < 130) ? Color.WHITE : Color.BLACK;
		} else {
			return textColor;
		}
	}

	private static int nullSafeWidth(FontMetrics fontMetrics, String s) {
		return s != null ? fontMetrics.stringWidth(s) : 0;
	}

	private Color nullSafeColor(Color color) {
		return color == null ? Color.BLACK : color;
	}

	public float getAttenuationFactor() {
		return attenuationFactor;
	}

	public void setAttenuationFactor(float attenuationFactor) {
		this.attenuationFactor = attenuationFactor;
	}

	public Font getDefaultFont() {
		return defaultFont;
	}

	public WedgeBuilder getWedgeBuilder() {
		return wedgeBuilder;
	}

	public void setWedgeBuilder(WedgeBuilder colorBuilder) {
		this.wedgeBuilder = colorBuilder;
	}

	public int getMaxWedgeWidth() {
		return maxWedgeWidth;
	}

	public void setMaxWedgeWidth(int maxWedgeWidth) {
		this.maxWedgeWidth = maxWedgeWidth;
	}

	public int getCollapsedLabelLength() {
		return collapsedLabelLength;
	}

	public void setCollapsedLabelLength(int collapsedLabelLength) {
		this.collapsedLabelLength = collapsedLabelLength;
	}

	public Stroke getWedgeStroke() {
		return wedgeStroke;
	}

	public void setWedgeStroke(Stroke wedgeStroke) {
		this.wedgeStroke = wedgeStroke;
	}

	public int getWedgeGap() {
		return wedgeGap;
	}

	public void setWedgeGap(int wedgeGap) {
		this.wedgeGap = wedgeGap;
	}

	public boolean isFixedWedgeWidth() {
		return getFixedWedgeWidth() != -1;
	}

	public void setFixedWedgeWidth(int fixedWedgeWidth) {
		this.fixedWedgeWidth = fixedWedgeWidth;
	}

	public int getFixedWedgeWidth() {
		return fixedWedgeWidth;
	}

	public int getMaxInfoWidth() {
		return maxInfoWidth;
	}

	public void setMaxInfoWidth(int maxInfoWidth) {
		this.maxInfoWidth = maxInfoWidth;
	}

	public boolean isFixedInfoWidth() {
		return getFixedInfoWidth() != -1;
	}

	public int getFixedInfoWidth() {
		return fixedInfoWidth;
	}

	public void setFixedInfoWidth(int fixedInfoWidth) {
		this.fixedInfoWidth = fixedInfoWidth;
	}

}"
SaveAsActionListener.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets.traceview;

import java.awt.Color;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.prefs.Preferences;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;

import org.processmining.framework.util.ui.widgets.helper.ProMUIHelper;

public class SaveAsActionListener<T> implements ActionListener {

	static final Preferences PREFS = Preferences.userRoot().node(""org.processmining.widgets.traceview"");
	static final String LAST_USED_FOLDER = ""lastUsedFolder"";

	private final ProMTraceList<T> listView;
	private final Comparator<T> sortOrder;

	public SaveAsActionListener(ProMTraceList<T> listView, Comparator<T> sortOrder) {
		this.listView = listView;
		this.sortOrder = sortOrder;
	}

	public void actionPerformed(ActionEvent e) {

		JFileChooser chooser = new JFileChooser(PREFS.get(LAST_USED_FOLDER, new File(""."").getAbsolutePath()));
		FileNameExtensionFilter pdfFilter = new FileNameExtensionFilter(""PDF"", ""pdf"");
		FileNameExtensionFilter emfFilter = new FileNameExtensionFilter(""EMF"", ""emf"");
		FileNameExtensionFilter epsFilter = new FileNameExtensionFilter(""EPS"", ""eps"");
		FileNameExtensionFilter svgFilter = new FileNameExtensionFilter(""SVG"", ""svg"");
		chooser.addChoosableFileFilter(pdfFilter);
		chooser.addChoosableFileFilter(emfFilter);
		chooser.addChoosableFileFilter(epsFilter);
		chooser.addChoosableFileFilter(svgFilter);
		chooser.setFileFilter(pdfFilter);
		chooser.setAcceptAllFileFilterUsed(false);
		int returnVal = chooser.showSaveDialog(listView);
		if (returnVal == JFileChooser.APPROVE_OPTION) {
			File file = chooser.getSelectedFile();
			PREFS.put(LAST_USED_FOLDER, file.getParent());

			List<T> traces = new ArrayList<>();
			List<T> selection = listView.getList().getSelectedValuesList();
			for (T o : selection) {
				traces.add(o);
			}

			if (selection.size() > 100) {
				int result = JOptionPane.showConfirmDialog(listView,
						String.format(
								""You selected %s traces to be saved, this could take a long time and freeze the UI. Do you want to continue?"",
								selection.size()));
				if (result != JOptionPane.OK_OPTION) {
					return;
				}
			}
			
			String font = JOptionPane.showInputDialog(listView, ""If you want to use a specific font, please specify its name (Experimental Feature)"", Font.SANS_SERIF);
	
			ProMTraceList<T> listForPrinting = new ProMTraceList<>(traces, listView.getTraceBuilder(), sortOrder, new Font(font, Font.PLAIN, 10), listView.hasLabels());

			listForPrinting.setOpaque(true);
			listForPrinting.setBackground(Color.WHITE);
			listForPrinting.setForeground(Color.BLACK);

			if (chooser.getFileFilter() == pdfFilter) {
				if (!file.getAbsolutePath().endsWith("".pdf"")) {
					file = new File(file.getAbsolutePath() + "".pdf"");
				}
				try {
					ProMTraceList.saveAsPDF(listForPrinting, """", file);
				} catch (IOException e1) {
					ProMUIHelper.showErrorMessage(listView, e1.getMessage(), ""Error saving"");
				}
			} else if (chooser.getFileFilter() == emfFilter) {
				if (!file.getAbsolutePath().endsWith("".emf"")) {
					file = new File(file.getAbsolutePath() + "".emf"");
				}
				try {
					ProMTraceList.saveAsEMF(listForPrinting, file);
				} catch (IOException e1) {
					ProMUIHelper.showErrorMessage(listView, e1.getMessage(), ""Error saving"");
				}
			} else if (chooser.getFileFilter() == epsFilter) {
				if (!file.getAbsolutePath().endsWith("".eps"")) {
					file = new File(file.getAbsolutePath() + "".eps"");
				}
				try {
					ProMTraceList.saveAsEPS(listForPrinting, file);
				} catch (IOException e1) {
					ProMUIHelper.showErrorMessage(listView, e1.getMessage(), ""Error saving"");
				}
			} else if (chooser.getFileFilter() == svgFilter) {
				if (!file.getAbsolutePath().endsWith("".svg"")) {
					file = new File(file.getAbsolutePath() + "".svg"");
				}
				try {
					ProMTraceList.saveAsSVG(listForPrinting, file);
				} catch (IOException e1) {
					ProMUIHelper.showErrorMessage(listView, e1.getMessage(), ""Error saving"");
				}
			}
		}

	}

}
"
WidgetColors.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Color;

/**
 * Colors used in widgets
 * 
 * @author mwesterg
 * 
 */
public interface WidgetColors {
	/**
	 * 
	 */
	public static final Color COLOR_ENCLOSURE_BG = new Color(40, 40, 40);
	/**
	 * 
	 */
	public static final Color COLOR_LIST_BG = new Color(60, 60, 60);
	/**
	 * 
	 */
	public static final Color COLOR_LIST_FG = new Color(180, 180, 180);
	/**
	 * 
	 */
	public static final Color COLOR_LIST_SELECTION_BG = new Color(80, 0, 0);
	/**
	 * 
	 */
	public static final Color COLOR_LIST_SELECTION_FG = new Color(240, 240, 240);
	/**
	 * 
	 */
	public static final Color COLOR_NON_FOCUS = new Color(70, 70, 70);
	/**
	 * 
	 */
	public static final Color HEADER_COLOR = new Color(20, 20, 20, 230);
	/**
	 * 
	 */
	public static final Color PROPERTIES_BACKGROUND = Color.LIGHT_GRAY;
	/**
	 * 
	 */
	public static final Color TEXT_COLOR = new Color(210, 210, 210);

}
"
WidgetImages.java,widgets-6.9.234,"package org.processmining.framework.util.ui.widgets;

import java.awt.Image;

import javax.swing.ImageIcon;

/**
 * Images useful for tabbed panes
 * 
 * @author mwesterg
 * 
 */
public interface WidgetImages {
	/**
	 * 
	 */
	final static Image dashboardIcon = new ImageIcon(WidgetImages.class.getResource(""resources/dashboard48.png""))
			.getImage();
	/**
	 * 
	 */
	final static Image inspectorIcon = new ImageIcon(WidgetImages.class.getResource(""resources/inspector48.png""))
			.getImage();
	/**
	 * 
	 */
	final static Image summaryIcon = new ImageIcon(WidgetImages.class.getResource(""resources/summary48-2.png""))
			.getImage();

}
"
InformationStep.java,widgets-6.9.234,"package org.processmining.framework.util.ui.wizard;

import javax.swing.JComponent;

/**
 * @author michael
 * 
 * @param <M>
 */
public abstract class InformationStep<M> implements ProMWizardStep<M> {

	private final String title;

	/**
	 * @param title
	 */
	public InformationStep(final String title) {
		this.title = title;
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizardStep#apply(java.lang.Object,
	 *      javax.swing.JComponent)
	 */
	@Override
	public M apply(final M model, final JComponent component) {
		return model;
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizardStep#canApply(java.lang.Object,
	 *      javax.swing.JComponent)
	 */
	@Override
	public boolean canApply(final M model, final JComponent component) {
		return true;
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizardStep#getTitle()
	 */
	@Override
	public String getTitle() {
		return title;
	}

}
"
ListWizard.java,widgets-6.9.234,"package org.processmining.framework.util.ui.wizard;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @author michael
 * 
 * @param <SettingsModel>
 */
public class ListWizard<SettingsModel> implements ProMWizard<SettingsModel, ListWizard.ListModel<SettingsModel>> {

	static class ListModel<SettingsModel> {
		private final SettingsModel model;

		private int step = 0;

		public ListModel(final int step, final SettingsModel model) {
			super();
			this.step = step;
			this.model = model;
		}

		public SettingsModel getModel() {
			return model;
		}

		public int getStep() {
			return step;
		}

	}

	private final List<ProMWizardStep<SettingsModel>> steps;

	/**
	 * @param steps
	 */
	public ListWizard(final List<ProMWizardStep<SettingsModel>> steps) {
		this.steps = new ArrayList<ProMWizardStep<SettingsModel>>(steps);
	}

	/**
	 * @param steps
	 */
	public ListWizard(final ProMWizardStep<SettingsModel>... steps) {
		this.steps = new ArrayList<ProMWizardStep<SettingsModel>>(Arrays.asList(steps));
	}

	/**
	 * @param step
	 */
	public ListWizard(final ProMWizardStep<SettingsModel> step) {
		this.steps = new ArrayList<ProMWizardStep<SettingsModel>>();
		steps.add(step);
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getFirst(java.lang.Object)
	 */
	@Override
	public ProMWizardStep<SettingsModel> getFirst(final ListModel<SettingsModel> model) {
		return getNext(model, null);
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getModel(java.lang.Object)
	 */
	@Override
	public SettingsModel getModel(final ListModel<SettingsModel> wizardModel) {
		return wizardModel.getModel();
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getNext(java.lang.Object,
	 *      org.processmining.framework.util.ui.wizard.ProMWizardStep)
	 */
	@Override
	public ProMWizardStep<SettingsModel> getNext(final ListModel<SettingsModel> model,
			final ProMWizardStep<SettingsModel> current) {

		if (steps.size() > model.getStep()) {
			return steps.get(model.getStep());
		}

		return null;
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getWizardModel(java.lang.Object,
	 *      java.lang.Object)
	 */
	@Override
	public ListModel<SettingsModel> getWizardModel(final SettingsModel model,
			final ListModel<SettingsModel> currentWizardModel) {
		if (currentWizardModel == null) {
			return new ListModel<SettingsModel>(0, model);
		} else {
			return new ListModel<SettingsModel>(currentWizardModel.getStep() + 1, model);
		}
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#isFinished(java.lang.Object)
	 */
	@Override
	public boolean isFinished(final ListModel<SettingsModel> model) {

		return model.getStep() >= steps.size();

	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#isLastStep(java.lang.Object)
	 */
	@Override
	public boolean isLastStep(final ListModel<SettingsModel> model) {
		return model.getStep() >= steps.size() - 1;
	}

}
"
MapWizard.java,widgets-6.9.234,"package org.processmining.framework.util.ui.wizard;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * @author michael
 * 
 * @param <SettingsModel>
 * @param <Key>
 */
public abstract class MapWizard<SettingsModel, Key> implements
		ProMWizard<SettingsModel, MapWizard.MapModel<SettingsModel, Key>> {

	/**
	 * @author michael
	 * 
	 * @param <SettingsModel>
	 * @param <Key>
	 */
	public static class MapModel<SettingsModel, Key> {

		private final Key current;
		private final Key previous;
		private final SettingsModel settings;

		/**
		 * @param current
		 * @param model
		 * @param previous
		 */
		public MapModel(final Key current, final SettingsModel model, final Key previous) {
			super();

			this.current = current;
			this.settings = model;
			this.previous = previous;
		}

		/**
		 * @return the current
		 */
		public Key getCurrent() {
			return current;
		}

		/**
		 * @return
		 */
		public SettingsModel getModel() {
			return this.settings;
		}

		/**
		 * @return
		 */
		public Key getPrevious() {
			return previous;
		}
	}

	protected Map<Key, ProMWizardStep<SettingsModel>> steps;

	/**
	 * @param steps
	 */
	public MapWizard(final Map<Key, ProMWizardStep<SettingsModel>> steps) {
		this.steps = new HashMap<Key, ProMWizardStep<SettingsModel>>(steps);
	}

	protected MapWizard() {
		this.steps = new HashMap<Key, ProMWizardStep<SettingsModel>>();
	}

	/**
	 * @param currentWizardModel
	 * @return
	 */
	public abstract Collection<Key> getFinalKeys(MapModel<SettingsModel, Key> currentWizardModel);

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getFirst(java.lang.Object)
	 */
	@Override
	public ProMWizardStep<SettingsModel> getFirst(final MapModel<SettingsModel, Key> model) {
		return getNext(model, null);
	}

	/**
	 * @param settings
	 * @return
	 */
	public abstract Key getInitialKey(SettingsModel settings);

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getModel(java.lang.Object)
	 */
	@Override
	public SettingsModel getModel(final MapModel<SettingsModel, Key> wizardModel) {
		return wizardModel.getModel();
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getNext(java.lang.Object,
	 *      org.processmining.framework.util.ui.wizard.ProMWizardStep)
	 */
	@Override
	public ProMWizardStep<SettingsModel> getNext(final MapModel<SettingsModel, Key> model,
			final ProMWizardStep<SettingsModel> current) {
		if (steps.containsKey(model.getCurrent())) {
			return steps.get(model.getCurrent());
		}
		return null;
	}

	/**
	 * @param currentWizardModel
	 * @return
	 */
	public abstract Key getNextKey(MapModel<SettingsModel, Key> currentWizardModel);

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#getWizardModel(java.lang.Object,
	 *      java.lang.Object)
	 */
	@Override
	public MapModel<SettingsModel, Key> getWizardModel(final SettingsModel model,
			final MapModel<SettingsModel, Key> currentWizardModel) {
		if (currentWizardModel == null) {
			return new MapModel<SettingsModel, Key>(getInitialKey(model), model, null);
		} else {
			return new MapModel<SettingsModel, Key>(getNextKey(currentWizardModel), model,
					currentWizardModel.getCurrent());
		}
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#isFinished(java.lang.Object)
	 */
	@Override
	public boolean isFinished(final MapModel<SettingsModel, Key> model) {
		return model.getPrevious() != null && getFinalKeys(model).contains(model.getPrevious());
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizard#isLastStep(java.lang.Object)
	 */
	@Override
	public boolean isLastStep(final MapModel<SettingsModel, Key> model) {
		return model.getCurrent() != null && getFinalKeys(model).contains(model.getCurrent());
	}

}
"
ProMWizard.java,widgets-6.9.234,"package org.processmining.framework.util.ui.wizard;

/**
 * @author michael
 * 
 * @param <SettingsModel>
 * @param <WizardModel>
 */
public interface ProMWizard<SettingsModel, WizardModel> {

	/**
	 * @param model
	 * @return
	 */
	public ProMWizardStep<SettingsModel> getFirst(WizardModel model);

	/**
	 * @param wizardModel
	 * @return
	 */
	public SettingsModel getModel(WizardModel wizardModel);

	/**
	 * @param model
	 * @param current
	 * @return
	 */
	public ProMWizardStep<SettingsModel> getNext(WizardModel model, ProMWizardStep<SettingsModel> current);

	/**
	 * @param model
	 * @param currentWizardModel
	 * @return
	 */
	public WizardModel getWizardModel(SettingsModel model, WizardModel currentWizardModel);

	//we do not have canFinish, as the ProM Wizard interface only 
	//shows the finish button if it is the last step
	//public boolean canFinish(WizardModel model);
	/**
	 * @param model
	 * @return
	 */
	public boolean isFinished(WizardModel model);

	/**
	 * @param model
	 * @return
	 */
	public boolean isLastStep(WizardModel model);

}
"
ProMWizardDisplay.java,widgets-6.9.234,"package org.processmining.framework.util.ui.wizard;

import java.util.Stack;

import javax.swing.JComponent;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.Pair;

/**
 * @author michael
 * 
 */
public class ProMWizardDisplay {

	/**
	 * @param context
	 * @param wizard
	 * @param model
	 * @return
	 */
	public static <SettingsModel, WizardModel> SettingsModel show(final UIPluginContext context,
			final ProMWizard<SettingsModel, WizardModel> wizard, final SettingsModel model) {

		WizardModel wizardModel = wizard.getWizardModel(model, null);

		ProMWizardStep<SettingsModel> current = wizard.getFirst(wizardModel);
		JComponent configuration = current.getComponent(wizard.getModel(wizardModel));

		final Stack<Pair<ProMWizardStep<SettingsModel>, WizardModel>> steps = new Stack<Pair<ProMWizardStep<SettingsModel>, WizardModel>>();

		int stepCount = 1;
		do {
			String title;
			if (current.getTitle() == null) {
				title = ""Step "" + stepCount;
			} else {
				title = current.getTitle();
			}

			final InteractionResult result = context.showWizard(title, steps.isEmpty(), wizard.isLastStep(wizardModel),
					configuration);

			switch (result) {
				case FINISHED :
				case NEXT :
					if (current.canApply(wizard.getModel(wizardModel), configuration)) {
						steps.push(new Pair<ProMWizardStep<SettingsModel>, WizardModel>(current, wizardModel));

						wizardModel = wizard.getWizardModel(current.apply(wizard.getModel(wizardModel), configuration),
								wizardModel);
						current = wizard.getNext(wizardModel, current);
						if (current != null) {
							configuration = current.getComponent(wizard.getModel(wizardModel));
							stepCount++;
						}
					}
					// if canApply is false, the current remains the same!
					break;
				case PREV :
					if (current.canApply(wizard.getModel(wizardModel), configuration)) {
						wizardModel = wizard.getWizardModel(current.apply(wizard.getModel(wizardModel), configuration),
								wizardModel);
					}
					final Pair<ProMWizardStep<SettingsModel>, WizardModel> prevstep = steps.pop();
					current = prevstep.getFirst();
					wizardModel = prevstep.getSecond();

					configuration = current.getComponent(wizard.getModel(wizardModel));
					stepCount--;
					break;
				case CANCEL :
					return null;
				case CONTINUE :
					//never used.
			}

		} while (!wizard.isFinished(wizardModel));

		//ProMWizardStep<SettingsModel> lastStupidStep = wizard.getLast(wizardModel, current); 
		//context.showWizard(lastStupidStep.getTitle(), true, true, lastStupidStep.getComponent(wizard.getModel(wizardModel)));

		return wizard.getModel(wizardModel);
	}

}
"
ProMWizardStep.java,widgets-6.9.234,"package org.processmining.framework.util.ui.wizard;

import javax.swing.JComponent;

/**
 * @author michael
 * 
 * @param <SettingsModel>
 */
public interface ProMWizardStep<SettingsModel> {

	/**
	 * @param model
	 * @param component
	 * @return
	 */
	public SettingsModel apply(SettingsModel model, JComponent component);

	/**
	 * @param model
	 * @param component
	 * @return
	 */
	public boolean canApply(SettingsModel model, JComponent component);

	/**
	 * @param model
	 * @return
	 */
	public JComponent getComponent(SettingsModel model);

	/**
	 * @return
	 */
	public String getTitle();
}
"
TextAreaStep.java,widgets-6.9.234,"package org.processmining.framework.util.ui.wizard;

import javax.swing.JComponent;

import org.processmining.framework.util.ui.widgets.ProMTextArea;

class TextAreaStep extends ProMTextArea implements ProMWizardStep<String> {

	private static final long serialVersionUID = 7227063553927410431L;

	private final String title;

	public TextAreaStep() {
		this("""");
	}

	public TextAreaStep(final String title) {
		this("""", """");
	}

	public TextAreaStep(final String title, final String text) {
		super();

		this.title = title;

		setText(text);

	}

	@Override
	public String apply(final String model, final JComponent component) {
		if (component instanceof TextAreaStep) {
			return ((TextAreaStep) component).getText();
		} else {
			return """";
		}
	}

	@Override
	public boolean canApply(final String model, final JComponent component) {
		return true;
	}

	@Override
	public JComponent getComponent(final String model) {
		return new TextAreaStep(title, model);
	}

	@Override
	public String getTitle() {
		return title;
	}
}"
TextStep.java,widgets-6.9.234,"package org.processmining.framework.util.ui.wizard;

import java.awt.BorderLayout;

import javax.swing.JComponent;
import javax.swing.JLabel;

import org.processmining.framework.util.ui.widgets.WidgetColors;

import com.fluxicon.slickerbox.components.RoundedPanel;
import com.fluxicon.slickerbox.factory.SlickerFactory;

/**
 * @author michael
 * 
 * @param <M>
 */
public class TextStep<M> extends InformationStep<M> {

	/**
	 * @param title
	 * @param text
	 * @return
	 */
	public static <T> TextStep<T> create(final String title, final String text) {
		return new TextStep<T>(title, text);
	}

	private final String text;

	/**
	 * @param title
	 * @param text
	 */
	public TextStep(final String title, final String text) {
		super(title);

		this.text = text;
	}

	/**
	 * @see org.processmining.framework.util.ui.wizard.ProMWizardStep#getComponent(java.lang.Object)
	 */
	@Override
	public JComponent getComponent(final Object model) {
		final JLabel label = SlickerFactory.instance().createLabel(text);
		final RoundedPanel panel = new RoundedPanel(15, 0, 3);

		panel.setOpaque(true);
		panel.setBackground(WidgetColors.PROPERTIES_BACKGROUND);

		panel.setLayout(new BorderLayout());
		panel.add(label, BorderLayout.CENTER);

		return panel;
	}

}
"
ContextMenuCreator.java,widgets-6.9.234,"package org.processmining.models.jgraph;

import java.util.Collection;

import javax.swing.JPopupMenu;

import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphElement;

public interface ContextMenuCreator {

	JPopupMenu createMenuFor(DirectedGraph<?, ?> graph, Collection<DirectedGraphElement> selectedElements);

}
"
DirectedGraphEdgeForMultiGraph.java,widgets-6.9.234,"package org.processmining.models.jgraph;

import java.awt.geom.Point2D;
import java.util.Arrays;

import org.processmining.models.graphbased.AbstractGraphElement;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

public final class DirectedGraphEdgeForMultiGraph extends AbstractGraphElement implements
		DirectedGraphEdge<DirectedGraphNode, DirectedGraphNode>, DirectedGraphElementForMultiEdge {
	private final DirectedGraphNode source;
	private final DirectedGraphNode target;
	private final DirectedGraphEdge<?, ?> e;
	private boolean toIntermediate;

	public DirectedGraphEdgeForMultiGraph(DirectedGraphNode source, DirectedGraphNodeForMultiGraph intermediate,
			DirectedGraphEdge<?, ?> e) {
		this.source = source;
		this.target = intermediate;
		this.e = e;
		copyAttributes(true, e.getAttributeMap());
	}

	public DirectedGraphEdgeForMultiGraph(DirectedGraphNodeForMultiGraph intermediate, DirectedGraphNode target,
			DirectedGraphEdge<?, ?> e) {
		this.source = intermediate;
		this.target = target;
		this.e = e;
		copyAttributes(false, e.getAttributeMap());
	}

	protected void copyAttributes(boolean toIntermediate, AttributeMap sourceMap) {

		this.toIntermediate = toIntermediate;
		if (sourceMap.containsKey(AttributeMap.STYLE))
			getAttributeMap().put(AttributeMap.STYLE, sourceMap.get(AttributeMap.STYLE));
		if (sourceMap.containsKey(AttributeMap.LINEWIDTH))
			getAttributeMap().put(AttributeMap.LINEWIDTH, sourceMap.get(AttributeMap.LINEWIDTH));
		if (sourceMap.containsKey(AttributeMap.DASHPATTERN))
			getAttributeMap().put(AttributeMap.DASHPATTERN, sourceMap.get(AttributeMap.DASHPATTERN));
		if (sourceMap.containsKey(AttributeMap.DASHOFFSET))
			getAttributeMap().put(AttributeMap.DASHOFFSET, sourceMap.get(AttributeMap.DASHOFFSET));
		if (sourceMap.containsKey(AttributeMap.LABELCOLOR))
			getAttributeMap().put(AttributeMap.LABELCOLOR, sourceMap.get(AttributeMap.LABELCOLOR));

		if (sourceMap.containsKey(AttributeMap.NUMLINES))
			getAttributeMap().put(AttributeMap.NUMLINES, sourceMap.get(AttributeMap.NUMLINES));
		if (sourceMap.containsKey(AttributeMap.LINEWIDTH))
			getAttributeMap().put(AttributeMap.LINEWIDTH, sourceMap.get(AttributeMap.LINEWIDTH));

		if (sourceMap.containsKey(AttributeMap.EDGECOLOR))
			getAttributeMap().put(AttributeMap.EDGECOLOR, sourceMap.get(AttributeMap.EDGECOLOR));

		if (toIntermediate) {
			if (sourceMap.containsKey(AttributeMap.EDGESTART))
				getAttributeMap().put(AttributeMap.EDGESTART, sourceMap.get(AttributeMap.EDGESTART));
			if (sourceMap.containsKey(AttributeMap.EDGESTARTFILLED))
				getAttributeMap().put(AttributeMap.EDGESTARTFILLED, sourceMap.get(AttributeMap.EDGESTARTFILLED));
			if (source == e.getSource()) {
				// draw the middle shape only once if the source is indeed the edge main source
				if (sourceMap.containsKey(AttributeMap.EDGEMIDDLE))
					getAttributeMap().put(AttributeMap.EDGEEND, sourceMap.get(AttributeMap.EDGEMIDDLE));
				if (sourceMap.containsKey(AttributeMap.EDGEMIDDLEFILLED))
					getAttributeMap().put(AttributeMap.EDGEENDFILLED, sourceMap.get(AttributeMap.EDGEMIDDLEFILLED));
			}
		} else {
			if (sourceMap.containsKey(AttributeMap.EDGEEND))
				getAttributeMap().put(AttributeMap.EDGEEND, sourceMap.get(AttributeMap.EDGEEND));
			if (sourceMap.containsKey(AttributeMap.EDGEENDFILLED))
				getAttributeMap().put(AttributeMap.EDGEENDFILLED, sourceMap.get(AttributeMap.EDGEENDFILLED));
		}

		if (sourceMap.containsKey(AttributeMap.EXTRALABELPOSITIONS)) {
			assert ((Point2D[]) sourceMap.get(AttributeMap.EXTRALABELPOSITIONS)).length == ((String[]) sourceMap
					.get(AttributeMap.EXTRALABELS)).length;
			Point2D[] points = (Point2D[]) sourceMap.get(AttributeMap.EXTRALABELPOSITIONS);
			String[] labels = (String[]) sourceMap.get(AttributeMap.EXTRALABELS);
			if (toIntermediate) {
				getAttributeMap().put(AttributeMap.EXTRALABELPOSITIONS,
						Arrays.copyOfRange(points, 0, points.length / 2));
				getAttributeMap().put(AttributeMap.EXTRALABELS, Arrays.copyOfRange(labels, 0, points.length / 2));
			} else {
				getAttributeMap().put(AttributeMap.EXTRALABELPOSITIONS,
						Arrays.copyOfRange(points, points.length / 2, points.length));
				getAttributeMap().put(AttributeMap.EXTRALABELS,
						Arrays.copyOfRange(labels, points.length / 2, points.length));
			}
		}
	}

	public String getLabel() {
		return source.getLabel() + ""->"" + target.getLabel();
	}

	public DirectedGraph<?, ?> getGraph() {
		return source.getGraph();
	}

	public DirectedGraphNode getSource() {
		return source;
	}

	public DirectedGraphNode getTarget() {
		return target;
	}

	public int hashCode() {
		return e.hashCode() * 31 + (toIntermediate ? source.hashCode() : target.hashCode());
	}

	public boolean equals(Object o) {
		if (o instanceof DirectedGraphEdgeForMultiGraph) {
			DirectedGraphEdgeForMultiGraph edge = (DirectedGraphEdgeForMultiGraph) o;
			return (edge.e.equals(e) && toIntermediate ? edge.source.equals(source) : edge.target.equals(target));
		}
		return false;
	}

	public boolean isToIntermediate() {
		return toIntermediate;
	}

	public DirectedGraphEdge<?, ?> getMultiEdge() {
		return e;
	}
}"
DirectedGraphElementForMultiEdge.java,widgets-6.9.234,"package org.processmining.models.jgraph;

import org.processmining.models.graphbased.directed.DirectedGraphEdge;

public interface DirectedGraphElementForMultiEdge {

	public DirectedGraphEdge<?,?> getMultiEdge();
}
"
DirectedGraphNodeForMultiGraph.java,widgets-6.9.234,"package org.processmining.models.jgraph;

import java.awt.Dimension;

import org.processmining.models.graphbased.AbstractGraphElement;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.NodeID;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.shapes.Rectangle;

public final class DirectedGraphNodeForMultiGraph extends AbstractGraphElement implements DirectedGraphNode,
		DirectedGraphElementForMultiEdge {
	private final DirectedGraphEdge<?, ?> e;
	private NodeID id = new NodeID();

	public DirectedGraphNodeForMultiGraph(DirectedGraphEdge<?, ?> e) {
		this.e = e;
		getAttributeMap().put(AttributeMap.SHAPE, new Rectangle());
		getAttributeMap().put(AttributeMap.BORDERWIDTH, 1);
		getAttributeMap().put(AttributeMap.DASHPATTERN, new float[] { 0f, 10f });

		if (e.getAttributeMap().get(AttributeMap.SHOWLABEL, false)) {
			getAttributeMap().put(AttributeMap.INSET, 0);
			getAttributeMap().put(AttributeMap.AUTOSIZE, true);
			getAttributeMap().put(AttributeMap.SHOWLABEL, true);

		} else {
			getAttributeMap().put(AttributeMap.SHOWLABEL, false);
			getAttributeMap().put(AttributeMap.SIZE, new Dimension(5, 5));
			getAttributeMap().put(AttributeMap.RESIZABLE, false);
		}
	}

	public int compareTo(DirectedGraphNode o) {
		throw new RuntimeException(""Not implemented!"");
	}

	public String getLabel() {
		return e.getLabel();
	}

	public DirectedGraph<?, ?> getGraph() {
		return e.getGraph();
	}

	public NodeID getId() {
		return id;
	}

	public int hashCode() {
		return e.hashCode();
	}

	public boolean equals(Object o) {
		return (o instanceof DirectedGraphNodeForMultiGraph && ((DirectedGraphNodeForMultiGraph) o).e.equals(e));
	}

	public DirectedGraphEdge<?, ?> getMultiEdge() {
		return e;
	}

}"
ProMGraphCell.java,widgets-6.9.234,"package org.processmining.models.jgraph.elements;

import java.awt.Color;
import java.awt.geom.Dimension2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.SwingConstants;

import org.jgraph.graph.DefaultGraphCell;
import org.jgraph.graph.GraphConstants;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.connections.GraphLayoutConnection;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.Expandable;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.ModelOwner;
import org.processmining.models.jgraph.ProMGraphModel;
import org.processmining.models.jgraph.views.JGraphShapeView;

public class ProMGraphCell extends DefaultGraphCell implements Cleanable, ModelOwner, ProMGraphElement {

	private static final long serialVersionUID = -5170284747077744754L;
	private DirectedGraphNode node;
	private ProMGraphModel model;
	private JGraphShapeView view;
	private GraphLayoutConnection layoutConnection;

	public ProMGraphCell(DirectedGraphNode node, ProMGraphModel model, GraphLayoutConnection layoutConnection) {
		super(node.getLabel());
		this.node = node;
		this.model = model;
		this.layoutConnection = layoutConnection;
		// update();
		GraphConstants.setConstrained(getAttributes(), node.getAttributeMap().get(AttributeMap.SQUAREBB, false));
		GraphConstants.setSizeable(getAttributes(), node.getAttributeMap().get(AttributeMap.RESIZABLE, true));
		GraphConstants.setResize(getAttributes(), node.getAttributeMap().get(AttributeMap.AUTOSIZE, false));
		GraphConstants.setHorizontalAlignment(getAttributes(), SwingConstants.CENTER);
		GraphConstants.setInset(getAttributes(), node.getAttributeMap().get(AttributeMap.INSET, 20));
		GraphConstants.setLineWidth(
				getAttributes(),
				new Float(node.getAttributeMap().get(AttributeMap.LINEWIDTH,
						GraphConstants.getLineWidth(getAttributes()))));
		GraphConstants.setForeground(getAttributes(), node.getAttributeMap().get(AttributeMap.LABELCOLOR, Color.black));
		GraphConstants.setOrientation(getAttributes(),
				node.getAttributeMap().get(AttributeMap.PREF_ORIENTATION, SwingConstants.NORTH));

		Dimension2D dim;
		Point2D pos;

		if (node instanceof Expandable) {
			dim = ((Expandable) node).getCollapsedSize();
			pos = layoutConnection.getPosition(node);
		} else {
			dim = layoutConnection.getSize(node);
			pos = layoutConnection.getPosition(node);
		}
		if (pos == null) {
			pos = new Point2D.Double(10, 10);
		}
		Rectangle2D rect = new Rectangle2D.Double(pos.getX(), pos.getY(), dim.getWidth(), dim.getHeight());
		GraphConstants.setBounds(getAttributes(), rect);

	}

	public void updateViewsFromMap() {
		assert (view != null);
		// Update the dimension / position
		Dimension2D dim = layoutConnection.getSize(node);
		Point2D pos = layoutConnection.getPosition(node);
		if (pos == null) {
			pos = new Point2D.Double(10, 10);
		}

		Rectangle2D rect = new Rectangle2D.Double(pos.getX(), pos.getY(), dim.getWidth(), dim.getHeight());
		Rectangle2D bounds = view.getBounds();//GraphConstants.getBounds(getAttributes());

		boolean boundsChanged = !rect.equals(bounds);
		if (boundsChanged) {
			//			GraphConstants.setBounds(getAttributes(), rect);
			view.setBounds(rect);
		}
	}

	public DirectedGraphNode getNode() {
		return node;
	}

	public String getUserObject() {
		return (String) super.getUserObject();
	}

	public void setView(JGraphShapeView view) {
		this.view = view;
	}

	public void cleanUp() {
		for (Object o : getChildren()) {
			if (o instanceof Cleanable) {
				Cleanable p = (Cleanable) o;
				p.cleanUp();
			}
		}
		removeAllChildren();
		if (view != null) {
			view.cleanUp();
		}
		view = null;
		model = null;
		node = null;
		layoutConnection = null;

	}

	// This method is called by all other addPort methods.
	@Override
	public ProMGraphPort addPort(Point2D offset, Object userObject) {
		ProMGraphPort port = new ProMGraphPort(userObject, model, layoutConnection);
		if (offset == null) {
			add(port);
		} else {
			GraphConstants.setOffset(port.getAttributes(), offset);
			add(port);
		}
		return port;
	}

	public String getLabel() {
		return node.getLabel();
	}

	public int hashCode() {
		return node.hashCode();
	}

	public ProMGraphModel getModel() {
		return model;
	}

	public JGraphShapeView getView() {
		return view;
	}

	/**
	 * This implementation of equals seems to be required by JGraph. Changing it
	 * to anything more meaningful will introduce very strange results.
	 */
	public boolean equals(Object o) {
		return o == this;
	}

}
"
ProMGraphEdge.java,widgets-6.9.234,"package org.processmining.models.jgraph.elements;

import java.awt.Color;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.List;

import org.jgraph.graph.DefaultEdge;
import org.jgraph.graph.GraphConstants;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.connections.GraphLayoutConnection;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.AttributeMap.ArrowType;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.jgraph.ModelOwner;
import org.processmining.models.jgraph.ProMGraphModel;
import org.processmining.models.jgraph.ProMLoopRouting;
import org.processmining.models.jgraph.views.JGraphEdgeView;

public class ProMGraphEdge extends DefaultEdge implements Cleanable, ModelOwner, ProMGraphElement {

	public static final int ARROW_TECHNICAL_CIRCLE = 10;
	public static final int ARROW_CROSS = 11;

	public static final String LINEMIDDLE = ""lineMiddle"";
	public static final String MIDDLEFILL = ""middleFill"";
	public static final String NUMBERLINES = ""numberLines"";
	public static final String LINEWIDTH = ""lineWidth"";

	private static final long serialVersionUID = 663907031594522244L;

	private ProMGraphModel model;
	private JGraphEdgeView view;
	private final List<Point2D> internalPoints = new ArrayList<Point2D>(0);
	private DirectedGraphEdge<?, ?> edge;
	private final GraphLayoutConnection layoutConnection;

	public ProMGraphEdge(DirectedGraphEdge<?, ?> edge, ProMGraphModel model, GraphLayoutConnection layoutConnection) {
		super(edge.getLabel());
		this.layoutConnection = layoutConnection;

		GraphConstants.setRouting(getAttributes(), ProMLoopRouting.ROUTER);
		GraphConstants.setLabelPosition(getAttributes(), new Point2D.Double(GraphConstants.PERMILLE / 2, 0));
		GraphConstants.setLabelAlongEdge(getAttributes(), edge.getAttributeMap()
				.get(AttributeMap.LABELALONGEDGE, false));
		GraphConstants.setLineStyle(getAttributes(),
				edge.getAttributeMap().get(AttributeMap.STYLE, GraphConstants.STYLE_SPLINE));
		//GraphConstants.setLineStyle(getAttributes(), GraphConstants.STYLE_SPLINE);
		GraphConstants.setLineWidth(
				getAttributes(),
				new Float(edge.getAttributeMap().get(AttributeMap.LINEWIDTH,
						GraphConstants.getLineWidth(getAttributes()))));

		float[] pattern = edge.getAttributeMap().get(AttributeMap.DASHPATTERN, new float[0]);
		if (pattern.length > 0f) {

			GraphConstants.setDashPattern(getAttributes(), pattern);
			GraphConstants.setDashOffset(getAttributes(), edge.getAttributeMap().get(AttributeMap.DASHOFFSET, 0f));
		}

		GraphConstants.setForeground(getAttributes(), edge.getAttributeMap().get(AttributeMap.LABELCOLOR, Color.black));

		ArrowType type = edge.getAttributeMap().get(AttributeMap.EDGESTART, ArrowType.ARROWTYPE_NONE);
		int arrow = extractArrowType(type);
		GraphConstants.setLineBegin(getAttributes(), arrow);
		GraphConstants.setBeginFill(getAttributes(), edge.getAttributeMap().get(AttributeMap.EDGESTARTFILLED, true));

		type = edge.getAttributeMap().get(AttributeMap.EDGEEND, ArrowType.ARROWTYPE_NONE);
		arrow = extractArrowType(type);
		GraphConstants.setLineEnd(getAttributes(), arrow);
		GraphConstants.setEndFill(getAttributes(), edge.getAttributeMap().get(AttributeMap.EDGEENDFILLED, true));

		type = edge.getAttributeMap().get(AttributeMap.EDGEMIDDLE, ArrowType.ARROWTYPE_NONE);
		arrow = extractArrowType(type);
		getAttributes().put(LINEMIDDLE, arrow);
		getAttributes().put(MIDDLEFILL, edge.getAttributeMap().get(AttributeMap.EDGEMIDDLEFILLED, true));
		getAttributes().put(NUMBERLINES, edge.getAttributeMap().get(AttributeMap.NUMLINES, 1));
		getAttributes().put(LINEWIDTH, edge.getAttributeMap().get(AttributeMap.LINEWIDTH, 1.0f));

		if (edge.getAttributeMap().containsKey(AttributeMap.EXTRALABELPOSITIONS)) {
			assert ((Point2D[]) edge.getAttributeMap().get(AttributeMap.EXTRALABELPOSITIONS)).length == ((String[]) edge
					.getAttributeMap().get(AttributeMap.EXTRALABELS)).length;
			Point2D[] points = (Point2D[]) edge.getAttributeMap().get(AttributeMap.EXTRALABELPOSITIONS);
			String[] labels = (String[]) edge.getAttributeMap().get(AttributeMap.EXTRALABELS);
			GraphConstants.setExtraLabelPositions(getAttributes(), points);
			GraphConstants.setExtraLabels(getAttributes(), labels);

		}

		this.edge = edge;
		this.model = model;

		internalPoints.addAll(layoutConnection.getEdgePoints(edge));

	}

	protected int extractArrowType(ArrowType type) {
		int arrow = GraphConstants.ARROW_NONE;
		if (type == ArrowType.ARROWTYPE_CLASSIC) {
			arrow = GraphConstants.ARROW_CLASSIC;
		} else if (type == ArrowType.ARROWTYPE_CIRCLE) {
			arrow = GraphConstants.ARROW_CIRCLE;
		} else if (type == ArrowType.ARROWTYPE_DIAMOND) {
			arrow = GraphConstants.ARROW_DIAMOND;
		} else if (type == ArrowType.ARROWTYPE_DOUBLELINE) {
			arrow = GraphConstants.ARROW_DOUBLELINE;
		} else if (type == ArrowType.ARROWTYPE_LINE) {
			arrow = GraphConstants.ARROW_LINE;
		} else if (type == ArrowType.ARROWTYPE_SIMPLE) {
			arrow = GraphConstants.ARROW_SIMPLE;
		} else if (type == ArrowType.ARROWTYPE_TECHNICAL) {
			arrow = GraphConstants.ARROW_TECHNICAL;
		} else if (type == ArrowType.ARROW_CROSS) {
			arrow = ARROW_CROSS;
		} else if (type == ArrowType.ARROW_TECHNICAL_CIRCLE) {
			arrow = ARROW_TECHNICAL_CIRCLE;
		}
		return arrow;
	}

	@SuppressWarnings(""unchecked"")
	public void updateViewsFromMap() {
		assert (view != null);
		// Update should not be called before any view is created,

		// Note that List is of type List<Point2D>, until list.add is called
		// later
		List list = new ArrayList(layoutConnection.getEdgePoints(edge));
		boolean pointsChanged = !internalPoints.equals(list);
		if (pointsChanged) {
			internalPoints.clear();
			List points = view.getPoints();
			internalPoints.addAll(list);
			list.add(0, points.get(0));
			list.add(points.get(points.size() - 1));
			view.setPoints(list);
		}
	}

	public List<Point2D> getInternalPoints() {
		return internalPoints;
	}

	public String toString() {
		return edge.toString();
	}

	public DirectedGraphEdge<?, ?> getEdge() {
		return edge;
	}

	public String getUserObject() {
		return (String) super.getUserObject();
	}

	public ProMGraphPort getSource() {
		return (ProMGraphPort) super.getSource();
	}

	public ProMGraphPort getTarget() {
		return (ProMGraphPort) super.getTarget();
	}

	public void setView(JGraphEdgeView view) {
		this.view = view;
	}

	public JGraphEdgeView getView() {
		return view;
	}

	public void cleanUp() {
		if (view != null) {
			view.cleanUp();
		}
		internalPoints.clear();
		model = null;
		view = null;
		edge = null;
	}

	public String getLabel() {
		return edge.getLabel();
	}

	public int hashCode() {
		return edge.hashCode();
	}

	/**
	 * This implementation of equals seems to be required by JGraph. Changing it
	 * to anything more meaningful will introduce very strange results.
	 */
	public boolean equals(Object o) {
		return o == this;
	}

	public ProMGraphModel getModel() {
		return model;
	}

}
"
ProMGraphElement.java,widgets-6.9.234,"package org.processmining.models.jgraph.elements;

import java.util.Map;

import org.jgraph.graph.CellView;

public interface ProMGraphElement {

	CellView getView();

	void updateViewsFromMap();

	Map getAttributes();
}
"
ProMGraphPort.java,widgets-6.9.234,"package org.processmining.models.jgraph.elements;

import java.awt.Dimension;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.jgraph.graph.DefaultPort;
import org.jgraph.graph.GraphConstants;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.connections.GraphLayoutConnection;
import org.processmining.models.graphbased.directed.BoundaryDirectedGraphNode;
import org.processmining.models.jgraph.ModelOwner;
import org.processmining.models.jgraph.ProMGraphModel;
import org.processmining.models.jgraph.views.JGraphPortView;

public class ProMGraphPort extends DefaultPort implements Cleanable, ModelOwner, ProMGraphElement {

	private static final long serialVersionUID = 34423826783834456L;
	private JGraphPortView view;
	private ProMGraphModel model;
	private boolean isBoundaryNode = false;
	private BoundaryDirectedGraphNode node;
	private final GraphLayoutConnection layoutConnection;

	public ProMGraphPort(Object userObject, ProMGraphModel model, GraphLayoutConnection layoutConnection) {
		super(userObject);
		this.model = model;
		this.layoutConnection = layoutConnection;
		if (userObject != null && userObject instanceof BoundaryDirectedGraphNode) {
			node = (BoundaryDirectedGraphNode) userObject;
			layoutConnection.getPortOffset(node);
			Dimension size = layoutConnection.getSize(node);
			Point2D offset = layoutConnection.getPortOffset(node);

			GraphConstants.setSize(getAttributes(), size);
			GraphConstants.setOffset(getAttributes(), offset);
			isBoundaryNode = true;
		}
	}

	@SuppressWarnings(""unchecked"")
	public void cleanUp() {
		view = null;
		setUserObject(null);
		Iterator<Object> edge = edges();
		List<Object> edges = new ArrayList<Object>();
		while (edge.hasNext()) {
			edges.add(edge.next());
		}
		for (Object e : edges) {
			removeEdge(e);
		}
		model = null;
	}

	public void setView(JGraphPortView view) {
		this.view = view;
	}

	public JGraphPortView getView() {
		return view;
	}

	public ProMGraphModel getModel() {
		return model;
	}

	public void updateViewsFromMap() {
		assert (view != null);

		if ((getUserObject() instanceof BoundaryDirectedGraphNode) ? ((BoundaryDirectedGraphNode) getUserObject())
				.getBoundingNode() != null : false) {

			// Update the port size
			// Note: the width and the height of a port should always be equal 			
			Dimension size = layoutConnection.getSize(node);
			Dimension currSize = new Dimension((int) view.getBounds().getWidth(), (int) view.getBounds().getHeight());// GraphConstants.getSize(getAttributes());
			if (!size.equals(currSize)) {
				//				GraphConstants.setSize(getAttributes(), size);
				view.setPortSize((int) size.getWidth());
			}

			Point2D offset = layoutConnection.getPortOffset(node);
			//			Point2D currOffset = new Point2D.Double(view.getBounds().getX(), view.getBounds().getY()); // GraphConstants.getOffset(getAttributes());
			Point2D currOffset = GraphConstants.getOffset(view.getAttributes());
			if (!offset.equals(currOffset)) {
				//				GraphConstants.setOffset(getAttributes(), offset);
				GraphConstants.setOffset(view.getAttributes(), offset);
			}
		}
	}

	/**
	 * This implementation of equals seems to be required by JGraph. Changing it
	 * to anything more meaningful will introduce very strange results.
	 */
	public boolean equals(Object o) {
		return o == this;
	}

	public boolean isBoundaryNode() {
		return isBoundaryNode;
	}

	public BoundaryDirectedGraphNode getBoundingNode() {
		return node;
	}

}
"
ProMCellViewFactory.java,widgets-6.9.234,"package org.processmining.models.jgraph.factory;

import java.util.ArrayList;
import java.util.List;

import org.jgraph.graph.DefaultCellViewFactory;
import org.jgraph.graph.Edge;
import org.jgraph.graph.EdgeView;
import org.jgraph.graph.GraphConstants;
import org.jgraph.graph.Port;
import org.jgraph.graph.PortView;
import org.jgraph.graph.VertexView;
import org.processmining.framework.util.Cast;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.jgraph.elements.ProMGraphCell;
import org.processmining.models.jgraph.elements.ProMGraphEdge;
import org.processmining.models.jgraph.elements.ProMGraphPort;
import org.processmining.models.jgraph.views.JGraphEdgeView;
import org.processmining.models.jgraph.views.JGraphPortView;
import org.processmining.models.jgraph.views.JGraphShapeView;

public class ProMCellViewFactory extends DefaultCellViewFactory {

	private static final long serialVersionUID = -2424217390990685801L;
	private final boolean isPIP;
	private final ViewSpecificAttributeMap viewSpecificAttributes;

	public ProMCellViewFactory(boolean isPIP, ViewSpecificAttributeMap viewSpecificAttributes) {
		this.isPIP = isPIP;
		this.viewSpecificAttributes = viewSpecificAttributes;
	}

	@Override
	protected VertexView createVertexView(Object v) {
		ProMGraphCell cell = (ProMGraphCell) v;
		JGraphShapeView view = new JGraphShapeView(cell, isPIP, viewSpecificAttributes);
		cell.setView(view);
		return view;
	}

	@Override
	@Deprecated
	protected EdgeView createEdgeView(Edge e) {
		return createEdgeView((Object) e);
	}

	@SuppressWarnings({ ""rawtypes"", ""unchecked"" })
	@Override
	protected EdgeView createEdgeView(Object e) {
		ProMGraphEdge cell = Cast.<ProMGraphEdge>cast(e);

		List list = new ArrayList(cell.getInternalPoints());
		list.add(0, cell.getSource().getView());
		list.add(cell.getTarget().getView());
		GraphConstants.setPoints(cell.getAttributes(), list);

		JGraphEdgeView view = new JGraphEdgeView(cell, isPIP, viewSpecificAttributes);
		cell.setView(view);
		return view;
	}

	@Override
	@Deprecated
	protected PortView createPortView(Port e) {
		return createPortView((Object) e);
	}

	@Override
	protected PortView createPortView(Object e) {
		ProMGraphPort cell = Cast.<ProMGraphPort>cast(e);
		JGraphPortView view = new JGraphPortView(cell, isPIP, viewSpecificAttributes);
		cell.setView(view);
		cell.updateViewsFromMap();
		return view;
	}

}
"
JGraphFoldingManager.java,widgets-6.9.234,"package org.processmining.models.jgraph;

import java.awt.Component;
import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.event.MouseInputAdapter;

import org.jgraph.JGraph;
import org.jgraph.graph.CellView;
import org.processmining.framework.util.Pair;
import org.processmining.models.connections.GraphLayoutConnection;
import org.processmining.models.graphbased.Expandable;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.renderers.ProMGroupShapeRenderer;
import org.processmining.models.jgraph.views.JGraphShapeView;

/**
 * Mananges the folding and unfolding of groups
 */
public class JGraphFoldingManager extends MouseInputAdapter {

	private final GraphLayoutConnection layoutConnection;

	public JGraphFoldingManager(GraphLayoutConnection layoutConnection) {
		super();
		this.layoutConnection = layoutConnection;

	}

	/**
	 * Called when the mouse button is released to see if a collapse or expand
	 * request has been made
	 */
	public void mouseReleased(MouseEvent e) {
		if (e.getSource() instanceof JGraph) {
			final JGraph graph = (JGraph) e.getSource();
			Pair<Expandable, CellView> pair = getGroupByFoldingHandle(graph, e.getPoint());
			if (pair != null) {
				if (pair.getSecond().isLeaf()) {
					layoutConnection.expand(pair.getFirst());
					layoutConnection.updated();
				} else {
					layoutConnection.collapse(pair.getFirst());
					layoutConnection.updated();
				}
			}
			e.consume();
		}
	}

	/**
	 * Called when the mouse button is released to see if a collapse or expand
	 * request has been made
	 */
	public static Pair<Expandable, CellView> getGroupByFoldingHandle(JGraph graph, Point2D pt) {
		CellView[] views = graph.getGraphLayoutCache().getCellViews();
		for (int i = 0; i < views.length; i++) {
			Point2D containerPoint = graph.fromScreen((Point2D) pt.clone());
			if (views[i].getBounds().contains(containerPoint.getX(), containerPoint.getY())) {
				Rectangle2D rectBounds = views[i].getBounds();
				containerPoint.setLocation(containerPoint.getX() - rectBounds.getX(), containerPoint.getY()
						- rectBounds.getY());
				Component renderer = views[i].getRendererComponent(graph, false, false, false);
				if (renderer instanceof ProMGroupShapeRenderer) {
					DirectedGraphNode node = ((JGraphShapeView) views[i]).getNode();
					boolean isGroup = (node instanceof Expandable);
					if (isGroup) {
						ProMGroupShapeRenderer group = (ProMGroupShapeRenderer) renderer;
						if (group.inHitRegion(containerPoint)) {
							return new Pair<Expandable, CellView>((Expandable) node, views[i]);
						}
					}
				}
			}
		}
		return null;
	}

}
"
SelectionListener.java,widgets-6.9.234,"package org.processmining.models.jgraph.listeners;

import java.util.Collection;

public interface SelectionListener<N, E> {

	void SelectionChanged(SelectionChangeEvent<N, E> event);

	public static class SelectionChangeEvent<N, E> {
		private final Collection<N> addedNodes;
		private final Collection<E> addedEdges;
		private final Collection<N> removedNodes;
		private final Collection<E> removedEdges;

		public SelectionChangeEvent(Collection<N> addedNodes, Collection<E> addedEdges, Collection<N> removedNodes,
				Collection<E> removedEdges) {
			this.addedNodes = addedNodes;
			this.addedEdges = addedEdges;
			this.removedNodes = removedNodes;
			this.removedEdges = removedEdges;
		}

		public Collection<N> getAddedNodes() {
			return addedNodes;
		}

		public Collection<E> getAddedEdges() {
			return addedEdges;
		}

		public Collection<N> getRemovedNodes() {
			return removedNodes;
		}

		public Collection<E> getRemovedEdges() {
			return removedEdges;
		}

		public String toString() {
			return ""N:+"" + addedNodes + "" -"" + removedNodes + ""  E:+"" + addedEdges + "" -"" + removedEdges;
		}

	}
}
"
ModelOwner.java,widgets-6.9.234,"package org.processmining.models.jgraph;

public interface ModelOwner {

	public ProMGraphModel getModel();

}
"
ProMGraphModel.java,widgets-6.9.234,"package org.processmining.models.jgraph;

import java.awt.geom.Rectangle2D;
import java.util.Map;

import org.jgraph.event.GraphModelEvent;
import org.jgraph.graph.CellView;
import org.jgraph.graph.ConnectionSet;
import org.jgraph.graph.DefaultGraphModel;
import org.jgraph.graph.GraphLayoutCache;
import org.jgraph.graph.ParentMap;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphNode;

public class ProMGraphModel extends DefaultGraphModel implements ModelOwner {

	private static final long serialVersionUID = 9097862538097193482L;
	private final DirectedGraph<? extends DirectedGraphNode, ? extends DirectedGraphEdge<? extends DirectedGraphNode, ? extends DirectedGraphNode>> graph;

	public ProMGraphModel(
			DirectedGraph<? extends DirectedGraphNode, ? extends DirectedGraphEdge<? extends DirectedGraphNode, ? extends DirectedGraphNode>> graph) {
		this.graph = graph;
	}

	public DirectedGraph<? extends DirectedGraphNode, ? extends DirectedGraphEdge<? extends DirectedGraphNode, ? extends DirectedGraphNode>> getGraph() {
		return graph;
	}

	public String toString() {
		return graph.toString();
	}

	public ProMGraphModel getModel() {
		return this;
	}

	/**
	 * Invoke this method after you've changed how the cells are to be
	 * represented in the graph.
	 */
	public void cellsChanged(final Object[] cells, final Rectangle2D dirtyRegion) {
		if (cells != null) {
			fireGraphChanged(this, new GraphModelEvent.GraphModelChange() {

				public Object[] getInserted() {
					return null;
				}

				public Object[] getRemoved() {
					return null;
				}

				public Map<?, ?> getPreviousAttributes() {
					return null;
				}

				public ConnectionSet getConnectionSet() {
					return null;
				}

				public ConnectionSet getPreviousConnectionSet() {
					return null;
				}

				public ParentMap getParentMap() {
					return null;
				}

				public ParentMap getPreviousParentMap() {
					return null;
				}

				public void putViews(GraphLayoutCache view, CellView[] cellViews) {
				}

				public CellView[] getViews(GraphLayoutCache view) {
					return null;
				}

				public Object getSource() {
					return this;
				}

				public Object[] getChanged() {
					return cells;
				}

				public Map<?, ?> getAttributes() {
					return null;
				}

				public Object[] getContext() {
					return null;
				}

				public Rectangle2D getDirtyRegion() {
					return dirtyRegion;
				}

				public void setDirtyRegion(Rectangle2D dirty) {
				}

			});
		}
	}

}
"
ProMJGraph.java,widgets-6.9.234,"package org.processmining.models.jgraph;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.MouseEvent;
import java.awt.geom.Dimension2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import javax.swing.JComponent;
import javax.swing.ToolTipManager;

import org.jgraph.JGraph;
import org.jgraph.event.GraphLayoutCacheEvent;
import org.jgraph.event.GraphLayoutCacheListener;
import org.jgraph.event.GraphModelEvent;
import org.jgraph.event.GraphModelListener;
import org.jgraph.event.GraphSelectionEvent;
import org.jgraph.event.GraphSelectionListener;
import org.jgraph.graph.CellView;
import org.jgraph.graph.ConnectionSet;
import org.jgraph.graph.DefaultGraphModel;
import org.jgraph.graph.DefaultPort;
import org.jgraph.graph.GraphConstants;
import org.jgraph.graph.GraphLayoutCache;
import org.jgraph.graph.ParentMap;
import org.processmining.framework.util.Cast;
import org.processmining.framework.util.Cleanable;
import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.models.connections.GraphLayoutConnection;
import org.processmining.models.connections.GraphLayoutConnection.Listener;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.AttributeMapOwner;
import org.processmining.models.graphbased.Expandable;
import org.processmining.models.graphbased.ExpansionListener;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.BoundaryDirectedGraphNode;
import org.processmining.models.graphbased.directed.ContainableDirectedGraphElement;
import org.processmining.models.graphbased.directed.ContainingDirectedGraphNode;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphEdge.MultipleSources;
import org.processmining.models.graphbased.directed.DirectedGraphEdge.MultipleTargets;
import org.processmining.models.graphbased.directed.DirectedGraphElement;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.elements.ProMGraphCell;
import org.processmining.models.jgraph.elements.ProMGraphEdge;
import org.processmining.models.jgraph.elements.ProMGraphElement;
import org.processmining.models.jgraph.elements.ProMGraphPort;
import org.processmining.models.jgraph.factory.ProMCellViewFactory;

import com.jgraph.layout.JGraphFacade;
import com.jgraph.layout.JGraphLayout;

public class ProMJGraph extends JGraph implements GraphModelListener, GraphLayoutCacheListener, GraphSelectionListener,
		Cleanable, ExpansionListener, ScalableComponent, Listener {

	private static final long serialVersionUID = -8477633603192312230L;

	public static final String PIPVIEWATTRIBUTE = ""signalPIPView"";

	private final ProMGraphModel model;
	private final Map<DirectedGraphNode, ProMGraphCell> nodeMap = new HashMap<>();
	private final Map<BoundaryDirectedGraphNode, ProMGraphPort> boundaryNodeMap = new HashMap<>();
	private final Map<DirectedGraphEdge<?, ?>, ProMGraphEdge> edgeMap = new HashMap<>();
	private final Map<DirectedGraphEdge<?, ?>, Collection<ProMGraphElement>> multiEdgeMap = new HashMap<>();

	private JGraphLayout layout;

	private final ViewSpecificAttributeMap viewSpecificAttributes;

	private final boolean isPIP;

	private final GraphLayoutConnection layoutConnection;

	public ProMJGraph(ProMGraphModel model, ViewSpecificAttributeMap viewSpecificAttributes,
			GraphLayoutConnection layoutConnection) {
		this(model, false, viewSpecificAttributes, layoutConnection);
	}

	public ProMJGraph(ProMGraphModel model, boolean isPIP, ViewSpecificAttributeMap viewSpecificAttributes,
			GraphLayoutConnection layoutConnection) {
		super(model, new GraphLayoutCache(model, new ProMCellViewFactory(isPIP, viewSpecificAttributes), true));
		this.layoutConnection = layoutConnection;
		layoutConnection.addListener(this);
		getGraphLayoutCache().setShowsInvisibleEditedCells(false);
		this.isPIP = isPIP;
		this.viewSpecificAttributes = viewSpecificAttributes;

		getGraphLayoutCache().setMovesChildrenOnExpand(true);
		// Strange: setResizesParentsOnCollapse has to be set to FALSE!
		getGraphLayoutCache().setResizesParentsOnCollapse(false);
		getGraphLayoutCache().setMovesParentsOnCollapse(true);

		this.model = model;

		setHighlightColor(Color.ORANGE);
		setLockedHandleColor(Color.RED);

		setAntiAliased(true);
		setDisconnectable(false);
		setConnectable(false);
		setGridEnabled(false);
		setDoubleBuffered(true);
		setSelectionEnabled(!isPIP);
		setMoveBelowZero(false);
		setPortsVisible(true);
		setPortsScaled(true);

		DirectedGraph<?, ?> net = model.getGraph();

		List<DirectedGraphNode> todo = new ArrayList<DirectedGraphNode>(net.getNodes());
		List<Object> toInsert = new ArrayList<Object>();
		while (!todo.isEmpty()) {
			Iterator<DirectedGraphNode> it = todo.iterator();
			while (it.hasNext()) {
				DirectedGraphNode n = it.next();
				if (n instanceof BoundaryDirectedGraphNode) {
					DirectedGraphNode m = ((BoundaryDirectedGraphNode) n).getBoundingNode();
					if ((m != null) && !nodeMap.containsKey(m)) {
						// first make sure the bounding node is added
						continue;
					} else if (m != null) {
						// add as port
						addPort((BoundaryDirectedGraphNode) n, m);
						it.remove();
						continue;
					}
				}
				if (n instanceof ContainableDirectedGraphElement) {
					ContainingDirectedGraphNode c = Cast.<ContainableDirectedGraphElement>cast(n).getParent();
					if ((c != null) && !nodeMap.containsKey(c)) {
						// if parent is not added yet, then continue
						continue;
					} else if (c == null) {
						toInsert.add(addCell(n));
					} else {
						addCell(n);
					}
				} else {
					toInsert.add(addCell(n));
				}

				it.remove();
			}
		}

		//		getGraphLayoutCache().insert(toInsert.toArray());

		//		getGraphLayoutCache().insert(boundaryNodeMap.values().toArray());
		for (DirectedGraphEdge<?, ?> e : net.getEdges()) {
			if (e instanceof ContainableDirectedGraphElement) {
				ContainingDirectedGraphNode m = Cast.<ContainableDirectedGraphElement>cast(e).getParent();
				if (m == null) {
					if (e instanceof MultipleSources<?> || e instanceof MultipleTargets<?>) {
						toInsert.addAll(addMultiEdge(e));
					} else {
						toInsert.add(addEdge(e));
					}
				} else {
					if (e instanceof MultipleSources<?> || e instanceof MultipleTargets<?>) {
						addMultiEdge(e);
					} else {
						addEdge(e);

					}
				}
			} else {
				if (e instanceof MultipleSources<?> || e instanceof MultipleTargets<?>) {

					toInsert.addAll(addMultiEdge(e));
				} else {
					toInsert.add(addEdge(e));
				}
			}
		}
		getGraphLayoutCache().insert(toInsert.toArray());
		// Add the listeners, only AFTER copying the graph.

		registerAsListener();
		layoutConnection.getExpansionListeners().add(this);

		if (!isPIP) {
			addMouseListener(new JGraphFoldingManager(layoutConnection));
		}

		ToolTipManager.sharedInstance().registerComponent(this);
	}

	/**
	 * Returns the <code>GraphModel</code> that is providing the data.
	 * 
	 * @return the model that is providing the data
	 */
	public ProMGraphModel getModel() {
		return (ProMGraphModel) graphModel;
	}

	public void cleanUp() {

		List<Cleanable> cells = new ArrayList<Cleanable>(nodeMap.values());
		cells.addAll(boundaryNodeMap.values());
		cells.addAll(edgeMap.values());
		// multiEdgeMap elements are contained in other maps as well.

		getGraphLayoutCache().removeCells(cells.toArray());

		for (Cleanable cell : cells) {
			cell.cleanUp();
		}

		model.removeGraphModelListener(this);
		removeGraphSelectionListener(this);
		getGraphLayoutCache().removeGraphLayoutCacheListener(this);
		ToolTipManager.sharedInstance().unregisterComponent(this);

		removeAll();
		setVisible(false);
		setEnabled(false);
		setLayout(null);
		setGraphLayoutCache(null);

	}

	private ProMGraphCell addCell(DirectedGraphNode node) {
		ProMGraphCell cell = new ProMGraphCell(node, model, layoutConnection);

		cell.addPort();
		((DefaultPort) cell.getChildAt(0)).setUserObject(""default port"");

		// getting the size
		nodeMap.put(node, cell);

		// if the node is contained in another node, its cell must be contained in the cell of that node
		if (node instanceof ContainableDirectedGraphElement) {
			ContainingDirectedGraphNode parent = Cast.<ContainableDirectedGraphElement>cast(node).getParent();
			if (parent != null) {
				ProMGraphCell parentNode = nodeMap.get(parent);
				parentNode.add(cell);
				cell.setParent(parentNode);
			}
		}

		return cell;
	}

	private ProMGraphPort addPort(BoundaryDirectedGraphNode node, DirectedGraphNode boundingNode) {
		ProMGraphCell cell = nodeMap.get(boundingNode);
		ProMGraphPort port = cell.addPort(new Point2D.Float(10, 10), node);
		assert (port.getParent() == cell);

		boundaryNodeMap.put(node, port);

		return port;
	}

	private ProMGraphEdge addEdge(DirectedGraphEdge<?, ?> e) {
		ProMGraphEdge edge = new ProMGraphEdge(e, model, layoutConnection);
		// For now, assume a single port.
		ProMGraphPort srcPort;
		if ((e.getSource() instanceof BoundaryDirectedGraphNode)
				&& ((BoundaryDirectedGraphNode) e.getSource()).getBoundingNode() != null) {
			srcPort = boundaryNodeMap.get(e.getSource());
		} else {
			srcPort = (ProMGraphPort) nodeMap.get(e.getSource()).getChildAt(0);
		}
		ProMGraphPort tgtPort;
		if ((e.getTarget() instanceof BoundaryDirectedGraphNode)
				&& ((BoundaryDirectedGraphNode) e.getTarget()).getBoundingNode() != null) {
			tgtPort = boundaryNodeMap.get(e.getTarget());
		} else {
			tgtPort = (ProMGraphPort) nodeMap.get(e.getTarget()).getChildAt(0);
		}

		edge.setSource(srcPort);
		edge.setTarget(tgtPort);

		srcPort.addEdge(edge);
		tgtPort.addEdge(edge);

		edgeMap.put(e, edge);

		// if the edge is contained in a node, its cell must be contained in the cell of that node
		if (e instanceof ContainableDirectedGraphElement) {
			ContainingDirectedGraphNode parent = Cast.<ContainableDirectedGraphElement>cast(e).getParent();
			if (parent != null) {
				nodeMap.get(parent).add(edge);
				assert (edge.getParent() == nodeMap.get(parent));
			}
		}

		return edge;
	}

	private Collection<ProMGraphElement> addMultiEdge(final DirectedGraphEdge<?, ?> e) {
		assert e instanceof MultipleSources || e instanceof MultipleTargets;

		Collection<ProMGraphElement> elements = new ArrayList<>();

		Collection<DirectedGraphNode> sources;
		if (e instanceof MultipleSources<?>) {
			sources = new ArrayList<>(((MultipleSources<?>) e).getSources().size());
			sources.addAll(((MultipleSources<?>) e).getSources());
		} else {
			sources = new ArrayList<>(1);
			sources.add(e.getSource());
		}

		Collection<DirectedGraphNode> targets;
		if (e instanceof MultipleTargets<?>) {
			targets = new ArrayList<>(((MultipleTargets<?>) e).getTargets().size());
			targets.addAll(((MultipleTargets<?>) e).getTargets());
		} else {
			targets = new ArrayList<>(1);
			targets.add(e.getTarget());
		}
		List<DirectedGraphElement> tempGraphElements = new ArrayList<DirectedGraphElement>(1 + targets.size()
				+ sources.size());
		layoutConnection.setMultiGraphElements(e, tempGraphElements);
		multiEdgeMap.put(e, elements);

		if (targets.size() == 1 && sources.size() == 1) {
			elements.add(addEdge(e));
			return elements;
		}

		final DirectedGraphNodeForMultiGraph intermediate = new DirectedGraphNodeForMultiGraph(e);

		layoutConnection.setSize(intermediate,
				intermediate.getAttributeMap().get(AttributeMap.SIZE, new Dimension(50, 50)));
		layoutConnection.setPortOffset(
				intermediate,
				intermediate.getAttributeMap().get(AttributeMap.PORTOFFSET,
						new Point2D.Double(GraphConstants.PERMILLE / 2, GraphConstants.PERMILLE / 2)));

		tempGraphElements.add(intermediate);
		elements.add(addCell(intermediate));

		for (final DirectedGraphNode source : sources) {
			DirectedGraphEdge<?, ?> tmpEdge = new DirectedGraphEdgeForMultiGraph(source, intermediate, e);
			tempGraphElements.add(tmpEdge);
			ProMGraphEdge edge = addEdge(tmpEdge);// new ProMGraphEdge(tmpEdge, model, layoutConnection);
			elements.add(edge);

			ProMGraphPort srcPort;
			if ((tmpEdge.getSource() instanceof BoundaryDirectedGraphNode)
					&& ((BoundaryDirectedGraphNode) tmpEdge.getSource()).getBoundingNode() != null) {
				srcPort = boundaryNodeMap.get(tmpEdge.getSource());
			} else {
				srcPort = (ProMGraphPort) nodeMap.get(tmpEdge.getSource()).getChildAt(0);
			}
			ProMGraphPort tgtPort = (ProMGraphPort) nodeMap.get(tmpEdge.getTarget()).getChildAt(0);

			edge.setSource(srcPort);
			edge.setTarget(tgtPort);

			srcPort.addEdge(edge);
			tgtPort.addEdge(edge);

			// if the edge is contained in a node, its cell must be contained in the cell of that node
			if (e instanceof ContainableDirectedGraphElement) {
				ContainingDirectedGraphNode parent = Cast.<ContainableDirectedGraphElement>cast(e).getParent();
				if (parent != null) {
					nodeMap.get(parent).add(edge);
					assert (edge.getParent() == nodeMap.get(parent));
				}
			}

		}

		for (final DirectedGraphNode target : targets) {
			DirectedGraphEdge<?, ?> tmpEdge = new DirectedGraphEdgeForMultiGraph(intermediate, target, e);
			tempGraphElements.add(tmpEdge);

			ProMGraphEdge edge = addEdge(tmpEdge);//ProMGraphEdge edge = new ProMGraphEdge(tmpEdge, model, layoutConnection);
			elements.add(edge);

			ProMGraphPort srcPort = (ProMGraphPort) nodeMap.get(tmpEdge.getSource()).getChildAt(0);

			ProMGraphPort tgtPort;
			if ((tmpEdge.getTarget() instanceof BoundaryDirectedGraphNode)
					&& ((BoundaryDirectedGraphNode) tmpEdge.getTarget()).getBoundingNode() != null) {
				tgtPort = boundaryNodeMap.get(tmpEdge.getTarget());
			} else {
				tgtPort = (ProMGraphPort) nodeMap.get(tmpEdge.getTarget()).getChildAt(0);
			}
			edge.setSource(srcPort);
			edge.setTarget(tgtPort);

			srcPort.addEdge(edge);
			tgtPort.addEdge(edge);

			// if the edge is contained in a node, its cell must be contained in the cell of that node
			if (e instanceof ContainableDirectedGraphElement) {
				ContainingDirectedGraphNode parent = Cast.<ContainableDirectedGraphElement>cast(e).getParent();
				if (parent != null) {
					nodeMap.get(parent).add(edge);
					assert (edge.getParent() == nodeMap.get(parent));
				}
			}
		}

		return elements;
	}

	public void update(Object... elements) {
		updateElements(Arrays.asList(elements));
	}

	public void update(Set<?> elements) {
		updateElements(elements);
	}

	private void updateElements(Collection<?> elements) {

		// For each updated element, find the corresponding view of the corresponding cell and copy the
		// attributes that matter, i.e. size/position/points.

		//The order in which cells, ports and edges are added matters:
		//Cells first, ports second and edges third (because ports are attached to cells and edges to ports.)
		Vector<ProMGraphElement> cellsToAdd = new Vector<ProMGraphElement>();
		Vector<ProMGraphElement> portsToAdd = new Vector<ProMGraphElement>();
		Vector<ProMGraphElement> edgesToAdd = new Vector<ProMGraphElement>();
		Vector<CellView> cellViewsToAdd = new Vector<CellView>();
		Vector<CellView> portViewsToAdd = new Vector<CellView>();
		Vector<CellView> edgeViewsToAdd = new Vector<CellView>();

		for (Object element : elements) {
			if ((element instanceof BoundaryDirectedGraphNode) ? ((BoundaryDirectedGraphNode) element)
					.getBoundingNode() != null : false) {
				ProMGraphPort cell = boundaryNodeMap.get(element);
				if (cell != null) {
					// An update on a cell that does not exist in the view should not be done.
					portsToAdd.add(cell);
					portViewsToAdd.add(cell.getView());
				}
			} else if (element instanceof DirectedGraphNode) {
				ProMGraphCell cell = nodeMap.get(element);
				if (cell != null) {
					// An update on a cell that does not exist in the view should not be done.
					cellsToAdd.add(cell);
					cellViewsToAdd.add(cell.getView());
				}
			} else if (element instanceof MultipleSources || element instanceof MultipleTargets) {
				Collection<ProMGraphElement> cells = multiEdgeMap.get(element);
				if (cells != null) {
					// An update on a cell that does not exist in the view should not be done.
					for (ProMGraphElement cell : cells) {
						if (cell instanceof ProMGraphCell) {
							// An update on a cell that does not exist in the view should not be done.
							cellsToAdd.add(cell);
							cellViewsToAdd.add(cell.getView());
						} else {
							edgesToAdd.add(cell);
							edgeViewsToAdd.add(cell.getView());
						}
					}
				}
			} else if (element instanceof DirectedGraphEdge<?, ?>) {
				ProMGraphEdge cell = edgeMap.get(element);
				if (cell != null) {
					// An update on a cell that does not exist in the view should not be done.
					edgesToAdd.add(cell);
					edgeViewsToAdd.add(cell.getView());
				}
			} else if (element instanceof DirectedGraph<?, ?>) {
				// graph has changed
			} else {
				assert (false);
			}
		}

		Vector<CellView> views = cellViewsToAdd;
		views.addAll(portViewsToAdd);
		views.addAll(edgeViewsToAdd);
		Vector<ProMGraphElement> cells = cellsToAdd;
		cells.addAll(portsToAdd);
		cells.addAll(edgesToAdd);
		Rectangle2D oldBound = GraphLayoutCache.getBounds(views.toArray(new CellView[0]));
		for (ProMGraphElement cell : cells) {
			cell.updateViewsFromMap();
		}
		if (oldBound != null) {
			Rectangle2D.union(oldBound, GraphLayoutCache.getBounds(views.toArray(new CellView[0])), oldBound);
		}
		//		repaint(oldBound.getBounds());
		getGraphLayoutCache().cellViewsChanged(views.toArray(new CellView[0]));
		// HV: Refresh the graph to show the changes.
		this.refresh();
	}

	public String toString() {
		return model.toString();
	}

	public void graphChanged(GraphModelEvent e) {
		handleChange(e.getChange());
		changeHandled();
		for (UpdateListener l : updateListeners) {
			l.updated();
		}
	}

	/**
	 * Might be overridden to signal that a change was handled
	 */
	protected void changeHandled() {
		layoutConnection.updated();
	}

	private void handleChange(GraphLayoutCacheEvent.GraphLayoutCacheChange change) {
		// A change originated in from the graph. This needs to be reflected in
		// the layoutConnection (if applicable)
		synchronized (model) {
			boolean signalChange = false;
			Object[] changed = change.getChanged();

			Set<AttributeMapOwner> changedOwners = new HashSet<AttributeMapOwner>();
			Set<ProMGraphEdge> edges = new HashSet<ProMGraphEdge>();
			for (Object o : changed) {
				if (o instanceof ProMGraphCell) {
					// handle a change for a cell
					ProMGraphCell cell = (ProMGraphCell) o;

					DirectedGraphNode node = cell.getNode();

					Rectangle2D rect;
					if (change.getSource() instanceof ProMGraphModel) {
						rect = GraphConstants.getBounds(cell.getAttributes());
					} else {
						rect = cell.getView().getBounds();
					}

					if (handleNodeChange(cell, node, rect)) {
						changedOwners.add(node);
						signalChange = true;
					}
				}
				if (o instanceof ProMGraphEdge) {
					edges.add((ProMGraphEdge) o);
				}
			}
			for (ProMGraphEdge cell : edges) {
				// handle a change for a cell
				DirectedGraphEdge<?, ?> edge = cell.getEdge();

				List<?> points;
				if (change.getSource() instanceof ProMGraphModel) {
					points = GraphConstants.getPoints(cell.getAttributes());
				} else {
					points = cell.getView().getPoints();
				}

				if (handleEdgeChange(cell, edge, points)) {
					changedOwners.add(edge);
					signalChange = true;
				}
			}
			if (signalChange && !isPIP) {
				layoutConnection.updatedAttributes(changedOwners.toArray(new AttributeMapOwner[0]));
			}
		}
	}

	private boolean handleNodeChange(ProMGraphCell cell, DirectedGraphNode node, Rectangle2D rect) {
		boolean changed = false;

		//		// get the view's bounds and put them in the attributemap
		//		Rectangle2D rect = cell.getView().getBounds();
		//		rect = GraphConstants.getBounds(cell.getAttributes());

		if (rect != null) {
			// SIZE
			Dimension2D size = new Dimension((int) rect.getWidth(), (int) rect.getHeight());
			changed |= layoutConnection.setSize(node, size);

			// POSITION
			Point2D pos = new Point2D.Double(rect.getX(), rect.getY());
			changed |= layoutConnection.setPosition(node, pos);

		}

		return changed;
	}

	private boolean handleEdgeChange(ProMGraphEdge cell, DirectedGraphEdge<?, ?> edge, List<?> points) {
		boolean changed = false;

		List<Point2D> list = new ArrayList<Point2D>(3);
		if (points != null) {
			for (int i = 1; i < points.size() - 1; i++) {
				Point2D point = (Point2D) points.get(i);
				list.add(new Point2D.Double(point.getX(), point.getY()));
			}
		}
		changed |= layoutConnection.setEdgePoints(edge, list);

		return changed;
	}

	public void graphLayoutCacheChanged(GraphLayoutCacheEvent e) {
		handleChange(e.getChange());
		changeHandled();
		for (UpdateListener l : updateListeners) {
			l.updated();
		}
	}

	public void valueChanged(GraphSelectionEvent e) {
		// Ignore for now
	}

	@Override
	public String getToolTipText(MouseEvent event) {
		// get first cell under the mouse pointer's position
		Object cell = getFirstCellForLocation(event.getX(), event.getY());

		ViewSpecificAttributeMap map = getViewSpecificAttributes();

		// determine what is being pointed to by the mouse pointer
		if (cell instanceof ProMGraphCell) {
			// mouse is pointing to a node or a port on that node
			ProMGraphCell c = ((ProMGraphCell) cell);
			return map.get(c.getNode(), AttributeMap.TOOLTIP, c.getLabel());
		} else if (cell instanceof ProMGraphEdge) {
			ProMGraphEdge e = ((ProMGraphEdge) cell);
			return map.get(e.getEdge(), AttributeMap.TOOLTIP, e.getLabel());
		}

		return null;
	}

	// returns the original origin
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	public void repositionToOrigin() {

		//		facade.translateCells(facade.getVertices(), 100.0, 100.0);
		//		facade.translateCells(facade.getEdges(), 100.0, 100.0);
		//		getGraphLayoutCache().edit(facade.createNestedMap(true, false));
		/*
		 * Second, pull everything back to (2,2). Works like a charm, even when
		 * a hack...
		 */

		//TODO Doesn't correctly handle collapsed nodes.

		JGraphFacade facade = new JGraphFacade(this);
		facade.setIgnoresHiddenCells(true);
		facade.setIgnoresCellsInGroups(false);
		facade.setIgnoresUnconnectedCells(false);

		double x = facade.getGraphOrigin().getX();
		double y = facade.getGraphOrigin().getY();

		ArrayList cells = new ArrayList();
		cells.addAll(facade.getVertices());
		cells.addAll(facade.getEdges());
		facade.translateCells(cells, 2.0 - x, 2.0 - y);
		Map map = facade.createNestedMap(true, false);
		getGraphLayoutCache().edit(map);

	}

	public DirectedGraph<? extends DirectedGraphNode, ? extends DirectedGraphEdge<? extends DirectedGraphNode, ? extends DirectedGraphNode>> getProMGraph() {
		return model.getGraph();
	}

	private void registerAsListener() {
		model.addGraphModelListener(this);
		addGraphSelectionListener(this);
		getGraphLayoutCache().addGraphLayoutCacheListener(this);
	}

	public int hashCode() {
		return model.getGraph().hashCode();
	}

	public JGraphLayout getUpdateLayout() {
		return layout;
	}

	public GraphLayoutConnection getLayoutConnection() {
		return layoutConnection;
	}

	public void setUpdateLayout(JGraphLayout layout) {
		this.layout = layout;
	}

	public ViewSpecificAttributeMap getViewSpecificAttributes() {
		return viewSpecificAttributes;
	}

	public void nodeCollapsed(Expandable source) {
		ProMGraphCell cell = (nodeMap.get(source));
		// Before calling collapse, set the size of cell to the collapsed size

		Point2D pos = layoutConnection.getPosition(source);
		if (pos == null) {
			pos = new Point2D.Double(10, 10);
		}

		Dimension size = source.getCollapsedSize();

		Rectangle2D bounds = GraphConstants.getBounds(cell.getAttributes());
		bounds.setFrame(pos.getX(), pos.getY(), size.getWidth(), size.getHeight());
		getGraphLayoutCache().collapse(DefaultGraphModel.getDescendants(model, new Object[] { cell }).toArray());
	}

	public void nodeExpanded(Expandable source) {
		ProMGraphCell cell = (nodeMap.get(source));
		getGraphLayoutCache().expand(DefaultGraphModel.getDescendants(model, new Object[] { cell }).toArray());
	}

	public JComponent getComponent() {
		// for interface Scalable
		return this;
	}

	Set<UpdateListener> updateListeners = new HashSet<UpdateListener>();

	public void addUpdateListener(UpdateListener listener) {
		updateListeners.add(listener);
	}

	public void removeUpdateListener(UpdateListener listener) {
		updateListeners.remove(listener);
	}

	public void layoutConnectionUpdated(AttributeMapOwner... owners) {
		update((Object[]) owners);
	}

}

class Change implements GraphModelEvent.GraphModelChange {

	private final Collection<Object> added;
	private final Collection<Object> removed;
	private final Collection<Object> changed;
	private final ProMGraphModel source;
	private final Rectangle2D dirtyRegion;

	public Change(ProMGraphModel source, Collection<Object> added, Collection<Object> removed,
			Collection<Object> changed, Rectangle2D dirtyRegion) {
		this.source = source;
		this.added = added;
		this.removed = removed;
		this.changed = changed;
		this.dirtyRegion = dirtyRegion;

	}

	public ConnectionSet getConnectionSet() {
		return null;
	}

	public ParentMap getParentMap() {
		return null;
	}

	public ConnectionSet getPreviousConnectionSet() {
		return null;
	}

	public ParentMap getPreviousParentMap() {
		return null;
	}

	public CellView[] getViews(GraphLayoutCache view) {
		return null;
	}

	public void putViews(GraphLayoutCache view, CellView[] cellViews) {

	}

	public Map<?, ?> getAttributes() {
		return null;
	}

	public Object[] getChanged() {
		return changed.toArray();
	}

	public Object[] getContext() {
		return null;
	}

	public Rectangle2D getDirtyRegion() {
		return dirtyRegion;
	}

	public Object[] getInserted() {
		return added.toArray();
	}

	public Map<?, ?> getPreviousAttributes() {
		return null;
	}

	public Object[] getRemoved() {
		return removed.toArray();
	}

	public Object getSource() {
		return source;
	}

	public void setDirtyRegion(Rectangle2D dirty) {

	}

}"
ProMJGraphVisualizer.java,widgets-6.9.234,"package org.processmining.models.jgraph;

import java.util.Collection;
import java.util.Map;

import javax.swing.SwingConstants;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionID;
import org.processmining.framework.connections.ConnectionManager;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;
import org.processmining.framework.util.ui.scalableview.interaction.ExportInteractionPanel;
import org.processmining.framework.util.ui.scalableview.interaction.PIPInteractionPanel;
import org.processmining.framework.util.ui.scalableview.interaction.ZoomInteractionPanel;
import org.processmining.models.connections.GraphLayoutConnection;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraph;
import org.processmining.models.jgraph.visualization.ProMJGraphPanel;

import com.jgraph.layout.JGraphFacade;
import com.jgraph.layout.JGraphLayout;
import com.jgraph.layout.hierarchical.JGraphHierarchicalLayout;

public class ProMJGraphVisualizer {

	protected ProMJGraphVisualizer() {
	};

	private static ProMJGraphVisualizer instance = null;

	public static ProMJGraphVisualizer instance() {
		if (instance == null) {
			instance = new ProMJGraphVisualizer();
		}
		return instance;
	}

	protected GraphLayoutConnection findConnection(PluginContext context, DirectedGraph<?, ?> graph) {
		return findConnection(context.getConnectionManager(), graph);
	}

	protected GraphLayoutConnection findConnection(ConnectionManager manager, DirectedGraph<?, ?> graph) {
		Collection<ConnectionID> cids = manager.getConnectionIDs();
		for (ConnectionID id : cids) {
			Connection c;
			try {
				c = manager.getConnection(id);
			} catch (ConnectionCannotBeObtained e) {
				continue;
			}
			if (c != null && !c.isRemoved() && c instanceof GraphLayoutConnection
					&& c.getObjectWithRole(GraphLayoutConnection.GRAPH) == graph) {
				return (GraphLayoutConnection) c;
			}
		}
		return null;
	}

	public ProMJGraphPanel visualizeGraphWithoutRememberingLayout(DirectedGraph<?, ?> graph) {
		return visualizeGraph(new GraphLayoutConnection(graph), null, graph, new ViewSpecificAttributeMap());
	}

	public ProMJGraphPanel visualizeGraphWithoutRememberingLayout(DirectedGraph<?, ?> graph,
			ViewSpecificAttributeMap map) {
		return visualizeGraph(new GraphLayoutConnection(graph), null, graph, map);
	}

	public ProMJGraphPanel visualizeGraph(PluginContext context, DirectedGraph<?, ?> graph) {
		return visualizeGraph(findConnection(context, graph), context, graph, new ViewSpecificAttributeMap());
	}

	public ProMJGraphPanel visualizeGraph(PluginContext context, DirectedGraph<?, ?> graph, ViewSpecificAttributeMap map) {
		return visualizeGraph(findConnection(context, graph), context, graph, map);
	}

	private ProMJGraphPanel visualizeGraph(GraphLayoutConnection layoutConnection, PluginContext context,
			DirectedGraph<?, ?> graph, ViewSpecificAttributeMap map) {
		boolean newConnection = false;
		if (layoutConnection == null) {
			layoutConnection = createLayoutConnection(graph);
			newConnection = true;
		}

		if (!layoutConnection.isLayedOut()) {
			// shown for the first time.
			layoutConnection.expandAll();
		}
		//		graph.signalViews();

		ProMGraphModel model = new ProMGraphModel(graph);
		ProMJGraph jgraph;
		/*
		 * Make sure that only a single ProMJGraph is created at every time.
		 * The underlying JGrpah code cannot handle creating multiple creations at the same time.
		 */
		synchronized (instance) {
			jgraph = new ProMJGraph(model, map, layoutConnection);
		}

		JGraphLayout layout = getLayout(map.get(graph, AttributeMap.PREF_ORIENTATION, SwingConstants.SOUTH));

		if (!layoutConnection.isLayedOut()) {

			JGraphFacade facade = new JGraphFacade(jgraph);

			facade.setOrdered(false);
			facade.setEdgePromotion(true);
			facade.setIgnoresCellsInGroups(false);
			facade.setIgnoresHiddenCells(false);
			facade.setIgnoresUnconnectedCells(false);
			facade.setDirected(true);
			facade.resetControlPoints();
			if (layout instanceof JGraphHierarchicalLayout) {
				facade.run((JGraphHierarchicalLayout) layout, true);
			} else {
				facade.run(layout, true);
			}

			Map<?, ?> nested = facade.createNestedMap(true, true);

			jgraph.getGraphLayoutCache().edit(nested);
//			jgraph.repositionToOrigin();
			layoutConnection.setLayedOut(true);

		}

		jgraph.setUpdateLayout(layout);

		ProMJGraphPanel panel = new ProMJGraphPanel(jgraph);

		panel.addViewInteractionPanel(new PIPInteractionPanel(panel), SwingConstants.NORTH);
		panel.addViewInteractionPanel(new ZoomInteractionPanel(panel, ScalableViewPanel.MAX_ZOOM), SwingConstants.WEST);
		panel.addViewInteractionPanel(new ExportInteractionPanel(panel), SwingConstants.SOUTH);

		layoutConnection.updated();

		if (newConnection) {
			context.getConnectionManager().addConnection(layoutConnection);
		}

		return panel;

	}

	private GraphLayoutConnection createLayoutConnection(DirectedGraph<?, ?> graph) {
		GraphLayoutConnection c = new GraphLayoutConnection(graph);
		return c;
	}

	protected JGraphLayout getLayout(int orientation) {
		JGraphHierarchicalLayout layout = new JGraphHierarchicalLayout();
		layout.setDeterministic(true);
		layout.setCompactLayout(true);
		layout.setFineTuning(true);
		layout.setParallelEdgeSpacing(15);
		layout.setFixRoots(false);
		
	
		layout.setOrientation(orientation);

		return layout;
	}

}
"
ProMLoopRouting.java,widgets-6.9.234,"package org.processmining.models.jgraph;

import java.util.List;

import org.jgraph.graph.DefaultEdge;
import org.jgraph.graph.EdgeView;
import org.jgraph.graph.GraphLayoutCache;

public class ProMLoopRouting extends DefaultEdge.DefaultRouting {

	public static ProMLoopRouting ROUTER = new ProMLoopRouting();

	private static final long serialVersionUID = -1502015269578934172L;

	public List<?> route(GraphLayoutCache cache, EdgeView edge) {
		// No routing is performed ""on the fly"", i.e. all routing information
		// is introduced during the layout phase where all internal control points
		// of edges are set. Hence, the route should just return null.
		return null;
	}
}
"
ProMEdgeRenderer.java,widgets-6.9.234,"package org.processmining.models.jgraph.renderers;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.util.Map;

import org.jgraph.graph.CellView;
import org.jgraph.graph.EdgeRenderer;
import org.jgraph.graph.EdgeView;
import org.jgraph.graph.GraphConstants;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.jgraph.elements.ProMGraphEdge;
import org.processmining.models.jgraph.views.JGraphEdgeView;

public class ProMEdgeRenderer extends EdgeRenderer implements Cleanable {

	private static final long serialVersionUID = 4470395577059556630L;

	private transient int middleDeco, middleSize;
	private transient boolean middleFill;
	private transient int numLines;
	private transient float lineWidth;

	public void cleanUp() {
		view = null;
	}

	protected void paintLabel(Graphics g, String label, Point2D p, boolean mainLabel) {
		ViewSpecificAttributeMap map = ((JGraphEdgeView) view).getViewSpecificAttributeMap();
		DirectedGraphEdge<?, ?> edge = ((JGraphEdgeView) view).getEdge();
		if (map.get(edge, AttributeMap.SHOWLABEL, false) && !((JGraphEdgeView) view).isPIP()) {
			super.paintLabel(g, mainLabel ? map.get(edge, AttributeMap.LABEL, label) : label, p, mainLabel);
		}
	}

	/**
	 * Returns the label size of the specified view in the given graph.
	 */
	public Dimension getLabelSize(EdgeView view, String label) {
		ViewSpecificAttributeMap map = ((JGraphEdgeView) view).getViewSpecificAttributeMap();
		DirectedGraphEdge<?, ?> edge = ((JGraphEdgeView) view).getEdge();
		if (map.get(edge, AttributeMap.SHOWLABEL, false) && !((JGraphEdgeView) view).isPIP()) {
			return super.getLabelSize(view, map.get(edge, AttributeMap.LABEL, """"));
		} else {
			return new Dimension(0, 0);
		}
	}

	@Override
	protected void installAttributes(final CellView view) {
		super.installAttributes(view);
		Map map = view.getAllAttributes();

		//		JGraphEdgeView v = (JGraphEdgeView) view;
		//		ViewSpecificAttributeMap vMap = v.getViewSpecificAttributeMap();
		//		DirectedGraphEdge<?, ?> edge = v.getEdge();

		lineWidth = (Float) map.get(ProMGraphEdge.LINEWIDTH);

		numLines = (Integer) map.get(ProMGraphEdge.NUMBERLINES);
		middleDeco = (Integer) map.get(ProMGraphEdge.LINEMIDDLE);
		middleSize = 20;
		middleFill = (Boolean) map.get(ProMGraphEdge.MIDDLEFILL) && isFillable(middleDeco);

	}

	@Override
	protected void paintEdge(Graphics g) {
		ViewSpecificAttributeMap map = ((JGraphEdgeView) view).getViewSpecificAttributeMap();
		Color foreground = map.get(((JGraphEdgeView) view).getEdge(), AttributeMap.EDGECOLOR, getForeground());
		setForeground((foreground != null) ? foreground : defaultForeground);
		lineWidth = map.get(((JGraphEdgeView) view).getEdge(), AttributeMap.LINEWIDTH, lineWidth);

		g.setColor(getForeground());
		if (lineWidth > 0) {
			Graphics2D g2 = (Graphics2D) g;
			int c = BasicStroke.CAP_BUTT;
			int j = BasicStroke.JOIN_MITER;
			g2.setStroke(new BasicStroke(lineWidth, c, j));
			if (gradientColor != null && !preview) {
				g2.setPaint(new GradientPaint(0, 0, getBackground(), getWidth(), getHeight(), gradientColor, true));
			}
			if (lineDash != null) // Dash For Line Only
				g2.setStroke(new BasicStroke(lineWidth, c, j, 10.0f, lineDash, dashOffset));
			if (view.lineShape != null) {
				Color color = getForeground();
				drawLine(g2, c, j, color);
			}
			g2.setStroke(new BasicStroke(lineWidth, c, j));
			g2.setColor(getForeground());
			if (view.beginShape != null) {
				if (beginFill) {
					g2.fill(view.beginShape);
					g2.draw(view.beginShape);
				} else {
					g2.setColor(getBackground());
					g2.fill(view.beginShape);
					g2.setColor(getForeground());
					g2.draw(view.beginShape);
				}
			}
			if (view.endShape != null) {
				if (endFill) {
					g2.fill(view.endShape);
					g2.draw(view.endShape);
				} else {
					g2.setColor(getBackground());
					g2.fill(view.endShape);
					g2.setColor(getForeground());
					g2.draw(view.endShape);
				}
			}

			if (((JGraphEdgeView) view).middleShape != null) {
				if (middleFill) {
					g2.fill(((JGraphEdgeView) view).middleShape);
					g2.draw(((JGraphEdgeView) view).middleShape);
				} else {
					g2.setColor(getBackground());
					g2.fill(((JGraphEdgeView) view).middleShape);
					g2.setColor(getForeground());
					g2.draw(((JGraphEdgeView) view).middleShape);
				}
			}

		}
	}

	protected void drawLine(Graphics2D g2, int c, int j, Color color) {
		if (numLines == 1) {
			g2.draw(view.lineShape);
		} else {
			for (int i = 2 * numLines - 1; i > 0; i -= 2) {
				if (lineDash != null) // Dash For Line Only
					g2.setStroke(new BasicStroke(lineWidth * i, c, j, 10.0f, lineDash, dashOffset));
				else
					g2.setStroke(new BasicStroke(lineWidth * i, c, j));
				g2.setColor(color);
				g2.draw(view.lineShape);
				color = switchColor(color);
			}
		}
	}

	@Override
	protected void paintSelection(Graphics g) {
		if (selected) { // Paint Selected
			Graphics2D g2 = (Graphics2D) g;
			int c = BasicStroke.CAP_BUTT;
			int j = BasicStroke.JOIN_MITER;
			g2.setStroke(GraphConstants.SELECTION_STROKE);
			g2.setColor(highlightColor);
			if (view.beginShape != null)
				g2.draw(view.beginShape);
			if (view.lineShape != null)
				//				g2.draw(view.lineShape);
				drawLine(g2, c, j, highlightColor);
			if (view.endShape != null)
				g2.draw(view.endShape);
			//			if (((JGraphEdgeView) view).middleShape != null) {
			//				g2.draw(((JGraphEdgeView) view).middleShape);
			//			}
		}
	}

	private Color switchColor(final Color color) {
		if (color != null) {
			if (color.equals(getForeground())) {
				return getBackground();
			} else {
				return getForeground();
			}
		}
		return getForeground();
	}

	/**
	 * Paint the current view's direction. Sets tmpPoint as a side-effect such
	 * that the invoking method can use it to determine the connection point to
	 * this decoration.
	 * 
	 * @param size
	 *            int
	 * @param style
	 *            int
	 * @param src
	 *            Point2D
	 * @param dst
	 *            Point2D
	 * @return Shape
	 */
	@Override
	protected Shape createLineEnd(final int size, final int style, final Point2D src, final Point2D dst) {
		if (src == null || dst == null) {
			return null;
		}

		switch (style) {
			case ProMGraphEdge.ARROW_TECHNICAL_CIRCLE :
				final Area areaCircle = new Area(super.createLineEnd(size, GraphConstants.ARROW_CIRCLE, src, dst));
				final Shape arrow = super.createLineEnd(size, GraphConstants.ARROW_TECHNICAL, src, dst);
				final Area areaPoly = new Area(arrow);
				areaCircle.add(areaPoly);
				return areaCircle;
			case ProMGraphEdge.ARROW_CROSS :
				final GeneralPath path = new GeneralPath(Path2D.WIND_NON_ZERO, 4);
				path.moveTo((float) (dst.getX() + 5), (float) (dst.getY() + 5));
				path.lineTo((float) (dst.getX() - 5), (float) (dst.getY() - 5));
				path.moveTo((float) (dst.getX() + 5), (float) (dst.getY() - 5));
				path.lineTo((float) (dst.getX() - 5), (float) (dst.getY() + 5));
				return path;
			default :
				return super.createLineEnd(size, style, src, dst);
		}
	}

	@Override
	protected Shape createShape() {
		if (middleDeco != GraphConstants.ARROW_NONE) {
			if (view.getPoints().size() > 1) {
				//				final Point2D p1 = view.getPoint(view.getPoints().size() / 2 - 1);
				//				final Point2D p2;
				//				if ((view.getPoints().size() & 1) == 0) {
				//					// even number of points
				//					p2 = new Point2D.Double((p1.getX() + view.getPoint(view.getPoints().size() / 2).getX()) / 2,
				//							(p1.getY() + view.getPoint(view.getPoints().size() / 2).getY()) / 2);
				//				} else {
				//					p2 = view.getPoint(view.getPoints().size() / 2);
				//				}
				Point2D p1 = view.getPoint(0);
				Point2D p2 = view.getPoint(view.getPoints().size() - 1);
				Point2D p3 = new Point2D.Double(p1.getX() + (p2.getX() - p1.getX()) / 2, p1.getY()
						+ (p2.getY() - p1.getY()) / 2);

				int pi = -1;
				double min = Double.MAX_VALUE;
				for (int i = 1; i < view.getPointCount() - 1; i++) {
					if (view.getPoint(i).distance(p3) < min) {
						min = view.getPoint(i).distance(p3);
						pi = i;
						p1 = view.getPoint(i - 1);
					}
				}
				if (pi >= 0)
					p3 = view.getPoint(pi);

				// We draw at p3 in the direction of p1

				((JGraphEdgeView) view).middleShape = createLineEnd(middleSize, middleDeco, p1, p3);
			}
		}
		return super.createShape();
	}
}
"
ProMGroupShapeRenderer.java,widgets-6.9.234,"package org.processmining.models.jgraph.renderers;

/*
 * $Id: JGraphGroupRenderer.java,v 1.1 2005/10/08 13:30:01 david Exp $ Copyright
 * (c) 2001-2005, Gaudenz Alder
 * 
 * All rights reserved.
 * 
 * This file is licensed under the JGraph software license, a copy of which will
 * have been provided to you in the file LICENSE at the root of your
 * installation directory. If you are unable to locate this file please contact
 * JGraph sales for another copy.
 */

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.awt.geom.Point2D;

import org.jgraph.JGraph;
import org.jgraph.graph.CellView;
import org.processmining.models.graphbased.Expandable;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.views.JGraphShapeView;

/**
 * Renderer for grouped cells, includes '+' '-' to expand/collapse
 */
public class ProMGroupShapeRenderer extends ProMShapeRenderer {

	/**
	 * 
	 */
	private static final long serialVersionUID = -2995081858764785849L;

	/**
	 * Default handle bounds for renderer, '+' or '-'
	 */
	public static Rectangle handle = new Rectangle(0, 0, 20, 20);

	/**
	 * Specifies whether the current view is a rich text value, and if the image
	 * should be stretched.
	 */
	protected boolean isGroup = false;

	/**
	 * Holds the background and foreground of the graph.
	 */
	protected Color handleColor = Color.white, graphForeground = Color.black;


	/**
	 * Overrides the parent implementation to return the value component stored
	 * in the user object instead of this renderer if a value component exists.
	 * This applies some of the values installed to this renderer to the value
	 * component (border, opaque) if the latter is a JComponent.
	 * 
	 * @return Returns a configured renderer for the specified view.
	 */
	public Component getRendererComponent(JGraph graph, CellView view, boolean sel, boolean focus, boolean preview) {
		handleColor = graph.getHandleColor();
		graphForeground = graph.getForeground();
		DirectedGraphNode node = ((JGraphShapeView) view).getNode();
		isGroup = (node instanceof Expandable); //DefaultGraphModel.isGroup(graph.getModel(), view.getCell());
		return super.getRendererComponent(graph, view, sel, focus, preview);
	}

	/**
	 * renderer paint method
	 */
	public void paint(Graphics g) {
		super.paint(g);
		if (isGroup) {
			Graphics2D g2 = (g instanceof Graphics2D ? (Graphics2D) g : null);
			Stroke stroke = (g2 != null ? g2.getStroke() : null);
			if (stroke != null) {
				g2.setStroke(new BasicStroke());
			}
			g.setColor(handleColor);
			g.fill3DRect(handle.x, handle.y, handle.width, handle.height, true);
			g.setColor(graphForeground);
			g.drawRect(handle.x, handle.y, handle.width, handle.height);
			g.drawLine(handle.x + 1, handle.y + handle.height / 2, handle.x + handle.width - 2, handle.y
					+ handle.height / 2);
			if (view.isLeaf()) {
				g.drawLine(handle.x + handle.width / 2, handle.y + 1, handle.x + handle.width / 2, handle.y
						+ handle.height - 2);
			}
			if (stroke != null) {
				g2.setStroke(stroke);
			}
		}
	}

	/**
	 * Detect whether or not a point has hit the group/ungroup image
	 * 
	 * @param pt
	 *            the point to check
	 * @return whether or not the point lies within the handle
	 */
	public boolean inHitRegion(Point2D pt) {
		return handle.contains(pt.getX(), pt.getY());
	}

}
"
ProMPortRenderer.java,widgets-6.9.234,"package org.processmining.models.jgraph.renderers;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.SwingConstants;

import org.jgraph.graph.DefaultPort;
import org.jgraph.graph.PortRenderer;
import org.jgraph.graph.PortView;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.BoundaryDirectedGraphNode;
import org.processmining.models.jgraph.views.JGraphPortView;
import org.processmining.models.jgraph.views.JGraphShapeView;
import org.processmining.models.shapes.Decorated;
import org.processmining.models.shapes.Shape;

public class ProMPortRenderer extends PortRenderer implements Cleanable {

	private static final long serialVersionUID = -4077623888811778878L;

	private static LabelRenderer renderer = new LabelRenderer();

	public ProMPortRenderer() {
		super();
	}

	public void cleanUp() {
		view = null;
	}

	public void paint(Graphics g) {
		renderer.setSize(getWidth(), getHeight());
		renderer.paint(view, selected, g);
	}

	public Point2D getPerimeterPoint(PortView view, Point2D source, Point2D p) {
		return renderer.getPerimeterPoint(view, source, p);

	}
}

class LabelRenderer extends JLabel {

	private static final long serialVersionUID = 4310963545024487311L;

	public void paint(PortView view, boolean selected, Graphics g) {
		Object representedObject = ((DefaultPort) view.getCell()).getUserObject();
		if ((representedObject instanceof BoundaryDirectedGraphNode) ? ((BoundaryDirectedGraphNode) representedObject)
				.getBoundingNode() != null : false) {
			BoundaryDirectedGraphNode node = (BoundaryDirectedGraphNode) representedObject;
			Dimension d = getSize();
			ViewSpecificAttributeMap map = ((JGraphPortView) view).getViewSpecificAttributeMap();

			if (!map.get(node, AttributeMap.SHOWLABEL, true) || ((JGraphPortView) view).isPIP()) {
				setText(null);
			} else {
				setVerticalAlignment(map.get(node, AttributeMap.LABELVERTICALALIGNMENT, SwingConstants.TOP));
				setHorizontalAlignment(map.get(node, AttributeMap.LABELHORIZONTALALIGNMENT, SwingConstants.CENTER));
				String text = map.get(node, AttributeMap.LABEL, getText());
				if (!text.toLowerCase().startsWith(""<html>"")) {
					text = ""<html>"" + text + ""</html>"";
				}
				setText(text);
			}

			Shape shape = map.get(node, AttributeMap.SHAPE, JGraphShapeView.RECTANGLE);
			Decorated shapeDecorator = map.get(node, AttributeMap.SHAPEDECORATOR, null);
			if (shapeDecorator == null && node instanceof Decorated) {
				shapeDecorator = (Decorated) node;
			}

			Icon icon = (Icon) map.get(node, AttributeMap.ICON);
			if (icon != null && icon instanceof ImageIcon) {
				Image image = ((ImageIcon) icon).getImage();
				if (icon.getIconHeight() > d.height || icon.getIconWidth() > d.width) {
					image = image.getScaledInstance(d.height, d.width, Image.SCALE_SMOOTH);
				}
				icon = new ImageIcon(image);
			}
			if (!((JGraphPortView) view).isPIP()) {
				setIcon(icon);
			} else {
				setIcon(null);
			}

			int b = map.get(node, AttributeMap.BORDERWIDTH, 1);
			Graphics2D g2 = (Graphics2D) g;

			boolean tmp = selected;

			GeneralPath path = shape.getPath(b, b, d.width - 2 * b, d.height - 2 * b);

			Color fill = (Color) map.get(node, AttributeMap.FILLCOLOR);
			g.setColor(fill);
			setOpaque(fill != null);
			if (fill != null) {
				g2.fill(path);
			}
			//g.setColor(Color.BLACK);
			g.setColor(map.get(node, AttributeMap.STROKECOLOR, Color.BLACK));
			//		g2.setStroke(new BasicStroke(borderWidth));
			float[] pattern = map.get(node, AttributeMap.DASHPATTERN, new float[0]);
			if (pattern.length > 0f) {

				float offset = map.get(node, AttributeMap.DASHOFFSET, 0f);
				g2.setStroke(new BasicStroke(b, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10f, pattern, offset));
			} else {
				g2.setStroke(new BasicStroke(b));
			}

			g2.draw(path);

			try {
				setBorder(null);
				setOpaque(false);
				// selected = false;
				super.paint(g);
				if (shapeDecorator != null) {
					shapeDecorator.decorate(g2, b, b, d.width - 2 * b, d.height - 2 * b);
				}
			} finally {
				selected = tmp;
			}
		}
	}

	public Point2D getPerimeterPoint(PortView view, Point2D source, Point2D p) {
		Rectangle2D bounds = view.getBounds();
		double x = bounds.getX();
		double y = bounds.getY();
		double width = bounds.getWidth();
		double height = bounds.getHeight();
		double xCenter = x + width / 2;
		double yCenter = y + height / 2;
		double dx = p.getX() - xCenter; // Compute Angle
		double dy = p.getY() - yCenter;
		double alpha = Math.atan2(dy, dx);
		double xout = 0, yout = 0;
		double pi = Math.PI;
		double pi2 = Math.PI / 2.0;
		double beta = pi2 - alpha;
		double t = Math.atan2(height, width);
		if (alpha < -pi + t || alpha > pi - t) { // Left edge
			xout = x;
			yout = yCenter - width * Math.tan(alpha) / 2;
		} else if (alpha < -t) { // Top Edge
			yout = y;
			xout = xCenter - height * Math.tan(beta) / 2;
		} else if (alpha < t) { // Right Edge
			xout = x + width;
			yout = yCenter + width * Math.tan(alpha) / 2;
		} else { // Bottom Edge
			yout = y + height;
			xout = xCenter + height * Math.tan(beta) / 2;
		}
		return new Point2D.Double(xout, yout);
	}
}"
ProMShapeRenderer.java,widgets-6.9.234,"package org.processmining.models.jgraph.renderers;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Paint;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.SwingConstants;

import org.jgraph.JGraph;
import org.jgraph.graph.CellView;
import org.jgraph.graph.GraphConstants;
import org.jgraph.graph.VertexRenderer;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.views.JGraphShapeView;
import org.processmining.models.shapes.Decorated;
import org.processmining.models.shapes.Shape;

// ************************************************************************
public class ProMShapeRenderer extends VertexRenderer implements Cleanable {

	static {
		// Change the default font
		GraphConstants.DEFAULTFONT = GraphConstants.DEFAULTFONT.deriveFont(Font.PLAIN);
		GraphConstants.DEFAULTFONT = GraphConstants.DEFAULTFONT.deriveFont(9.0f);
		GraphConstants.DEFAULTFONT = GraphConstants.DEFAULTFONT.deriveFont(AffineTransform.getScaleInstance(0.75, 1.0));
	}

	private static final long serialVersionUID = 9118304969661088440L;
	private static final Stroke SELECTIONSTROKE = new BasicStroke(2f);

	/**
	 * Return a slightly larger preferred size than for a rectangle.
	 */
	public Dimension getPreferredSize() {
		Dimension d = super.getPreferredSize();
		d.setSize(d.getWidth() * 1.4, d.getHeight() * 1.4);
		return d;
	}

	/**
	 */
	public void paint(Graphics g) {
		ViewSpecificAttributeMap map = ((JGraphShapeView) view).getViewSpecificAttributeMap();

		highlightColor = highlightColor != null ? highlightColor : Color.ORANGE;
		lockedHandleColor = lockedHandleColor != null ? lockedHandleColor : Color.RED;
		DirectedGraphNode node = ((JGraphShapeView) view).getNode();
		//		Dimension d = (Dimension) map.get(node,AttributeMap.SIZE);
		//		d.setSize(d.getWidth() * 1.4, d.getHeight() * 1.4);

		Dimension d = (Dimension) map.get(node, AttributeMap.SIZE);
		if (d == null) {
			d = getSize();
		} else {
			Rectangle2D bounds = view.getBounds();
			if (bounds.getWidth() != d.getWidth() || bounds.getHeight() != d.getHeight()) {
				view.setBounds(new Rectangle2D.Double(bounds.getX(), bounds.getY(), d.getWidth(), d.getHeight()));
			}
			setSize(d);
		}

		//assert(d.equals(node.getAttributeMap().get(AttributeMap.SIZE)));

		if (!map.get(node, AttributeMap.SHOWLABEL, true) || ((JGraphShapeView) view).isPIP()) {
			setText(null);
		} else {
			setVerticalAlignment(map.get(node, AttributeMap.LABELVERTICALALIGNMENT, SwingConstants.TOP));
			setHorizontalAlignment(map.get(node, AttributeMap.LABELHORIZONTALALIGNMENT, SwingConstants.CENTER));
			String text = map.get(node, AttributeMap.LABEL, getText());
			if (!text.toLowerCase().startsWith(""<html>"")) {
				text = ""<html>"" + text + ""</html>"";
			}
			setText(text);
		}

		Shape shape = map.get(node, AttributeMap.SHAPE, JGraphShapeView.RECTANGLE);
		Decorated shapeDecorator = map.get(node, AttributeMap.SHAPEDECORATOR, null);
		if (shapeDecorator == null && node instanceof Decorated) {
			shapeDecorator = (Decorated) node;
		}

		Icon icon = (Icon) map.get(node, AttributeMap.ICON);
		if ((icon != null) && (icon instanceof ImageIcon)) {
			Image image = ((ImageIcon) icon).getImage();
			if ((icon.getIconHeight() > d.height) || (icon.getIconWidth() > d.width)) {
				image = image.getScaledInstance(d.height, d.width, Image.SCALE_SMOOTH);
			}
			icon = new ImageIcon(image);
		}
		if (!((JGraphShapeView) view).isPIP()) {
			setIcon(icon);
		} else {
			setIcon(null);
		}

		borderWidth = map.get(node, AttributeMap.BORDERWIDTH, borderWidth);
		int b = borderWidth - 1;
		Graphics2D g2 = (Graphics2D) g;

		boolean tmp = selected;

		GeneralPath path = shape.getPath(b, b, d.width - 2 * b, d.height - 2 * b);

		Color fill = (Color) map.get(((JGraphShapeView) view).getNode(), AttributeMap.FILLCOLOR);
		Color gradient = (Color) map.get(((JGraphShapeView) view).getNode(), AttributeMap.GRADIENTCOLOR);
		if (gradient == null || gradient.equals(fill)) {
			g.setColor(fill);
			setOpaque(fill != null);
		} else {
			Paint paint = new GradientPaint(0, 0, fill, d.width, 0, gradient);
			g2.setPaint(paint);
			setOpaque(paint != null);
		}
		if (fill != null) {
			g2.fill(path);
		}
		//g.setColor(Color.BLACK);
		g.setColor(map.get(node, AttributeMap.STROKECOLOR, Color.BLACK));
		//		g2.setStroke(new BasicStroke(borderWidth));
		float[] pattern = map.get(node, AttributeMap.DASHPATTERN, new float[0]);
		if (pattern.length > 0f) {

			float offset = map.get(node, AttributeMap.DASHOFFSET, 0f);
			g2.setStroke(new BasicStroke(borderWidth, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10f, pattern,
					offset));
		} else {
			g2.setStroke(new BasicStroke(borderWidth));
		}

		g2.draw(path);

		try {
			setBorder(null);
			setOpaque(false);
			// selected = false;
			super.paint(g);
			if (shapeDecorator != null) {
				shapeDecorator.decorate(g2, b, b, d.width - 2 * b, d.height - 2 * b);
			}

			//			if (isGroup) {
			//				g.setColor(handleColor);
			//				g.fill3DRect(handle.x, handle.y, handle.width, handle.height, true);
			//				g.setColor(graphForeground);
			//				g.drawRect(handle.x, handle.y, handle.width, handle.height);
			//				g.drawLine(handle.x + 1, handle.y + handle.height / 2, handle.x + handle.width - 2, handle.y
			//						+ handle.height / 2);
			//				if (view.isLeaf()) {
			//					g.drawLine(handle.x + handle.width / 2, handle.y + 1, handle.x + handle.width / 2, handle.y
			//							+ handle.height - 2);
			//				}
			//			}

		} finally {
			selected = tmp;
		}
	}

	protected void paintSelectionBorder(Graphics g) {
		Graphics2D g2 = (Graphics2D) g;
		Stroke previousStroke = g2.getStroke();
		g2.setStroke(SELECTIONSTROKE);
		if (childrenSelected || selected) {
			if (childrenSelected) {
				g.setColor(gridColor);
			} else if (hasFocus && selected) {
				g.setColor(lockedHandleColor);
			} else if (selected) {
				g.setColor(highlightColor);
			}
			Dimension d = getSize();
			g.drawRect(0, 0, d.width - 1, d.height - 1);
		}
		g2.setStroke(previousStroke);
	}

	public void cleanUp() {
		view = null;
	}

	/**
	 * Default handle bounds for renderer, '+' or '-'
	 */
	public static Rectangle handle = new Rectangle(0, 0, 7, 7);

	//	/**
	//	 * Specifies whether the current view is a rich text value, and if the image
	//	 * should be stretched.
	//	 */
	//	protected boolean isGroup = false;

	/**
	 * Holds the background and foreground of the graph.
	 */
	protected Color handleColor = Color.white, graphForeground = Color.black;

	/**
	 * Overrides the parent implementation to return the value component stored
	 * in the user object instead of this renderer if a value component exists.
	 * This applies some of the values installed to this renderer to the value
	 * component (border, opaque) if the latter is a JComponent.
	 * 
	 * @return Returns a configured renderer for the specified view.
	 */
	@Override
	public Component getRendererComponent(JGraph graph, CellView view, boolean sel, boolean focus, boolean preview) {
		handleColor = graph.getHandleColor();
		graphForeground = graph.getForeground();
		return super.getRendererComponent(graph, view, sel, focus, preview);
	}

	/**
	 * Detect whether or not a point has hit the group/ungroup image
	 * 
	 * @param pt
	 *            the point to check
	 * @return whether or not the point lies within the handle
	 */
	public boolean inHitRegion(Point2D pt) {
		return handle.contains(pt.getX(), pt.getY());
	}

}
"
JGraphEdgeView.java,widgets-6.9.234,"package org.processmining.models.jgraph.views;

import java.awt.Shape;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.List;

import org.jgraph.graph.EdgeView;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.jgraph.elements.ProMGraphEdge;
import org.processmining.models.jgraph.renderers.ProMEdgeRenderer;

public class JGraphEdgeView extends EdgeView implements Cleanable {

	private static final long serialVersionUID = -2874236692967529775L;
	private static ProMEdgeRenderer renderer;
	private DirectedGraphEdge<?, ?> edge;
	private final boolean isPIP;
	private final ViewSpecificAttributeMap viewSpecificAttributes;

	public transient Shape middleShape;

	@SuppressWarnings(""unchecked"")
	public JGraphEdgeView(ProMGraphEdge cell, boolean isPIP, ViewSpecificAttributeMap viewSpecificAttributes) {
		super(cell);
		this.isPIP = isPIP;
		this.viewSpecificAttributes = viewSpecificAttributes;
		edge = cell.getEdge();
		points = new ArrayList(2);
		points.add(cell.getSource().getView());
		points.addAll(cell.getInternalPoints());
		points.add(cell.getTarget().getView());

		groupBounds = null;
	}

	public void setPoints(List<Point2D> list) {
		points = list;
	}

	public ViewSpecificAttributeMap getViewSpecificAttributeMap() {
		return viewSpecificAttributes;
	}

	@Override
	public ProMEdgeRenderer getRenderer() {
		if (renderer == null) {
			renderer = edge.getAttributeMap().get(AttributeMap.RENDERER, null);
			if (renderer == null) {
				renderer = new ProMEdgeRenderer();
			}
		}
		return renderer;
	}

	public void cleanUp() {
		edge = null;
		setCell(null);
		viewSpecificAttributes.clearViewSpecific(edge);
		source = null;
		target = null;
		if (renderer != null) {
			renderer.cleanUp();
			renderer = null;
		}
	}

	public DirectedGraphEdge<?, ?> getEdge() {
		return edge;
	}

	public boolean isPIP() {
		return isPIP;
	}

}
"
JGraphPortView.java,widgets-6.9.234,"package org.processmining.models.jgraph.views;

import java.awt.geom.Point2D;

import org.jgraph.graph.EdgeView;
import org.jgraph.graph.PortView;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.jgraph.elements.ProMGraphPort;
import org.processmining.models.jgraph.renderers.ProMPortRenderer;

public class JGraphPortView extends PortView implements Cleanable {

	private static final long serialVersionUID = 5279360045457316828L;
	private static ProMPortRenderer renderer;
	private final boolean isPIP;
	private final ViewSpecificAttributeMap viewSpecificAttributes;
	private final ProMGraphPort cell;

	public JGraphPortView(ProMGraphPort cell, boolean isPIP, ViewSpecificAttributeMap viewSpecificAttributes) {
		super(cell);
		this.cell = cell;
		this.isPIP = isPIP;
		this.viewSpecificAttributes = viewSpecificAttributes;

		groupBounds = null;
	}

	@Override
	public ProMPortRenderer getRenderer() {
		if (renderer == null) {
			renderer = new ProMPortRenderer();
		}
		return renderer;
	}

	public ViewSpecificAttributeMap getViewSpecificAttributeMap() {
		return viewSpecificAttributes;
	}

	public void cleanUp() {
		setCell(null);
		parent = null;
		lastParent = null;
		if (renderer != null) {
			renderer.cleanUp();
			renderer = null;
		}
	}

	public boolean isPIP() {
		return isPIP;
	}

	@Override
	public Point2D getLocation(EdgeView edge, Point2D nearest) {
		Point2D pos = super.getLocation(edge, nearest);
		Point2D pos2 = pos;
		if (renderer != null && nearest != null && //
				cell.isBoundaryNode()) {
			pos2 = renderer.getPerimeterPoint(this, pos, nearest);
		}
		return pos2;
	}
}
"
JGraphShapeView.java,widgets-6.9.234,"package org.processmining.models.jgraph.views;

import java.awt.Dimension;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;

import org.jgraph.graph.EdgeView;
import org.jgraph.graph.GraphConstants;
import org.jgraph.graph.VertexView;
import org.processmining.framework.util.Cleanable;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.elements.ProMGraphCell;
import org.processmining.models.jgraph.renderers.ProMGroupShapeRenderer;
import org.processmining.models.jgraph.renderers.ProMShapeRenderer;
import org.processmining.models.shapes.Rectangle;
import org.processmining.models.shapes.Shape;

public class JGraphShapeView extends VertexView implements Cleanable {

	public final static Shape RECTANGLE = new Rectangle();

	private static final long serialVersionUID = 660416141359812229L;
	private static ProMGroupShapeRenderer renderer;
	private DirectedGraphNode node;
	private Shape shape;

	private final boolean isPIP;

	private final ViewSpecificAttributeMap viewSpecificAttributes;

	@SuppressWarnings(""unchecked"")
	public JGraphShapeView(ProMGraphCell cell, boolean isPIP, ViewSpecificAttributeMap viewSpecificAttributes) {
		super(cell);
		this.isPIP = isPIP;
		this.viewSpecificAttributes = viewSpecificAttributes;
		node = cell.getNode();
		shape = node.getAttributeMap().get(AttributeMap.SHAPE, RECTANGLE);

		GraphConstants.setMoveable(getAttributes(), node.getAttributeMap().get(AttributeMap.MOVEABLE, true));

		groupBounds = null;
		childViews = new ArrayList();
		for (Object child : cell.getChildren()) {
			if (child instanceof ProMGraphCell) {
				ProMGraphCell c2 = (ProMGraphCell) child;
				if (c2.getView() != null) {
					childViews.add(c2.getView());
				}
			}
		}
		setCachedBounds(GraphConstants.getBounds(cell.getAttributes()));

	}

	@Override
	public ProMShapeRenderer getRenderer() {
		if (renderer == null) {
			renderer = node.getAttributeMap().get(AttributeMap.RENDERER, null);
			if (renderer == null) {
				renderer = new ProMGroupShapeRenderer();
			}
		}
		return renderer;
	}

	@Override
	public Point2D getPerimeterPoint(EdgeView edge, Point2D source, Point2D p) {
		if (p == null) {
			p = getCenterPoint(this);
		}
		return shape.getPerimeterPoint(this.getBounds(), source, p);
	}

	public DirectedGraphNode getNode() {
		return node;
	}

	public ViewSpecificAttributeMap getViewSpecificAttributeMap() {
		return viewSpecificAttributes;
	}

	public void cleanUp() {
		viewSpecificAttributes.clearViewSpecific(node);
		setCell(null);
		node = null;
		shape = null;
		if (renderer != null) {
			getRenderer().cleanUp();
			renderer = null;
		}
	}

	public boolean isPIP() {
		return isPIP;
	}

	@Override
	public Rectangle2D getBounds() {
		Dimension d = (Dimension) viewSpecificAttributes.get(node, AttributeMap.SIZE);
		Rectangle2D b = super.getBounds();
		if (d != null && (d.getWidth() != b.getWidth() || d.getHeight() != b.getHeight())) {
			return new Rectangle2D.Double(b.getX(), b.getY(), d.getWidth(), d.getHeight());
		} else {
			return b;
		}
	}

	/**
	 * Sets the bounds of this <code>view</code>. Calls translateView and
	 * scaleView.
	 * 
	 * @param bounds
	 *            the new bounds for this cell view
	 */
	@Override
	public void setBounds(Rectangle2D bounds) {
		super.setBounds(bounds);
		viewSpecificAttributes.putViewSpecific(node, AttributeMap.SIZE, new Dimension((int) bounds.getWidth(),
				(int) bounds.getHeight()));
	}

}
"
ProMJGraphPanel.java,widgets-6.9.234,"package org.processmining.models.jgraph.visualization;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import javax.swing.JLabel;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;

import org.jgraph.graph.BasicMarqueeHandler;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;
import org.processmining.models.graphbased.directed.DirectedGraphEdge;
import org.processmining.models.graphbased.directed.DirectedGraphElement;
import org.processmining.models.graphbased.directed.DirectedGraphNode;
import org.processmining.models.jgraph.ProMJGraph;
import org.processmining.models.jgraph.elements.ProMGraphCell;
import org.processmining.models.jgraph.elements.ProMGraphEdge;

public class ProMJGraphPanel extends ScalableViewPanel {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8937461038820086748L;

	public ProMJGraphPanel(final ProMJGraph graph) {
		super(graph);

		JLabel label = new JLabel(""<html>&#8629;</html>"");

		addButton(label, new ActionListener() {

			public void actionPerformed(ActionEvent e) {
				graph.repositionToOrigin();
				updated();
			}
		}, SwingConstants.NORTH_WEST);
	}

	@Override
	protected void initialize() {
		getGraph().setTolerance(4);

		getGraph().setMarqueeHandler(new BasicMarqueeHandler() {
			private boolean test(MouseEvent e) {
				return SwingUtilities.isRightMouseButton(e) && ((e.getModifiers() & InputEvent.ALT_MASK) == 0);

			}

			public boolean isForceMarqueeEvent(MouseEvent event) {
				if (test(event)) {
					return true;
				} else {
					return false;
				}
			}

			@Override
			public void mouseReleased(final MouseEvent e) {
				if (test(e)) {
					e.consume();
				} else {
					super.mouseReleased(e);
				}
			}

			@Override
			public void mousePressed(final MouseEvent e) {
				if (test(e)) {
					synchronized (getGraph().getProMGraph()) {
						// Check for selection.
						// If the cell that is being clicked is part of the
						// selection,
						// we use the current selection.
						// otherwise, we use a new selection
						Object cell = getGraph().getFirstCellForLocation(e.getX(), e.getY());

						Collection<DirectedGraphElement> sel;
						if (cell == null) {
							// Nothing selected
							getGraph().clearSelection();
							sel = new ArrayList<DirectedGraphElement>(0);
						} else if (getGraph().getSelectionModel().isCellSelected(cell)) {
							// the current selection contains cell
							// use that selection
							sel = getSelectedElements();
						} else {
							// the current selection does not contain cell.
							// reset the selection to [cell]
							sel = new ArrayList<DirectedGraphElement>(1);
							sel.add(getElementForLocation(e.getX(), e.getY()));
							getGraph().setSelectionCell(cell);
						}

					}
				} else {
					super.mousePressed(e);
				}
			}

		});
		super.initialize();
	}

	public ProMJGraph getGraph() {
		return (ProMJGraph) getComponent();
	}

	public Collection<DirectedGraphElement> getSelectedElements() {
		List<DirectedGraphElement> elements = new ArrayList<DirectedGraphElement>();
		for (Object o : getGraph().getSelectionCells()) {
			if (o instanceof ProMGraphCell) {
				elements.add(((ProMGraphCell) o).getNode());
			} else if (o instanceof ProMGraphEdge) {
				elements.add(((ProMGraphEdge) o).getEdge());
			}
		}
		return elements;
	}

	public Collection<DirectedGraphNode> getSelectedNodes() {
		List<DirectedGraphNode> nodes = new ArrayList<DirectedGraphNode>();
		for (Object o : getGraph().getSelectionCells()) {
			if (o instanceof ProMGraphCell) {
				nodes.add(((ProMGraphCell) o).getNode());
			}
		}
		return nodes;
	}

	public Collection<DirectedGraphEdge<?, ?>> getSelectedEdges() {
		List<DirectedGraphEdge<?, ?>> edges = new ArrayList<DirectedGraphEdge<?, ?>>();
		for (Object o : getGraph().getSelectionCells()) {
			if (o instanceof ProMGraphEdge) {
				edges.add(((ProMGraphEdge) o).getEdge());
			}
		}
		return edges;
	}

	public DirectedGraphElement getElementForLocation(double x, double y) {
		Object cell = getGraph().getFirstCellForLocation(x, y);
		if (cell instanceof ProMGraphCell) {
			return ((ProMGraphCell) cell).getNode();
		}
		if (cell instanceof ProMGraphEdge) {
			return ((ProMGraphEdge) cell).getEdge();
		}
		return null;
	}

}
"
AbstractSelectionPanel.java,widgets-6.9.234,"package org.processmining.models.util;

import java.awt.BorderLayout;
import java.awt.Color;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingConstants;

import org.processmining.framework.util.ui.scalableview.ScalableComponent;
import org.processmining.framework.util.ui.scalableview.interaction.ViewInteractionPanel;
import org.processmining.models.graphbased.AttributeMap;
import org.processmining.models.graphbased.AttributeMapOwner;
import org.processmining.models.graphbased.ViewSpecificAttributeMap;
import org.processmining.models.graphbased.directed.DirectedGraphElement;
import org.processmining.models.jgraph.ProMJGraph;

import com.fluxicon.slickerbox.factory.SlickerDecorator;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public abstract class AbstractSelectionPanel<C extends JComponent> extends JPanel implements ViewInteractionPanel {

	private static final long serialVersionUID = 8436979211504873546L;
	protected ProMJGraph graph;
	protected SlickerFactory factory = SlickerFactory.instance();
	protected SlickerDecorator decorator = SlickerDecorator.instance();

	protected final String title;
	protected ViewSpecificAttributeMap originalSpecificMap;
	protected ViewSpecificAttributeMap viewSpecificMap;
	private Map<DirectedGraphElement, String> selectedNodes = new HashMap<DirectedGraphElement, String>();
	protected final JScrollPane scroll;
	protected final C component;

	public AbstractSelectionPanel(String title, C component) {
		super(new BorderLayout());
		this.title = title;
		this.scroll = new JScrollPane(component);
		this.component = component;
		this.component.setOpaque(false);

		// add the title
		JLabel panelTitle = factory.createLabel(title);
		panelTitle.setHorizontalTextPosition(SwingConstants.CENTER);
		panelTitle.setVerticalTextPosition(SwingConstants.CENTER);
		panelTitle.setForeground(Color.WHITE);
		panelTitle.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 16));
		panelTitle.setOpaque(false);
		this.add(panelTitle, BorderLayout.NORTH);
		this.setOpaque(false);

		decorator.decorate(scroll, Color.WHITE, Color.GRAY, Color.DARK_GRAY);
		scroll.getViewport().setOpaque(false);
		scroll.setOpaque(false);
		scroll.setBorder(BorderFactory.createEmptyBorder());
		scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scroll.getVerticalScrollBar().setOpaque(false);

		this.add(scroll, BorderLayout.CENTER);
	}

	public JComponent getComponent() {
		return this;
	}

	public void setScalableComponent(ScalableComponent scalable) {
		if (scalable instanceof ProMJGraph) {
			this.graph = (ProMJGraph) scalable;
			this.viewSpecificMap = graph.getViewSpecificAttributes();

			originalSpecificMap = new ViewSpecificAttributeMap();
			for (AttributeMapOwner o : viewSpecificMap.keySet()) {
				for (String key : viewSpecificMap.keySet(o)) {
					originalSpecificMap.putViewSpecific(o, key, viewSpecificMap.get(o, key));
				}
			}
		} else {
			throw new IllegalArgumentException(""Scalable needs to be instance of ProMJGraph"");
		}
	}

	public double getHeightInView() {
		return 140;
	}

	public double getWidthInView() {
		return 250;
	}

	protected synchronized void unselectAll(boolean signal) {
		if (viewSpecificMap == null) {
			return;
		}
		ArrayList<AttributeMapOwner> toUpdate = new ArrayList<AttributeMapOwner>(viewSpecificMap.keySet());
		for (AttributeMapOwner p : toUpdate) {
			// copy the original keys back into viewSpecific
			viewSpecificMap.clearViewSpecific(p);
			for (String key : originalSpecificMap.keySet(p)) {
				viewSpecificMap.putViewSpecific(p, key, originalSpecificMap.get(p, key));
			}
		}
		selectedNodes.clear();

		if (signal) {
			// HV: Convert toUpdate to a set of AttributeMapOwners, as otherwise the update 
			//     gets an array containing the set as only element, which it does not handle properly.
			graph.update(new HashSet<AttributeMapOwner>(toUpdate));
		}
	}

	public void willChangeVisibility(boolean to) {
		if (to) {
			// HV: Also show if the selection has become empty.
			//			if (!selectedNodes.keySet().isEmpty()) {
			selectElements(new HashMap<DirectedGraphElement, String>(selectedNodes));
			//			}
		}
	}

	protected synchronized <T extends DirectedGraphElement> void selectElements(Map<T, String> labelledSelection) {
		unselectAll(false);
		selectedNodes.putAll(labelledSelection);

		for (DirectedGraphElement p : labelledSelection.keySet()) {
			String newLabel = labelledSelection.get(p);
			String tooltip = p.getAttributeMap().get(AttributeMap.LABEL,
					viewSpecificMap.get(p, AttributeMap.LABEL, newLabel));

			// set the attributes
			viewSpecificMap.putViewSpecific(p, AttributeMap.FILLCOLOR, Color.ORANGE);
			viewSpecificMap.putViewSpecific(p, AttributeMap.LABEL, newLabel);
			viewSpecificMap.putViewSpecific(p, AttributeMap.TOOLTIP, tooltip);
			viewSpecificMap.putViewSpecific(p, AttributeMap.SHOWLABEL, !newLabel.isEmpty());
		}

		// refresh the figure

		graph.update(labelledSelection.keySet());
	}

}
"
ListSelectionPanel.java,widgets-6.9.234,"package org.processmining.models.util;

import java.awt.Color;
import java.awt.Component;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.geom.Rectangle2D;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import javax.swing.BorderFactory;
import javax.swing.DefaultListModel;
import javax.swing.DefaultListSelectionModel;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.ListCellRenderer;
import javax.swing.ListSelectionModel;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

import org.processmining.framework.util.HTMLToString;
import org.processmining.framework.util.Pair;
import org.processmining.framework.util.collection.MultiSet;
import org.processmining.framework.util.ui.scalableview.ScalableViewPanel;
import org.processmining.models.graphbased.directed.DirectedGraphElement;

import com.fluxicon.slickerbox.factory.SlickerDecorator;
import com.fluxicon.slickerbox.factory.SlickerFactory;

public class ListSelectionPanel extends AbstractSelectionPanel<JList> {

	private static final long serialVersionUID = -196246314805797890L;
	static final Pair<Collection<? extends DirectedGraphElement>, String> NONE = new Pair<Collection<? extends DirectedGraphElement>, String>(
			Collections.<DirectedGraphElement>emptySet(), ""None"");
	private String name;

	public ListSelectionPanel(String name, String title, boolean interactive) {
		super(title, new JList());
		this.name = name;

		ListCellRenderer renderer = new ViewListCellRenderer(interactive);
		this.component.setCellRenderer(renderer);
		this.component.setSelectionModel(new ToggleSelectionModel());

		//component.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);

		if (interactive) {
			component.addListSelectionListener(new ListSelectionListener() {

				@SuppressWarnings(""unchecked"")
				public void valueChanged(ListSelectionEvent e) {
					if (e.getValueIsAdjusting()) {
						return;
					}
					ListSelectionModel lsm = component.getSelectionModel();
					int selectedIndex = lsm.getMinSelectionIndex();
					if (selectedIndex < 0) {
						unselectAll(true);
						component.clearSelection();
						return;
					}
					Pair<Collection<? extends DirectedGraphElement>, String> pair = (Pair<Collection<? extends DirectedGraphElement>, String>) component
							.getModel().getElementAt(selectedIndex);
					Collection<? extends DirectedGraphElement> selected = pair.getFirst();

					Map<DirectedGraphElement, String> labelled = new HashMap<DirectedGraphElement, String>(selected
							.size());
					// For multisets, label with occurance count
					if (selected instanceof MultiSet) {
						for (DirectedGraphElement elt : ((MultiSet<DirectedGraphElement>) selected).baseSet()) {
							labelled.put(elt, """" + ((MultiSet<DirectedGraphElement>) selected).occurrences(elt));
						}
					} else {
						for (DirectedGraphElement elt : selected) {
							labelled.put(elt, elt.getLabel());
						}
					}
					selectElements(labelled);

				}

			});
		}

		component.setModel(new DefaultListModel());
		component.setEnabled(false);
		((DefaultListModel) component.getModel()).addElement(NONE);

	}

	public void addElementCollection(Collection<? extends DirectedGraphElement> collection) {
		if (collection instanceof HTMLToString) {
			addElementCollection(collection, ((HTMLToString) collection).toHTMLString(true));
		} else {
			addElementCollection(collection, collection.toString());
		}
	}

	public void addElementCollection(Collection<? extends DirectedGraphElement> collection, String label) {
		Pair<Collection<? extends DirectedGraphElement>, String> pair = new Pair<Collection<? extends DirectedGraphElement>, String>(
				collection, label);
		if (!component.isEnabled()) {
			((DefaultListModel) component.getModel()).removeAllElements();
			component.setEnabled(true);
		}
		if (!((DefaultListModel) component.getModel()).contains(pair)) {
			((DefaultListModel) component.getModel()).addElement(pair);
		}
	}

	public void updated() {
		// Ignore
	}

	public String getPanelName() {
		return name;
	}

	public void setParent(ScalableViewPanel viewPanel) {
		// ignore
	}

}

/**
 * This DefaultSelectionModel subclass enables SINGLE_SELECTION mode and
 * overrides setSelectionInterval so that the first selection update in a
 * gesture (like mouse press, drag, release) toggles the current selection
 * state. A ""gesture"" starts when the first update to the selection model
 * occurs, and the gesture ends when the isAdjusting ListSelectionModel property
 * is set to false.
 */
class ToggleSelectionModel extends DefaultListSelectionModel {
	private static final long serialVersionUID = -8595521046515667658L;
	boolean gestureStarted = false;

	// HV: Allow only a single selection, as only one will be shown.
	public ToggleSelectionModel() {
		super ();
		this.setSelectionMode(SINGLE_SELECTION);
	}
	
	public void setSelectionInterval(int index0, int index1) {
		if (isSelectedIndex(index0) && !gestureStarted) {
			super.removeSelectionInterval(index0, index1);
		} else {
			super.setSelectionInterval(index0, index1);
		}
		gestureStarted = true;
	}

	public void setValueIsAdjusting(boolean isAdjusting) {
		if (isAdjusting == false) {
			gestureStarted = false;
		}
	}
}

class ViewListCellRenderer implements ListCellRenderer {
	/**
	 * 
	 */
	private static final long serialVersionUID = -808355468668630456L;
	private static final CompoundBorder BORDER = BorderFactory.createCompoundBorder(BorderFactory
			.createRaisedBevelBorder(), BorderFactory.createEmptyBorder(2, 5, 2, 5));;
	private static final CompoundBorder SELBORDER = BorderFactory.createCompoundBorder(BorderFactory
			.createLoweredBevelBorder(), BorderFactory.createEmptyBorder(2, 5, 2, 5));

	private final static JLabel LABEL = SlickerFactory.instance().createLabel(""test"");
	private static final Border EMPTYBORDER = BorderFactory.createEmptyBorder(2, 5, 2, 5);
	private final boolean allowsClick;

	public ViewListCellRenderer(boolean allowsClick) {
		this.allowsClick = allowsClick;
		LABEL.setFont(new java.awt.Font(""Dialog"", java.awt.Font.BOLD, 12));

		LABEL.setBorder(EMPTYBORDER);
		LABEL.setOpaque(false);
		SlickerDecorator.instance().decorate(LABEL);
	}

	@SuppressWarnings(""unchecked"")
	public Component getListCellRendererComponent(JList component, Object value, int index, boolean isSelected,
			boolean cellHasFocus) {

		Pair<Collection<? extends DirectedGraphElement>, String> pair = (Pair<Collection<? extends DirectedGraphElement>, String>) value;
		if (pair == ListSelectionPanel.NONE) {
			LABEL.setText(""None"");
			LABEL.setForeground(Color.DARK_GRAY);
			LABEL.setBorder(EMPTYBORDER);
			return LABEL;
		}
		String label = pair.getSecond().trim();
		LABEL.setText(fitLabelToWidth(LABEL, label, component.getWidth()));
		LABEL.setToolTipText(label);
		if (allowsClick) {
			LABEL.setForeground(isSelected ? Color.WHITE : Color.BLACK);
			LABEL.setBorder(isSelected ? SELBORDER : BORDER);
		} else {
			LABEL.setBorder(EMPTYBORDER);
		}

		return LABEL;

	}

	public static String fitLabelToWidth(JComponent c, String label, int maxWidth) {
		FontMetrics metrics = c.getFontMetrics(c.getFont());
		Graphics g = c.getGraphics();
		boolean abbreviated = false;
		int width = Integer.MAX_VALUE;
		while (true) {
			if (label.length() < 2) {
				break;
			}
			String test = label;
			if (abbreviated) {
				test += ""..."";
			}
			Rectangle2D stringBounds = metrics.getStringBounds(test, g);
			width = (int) stringBounds.getWidth();
			if (width > maxWidth) {
				label = label.substring(0, label.length() - 1);
				if (!abbreviated) {
					abbreviated = true;
				}
			} else {
				break;
			}
		}
		if (abbreviated) {
			label += ""..."";
		}
		return label;
	}
}
"
ConnectionManagerHelper.java,widgets-6.9.234,"package org.processmining.plugins.utils;

import java.util.ArrayList;
import java.util.Collection;

import org.processmining.framework.connections.Connection;
import org.processmining.framework.connections.ConnectionCannotBeObtained;
import org.processmining.framework.connections.ConnectionID;
import org.processmining.framework.connections.ConnectionManager;

/**
 * Helper methods to work in a 'safer' way with the {@link ConnectionManager} of
 * ProM.
 * 
 * @author F. Mannhardt
 * 
 */
public final class ConnectionManagerHelper {

	private ConnectionManagerHelper() {
		super();
	}

	/**
	 * Returns a collection of connections between the objects specified, such
	 * that the type of the connection is assignable from the given
	 * connectionType. Returns an empty {@link Collection} in case no connection
	 * is available. Does NOT try to automatically create a connection.
	 * 
	 * @param connectionManager
	 * @param connectionType
	 * @param objects
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
	public static <T extends Connection> Collection<T> safeGetConnections(ConnectionManager connectionManager,
			Class<T> connectionType, Object... objects) {
		Collection<T> connections = new ArrayList<T>(1);
		for (ConnectionID connID : connectionManager.getConnectionIDs()) {
			try {
				Connection c = connectionManager.getConnection(connID);
				if (((connectionType == null) || connectionType.isAssignableFrom(c.getClass()))
						&& c.containsObjects(objects)) {
					connections.add((T) c);
				}
			} catch (ConnectionCannotBeObtained e) {
			}
		}
		return connections;
	}

	/**
	 * Returns the first connection between the objects specified, such that the
	 * type of the connection is assignable from the given connectionType. Throw
	 * {@link ConnectionCannotBeObtained} in case no connection is available.
	 * Does NOT try to automatically create a connection.
	 * 
	 * @param connectionManager
	 * @param connectionType
	 * @param objects
	 * @return
	 * @throws ConnectionCannotBeObtained
	 */
	@SuppressWarnings(""unchecked"")
	public static <T extends Connection> T safeGetFirstConnection(ConnectionManager connectionManager,
			Class<T> connectionType, Object... objects) throws ConnectionCannotBeObtained {
		for (ConnectionID connID : connectionManager.getConnectionIDs()) {
			Connection c = connectionManager.getConnection(connID);
			if (((connectionType == null) || connectionType.isAssignableFrom(c.getClass()))
					&& c.containsObjects(objects)) {
				return (T) c;
			}
		}
		throw new ConnectionCannotBeObtained(""Connection not found"", connectionType, objects);
	}

}
"
HammingDistance.java,widgets-6.9.234,"package org.processmining.plugins.utils;

import java.util.Comparator;

/**
 * @author michael
 * 
 */
public class HammingDistance {
	/**
	 * @author michael
	 * 
	 * @param <T>
	 */
	public static interface Namer<T> {
		/**
		 * @param object
		 * @return
		 */
		String toString(T object);
	}

	/**
	 * @param <T>
	 * @param name
	 * @param values
	 * @return
	 */
	public static <T> T getBestMatch(final String name, final Iterable<T> values) {
		return HammingDistance.getBestMatch(name, values, new Namer<T>() {
			@Override
			public String toString(final T object) {
				if (object == null) {
					return ""<null>"";
				}
				return object.toString();
			}
		});
	}

	/**
	 * @param <T>
	 * @param name
	 * @param values
	 * @param namer
	 * @return
	 */
	public static <T> T getBestMatch(final String name, final Iterable<T> values, final Namer<T> namer) {
		return HammingDistance.getBestMatch(name, values, namer, new Comparator<T>() {
			@Override
			public int compare(final T o1, final T o2) {
				return 0;
			}
		});
	}

	/**
	 * @param <T>
	 * @param name
	 * @param values
	 * @param namer
	 * @param comparator
	 * @return
	 */
	public static <T> T getBestMatch(final String name, final Iterable<T> values, final Namer<T> namer,
			final Comparator<T> comparator) {
		int match = -1;
		T result = null;
		for (final T value : values) {
			final String newName = namer.toString(value);
			final int newMatch = HammingDistance.hammingDistance(name, newName, false);
			if (newMatch > match) {
				match = newMatch;
				result = value;
			}
			if (newMatch == match) {
				final int thisStrictMatch = HammingDistance.hammingDistance(name, newName);
				final int oldStrictMatch = HammingDistance.hammingDistance(name, namer.toString(result));
				if (thisStrictMatch > oldStrictMatch) {
					match = newMatch;
					result = value;
				}
				if (thisStrictMatch == oldStrictMatch) {
					if (comparator.compare(result, value) < 0) {
						match = newMatch;
						result = value;
					}
				}
			}
		}
		return result;
	}

	/**
	 * @param s1
	 * @param s2
	 * @return
	 */
	public static int hammingDistance(final String s1, final String s2) {
		return HammingDistance.hammingDistance(s1, s2, true);
	}

	/**
	 * @param s1
	 * @param s2
	 * @param caseSensitive
	 * @return
	 */
	public static int hammingDistance(String s1, String s2, final boolean caseSensitive) {
		if (s2.length() > s1.length()) {
			final String tmp = s1;
			s1 = s2;
			s2 = tmp;
		}
		final int[][] matrix = new int[2][s2.length() + 1];
		for (int i = 1; i < s1.length() + 1; i++) {
			for (int j = 1; j < s2.length() + 1; j++) {
				int result = Math.max(matrix[(i - 1) % 2][j], matrix[i % 2][j - 1]);
				if (s1.charAt(i - 1) == s2.charAt(j - 1) || !caseSensitive
						&& Character.toLowerCase(s1.charAt(i - 1)) == Character.toLowerCase(s2.charAt(j - 1))) {
					result = Math.max(result, matrix[(i - 1) % 2][j - 1] + 1);
				}
				matrix[i % 2][j] = result;
			}
		}
		return matrix[s1.length() % 2][s2.length()];
	}

	/**
	 * @param args
	 */
	public static void main(final String[] args) {
		HammingDistance.test(""Michael"", ""mikael"");
		HammingDistance.test(""Britney"", ""britney"");
		HammingDistance.test(""Lady Gaga"", ""ladygaga"");
	}

	/**
	 * @param s1
	 * @param s2
	 */
	public static void test(final String s1, final String s2) {
		System.out.print(""\"""" + s1 + ""\"""");
		System.out.print("" -- "");
		System.out.print(""\"""" + s2 + ""\"""");
		System.out.print("": "");
		System.out.println(HammingDistance.hammingDistance(s1, s2));
		System.out.print(""\"""" + s1 + ""\"""");
		System.out.print("" -- "");
		System.out.print(""\"""" + s2 + ""\"""");
		System.out.print("": "");
		System.out.println(HammingDistance.hammingDistance(s1, s2, false));
	}
}
"
ProvidedObjectHelper.java,widgets-6.9.234,"package org.processmining.plugins.utils;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import javax.swing.SwingUtilities;

import org.deckfour.uitopia.api.model.ResourceType;
import org.deckfour.uitopia.api.model.View;
import org.deckfour.uitopia.api.model.ViewType;
import org.deckfour.uitopia.ui.UITopiaController;
import org.processmining.contexts.uitopia.UIContext;
import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.contexts.uitopia.model.ProMPOResource;
import org.processmining.contexts.uitopia.model.ProMResource;
import org.processmining.contexts.uitopia.model.ProMTask;
import org.processmining.framework.plugin.GlobalContext;
import org.processmining.framework.plugin.PluginContext;
import org.processmining.framework.providedobjects.ProvidedObjectDeletedException;
import org.processmining.framework.providedobjects.ProvidedObjectID;
import org.processmining.framework.providedobjects.ProvidedObjectManager;

/**
 * @author michael
 * @author F. Mannhardt
 * 
 */
public class ProvidedObjectHelper {
	/**
	 * Will publish object as a provided object with the class specified by
	 * clazz. If the context is a UIPluginContext and favorite is true, it will
	 * be marked as a favorite object as well. Finally, if it is marked as
	 * favorite, it will also be show and ProM will switch to the Views tab.
	 * Encapsulation is for scared little boys/girls who still believe in the
	 * invisible pink unicorn (IPU).
	 * 
	 * @param <T>
	 * @param context
	 * @param name
	 * @param object
	 * @param clazz
	 * @param favorite
	 */
	public static <T> void publish(final PluginContext context, final String name, final T object,
			final Class<? super T> clazz, final boolean favorite) {
		final ProvidedObjectID id = context.getProvidedObjectManager().createProvidedObject(name, object, clazz,
				context);
		// Do not look at the rest of this method.  Boudewijn was busy and I just decided to do what is necessary.
		// It works.  It probably breaks if somebody changes anything.  Here or elsewhere.

		if (context instanceof UIPluginContext) {
			final GlobalContext gcontext = ((UIPluginContext) context).getGlobalContext();
			if (gcontext instanceof UIContext) {
				final UIContext uicontext = (UIContext) gcontext;
				final ResourceType resType = uicontext.getResourceManager().getResourceTypeFor(clazz);
				if (resType != null) {
					ProMTask task = null;
					try {
						final Field taskField = context.getClass().getDeclaredField(""task"");
						taskField.setAccessible(true);
						task = (ProMTask) taskField.get(context);
					} catch (final Exception _) {
						// Guess it wasn't meant to be, then...
					}
					final List<Collection<ProMPOResource>> lst = Collections.emptyList();
					ProMPOResource res = new ProMPOResource(uicontext, task == null ? null : task.getAction(), resType,
							id, lst);
					res = uicontext.getResourceManager().addResource(id, res);
				}
			}
		}
		if (favorite) {
			ProvidedObjectHelper.setFavorite(context, object);
			ProvidedObjectHelper.raise(context, object);
		}
	}

	/**
	 * Show the visualizer for the provided object
	 * 
	 * @param context
	 * @param object
	 */
	public static void raise(final PluginContext context, final Object object) {
		if (context instanceof UIPluginContext) {
			final GlobalContext gcontext = ((UIPluginContext) context).getGlobalContext();
			if (gcontext instanceof UIContext) {
				final UIContext uicontext = (UIContext) gcontext;
				final ProMResource<?> res = uicontext.getResourceManager().getResourceForInstance(object);
				final List<ViewType> viewTypes = uicontext.getViewManager().getViewTypes(res);
				if (viewTypes.size() > 0) {
					final ViewType viewType = viewTypes.get(0);
					final View view = viewType.createView(res);
					uicontext.getViewManager().addView(view);
					final UITopiaController controller = uicontext.getController();
					SwingUtilities.invokeLater(new Runnable() {
						@Override
						public void run() {
							controller.getMainView().showViewsView();
							controller.getMainView().getViewsView().showFullScreen(view);
						}
					});
				}
			}
		}
	}

	/**
	 * @param context
	 * @param object
	 */
	public static void setFavorite(final PluginContext context, final Object object) {
		ProvidedObjectHelper.setFavorite(context, object, true);
	}

	/**
	 * @param context
	 * @param object
	 * @param favorite
	 */
	public static void setFavorite(final PluginContext context, final Object object, final boolean favorite) {
		if (context instanceof UIPluginContext) {
			final GlobalContext gcontext = ((UIPluginContext) context).getGlobalContext();
			if (gcontext instanceof UIContext) {
				final UIContext uicontext = (UIContext) gcontext;
				final ProMResource<?> res = uicontext.getResourceManager().getResourceForInstance(object);
				try {
					res.setFavorite(favorite);
				} catch (final Exception _) {
					// Ignore
				}
			}
		}
	}

	/**
	 * List all the provided objects of the type
	 * 
	 * @param context
	 * @param clazz
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
	public static <T> Collection<T> getProvidedObjects(final PluginContext context, final Class<T> clazz) {
		Collection<T> filteredObjects = new ArrayList<>();
		ProvidedObjectManager pom = context.getProvidedObjectManager();
		List<ProvidedObjectID> allProvidedObjects = pom.getProvidedObjects();
		for (ProvidedObjectID id : allProvidedObjects) {
			try {
				Class<?> type = pom.getProvidedObjectType(id);
				if (clazz.equals(type)) {
					filteredObjects.add((T) pom.getProvidedObjectObject(id, false));
				}
			} catch (ProvidedObjectDeletedException e) {
				//Ignore
			}
		}
		return filteredObjects;
	}

	/**
	 * Rename the provided object
	 * 
	 * @param context
	 * @param obj
	 *            the object instance
	 * @param newName
	 */
	public static void changeProvidedObjectName(final PluginContext context, final Object obj, final String newName) {
		ProvidedObjectManager pom = context.getProvidedObjectManager();
		for (ProvidedObjectID id : pom.getProvidedObjects()) {
			try {
				Object providedObj = pom.getProvidedObjectObject(id, false);
				if (obj != null && obj.equals(providedObj)) {
					pom.relabelProvidedObject(id, newName);
				}
			} catch (ProvidedObjectDeletedException e) {
			}
		}
	}

	/**
	 * Returns the label of the provided object
	 * 
	 * @param context
	 * @param obj
	 * @return
	 */
	public static String getProvidedObjectLabel(final PluginContext context, Object obj) {
		ProvidedObjectManager pom = context.getProvidedObjectManager();
		for (ProvidedObjectID id : pom.getProvidedObjects()) {
			try {
				Object providedObj = pom.getProvidedObjectObject(id, false);
				if (obj != null && obj.equals(providedObj)) {
					return pom.getProvidedObjectLabel(id);
				}
			} catch (ProvidedObjectDeletedException e) {
			}
		}
		return null;
	}

}
"
AbstractSequenceDistance.java,widgets-6.9.234,"package org.processmining.plugins.utils.sequencedistance;

import java.util.Arrays;

public abstract class AbstractSequenceDistance<T> implements SequenceDistance<T> {

	public AbstractSequenceDistance() {
		super();
	}

	public DistanceResult<T> computeAlignment(T[] a, T[] b, SequenceDistance.Equivalence<T> eq) {
		return computeAlignment(Arrays.asList(a), Arrays.asList(b), eq);
	}

	public int computeDistance(T[] a, T[] b, SequenceDistance.Equivalence<T> eq) {
		return computeDistance(Arrays.asList(a), Arrays.asList(b), eq);
	}

}"
GenericLevenshteinDistance.java,widgets-6.9.234,"package org.processmining.plugins.utils.sequencedistance;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Generic Levenshtein Distance computation that also returns an ""aligned""
 * version of the two input Lists. Adapted from this post at <a href=
 * ""http://stackoverflow.com/questions/15042879/java-characters-alignment-algorithm/15043478#15043478""
 * >Stack Overflow</a>.
 * <p>
 * Please note that this class is not thread-safe.
 * 
 * @author F. Mannhardt
 * 
 * @param <T>
 *            type of the objects
 */
public final class GenericLevenshteinDistance<T> extends AbstractSequenceDistance<T> {

	private final class ResultEntryImpl implements DistanceResult.Entry<T> {

		private final T a;
		private final T b;

		public ResultEntryImpl(T a, T b) {
			this.a = a;
			this.b = b;
		}

		public T getA() {
			return a;
		}

		public T getB() {
			return b;
		}

	}

	private final int maxDistance;
	
	private int[][] matrix;
	private int[] array1;
	private int[] array2;
	
	public GenericLevenshteinDistance() {
		this(Integer.MAX_VALUE);
	}

	public GenericLevenshteinDistance(int maxDistance) {
		this(maxDistance, 30);
	}
	
	public GenericLevenshteinDistance(int maxDistance, int initialCapacity) {
		super();
		this.maxDistance = maxDistance;
		this.matrix = new int[initialCapacity][initialCapacity];
		this.array1 = new int[initialCapacity];
		this.array2 = new int[initialCapacity];
	}
	

	public final DistanceResult<T> computeAlignment(final List<T> a, final List<T> b,
			final SequenceDistance.Equivalence<T> eq) {
		
		if (a == b) {
			return new DistanceResult<T>() {

				public int getDistance() {
					return 0;
				}

				public List<DistanceResult.Entry<T>> getAlignment() {
					ArrayList<DistanceResult.Entry<T>> alignment = new ArrayList<DistanceResult.Entry<T>>(a.size());
					for (int i = 0; i < a.size(); i++) {
						alignment.add(new ResultEntryImpl(a.get(i), b.get(i)));
					}
					return alignment;
				}

			};
		}

		final int sizeA = a.size();
		final int sizeB = b.size();

		final int[][] matrix = getMatrix(sizeA + 1, sizeB + 1);

		for (int i = 0; i <= sizeA; i++) {
			matrix[i][0] = i;
		}
		for (int i = 0; i <= sizeB; i++) {
			matrix[0][i] = i;
		}

		for (int i = 1; i <= sizeA; i++) {
			for (int j = 1; j <= sizeB; j++) {
				if (eq.equals(a.get(i - 1), b.get(j - 1))) {
					matrix[i][j] = matrix[i - 1][j - 1];
				} else {
					matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i][j - 1]) + 1;
				}
			}
		}

		final int distance = matrix[sizeA][sizeB];

		final List<DistanceResult.Entry<T>> result = new ArrayList<DistanceResult.Entry<T>>(Math.max(sizeA, sizeB));
		for (int i = sizeA, j = sizeB; i > 0 || j > 0;) {
			if (i > 0 && matrix[i][j] == matrix[i - 1][j] + 1) {
				result.add(new ResultEntryImpl(a.get(--i), null));
			} else if (j > 0 && matrix[i][j] == matrix[i][j - 1] + 1) {
				result.add(new ResultEntryImpl(null, b.get(--j)));
			} else if (i > 0 && j > 0 && matrix[i][j] == matrix[i - 1][j - 1]) {
				result.add(new ResultEntryImpl(a.get(--i), b.get(--j)));
			}
		}
		Collections.reverse(result);

		return new DistanceResult<T>() {

			public int getDistance() {
				return distance;
			}

			public List<DistanceResult.Entry<T>> getAlignment() {
				return result;
			}

		};
	}

	private final int[][] getMatrix(final int sizeA, final int sizeB) {
		if (matrix.length < sizeA || matrix[0].length < sizeB) {
			int newSize = Math.max(sizeA, sizeB);
			matrix = new int[newSize][newSize];
		}
		return matrix;
	}

	public final int computeDistance(List<T> a, List<T> b, SequenceDistance.Equivalence<T> eq) {
		
		if (a == b) {
			return 0;
		}
		
		int aSize = a.size() + 1;
		int bSize = b.size() + 1;

		int[] array1 = getArray1(aSize);
		int[] array2 = getArray2(aSize);

		for (int i = 0; i < aSize; i++) {
			array1[i] = i;
		}

		for (int j = 1; j < bSize; j++) {
			array2[0] = j;
			for (int i = 1; i < aSize; i++) {
				int substitution = array1[i - 1] + (eq.equals(a.get(i - 1), b.get(j - 1)) ? 0 : 1);
				int insertion = array1[i] + 1;
				int deletion = array2[i - 1] + 1;
				array2[i] = Math.min(Math.min(insertion, deletion), substitution);
			}
			int[] temp = array1;
			array1 = array2;
			array2 = temp;
		}
		return array1[aSize - 1];
	}

	private int[] getArray1(int size) {
		if (array1.length < size) {
			array1 = new int[Math.max(size, array1.length * 2)];
		}
		return array1;
	}

	private int[] getArray2(int size) {
		if (array2.length < size) {
			array2 = new int[Math.max(size, array2.length * 2)];
		}
		return array2;
	}

}
"
SequenceDistance.java,widgets-6.9.234,"package org.processmining.plugins.utils.sequencedistance;

import java.util.List;

public interface SequenceDistance<T> {

	public interface Equivalence<T> {

		boolean equals(T a, T b);

	}

	/**
	 * Holds the result of a sequence distance computation.
	 * 
	 * @author F. Mannhardt
	 * 
	 * @param <T>
	 */
	public interface DistanceResult<T> {

		/**
		 * A single step in the alignment of A and B. Either A or B can be
		 * <code>null</code>, if the distance function did not find a
		 * corresponding ""move"".
		 * 
		 * @author F. Mannhardt
		 * 
		 * @param <T>
		 */
		public interface Entry<T> {
			T getA();
			T getB();
		}

		/**
		 * Optional alignment of the two sequences. This may be
		 * <code>null</code>.
		 * 
		 * @return a list of {@link Entry} that represents the ""alignment"" of A
		 *         and B according to the distance function
		 */
		List<Entry<T>> getAlignment();

		/**
		 * @return the distance between A and B
		 */
		int getDistance();
	}

	/**
	 * Compute the distance and a possible alignment between two sequences. 
	 * 
	 * @param a
	 *            first sequence
	 * @param b
	 *            second sequence
	 * @param eq
	 *            equivalence relation on <code>T</code>
	 * @return a distance and optional alignment
	 */
	DistanceResult<T> computeAlignment(T[] a, T[] b, Equivalence<T> eq);

	/**
	 * Compute the distance and a possible alignment between two sequences. 
	 * 
	 * @param a
	 *            first sequence
	 * @param b
	 *            second sequence
	 * @param eq
	 *            equivalence relation on <code>T</code>
	 * @return a distance and optional alignment
	 */
	DistanceResult<T> computeAlignment(List<T> a, List<T> b, Equivalence<T> eq);

	/**
	 * Computes only the distance between two sequences.
	 * 
	 * @param a
	 *            first sequence
	 * @param b
	 *            second sequence
	 * @param eq
	 *            equivalence relation on <code>T</code>
	 * @return the distance
	 */
	int computeDistance(T[] a, T[] b, Equivalence<T> eq);
	
	/**
	 * Computes only the distance between two sequences.
	 * 
	 * @param a
	 *            first sequence
	 * @param b
	 *            second sequence
	 * @param eq
	 *            equivalence relation on <code>T</code>
	 * @return the distance
	 */
	int computeDistance(List<T> a, List<T> b, Equivalence<T> eq);

}"
JSplitPaneUtils.java,widgets-6.9.234,"package org.processmining.widgets.ui.utils;

import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JSplitPane;
import javax.swing.border.Border;
import javax.swing.plaf.basic.BasicSplitPaneDivider;
import javax.swing.plaf.basic.BasicSplitPaneUI;

public class JSplitPaneUtils {

	public static JSplitPane borderlessSplitPane(int orientation, JComponent left, JComponent right) {
		JSplitPane pane = new JSplitPane(orientation, left, right);
		// svzelst@20151022 the fix for no borders comes from stack-overflow
		// as commented in the thread, this fix is not guaranteed to work cross-platform
		//http://stackoverflow.com/questions/12799640/why-does-jsplitpane-add-a-border-to-my-components-and-how-do-i-stop-it
		pane.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
		BasicSplitPaneUI flatDividerSplitPaneUI = new BasicSplitPaneUI() {
			@Override
			public BasicSplitPaneDivider createDefaultDivider() {
				return new BasicSplitPaneDivider(this) {

					private static final long serialVersionUID = -7728070024389270847L;

					@Override
					public void setBorder(Border b) {
					}
				};
			}
		};
		pane.setUI(flatDividerSplitPaneUI);
		pane.setBorder(null);
		pane.setOpaque(false);
		return pane;
	}

}
"
AbstractDialog.java,widgets-6.9.234,"package org.processmining.widgets.wizard;

import javax.swing.JOptionPane;

import org.processmining.contexts.uitopia.UIPluginContext;
import org.processmining.framework.util.ui.widgets.ProMHeaderPanel;

public abstract class AbstractDialog<P> extends ProMHeaderPanel implements Dialog<P> {

	private static final long serialVersionUID = -1559194274412334852L;

	private final UIPluginContext context;

	private P parameters;

	private Dialog<P> previous = null;

	private final String title;

	public AbstractDialog(final UIPluginContext context, final String title, final P parameters,
			final Dialog<P> previous) {
		super(title);
		this.parameters = parameters;
		this.previous = previous;
		this.context = context;
		this.title = title;
	}

	protected abstract boolean canProceedToNext();

	protected abstract Dialog<P> determineNextDialog();

	public final Dialog<P> getNext() {
		if (canProceedToNext()) {
			updateParametersOnGetNext();
			return determineNextDialog();
		} else {
			JOptionPane.showMessageDialog(this, getUserInputProblems(), ""Incomplete Parameter Selection"",
					JOptionPane.WARNING_MESSAGE);
			return this;
		}
	}

	public P getParameters() {
		return parameters;
	}

	public Dialog<P> getPrevious() {
		updateParametersOnGetPrevious();
		return previous;
	}

	public String getTitle() {
		return title;
	}

	public UIPluginContext getUIPluginContext() {
		return context;
	}

	protected abstract String getUserInputProblems();

	public boolean hasPreviousDialog() {
		return previous != null;
	}

	public void setParameters(P parameters) {
		this.parameters = parameters;
	}
}
"
AbstractRoutableDialog.java,widgets-6.9.234,"package org.processmining.widgets.wizard;

import org.processmining.contexts.uitopia.UIPluginContext;

public abstract class AbstractRoutableDialog<P> extends AbstractDialog<P> {

	private static final long serialVersionUID = 191742936970950461L;
	private final Route<P> route;

	public AbstractRoutableDialog(UIPluginContext context, String title, P parameters, Dialog<P> previous,
			Route<P> route) {
		super(context, title, parameters, previous);
		this.route = route;
	}

	public boolean hasNextDialog() {
		return route == null ? false : route.getNext(this) != null;
	}

	protected Dialog<P> determineNextDialog() {
		return route == null ? null : route.getNext(this);
	}
}
"
Dialog.java,widgets-6.9.234,"package org.processmining.widgets.wizard;

import javax.swing.JComponent;

import org.processmining.contexts.uitopia.UIPluginContext;

/**
 * @author svzelst
 *
 * @param
 * 			<P>
 *            parameters object
 */
public interface Dialog<P> {

	Dialog<P> getNext();

	P getParameters();

	Dialog<P> getPrevious();

	String getTitle();

	UIPluginContext getUIPluginContext();

	boolean hasNextDialog();

	boolean hasPreviousDialog();

	void setParameters(P parameters);

	void updateParametersOnGetNext();

	void updateParametersOnGetPrevious();

	JComponent visualize();

}
"
Route.java,widgets-6.9.234,"package org.processmining.widgets.wizard;

public interface Route<P> {

	Dialog<P> getNext(Dialog<P> current);

}
"
Wizard.java,widgets-6.9.234,"package org.processmining.widgets.wizard;

import org.deckfour.uitopia.api.event.TaskListener;
import org.processmining.contexts.uitopia.UIPluginContext;

public class Wizard {

	public static <P> WizardResult<P> show(UIPluginContext context, Dialog<P> dialog) {
		return route(context, dialog, embed(context, dialog).getInteractionResult());
	}

	private static <P> WizardResult<P> embed(UIPluginContext context, Dialog<P> dialog) {
		return new WizardResult<>(dialog.getParameters(), context.showWizard(dialog.getTitle(),
				!dialog.hasPreviousDialog(), !dialog.hasNextDialog(), dialog.visualize()));
	}

	private static <P> WizardResult<P> route(UIPluginContext context, Dialog<P> dialog,
			TaskListener.InteractionResult interactionResult) {
		Dialog<P> next;
		switch (interactionResult) {
			case NEXT :
				next = dialog.getNext();
				return route(context, next, embed(context, next).getInteractionResult());
			case PREV :
				next = dialog.getPrevious();
				if (next == null)
					next = dialog;
				return route(context, next, embed(context, next).getInteractionResult());
			case FINISHED :
				next = dialog.getNext();
				if (next == null) {
					dialog.updateParametersOnGetNext();
					return new WizardResult<>(dialog.getParameters(), interactionResult);
				}
				return route(context, next, embed(context, next).getInteractionResult());
			default :
				return new WizardResult<>(dialog.getParameters(), interactionResult);
		}
	}

}
"
WizardResult.java,widgets-6.9.234,"package org.processmining.widgets.wizard;

import org.deckfour.uitopia.api.event.TaskListener.InteractionResult;

public class WizardResult<P> {

	private final P parameters;

	private final InteractionResult interactionResult;

	public WizardResult(P parameters, InteractionResult interactionResult) {
		this.parameters = parameters;
		this.interactionResult = interactionResult;
	}

	public P getParameters() {
		return parameters;
	}

	public InteractionResult getInteractionResult() {
		return interactionResult;
	}
	
	
}
"
